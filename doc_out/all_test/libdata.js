/* Index used for searching */
/*
   Fields used:
     url, name, type, filename, authors, routine name, comments, parameters,
     categories, and attributes
*/
title = "OMINAS API Documentation";
subtitle = "Generated by IDLdoc";
libdata = new Array();
libdataItem = 0;



libdata[libdataItem++] = new Array("demo/02_color_example.html", "02_color_example.pro", '.pro file in <a href="demo/dir-overview.html">demo/ directory</a>', "02_color_example.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("util/__image_offset.html", "__image_offset.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "__image_offset.pro", "", "", " NAME: 	image_offset    PURPOSE: 	Searches for the offset (dx,dy) that best locates an image within a 	a reference image.    CATEGORY: 	UTIL    CALLING SEQUENCE: 	dxy = image_offset(im0, im)    ARGUMENTS:   INPUT: 	im0:		Reference image.  	im:		Test image, must be smaller than im0.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	2-element array giving the fit offset as [dx,dy].    PROCEDURE: 	This routine considers every possble image offset by iterating over 	various correlation scales.    STATUS: 	Some bugs.     SEE ALSO: 	pg_farfit    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/__image_offset.html#__ioff_peak", "__ioff_peak", 'routine in <a href="util/__image_offset.html">__image_offset.pro</a>', "__image_offset.pro", "", "__ioff_peak", "", "corrgrid", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/__image_offset.html#ioff_peak", "ioff_peak", 'routine in <a href="util/__image_offset.html">__image_offset.pro</a>', "__image_offset.pro", "", "ioff_peak", "", "corrgrid", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/__image_offset.html#ioff_variance", "ioff_variance", 'routine in <a href="util/__image_offset.html">__image_offset.pro</a>', "__image_offset.pro", "", "ioff_variance", "", "im0im", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/__image_offset.html#ioff_ccorr", "ioff_ccorr", 'routine in <a href="util/__image_offset.html">__image_offset.pro</a>', "__image_offset.pro", "", "ioff_ccorr", "", "im0im", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/__image_offset.html#ioff_correlate", "ioff_correlate", 'routine in <a href="util/__image_offset.html">__image_offset.pro</a>', "__image_offset.pro", "", "ioff_correlate", "", "dxyim0immask_grid", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/__image_offset.html#image_offset", "image_offset", 'routine in <a href="util/__image_offset.html">__image_offset.pro</a>', "__image_offset.pro", "", "image_offset", "", "_im0_im", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/__image_offset.html#test", "test", 'routine in <a href="util/__image_offset.html">__image_offset.pro</a>', "__image_offset.pro", "", "test", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/stn/__stn_evolve.html", "__stn_evolve.pro", '.pro file in <a href="config/stn/dir-overview.html">config/stn/ directory</a>', "__stn_evolve.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/stn/__stn_evolve.html#stn_evolve", "stn_evolve", 'routine in <a href="config/stn/__stn_evolve.html">__stn_evolve.pro</a>', "__stn_evolve.pro", "", "stn_evolve", "", "cdspd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/bod/_bod_aberration_mask.html", "_bod_aberration_mask.pro", '.pro file in <a href="nv/obj/bod/dir-overview.html">nv/obj/bod/ directory</a>', "_bod_aberration_mask.pro", "", "", " NAME: 	_bod_aberration_mask    PURPOSE: 	Returns a bitmask for an aberration.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	mask = _bod_aberration_mask(_bx, name)    ARGUMENTS:   INPUT: NONE 	name:	 Name of aberration.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Aberration mask associated with the given name for each given body 	structure.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/bod/_bod_aberration_mask.html#_bod_aberration_mask", "_bod_aberration_mask", 'routine in <a href="nv/obj/bod/_bod_aberration_mask.html">_bod_aberration_mask.pro</a>', "_bod_aberration_mask.pro", "", "_bod_aberration_mask", "", "name", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/iss/_cas_spice_ck_detect.html", "_cas_spice_ck_detect.pro", '.pro file in <a href="config/cas/iss/dir-overview.html">config/cas/iss/ directory</a>', "_cas_spice_ck_detect.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/iss/_cas_spice_ck_detect.html#get_all_ck_files", "get_all_ck_files", 'routine in <a href="config/cas/iss/_cas_spice_ck_detect.html">_cas_spice_ck_detect.pro</a>', "_cas_spice_ck_detect.pro", "", "get_all_ck_files", "", "ckpath", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/cas/iss/_cas_spice_ck_detect.html#cas_spice_ck_components", "cas_spice_ck_components", 'routine in <a href="config/cas/iss/_cas_spice_ck_detect.html">_cas_spice_ck_detect.pro</a>', "_cas_spice_ck_detect.pro", "", "cas_spice_ck_components", "", "iijd_startjd_stoptypeversiondescall_namesformat", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/cas/iss/_cas_spice_ck_detect.html#cas_spice_ck_detect", "cas_spice_ck_detect", 'routine in <a href="config/cas/iss/_cas_spice_ck_detect.html">_cas_spice_ck_detect.pro</a>', "_cas_spice_ck_detect.pro", "", "cas_spice_ck_detect", "", "scdjdtimeallstrictddckpath", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/cas/iss/_cas_spice_ck_detect.html#____cas_spice_ck_detect", "____cas_spice_ck_detect", 'routine in <a href="config/cas/iss/_cas_spice_ck_detect.html">_cas_spice_ck_detect.pro</a>', "_cas_spice_ck_detect.pro", "", "____cas_spice_ck_detect", "", "djdtimeallstrictddckpath", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/iss/_cas_spice_spk_detect.html", "_cas_spice_spk_detect.pro", '.pro file in <a href="config/cas/iss/dir-overview.html">config/cas/iss/ directory</a>', "_cas_spice_spk_detect.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/iss/_cas_spice_spk_detect.html#cas_spice_spk_components", "cas_spice_spk_components", 'routine in <a href="config/cas/iss/_cas_spice_spk_detect.html">_cas_spice_spk_detect.pro</a>', "_cas_spice_spk_detect.pro", "", "cas_spice_spk_components", "", "wbadwgoodjd_delivdescrtypeversionformatall_names", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/cas/iss/_cas_spice_spk_detect.html#cas_spice_spk_match_target", "cas_spice_spk_match_target", 'routine in <a href="config/cas/iss/_cas_spice_spk_detect.html">_cas_spice_spk_detect.pro</a>', "_cas_spice_spk_detect.pro", "", "cas_spice_spk_match_target", "", "datatarget", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/cas/iss/_cas_spice_spk_detect.html#cas_spice_spk_reject_by_descr", "cas_spice_spk_reject_by_descr", 'routine in <a href="config/cas/iss/_cas_spice_spk_detect.html">_cas_spice_spk_detect.pro</a>', "_cas_spice_spk_detect.pro", "", "cas_spice_spk_reject_by_descr", "", "wdatadescr", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/cas/iss/_cas_spice_spk_detect.html#cas_spice_spk_latest", "cas_spice_spk_latest", 'routine in <a href="config/cas/iss/_cas_spice_spk_detect.html">_cas_spice_spk_detect.pro</a>', "_cas_spice_spk_detect.pro", "", "cas_spice_spk_latest", "", "dataw1w2", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/cas/iss/_cas_spice_spk_detect.html#cas_spice_spk_detect", "cas_spice_spk_detect", 'routine in <a href="config/cas/iss/_cas_spice_spk_detect.html">_cas_spice_spk_detect.pro</a>', "_cas_spice_spk_detect.pro", "", "cas_spice_spk_detect", "", "scstrictalltimeddkpath", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cor/_cor_gd.html", "_cor_gd.pro", '.pro file in <a href="nv/obj/cor/dir-overview.html">nv/obj/cor/ directory</a>', "_cor_gd.pro", "", "", " NAME: 	_cor_gd    PURPOSE: 	Retrieves the generic descriptor from a CORE structure.  The generic 	descriptor is stored in a protected structure that prevents its contents 	from being freed by nv_free, while still allowing its references to 	be copied by nv_clone.    CATEGORY: 	NV/OBJ/COR    CALLING SEQUENCE: 	gd = _cor_gd(_crd)    ARGUMENTS:   INPUT: 	_crd:		CORE structure.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	_cor_set_gd     MODIFICATION HISTORY:  	Written by:	Spitale		3/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cor/_cor_gd.html#_cor_gd", "_cor_gd", 'routine in <a href="nv/obj/cor/_cor_gd.html">_cor_gd.pro</a>', "_cor_gd.pro", "", "_cor_gd", "", "_xd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cor/_cor_set_gd.html", "_cor_set_gd.pro", '.pro file in <a href="nv/obj/cor/dir-overview.html">nv/obj/cor/ directory</a>', "_cor_set_gd.pro", "", "", " NAME: 	_cor_set_gd    PURPOSE: 	Sets the generic descriptor in a CORE structure.  The generic 	descriptor is stored in a protected structure that prevents its contents 	from being freed by nv_free, while still allowing its references to 	be copied by nv_clone.    CATEGORY: 	NV/OBJ/COR    CALLING SEQUENCE: 	_cor_set_gd, _crd, gd    ARGUMENTS:   INPUT: 	_crd:		CORE structure.  	gd:		New gd.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	_cor_gd     MODIFICATION HISTORY:  	Written by:	Spitale		3/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cor/_cor_set_gd.html#_cor_set_gd", "_cor_set_gd", 'routine in <a href="nv/obj/cor/_cor_set_gd.html">_cor_set_gd.pro</a>', "_cor_set_gd.pro", "", "_cor_set_gd", "", "_xdgd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cor/_cor_test_udata.html", "_cor_test_udata.pro", '.pro file in <a href="nv/obj/cor/dir-overview.html">nv/obj/cor/ directory</a>', "_cor_test_udata.pro", "", "", " NAME: 	_cor_test_udata    PURPOSE: 	Tests the existence of data stored in a structure under the 	specified name.    CATEGORY: 	NV/LIB/COR    CALLING SEQUENCE: 	data = _cor_test_udata(_crd, name)    ARGUMENTS:   INPUT: 	_crd:	 Any subclass of CORE.  Only one structure may be provided.  	name:	 Name associated with the data to test.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	True if the data is stored under the given name, false otherwise.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cor/_cor_test_udata.html#_cor_test_udata", "_cor_test_udata", 'routine in <a href="nv/obj/cor/_cor_test_udata.html">_cor_test_udata.pro</a>', "_cor_test_udata.pro", "", "_cor_test_udata", "", "_crdname", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/_dat_compress_data.html", "_dat_compress_data.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "_dat_compress_data.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/_dat_compress_data.html#_dat_compress_data", "_dat_compress_data", 'routine in <a href="nv/obj/dat/_dat_compress_data.html">_dat_compress_data.pro</a>', "_dat_compress_data.pro", "", "_dat_compress_data", "", "cdatacabscissa_dd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/_dat_compute_size.html", "_dat_compute_size.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "_dat_compute_size.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/_dat_compute_size.html#_dat_compute_size", "_dat_compute_size", 'routine in <a href="nv/obj/dat/_dat_compute_size.html">_dat_compute_size.pro</a>', "_dat_compute_size.pro", "", "_dat_compute_size", "", "_ddsamples", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/_dat_uncompress_data.html", "_dat_uncompress_data.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "_dat_uncompress_data.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/_dat_uncompress_data.html#_dat_uncompress_data", "_dat_uncompress_data", 'routine in <a href="nv/obj/dat/_dat_uncompress_data.html">_dat_uncompress_data.pro</a>', "_dat_uncompress_data.pro", "", "_dat_uncompress_data", "", "cdatacabscissa_dd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/glb/_glb_get_surface_normal_body.html", "_glb_get_surface_normal_body.pro", '.pro file in <a href="nv/obj/glb/dir-overview.html">nv/obj/glb/ directory</a>', "_glb_get_surface_normal_body.pro", "", "", " NAME: 	_glb_get_surface_normal_body    PURPOSE: 	Computes the surface normals of a GLOBE object at the given 	body-frame positions.  This is an internal routine.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	n = _glb_get_surface_normalbody(_gbd, r)    ARGUMENTS:   INPUT: 	_gbd:	Array (nt) of GLOBE structures.  	r:	Array (nv,3) of surface positions in the BODY frame.     OUTPUT: NONE    KEYWORDS:   INPUT: 	nonorm:	If set, the returned vectors are not normalized.    OUTPUT: NONE    RETURN: 	Array (nv, 3, nt) of surface unit normals in the BODY frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/glb/_glb_get_surface_normal_body.html#_glb_get_surface_normal_body", "_glb_get_surface_normal_body", 'routine in <a href="nv/obj/glb/_glb_get_surface_normal_body.html">_glb_get_surface_normal_body.pro</a>', "_glb_get_surface_normal_body.pro", "", "_glb_get_surface_normal_body", "", "nonorm_gbdr", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/gll/ssi/_gll_spice_ck_detect.html", "_gll_spice_ck_detect.pro", '.pro file in <a href="config/gll/ssi/dir-overview.html">config/gll/ssi/ directory</a>', "_gll_spice_ck_detect.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/gll/ssi/_gll_spice_ck_detect.html#gll_spice_ck_detect", "gll_spice_ck_detect", 'routine in <a href="config/gll/ssi/_gll_spice_ck_detect.html">_gll_spice_ck_detect.pro</a>', "_gll_spice_ck_detect.pro", "", "gll_spice_ck_detect", "", "scdjdtimeallstrictddckpath", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/gll/ssi/_gll_spice_spk_detect.html", "_gll_spice_spk_detect.pro", '.pro file in <a href="config/gll/ssi/dir-overview.html">config/gll/ssi/ directory</a>', "_gll_spice_spk_detect.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/gll/ssi/_gll_spice_spk_detect.html#gll_spice_spk_detect", "gll_spice_spk_detect", 'routine in <a href="config/gll/ssi/_gll_spice_spk_detect.html">_gll_spice_spk_detect.pro</a>', "_gll_spice_spk_detect.pro", "", "gll_spice_spk_detect", "", "scstrictalltimeddkpath", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/_image_median.html", "_image_median.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "_image_median.pro", "", "", " NAME: 	image_median    PURPOSE: 	Produces an image in which each pixel is the median of the corresponding 	pixels in the input images.    CATEGORY: 	UTIL    CALLING SEQUENCE: 	result = image_median(images)    ARGUMENTS:   INPUT: 	images:	Array (xsize, ysize, n) containing the n input images.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	NONE    OUTPUT: 	NONE    RETURN: 	Array (xsize, ysize) with the output image.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/_image_median.html#_image_median", "_image_median", 'routine in <a href="util/_image_median.html">_image_median.pro</a>', "_image_median.pro", "", "_image_median", "", "images", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/_map_apply_pole.html", "_map_apply_pole.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "_map_apply_pole.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/_map_apply_pole.html#_map_apply_pole", "_map_apply_pole", 'routine in <a href="nv/obj/map/_map_apply_pole.html">_map_apply_pole.pro</a>', "_map_apply_pole.pro", "", "_map_apply_pole", "", "inverse_mdmap_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/_map_lookup_transformations.html", "_map_lookup_transformations.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "_map_lookup_transformations.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/_map_lookup_transformations.html#_map_lookup_transformations", "_map_lookup_transformations", 'routine in <a href="nv/obj/map/_map_lookup_transformations.html">_map_lookup_transformations.pro</a>', "_map_lookup_transformations.pro", "", "_map_lookup_transformations", "", "_mdfn_map_to_imagefn_image_to_map", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/_map_valid_points.html", "_map_valid_points.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "_map_valid_points.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/_map_valid_points.html#_map_valid_points", "_map_valid_points", 'routine in <a href="nv/obj/map/_map_valid_points.html">_map_valid_points.pro</a>', "_map_valid_points.pro", "", "_map_valid_points", "", "_mdmap_ptsimage_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/_map_valid_points_mercator.html", "_map_valid_points_mercator.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "_map_valid_points_mercator.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/_map_valid_points_mercator.html#_map_valid_points_mercator", "_map_valid_points_mercator", 'routine in <a href="nv/obj/map/_map_valid_points_mercator.html">_map_valid_points_mercator.pro</a>', "_map_valid_points_mercator.pro", "", "_map_valid_points_mercator", "", "_mdmap_ptsimage_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/_map_valid_points_mollweide.html", "_map_valid_points_mollweide.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "_map_valid_points_mollweide.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/_map_valid_points_mollweide.html#_map_valid_points_mollweide", "_map_valid_points_mollweide", 'routine in <a href="nv/obj/map/_map_valid_points_mollweide.html">_map_valid_points_mollweide.pro</a>', "_map_valid_points_mollweide.pro", "", "_map_valid_points_mollweide", "", "_mdmap_ptsimage_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/_map_valid_points_orthographic.html", "_map_valid_points_orthographic.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "_map_valid_points_orthographic.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/_map_valid_points_orthographic.html#_map_valid_points_orthographic", "_map_valid_points_orthographic", 'routine in <a href="nv/obj/map/_map_valid_points_orthographic.html">_map_valid_points_orthographic.pro</a>', "_map_valid_points_orthographic.pro", "", "_map_valid_points_orthographic", "", "_mdmap_ptsimage_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/_map_valid_points_orthographic_disk.html", "_map_valid_points_orthographic_disk.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "_map_valid_points_orthographic_disk.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/_map_valid_points_orthographic_disk.html#_map_valid_points_orthographic_disk", "_map_valid_points_orthographic_disk", 'routine in <a href="nv/obj/map/_map_valid_points_orthographic_disk.html">_map_valid_points_orthographic_disk.pro</a>', "_map_valid_points_orthographic_disk.pro", "", "_map_valid_points_orthographic_disk", "", "_mdmap_ptsimage_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/_map_valid_points_rectangular.html", "_map_valid_points_rectangular.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "_map_valid_points_rectangular.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/_map_valid_points_rectangular.html#_map_valid_points_rectangular", "_map_valid_points_rectangular", 'routine in <a href="nv/obj/map/_map_valid_points_rectangular.html">_map_valid_points_rectangular.pro</a>', "_map_valid_points_rectangular.pro", "", "_map_valid_points_rectangular", "", "_mdmap_ptsimage_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/_map_valid_points_rectangular_disk.html", "_map_valid_points_rectangular_disk.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "_map_valid_points_rectangular_disk.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/_map_valid_points_rectangular_disk.html#_map_valid_points_rectangular_disk", "_map_valid_points_rectangular_disk", 'routine in <a href="nv/obj/map/_map_valid_points_rectangular_disk.html">_map_valid_points_rectangular_disk.pro</a>', "_map_valid_points_rectangular_disk.pro", "", "_map_valid_points_rectangular_disk", "", "_mdmap_ptsimage_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/_map_valid_points_sinusoidal.html", "_map_valid_points_sinusoidal.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "_map_valid_points_sinusoidal.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/_map_valid_points_sinusoidal.html#_map_valid_points_sinusoidal", "_map_valid_points_sinusoidal", 'routine in <a href="nv/obj/map/_map_valid_points_sinusoidal.html">_map_valid_points_sinusoidal.pro</a>', "_map_valid_points_sinusoidal.pro", "", "_map_valid_points_sinusoidal", "", "_mdmap_ptsimage_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/_map_valid_points_stereographic.html", "_map_valid_points_stereographic.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "_map_valid_points_stereographic.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/_map_valid_points_stereographic.html#_map_valid_points_stereographic", "_map_valid_points_stereographic", 'routine in <a href="nv/obj/map/_map_valid_points_stereographic.html">_map_valid_points_stereographic.pro</a>', "_map_valid_points_stereographic.pro", "", "_map_valid_points_stereographic", "", "_mdmap_ptsimage_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/_map_wrap_points.html", "_map_wrap_points.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "_map_wrap_points.pro", "", "", " NAME: 	_map_wrap_points    PURPOSE: 	Forces all map image points to lie inside a specified map by wrapping 	longitudes.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	wrap_image_pts = map_wrap_points(md, image_pts)    ARGUMENTS:   INPUT: 	md	 	Array (nt) of MAP descriptors.  	image_pts:	Array (2,nv,nt) of map image points.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (2,nv,nt) of wrapped map image points.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/_map_wrap_points.html#_map_wrap_points", "_map_wrap_points", 'routine in <a href="nv/obj/map/_map_wrap_points.html">_map_wrap_points.pro</a>', "_map_wrap_points.pro", "", "_map_wrap_points", "", "_md_image_pts_map_pts", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/map/_map_wrap_points.html#__map_wrap_points", "__map_wrap_points", 'routine in <a href="nv/obj/map/_map_wrap_points.html">_map_wrap_points.pro</a>', "_map_wrap_points.pro", "", "__map_wrap_points", "", "_md_image_pts", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/map/_map_wrap_points.html#_map_wrap_points", "_map_wrap_points", 'routine in <a href="nv/obj/map/_map_wrap_points.html">_map_wrap_points.pro</a>', "_map_wrap_points.pro", "", "_map_wrap_points", "", "_md_image_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/pnt/_pnt_resize.html", "_pnt_resize.pro", '.pro file in <a href="nv/obj/pnt/dir-overview.html">nv/obj/pnt/ directory</a>', "_pnt_resize.pro", "", "", " NAME: 	_pnt_resize    PURPOSE: 	Resizes a POINT structure.  Arrays are padded with zeroes or truncated 	as needed.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	pnt_resize, _ptd, nv=nv, nt=nt    ARGUMENTS:   INPUT: 	_ptd:		POINT struct.  Note this is an actual POINT structure 			rather than an object, as this routine is only 			meant to be called internally.    OUTPUT: NONE    KEYWORDS:   INPUT: 	nv.nt:		New nv, nt.  	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete;    MODIFICATION HISTORY:  	Written by:	Spitale		12/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/pnt/_pnt_resize.html#_pnt_resize", "_pnt_resize", 'routine in <a href="nv/obj/pnt/_pnt_resize.html">_pnt_resize.pro</a>', "_pnt_resize.pro", "", "_pnt_resize", "", "nvnt_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/_read_cv.html", "_read_cv.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "_read_cv.pro", "", "", " NAME: 	read_csv    PURPOSE: 	Reads a CSV file.    CATEGORY: 	UTIL    CALLING SEQUENCE: 	result = read_csv(filename)    ARGUMENTS:   INPUT: 	filename:	Name of file to read    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	delim:	String giving character to use to delimit columns. 		Defaults to ','.    OUTPUT: 	NONE    RETURN: 	Array (ncol, nrow) of strings.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 9/2012   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/_read_cv.html#read_csv", "read_csv", 'routine in <a href="util/_read_cv.html">_read_cv.pro</a>', "_read_cv.pro", "", "read_csv", "", "delimfilename", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/vims/_vims_spice_ck_detect.html", "_vims_spice_ck_detect.pro", '.pro file in <a href="config/cas/vims/dir-overview.html">config/cas/vims/ directory</a>', "_vims_spice_ck_detect.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/vims/_vims_spice_ck_detect.html#vims_spice_ck_detect", "vims_spice_ck_detect", 'routine in <a href="config/cas/vims/_vims_spice_ck_detect.html">_vims_spice_ck_detect.pro</a>', "_vims_spice_ck_detect.pro", "", "vims_spice_ck_detect", "", "djdtimeallrejectstrictscddckpath", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/vims/_vims_spice_lsk_detect.html", "_vims_spice_lsk_detect.pro", '.pro file in <a href="config/cas/vims/dir-overview.html">config/cas/vims/ directory</a>', "_vims_spice_lsk_detect.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/vims/_vims_spice_lsk_detect.html#vims_spice_lsk_detect", "vims_spice_lsk_detect", 'routine in <a href="config/cas/vims/_vims_spice_lsk_detect.html">_vims_spice_lsk_detect.pro</a>', "_vims_spice_lsk_detect.pro", "", "vims_spice_lsk_detect", "", "timerejectstrictallscddkpath", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/vims/_vims_spice_pck_detect.html", "_vims_spice_pck_detect.pro", '.pro file in <a href="config/cas/vims/dir-overview.html">config/cas/vims/ directory</a>', "_vims_spice_pck_detect.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/vims/_vims_spice_pck_detect.html#vims_spice_pck_detect", "vims_spice_pck_detect", 'routine in <a href="config/cas/vims/_vims_spice_pck_detect.html">_vims_spice_pck_detect.pro</a>', "_vims_spice_pck_detect.pro", "", "vims_spice_pck_detect", "", "timerejectstrictallscddkpath", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/vims/_vims_spice_spk_detect.html", "_vims_spice_spk_detect.pro", '.pro file in <a href="config/cas/vims/dir-overview.html">config/cas/vims/ directory</a>', "_vims_spice_spk_detect.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/vims/_vims_spice_spk_detect.html#vims_spice_spk_detect", "vims_spice_spk_detect", 'routine in <a href="config/cas/vims/_vims_spice_spk_detect.html">_vims_spice_spk_detect.pro</a>', "_vims_spice_spk_detect.pro", "", "vims_spice_spk_detect", "", "strictalltimescddkpath", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/abcorr.html", "abcorr.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "abcorr.pro", "", "", " NAME:        abcorr    PURPOSE: 	Performs stellar aberration and light-travel-time corrections.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        abcorr, obs_bx, targ_bx, c=c    ARGUMENTS:   INPUT: 	obs_bx:	  Any subclass of BODY describing the observer.  	targ_bx:  Array(nt) of any subclass of BODY describing the targets.    OUTPUT:  NONE    KEYOWRDS:   INPUT: 	c:		Speed of light.  	iterate:	If set, then the lt correction routine will iterate 			to refine its solution.  	epsilon:	Stopping criterion for the lt correction: maximum 			allowable timing error.  Default is 1d-7.    OUTPUT: NONE    RETURN: NONE     MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/abcorr.html#abcorr", "abcorr", 'routine in <a href="nv/obj/tools/abcorr.html">abcorr.pro</a>', "abcorr.pro", "", "abcorr", "", "citerateepsilonfastinvertobs_bxtarg_bx", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/tools/abcorr.html#abcorr", "abcorr", 'routine in <a href="nv/obj/tools/abcorr.html">abcorr.pro</a>', "abcorr.pro", "", "abcorr", "", "citerateepsilonfastobs_bxtarg_bx0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/activity.html", "activity.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "activity.pro", "", "", " NAME:        activity    PURPOSE:        Computes the activity in an image.    CATEGORY:        UTIL    CALLING SEQUENCE:        result = activity(image)    ARGUMENTS:   INPUT:        image:  Input image.     OUTPUT:        NONE   KEYWORDS:   INPUT: 	NONE     OUTPUT:        NONE    RETURN:        The image activity at each pixel, computed as  		activity = |dn_00 - dn_22| + |dn_20 - dn_02|,  	where the pixel coordinates (i,j) are defined by  			(0,0) (1,0) (2,0) 			(0,1) (1,1) (2,1) 			(0,2) (1,2) (2,2)  	in a 3x3 box centered at a given image location.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale;  4/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/activity.html#activity", "activity", 'routine in <a href="util/activity.html">activity.pro</a>', "activity.pro", "", "activity", "", "image", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/addeobj.html", "addeobj.pro", '.pro file in <a href="config/pds/Readpds_4.4/dir-overview.html">config/pds/Readpds_4.4/ directory</a>', "addeobj.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/addeobj.html#cleanline", "cleanline", 'routine in <a href="config/pds/Readpds_4.4/addeobj.html">addeobj.pro</a>', "addeobj.pro", "", "cleanline", "", "ln", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/addeobj.html#addeobj", "addeobj", 'routine in <a href="config/pds/Readpds_4.4/addeobj.html">addeobj.pro</a>', "addeobj.pro", "", "addeobj", "", "lnobjarrobjcount", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/append_array.html", "append_array.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "append_array.pro", "", "", " NAME: 	append_array    PURPOSE: 	Concatenates two arrays; even if one is undefined or  unset . 	This routine is intended to be used as a replacement for the 	syntax: result = [array1, array2], except that neither array 	requires checking.    CATEGORY: 	UTIL    CALLING SEQUENCE: 	result = append_array(array1, array2)    ARGUMENTS:   INPUT: 	array1:	First array.  If undefined, the second array is returned.  	array2:	Second array.  If undefined, the first array is returned.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	def:		If set, new items simply ust be defined instead of  set .  	positive:	If set, a single value of -1 is taken as an undefined 			array.    OUTPUT: NONE    RETURN: 	Concatentated array.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/append_array.html#append_array", "append_array", 'routine in <a href="util/append_array.html">append_array.pro</a>', "append_array.pro", "", "append_array", "", "defpositivearrayitem", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/append_struct.html", "append_struct.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "append_struct.pro", "", "", " NAME: 	append_struct    PURPOSE: 	Concatenates two structures; even if one is undefined or  unset . 	This routine is intended to be used as a replacement for the 	syntax: result = create_struct(struct1, struct2), except that neither 	struct requires checking.    CATEGORY: 	UTIL    CALLING SEQUENCE: 	result = append_struct(struct1, struct2)    ARGUMENTS:   INPUT: 	struct1:	First structure.  If undefined, the second structure is 			returned.  	struct2:	Second structure.  If undefined, the first structure is 			returned.  If duplicate fields exist, the output 			field wil be an array of the unique elements from both 			input structures.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	fast:		If set, no checking is performed to ensure structure 			tags are not duplicated.  	replace:	If set, duplicate fields in struct2 are replace those 			from struct1 instead of concatenating them.    OUTPUT: NONE    RETURN: 	Concatentated structure.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale		2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/append_struct.html#append_struct_cat", "append_struct_cat", 'routine in <a href="util/append_struct.html">append_struct.pro</a>', "append_struct.pro", "", "append_struct_cat", "", "fastreplaces1s2", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/append_struct.html#append_struct", "append_struct", 'routine in <a href="util/append_struct.html">append_struct.pro</a>', "append_struct.pro", "", "append_struct", "", "fastreplacestruct1struct2", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/apply_bitmask.html", "apply_bitmask.pro", '.pro file in <a href="config/pds/Readpds_4.4/dir-overview.html">config/pds/Readpds_4.4/ directory</a>', "apply_bitmask.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/apply_bitmask.html#extract_bitmask", "extract_bitmask", 'routine in <a href="config/pds/Readpds_4.4/apply_bitmask.html">apply_bitmask.pro</a>', "apply_bitmask.pro", "", "extract_bitmask", "", "lineidl_type", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/apply_bitmask.html#apply_bitmask", "apply_bitmask", 'routine in <a href="config/pds/Readpds_4.4/apply_bitmask.html">apply_bitmask.pro</a>', "apply_bitmask.pro", "", "apply_bitmask", "", "labelstart_indend_indelement", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/colormap/apply_colormap.html", "apply_colormap.pro", '.pro file in <a href="util/colormap/dir-overview.html">util/colormap/ directory</a>', "apply_colormap.pro", "", "", " NAME: 	apply_colormap    PURPOSE: 	Apply a colormap to an image.    CATEGORY: 	UTIL    CALLING SEQUENCE: 	result = xx(xx, xx) 	xx, xx, xx    ARGUMENTS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    KEYWORDS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    ENVIRONMENT VARIABLES: 	xx:	xx  	xx:	xx    RETURN: 	xx    COMMON BLOCKS: 	xx:	xx  	xx:	xx    SIDE EFFECTS: 	xx    RESTRICTIONS: 	xx    PROCEDURE: 	xx    EXAMPLE: 	xx    STATUS: 	xx    SEE ALSO: 	xx, xx, xx    MODIFICATION HISTORY:  	Written by:	Spitale, 12/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/colormap/apply_colormap.html#apply_colormap", "apply_colormap", 'routine in <a href="util/colormap/apply_colormap.html">apply_colormap.pro</a>', "apply_colormap.pro", "", "apply_colormap", "", "channelmaxmin_image_map", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/arclen.html", "arclen.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "arclen.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/arclen.html#arclen", "arclen", 'routine in <a href="util/arclen.html">arclen.pro</a>', "arclen.pro", "", "arclen", "", "closedp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/arr/arr_assign.html", "arr_assign.pro", '.pro file in <a href="nv/obj/arr/dir-overview.html">nv/obj/arr/ directory</a>', "arr_assign.pro", "", "", " NAME: 	arr_assign    PURPOSE: 	Replaces fields in a ARRAY object.  This is a convenient way of 	setting multiple fields in one call, and only a single event is 	generated.    CATEGORY: 	NV/OBJ/ARR    CALLING SEQUENCE: 	arr_assign, ard, <keywords>=<values>    ARGUMENTS:   INPUT: 	ard:		ARRAY object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	ARRAY fields to set.  	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	arr_set_*     MODIFICATION HISTORY:  	Written by:	Spitale		2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/arr/arr_assign.html#arr_assign", "arr_assign", 'routine in <a href="nv/obj/arr/arr_assign.html">arr_assign.pro</a>', "arr_assign.pro", "", "arr_assign", "", "noeventxd@arr__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/arr/arr_create_descriptors.html", "arr_create_descriptors.pro", '.pro file in <a href="nv/obj/arr/dir-overview.html">nv/obj/arr/ directory</a>', "arr_create_descriptors.pro", "", "", " NAME:        arr_create_descriptors    PURPOSE: 	Init method for the ARRAY class.    CATEGORY:        NV/LIB/arr    CALLING SEQUENCE:        ard = arr_create_descriptors(n)    ARGUMENTS:   INPUT:        n:      Number of array descriptors.    OUTPUT:        NONE    KEYWORDS:   INPUT: 	ard:	Station descriptor(s) to initialize, instead of creating new 		ones.  	bd:	Body descriptor(s) to pass to bod_create_descriptors.  	crd:	Core descriptor(s) to pass to cor_create_descriptors.  	primary:	Array (n) of primary strings.    OUTPUT: NONE   RETURN:        An array (n) of array descriptors.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/arr/arr_create_descriptors.html#arr_create_descriptors", "arr_create_descriptors", 'routine in <a href="nv/obj/arr/arr_create_descriptors.html">arr_create_descriptors.pro</a>', "arr_create_descriptors.pro", "", "arr_create_descriptors", "", "crdardn@arr__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/arr/arr_primary.html", "arr_primary.pro", '.pro file in <a href="nv/obj/arr/dir-overview.html">nv/obj/arr/ directory</a>', "arr_primary.pro", "", "", " NAME: 	arr_primary    PURPOSE: 	Returns the primary descriptor for each given array descriptor.    CATEGORY: 	NV/LIB/arr    CALLING SEQUENCE: 	primary = arr_primary(ard)    ARGUMENTS:   INPUT: 	ard:	 Array (nt) of ARRAY descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Primary descriptors associated with each given array descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/arr/arr_primary.html#arr_primary", "arr_primary", 'routine in <a href="nv/obj/arr/arr_primary.html">arr_primary.pro</a>', "arr_primary.pro", "", "arr_primary", "", "noeventard", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/arr/arr_query.html", "arr_query.pro", '.pro file in <a href="nv/obj/arr/dir-overview.html">nv/obj/arr/ directory</a>', "arr_query.pro", "", "", " NAME: 	arr_query    PURPOSE: 	Returns the fields associated with a ARRAY object.  This is a 	convenient way of getting multiple fields in one call, and only a 	single event is generated.    CATEGORY: 	NV/OBJ/ARR    CALLING SEQUENCE: 	arr_query, ard, <keywords>=<values>    ARGUMENTS:   INPUT: 	ard:	ARRAY object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	ARRAY object fields to set.  	condition:	Structure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT object, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.  	cat:		If set, arrays from mulitple input objets are 			concatenated.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.  	noevent:	If set, no event is generated.    OUTPUT: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/arr/arr_query.html#arr_query", "arr_query", 'routine in <a href="nv/obj/arr/arr_query.html">arr_query.pro</a>', "arr_query.pro", "", "arr_query", "", "conditioncatnoeventxd@arr__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/arr/arr_read.html", "arr_read.pro", '.pro file in <a href="config/arr/dir-overview.html">config/arr/ directory</a>', "arr_read.pro", "", "", " NAME: 	arr_read    PURPOSE: 	Reads an array file.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	array = arr_read(filename)    ARGUMENTS:   INPUT: 	filename:	 String giving the name of the file.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: Array of surface points.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 10/2012   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/arr/arr_read.html#arr_read", "arr_read", 'routine in <a href="config/arr/arr_read.html">arr_read.pro</a>', "arr_read.pro", "", "arr_read", "", "filename", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/arr/arr_replicate.html", "arr_replicate.pro", '.pro file in <a href="nv/obj/arr/dir-overview.html">nv/obj/arr/ directory</a>', "arr_replicate.pro", "", "", " NAME: 	arr_replicate    PURPOSE: 	Replicates the given descriptor, producing an array of the given 	dimensions containing cloned versions of the input descriptor.    CATEGORY: 	NV/LIB/arr    CALLING SEQUENCE: 	ards = str_replicate(ard, dim)    ARGUMENTS:   INPUT: 	ard:	 Station descriptor.  	dim:	 Dimensions of the result.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Array of the given dimensions containing cloned versions of the input 	descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/arr/arr_replicate.html#arr_replicate", "arr_replicate", 'routine in <a href="nv/obj/arr/arr_replicate.html">arr_replicate.pro</a>', "arr_replicate.pro", "", "arr_replicate", "", "arddim", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/arr/arr_set_primary.html", "arr_set_primary.pro", '.pro file in <a href="nv/obj/arr/dir-overview.html">nv/obj/arr/ directory</a>', "arr_set_primary.pro", "", "", " NAME: 	arr_set_primary    PURPOSE: 	Replaces the primary string in each given array descriptor.    CATEGORY: 	NV/LIB/arr    CALLING SEQUENCE: 	arr_set_primary, ard, primary    ARGUMENTS:   INPUT: 	ard:	Array (nt) of ARRAY descriptors.  	primary:	Array (nt) of primary descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/arr/arr_set_primary.html#arr_set_primary", "arr_set_primary", 'routine in <a href="nv/obj/arr/arr_set_primary.html">arr_set_primary.pro</a>', "arr_set_primary.pro", "", "arr_set_primary", "", "noeventardprimary", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/arr/arr_set_surface_pts.html", "arr_set_surface_pts.pro", '.pro file in <a href="nv/obj/arr/dir-overview.html">nv/obj/arr/ directory</a>', "arr_set_surface_pts.pro", "", "", " NAME: 	arr_set_surface_pts    PURPOSE: 	Replaces the surface_pts vector in each given array descriptor.    CATEGORY: 	NV/LIB/arr    CALLING SEQUENCE: 	arr_set_surface_pts, ard, surface_pts    ARGUMENTS:   INPUT: 	ard:		Array (nt) of ARRAY descriptors.  	surface_pts:	Array (nv,3,nt) of surface_pts vectors.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/arr/arr_set_surface_pts.html#arr_set_surface_pts", "arr_set_surface_pts", 'routine in <a href="nv/obj/arr/arr_set_surface_pts.html">arr_set_surface_pts.pro</a>', "arr_set_surface_pts.pro", "", "arr_set_surface_pts", "", "noeventardsurface_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/arr_struct.html", "arr_struct.pro", '.pro file in <a href="config/pds/Readpds_4.4/dir-overview.html">config/pds/Readpds_4.4/ directory</a>', "arr_struct.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/arr_struct.html#get_arr_axes", "get_arr_axes", 'routine in <a href="config/pds/Readpds_4.4/arr_struct.html">arr_struct.pro</a>', "arr_struct.pro", "", "get_arr_axes", "", "labelcur_indend_index", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/arr_struct.html#get_arr_axis_items", "get_arr_axis_items", 'routine in <a href="config/pds/Readpds_4.4/arr_struct.html">arr_struct.pro</a>', "arr_struct.pro", "", "get_arr_axis_items", "", "labelcur_indend_indexaxes", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/arr_struct.html#arr_struct", "arr_struct", 'routine in <a href="config/pds/Readpds_4.4/arr_struct.html">arr_struct.pro</a>', "arr_struct.pro", "", "arr_struct", "", "labelobjectscount", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/arr/arr_surface_pts.html", "arr_surface_pts.pro", '.pro file in <a href="nv/obj/arr/dir-overview.html">nv/obj/arr/ directory</a>', "arr_surface_pts.pro", "", "", " NAME: 	arr_surface_pts    PURPOSE: 	Returns the surface_pts vector for each given array descriptor.    CATEGORY: 	NV/LIB/arr    CALLING SEQUENCE: 	surface_pts = arr_surface_pts(ard)    ARGUMENTS:   INPUT: 	ard:	 Array (nt) of ARRAY descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (nv,3,nt) of surface_pts vectors associated with each given 	array descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/arr/arr_surface_pts.html#arr_surface_pts", "arr_surface_pts", 'routine in <a href="nv/obj/arr/arr_surface_pts.html">arr_surface_pts.pro</a>', "arr_surface_pts.pro", "", "arr_surface_pts", "", "noeventard", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/arr/arr_write.html", "arr_write.pro", '.pro file in <a href="config/arr/dir-overview.html">config/arr/ directory</a>', "arr_write.pro", "", "", " NAME: 	arr_write    PURPOSE: 	Write an array file.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	arr_write, filename, array    ARGUMENTS:   INPUT: 	filename:	 String giving the name of the file.  	array:		 Array of surface points.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 10/2012   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/arr/arr_write.html#arr_write", "arr_write", 'routine in <a href="config/arr/arr_write.html">arr_write.pro</a>', "arr_write.pro", "", "arr_write", "", "filenamearray", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/arr/array_input.html", "array_input.pro", '.pro file in <a href="config/arr/dir-overview.html">config/arr/ directory</a>', "array_input.pro", "", "", " NAME: 	array_input    PURPOSE: 	Input translator for arrays.    CATEGORY: 	NV/CONFIG    CALLING SEQUENCE(only to be called by dat_get_value): 	result = array_input(dd, keyword)    ARGUMENTS:   INPUT: 	dd:  Data descriptor.  	keyword: String giving the name of the translator quantity.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	key1:  Body descriptor  	key2:  Camera descriptor    OUTPUT: 	status:  Zero if valid data is returned    ENVIRONMENT VARIABLES: 	NV_ARRAY_DATA:	Sets directory in which to look for data files.    TRANSLATOR KEYWORDS: 	NONE    RETURN: 	Data associated with the requested keyword.    STATUS: 	Complete    MODIFICATION HISTORY: 	Written by: Spitale; 10/2012   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/arr/array_input.html#array_input", "array_input", 'routine in <a href="config/arr/array_input.html">array_input.pro</a>', "array_input.pro", "", "array_input", "", "valuesstatusddkeywordprefix@nv_trs_keywords_include.pro", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/arr/array_record__define.html", "array_record__define.pro", '.pro file in <a href="config/arr/dir-overview.html">config/arr/ directory</a>', "array_record__define.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/arr/array_record__define.html#array_record__define", "array_record__define", 'routine in <a href="config/arr/array_record__define.html">array_record__define.pro</a>', "array_record__define.pro", "", "array_record__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/arrcat.html", "arrcat.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "arrcat.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/arrcat.html#arrcat", "arrcat", 'routine in <a href="util/arrcat.html">arrcat.pro</a>', "arrcat.pro", "", "arrcat", "", "arr", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/arrcol_struct.html", "arrcol_struct.pro", '.pro file in <a href="config/pds/Readpds_4.4/dir-overview.html">config/pds/Readpds_4.4/ directory</a>', "arrcol_struct.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/arrcol_struct.html#extract_name", "extract_name", 'routine in <a href="config/pds/Readpds_4.4/arrcol_struct.html">arrcol_struct.pro</a>', "arrcol_struct.pro", "", "extract_name", "", "labelobjindexend_index", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/arrcol_struct.html#extract_bytes", "extract_bytes", 'routine in <a href="config/pds/Readpds_4.4/arrcol_struct.html">arrcol_struct.pro</a>', "arrcol_struct.pro", "", "extract_bytes", "", "labelcur_indend_index", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/arrcol_struct.html#extract_start_byte", "extract_start_byte", 'routine in <a href="config/pds/Readpds_4.4/arrcol_struct.html">arrcol_struct.pro</a>', "arrcol_struct.pro", "", "extract_start_byte", "", "labelcur_indend_index", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/arrcol_struct.html#sort_objects", "sort_objects", 'routine in <a href="config/pds/Readpds_4.4/arrcol_struct.html">arrcol_struct.pro</a>', "arrcol_struct.pro", "", "sort_objects", "", "object1object2", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/arrcol_struct.html#is_element", "is_element", 'routine in <a href="config/pds/Readpds_4.4/arrcol_struct.html">arrcol_struct.pro</a>', "arrcol_struct.pro", "", "is_element", "", "objectname", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/arrcol_struct.html#is_array", "is_array", 'routine in <a href="config/pds/Readpds_4.4/arrcol_struct.html">arrcol_struct.pro</a>', "arrcol_struct.pro", "", "is_array", "", "objectname", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/arrcol_struct.html#is_collection", "is_collection", 'routine in <a href="config/pds/Readpds_4.4/arrcol_struct.html">arrcol_struct.pro</a>', "arrcol_struct.pro", "", "is_collection", "", "objectname", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/arrcol_struct.html#get_subobjects", "get_subobjects", 'routine in <a href="config/pds/Readpds_4.4/arrcol_struct.html">arrcol_struct.pro</a>', "arrcol_struct.pro", "", "get_subobjects", "", "labelobjindex", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/arrcol_struct.html#process_structs", "process_structs", 'routine in <a href="config/pds/Readpds_4.4/arrcol_struct.html">arrcol_struct.pro</a>', "arrcol_struct.pro", "", "process_structs", "", "labelobjects", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/arrcol_struct.html#arrcol_struct", "arrcol_struct", 'routine in <a href="config/pds/Readpds_4.4/arrcol_struct.html">arrcol_struct.pro</a>', "arrcol_struct.pro", "", "arrcol_struct", "", "labelobjindex", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/arrcolascpds.html", "arrcolascpds.pro", '.pro file in <a href="config/pds/Readpds_4.4/dir-overview.html">config/pds/Readpds_4.4/ directory</a>', "arrcolascpds.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/arrcolascpds.html#obtain_arrcol_architecture", "obtain_arrcol_architecture", 'routine in <a href="config/pds/Readpds_4.4/arrcolascpds.html">arrcolascpds.pro</a>', "arrcolascpds.pro", "", "obtain_arrcol_architecture", "", "labelobjindexend_objindex", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/arrcolascpds.html#extract_object_name", "extract_object_name", 'routine in <a href="config/pds/Readpds_4.4/arrcolascpds.html">arrcolascpds.pro</a>', "arrcolascpds.pro", "", "extract_object_name", "", "labelobjindex", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/arrcolascpds.html#sort_objects", "sort_objects", 'routine in <a href="config/pds/Readpds_4.4/arrcolascpds.html">arrcolascpds.pro</a>', "arrcolascpds.pro", "", "sort_objects", "", "object1object2", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/arrcolascpds.html#is_object", "is_object", 'routine in <a href="config/pds/Readpds_4.4/arrcolascpds.html">arrcolascpds.pro</a>', "arrcolascpds.pro", "", "is_object", "", "objectnameobject", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/arrcolascpds.html#create_element", "create_element", 'routine in <a href="config/pds/Readpds_4.4/arrcolascpds.html">arrcolascpds.pro</a>', "arrcolascpds.pro", "", "create_element", "", "labelobjectssoindexeoindex", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/arrcolascpds.html#create_collection", "create_collection", 'routine in <a href="config/pds/Readpds_4.4/arrcolascpds.html">arrcolascpds.pro</a>', "arrcolascpds.pro", "", "create_collection", "", "labelobjectssoindexeoindex", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/arrcolascpds.html#create_array", "create_array", 'routine in <a href="config/pds/Readpds_4.4/arrcolascpds.html">arrcolascpds.pro</a>', "arrcolascpds.pro", "", "create_array", "", "labelobjectssoindexeoindex", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/arrcolascpds.html#get_subobjects_arrcol", "get_subobjects_arrcol", 'routine in <a href="config/pds/Readpds_4.4/arrcolascpds.html">arrcolascpds.pro</a>', "arrcolascpds.pro", "", "get_subobjects_arrcol", "", "labelstart_indexend_index", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/arrcolascpds.html#organize_struct", "organize_struct", 'routine in <a href="config/pds/Readpds_4.4/arrcolascpds.html">arrcolascpds.pro</a>', "arrcolascpds.pro", "", "organize_struct", "", "structurename", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/arrcolascpds.html#organize_data", "organize_data", 'routine in <a href="config/pds/Readpds_4.4/arrcolascpds.html">arrcolascpds.pro</a>', "arrcolascpds.pro", "", "organize_data", "", "read_struct", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/arrcolascpds.html#arrcolascpds", "arrcolascpds", 'routine in <a href="config/pds/Readpds_4.4/arrcolascpds.html">arrcolascpds.pro</a>', "arrcolascpds.pro", "", "arrcolascpds", "", "SILENTfilenamelabelobjindex", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/arrcolpds.html", "arrcolpds.pro", '.pro file in <a href="config/pds/Readpds_4.4/dir-overview.html">config/pds/Readpds_4.4/ directory</a>', "arrcolpds.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/arrcolpds.html#extract_object_name", "extract_object_name", 'routine in <a href="config/pds/Readpds_4.4/arrcolpds.html">arrcolpds.pro</a>', "arrcolpds.pro", "", "extract_object_name", "", "labelobjindex", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/arrcolpds.html#is_binary", "is_binary", 'routine in <a href="config/pds/Readpds_4.4/arrcolpds.html">arrcolpds.pro</a>', "arrcolpds.pro", "", "is_binary", "", "labelobjindexend_objindex", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/arrcolpds.html#obtain_arrcol_architecture", "obtain_arrcol_architecture", 'routine in <a href="config/pds/Readpds_4.4/arrcolpds.html">arrcolpds.pro</a>', "arrcolpds.pro", "", "obtain_arrcol_architecture", "", "labelobjindexend_objindex", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/arrcolpds.html#arrcolpds", "arrcolpds", 'routine in <a href="config/pds/Readpds_4.4/arrcolpds.html">arrcolpds.pro</a>', "arrcolpds.pro", "", "arrcolpds", "", "SILENTfilenamelabelobjindex", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/arrtrim.html", "arrtrim.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "arrtrim.pro", "", "", " NAME: 	arrtrim    PURPOSE: 	Trims all elements matching the given item from an array.  Options 	are to trim all matching elements, just leading elements, just 	trailing elements, or both leading and trailing elements.    CATEGORY: 	UTIL    CALLING SEQUENCE: 	result = arrtrim(arr, code, match)    ARGUMENTS:   INPUT: 	arr:		Array to be trimmed.  	code:		Option code, 0 = trailing, 1=leading, 2=both, 3=all. 			(See above).  	match:		Object to be trimmed out of the array.  If not defined, 			the null string '' will be matched.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	The updated array.  If there is only one item in the array, 	it wil be returned unchanged.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 5/1995   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/arrtrim.html#tr_leading", "tr_leading", 'routine in <a href="util/arrtrim.html">arrtrim.pro</a>', "arrtrim.pro", "", "tr_leading", "", "blanksarraymatch", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/arrtrim.html#tr_trailing", "tr_trailing", 'routine in <a href="util/arrtrim.html">arrtrim.pro</a>', "arrtrim.pro", "", "tr_trailing", "", "blanksarraymatch", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/arrtrim.html#tr_both", "tr_both", 'routine in <a href="util/arrtrim.html">arrtrim.pro</a>', "arrtrim.pro", "", "tr_both", "", "blanksarraymatch", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/arrtrim.html#tr_all", "tr_all", 'routine in <a href="util/arrtrim.html">arrtrim.pro</a>', "arrtrim.pro", "", "tr_all", "", "blanksarraymatch", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/arrtrim.html#arrtrim", "arrtrim", 'routine in <a href="util/arrtrim.html">arrtrim.pro</a>', "arrtrim.pro", "", "arrtrim", "", "arrcodematch", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/assign_colors.html", "assign_colors.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "assign_colors.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/assign_colors.html#assign_colors", "assign_colors", 'routine in <a href="util/assign_colors.html">assign_colors.pro</a>', "assign_colors.pro", "", "assign_colors", "", "interleaveidsidcolorsbase_colors_ids", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/b1950_to_j2000.html", "b1950_to_j2000.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "b1950_to_j2000.pro", "", "", " NAME: 	b1950_to_j2000    PURPOSE: 	Transforms vectors from B1950 to J2000 coordinates, or visa-versa.    CATEGORY: 	UTIL    CALLING SEQUENCE: 	result = b1950_to_j2000(v)    ARGUMENTS:   INPUT:  	      v:	An array of (n,3) column vectors in B1950 			(or J2000 if /reverse is used)     OUTPUT: NONE    KEYWORDS:   INPUT:  	reverse:	If set, then J2000 to B1950 is done.    OUTPUT: NONE    PROCEDURE: 	Multiplies the input vector by a transformation matrix.  The   transformation matrix from B1950 to J2000 was defined using the   December 20, 1984 memo from Mert Davies (Rand) to Larry Soderblom (USGS)    RETURN: 	An array of vectors in the other coordinate system.    RESTRICTIONS: 	Output array is double precision.    STATUS: 	Complete.    MODIFICATION HISTORY:  	Written by:	Haemmerle, 1/1999   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/b1950_to_j2000.html#b1950_to_j2000", "b1950_to_j2000", 'routine in <a href="util/b1950_to_j2000.html">b1950_to_j2000.pro</a>', "b1950_to_j2000.pro", "", "b1950_to_j2000", "", "reversev", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/band_intersection_area.html", "band_intersection_area.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "band_intersection_area.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/band_intersection_area.html#band_intersection_area", "band_intersection_area", 'routine in <a href="util/band_intersection_area.html">band_intersection_area.pro</a>', "band_intersection_area.pro", "", "band_intersection_area", "", "v1n1w1v2n2w2", "          -1", "");
  
  

libdata[libdataItem++] = new Array("bat/bat_argv.html", "bat_argv.pro", '.pro file in <a href="bat/dir-overview.html">bat/ directory</a>', "bat_argv.pro", "", "", " NAME:        bat_argv   PURPOSE:        Returns a shell argument list. Arguments are expanded 	according to standard shell rules.   -  is used instead of  /  to set 	a keyword to one.  Arrays are specified as comma-dilineated lists 	with no white space.    CATEGORY:        BAT    CALLING SEQUENCE:        arg = bat_argv(i)    ARGUMENTS:   INPUT: 	i:	Index of the argument to return.  If there are no arguments, 		or if i is invalid, then '' is returned.  If i is not 		specified, then all arguments are returned.    OUTPUT: NONE    KEYWORDS: NONE    RETURN:        The requested argument.  Note all arguments are returned as strings.    STATUS:        Complete.    MODIFICATION HISTORY:        Adapted from xidl_argv by:     Spitale 6/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("bat/bat_argv.html#bat_argv", "bat_argv", 'routine in <a href="bat/bat_argv.html">bat_argv.pro</a>', "bat_argv.pro", "", "bat_argv", "", "i", "          -1", "");
  
  

libdata[libdataItem++] = new Array("bat/bat_expand.html", "bat_expand.pro", '.pro file in <a href="bat/dir-overview.html">bat/ directory</a>', "bat_expand.pro", "", "", " NAME:        bat_expand   PURPOSE:        Expands file specifications using read_txt_file.  Also, defines 	global keywords for OMINAS shell commands.    CATEGORY:        BAT    CALLING SEQUENCE:        filespecs = bat_expand(keys, val_ps, input_files)    ARGUMENTS:   INPUT: 	keys:	String array giving the names of keywords aruments.  	val_ps:	Pointer array giving value for each keyword.  	input_files: String array giving names of files to be read using 	             read_txt_file.     OUTPUT: NONE    KEYWORDS: NONE    GLOBAL SHELL KEYWORDS: 	file_sample: 		Sets file list sampling; see read_txt_file.  	file_select: 		Sets file selection criterion; see read_txt_file.  	verbosity: 		Sets verbosity level; see nv_message.     RETURN: 	String array giving the concatanated results of reading every 	input file, subject to the rules of read_txt_file.  Note that 	the special keyowrds 'file_sample' and 'file_select' are detected 	and passed to read_txt_file.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("bat/bat_expand.html#bat_expand", "bat_expand", 'routine in <a href="bat/bat_expand.html">bat_expand.pro</a>', "bat_expand.pro", "", "bat_expand", "", "filespecskeysval_psinput_files", "          -1", "");
  
  

libdata[libdataItem++] = new Array("bat/bat_parse_argv.html", "bat_parse_argv.pro", '.pro file in <a href="bat/dir-overview.html">bat/ directory</a>', "bat_parse_argv.pro", "", "", " NAME:        bat_parse_argv   PURPOSE:        Parses a given idl argument list.    CATEGORY:        BAT    CALLING SEQUENCE:        argv = bat_parse_argv(argv, keys, val_ps)    ARGUMENTS:   INPUT: 	argv:	idl argument list.    OUTPUT: 	keys:	String array giving the names of keywords from any 		keyword=value pairs.  Also, any argument containing a single 		'-' as its first character is considered to be a keyword 		whose value is set to '1'.  	val_ps:	Array of pointers, one for each keyword, giving the values 		from each keyword=value pair.  Array values are delimited 		by commas.    KEYWORDS: 	special_args:	Returns the names of any arguments ending with '@'. 			Those arguments are removed from the argument list.   RETURN: 	The trimmed argument list, with all keywords=value pairs and 	special argument removed.    STATUS:        Completed.    MODIFICATION HISTORY:        Adapted from xidl_parse_argv by:     Spitale 6/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("bat/bat_parse_argv.html#bat_parse_argv", "bat_parse_argv", 'routine in <a href="bat/bat_parse_argv.html">bat_parse_argv.pro</a>', "bat_parse_argv.pro", "", "bat_parse_argv", "", "special_argsargvkeysval_ps", "          -1", "");
  
  

libdata[libdataItem++] = new Array("bat/bat_value.html", "bat_value.pro", '.pro file in <a href="bat/dir-overview.html">bat/ directory</a>', "bat_value.pro", "", "", " NAME:        bat_value   PURPOSE:        Returns the value associated with a specified keyword in an 	argument list, and removes that keyword/value pair from 	the argument list.   -  is used instead of  /  to set 	a keyword to one.    CATEGORY:        BAT    CALLING SEQUENCE:        value = bat_value(argv, keyword)    ARGUMENTS:   INPUT: 	argv:	xidl argument list.  	keyword: 		String array giving the name of the keyword for which a value 		is desired.  Keyword names may be abreviated as in IDL.    RETURN: 	Value associated with the specified keyword, or ''.    STATUS:        Completed.    MODIFICATION HISTORY:        Adapted from xidl_value by:     Spitale 6/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("bat/bat_value.html#bat_value", "bat_value", 'routine in <a href="bat/bat_value.html">bat_value.pro</a>', "bat_value.pro", "", "bat_value", "", "argvkeyword", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/sedr/bcons__define.html", "bcons__define.pro", '.pro file in <a href="config/sedr/dir-overview.html">config/sedr/ directory</a>', "bcons__define.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/sedr/bcons__define.html#bcons__define", "bcons__define", 'routine in <a href="config/sedr/bcons__define.html">bcons__define.pro</a>', "bcons__define.pro", "", "bcons__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/best_radial_scale_feat.html", "best_radial_scale_feat.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "best_radial_scale_feat.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/best_radial_scale_feat.html#best_radial_scale_feat", "best_radial_scale_feat", 'routine in <a href="nv/obj/tools/best_radial_scale_feat.html">best_radial_scale_feat.pro</a>', "best_radial_scale_feat.pro", "", "best_radial_scale_feat", "", "radminradmaxlonminlonmaxpp_minpp_maxpp0resperpcdrdpd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/binogram.html", "binogram.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "binogram.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/binogram.html#binogram", "binogram", 'routine in <a href="util/binogram.html">binogram.pro</a>', "binogram.pro", "", "binogram", "", "binreverse_indicescoords", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/bod/bod_aberration.html", "bod_aberration.pro", '.pro file in <a href="nv/obj/bod/dir-overview.html">nv/obj/bod/ directory</a>', "bod_aberration.pro", "", "", " NAME: 	bod_aberration    PURPOSE: 	Returns the aberration flags for each given body descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	ab = bod_aberration(bx, name)    ARGUMENTS:   INPUT: NONE 	bx:	 Any subclass of BODY.  	name:	 Name of aberration to return.  If not given, the full 		 aberration value is returned.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Aberration flag associated with the given name for each given body 	descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/bod/bod_aberration.html#bod_aberration", "bod_aberration", 'routine in <a href="nv/obj/bod/bod_aberration.html">bod_aberration.pro</a>', "bod_aberration.pro", "", "bod_aberration", "", "noeventbdname", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/bod/bod_assign.html", "bod_assign.pro", '.pro file in <a href="nv/obj/bod/dir-overview.html">nv/obj/bod/ directory</a>', "bod_assign.pro", "", "", " NAME: 	bod_assign    PURPOSE: 	Replaces fields in a BODY object.  This is a convenient way of 	setting multiple fields in one call, and only a single event is 	generated.    CATEGORY: 	NV/OBJ/BOD    CALLING SEQUENCE: 	bod_assign, bd, <keywords>=<values>    ARGUMENTS:   INPUT: 	bd:		BODY object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	BODY fields to set.  	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	bod_set_*     MODIFICATION HISTORY:  	Written by:	Spitale		2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/bod/bod_assign.html#bod_assign", "bod_assign", 'routine in <a href="nv/obj/bod/bod_assign.html">bod_assign.pro</a>', "bod_assign.pro", "", "bod_assign", "", "noeventxd@bod__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/bod/bod_avel.html", "bod_avel.pro", '.pro file in <a href="nv/obj/bod/dir-overview.html">nv/obj/bod/ directory</a>', "bod_avel.pro", "", "", " NAME: 	bod_avel    PURPOSE: 	Returns the angular velocity for each given body descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	avel = bod_avel(bx)    ARGUMENTS:   INPUT: NONE 	bx:	 Array (nt) of any subclass of BODY descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Angular velocity value associated with each given body descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/bod/bod_avel.html#bod_avel", "bod_avel", 'routine in <a href="nv/obj/bod/bod_avel.html">bod_avel.pro</a>', "bod_avel.pro", "", "bod_avel", "", "noeventbd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/bod/bod_body_to_inertial.html", "bod_body_to_inertial.pro", '.pro file in <a href="nv/obj/bod/dir-overview.html">nv/obj/bod/ directory</a>', "bod_body_to_inertial.pro", "", "", " NAME: 	bod_body_to_inertial    PURPOSE: 	Transforms the given column vectors from the body coordinate 	system to the inertial coordinate system.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	inertial_pts = bod_body_to_inertial(bx, body_pts)    ARGUMENTS:   INPUT: 	bx:	 	Any subclass of BODY.  	body_pts:	Array (nv,3,nt) of column vectors in the body frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (nv,3,nt) of column vectors in the bx inertial frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/bod/bod_body_to_inertial.html#bod_body_to_inertial", "bod_body_to_inertial", 'routine in <a href="nv/obj/bod/bod_body_to_inertial.html">bod_body_to_inertial.pro</a>', "bod_body_to_inertial.pro", "", "bod_body_to_inertial", "", "_subbdv", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/bod/bod_body_to_inertial.html#bod_body_to_inertial", "bod_body_to_inertial", 'routine in <a href="nv/obj/bod/bod_body_to_inertial.html">bod_body_to_inertial.pro</a>', "bod_body_to_inertial.pro", "", "bod_body_to_inertial", "", "_subbdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/bod/bod_body_to_inertial_default.html", "bod_body_to_inertial_default.pro", '.pro file in <a href="nv/obj/bod/dir-overview.html">nv/obj/bod/ directory</a>', "bod_body_to_inertial_default.pro", "", "", " NAME: 	bod_body_to_inertial_default    PURPOSE: 	Transforms the given column vectors from the body coordinate 	system to the inertial coordinate system.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	inertial_pts = bod_body_to_inertial_default(bx, body_pts)    ARGUMENTS:   INPUT: 	bx:	 	Any subclass of BODY.  	body_pts:	Array (nv,3,nt) of column vectors in the body frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (nv,3,nt) of column vectors in the bx inertial frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/bod/bod_body_to_inertial_default.html#bod_body_to_inertial_default", "bod_body_to_inertial_default", 'routine in <a href="nv/obj/bod/bod_body_to_inertial_default.html">bod_body_to_inertial_default.pro</a>', "bod_body_to_inertial_default.pro", "", "bod_body_to_inertial_default", "", "_subbdvp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/bod/bod_body_to_inertial_pos.html", "bod_body_to_inertial_pos.pro", '.pro file in <a href="nv/obj/bod/dir-overview.html">nv/obj/bod/ directory</a>', "bod_body_to_inertial_pos.pro", "", "", " NAME: 	bod_body_to_inertial_pos    PURPOSE:        Transforms the given column position vectors from the body        coordinate system to the inertial coordinate system.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	inertial_pts = bod_body_to_inertial(bx, body_pts)    ARGUMENTS:   INPUT: 	bx:	 	Array (nt) of any subclass of BODY descriptors.  	body_pts:	Array (nv,3,nt) of column POSITION vectors in the body frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (nv,3,nt) of column position vectors in the inertial        frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/bod/bod_body_to_inertial_pos.html#bod_body_to_inertial_pos", "bod_body_to_inertial_pos", 'routine in <a href="nv/obj/bod/bod_body_to_inertial_pos.html">bod_body_to_inertial_pos.pro</a>', "bod_body_to_inertial_pos.pro", "", "bod_body_to_inertial_pos", "", "bdv", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/bod/bod_body_to_inertial_pos.html#__bod_body_to_inertial_pos", "__bod_body_to_inertial_pos", 'routine in <a href="nv/obj/bod/bod_body_to_inertial_pos.html">bod_body_to_inertial_pos.pro</a>', "bod_body_to_inertial_pos.pro", "", "__bod_body_to_inertial_pos", "", "bdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/bod/bod_body_to_inertial_vel.html", "bod_body_to_inertial_vel.pro", '.pro file in <a href="nv/obj/bod/dir-overview.html">nv/obj/bod/ directory</a>', "bod_body_to_inertial_vel.pro", "", "", " NAME: 	bod_body_to_inertial_vel    PURPOSE:        Transforms the given column velocity vectors from the body        coordinate system to the inertial coordinate system.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	inertial_vel = bod_body_to_inertial_vel(bx, body_vel)    ARGUMENTS:   INPUT: 	bx:	 	Array (nt) of any subclass of BODY descriptors.  	body_vel:	Array (nv,3,nt) of column velocity vectors in the body frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (nv,3,nt) of column velocity vectors in the inertial        frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/bod/bod_body_to_inertial_vel.html#bod_body_to_inertial_vel", "bod_body_to_inertial_vel", 'routine in <a href="nv/obj/bod/bod_body_to_inertial_vel.html">bod_body_to_inertial_vel.pro</a>', "bod_body_to_inertial_vel.pro", "", "bod_body_to_inertial_vel", "", "bdv", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/bod/bod_body_to_inertial_vel.html#bod_body_to_inertial_vel", "bod_body_to_inertial_vel", 'routine in <a href="nv/obj/bod/bod_body_to_inertial_vel.html">bod_body_to_inertial_vel.pro</a>', "bod_body_to_inertial_vel.pro", "", "bod_body_to_inertial_vel", "", "bdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/bod/bod_body_to_radec.html", "bod_body_to_radec.pro", '.pro file in <a href="nv/obj/bod/dir-overview.html">nv/obj/bod/ directory</a>', "bod_body_to_radec.pro", "", "", " NAME: 	bod_body_to_radec    PURPOSE:        Transforms the given column vectors from the body coordinate        system to the RA/DEC coordinate system associated to that        body.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	radec_pts = bod_body_to_radec(bx, body_pts)    ARGUMENTS:   INPUT: 	bx:	 	Array (nt) of any subclass of BODY descriptors.  	body_pts:	Array (nv,3,nt) of column vectors in the body frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (nv,3,nt) of column vectors in the bx radec frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/bod/bod_body_to_radec.html#bod_body_to_radec", "bod_body_to_radec", 'routine in <a href="nv/obj/bod/bod_body_to_radec.html">bod_body_to_radec.pro</a>', "bod_body_to_radec.pro", "", "bod_body_to_radec", "", "bdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/bod/bod_body_to_radec_vel.html", "bod_body_to_radec_vel.pro", '.pro file in <a href="nv/obj/bod/dir-overview.html">nv/obj/bod/ directory</a>', "bod_body_to_radec_vel.pro", "", "", " NAME: 	bod_body_to_radec_vel    PURPOSE:        Transforms the given column velocity vectors from the body coordinate        system to the RA/DEC coordinate system associated with that body.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	radec_pts = bod_body_to_radec_vel(bx, body_pts)    ARGUMENTS:   INPUT: 	bx:	 	Array (nt) of any subclass of BODY descriptors.  	body_pts:	Array (nv,3,nt) of column vectors in the body frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (nv,3,nt) of column vectors in the bx radec frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/bod/bod_body_to_radec_vel.html#bod_body_to_radec_vel", "bod_body_to_radec_vel", 'routine in <a href="nv/obj/bod/bod_body_to_radec_vel.html">bod_body_to_radec_vel.pro</a>', "bod_body_to_radec_vel.pro", "", "bod_body_to_radec_vel", "", "bdrv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/bod/bod_create_descriptors.html", "bod_create_descriptors.pro", '.pro file in <a href="nv/obj/bod/dir-overview.html">nv/obj/bod/ directory</a>', "bod_create_descriptors.pro", "", "", " NAME: 	bod_create_descriptors    PURPOSE: 	Init method for the BODY class.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	bd = bod_create_descriptors(n)    ARGUMENTS:   INPUT: 	n:	Number of descriptors to create.    OUTPUT: NONE    KEYWORDS (in addition to those accepted by all superclasses):   INPUT: 	bd:	Body descriptor(s) to initialize, instead of creating a new one.  	crd:	Core descriptor(s) to pass to cor_create_descriptors.  	time:	Array (n) of times, at body position, at which each descriptor 		is valid.  	opaque:	Array (n) of flags describing whether each body is  easily 		visible .  	orient:	Array (3,3,n) of orientation matrices, transforming body to 		inertial for each body.  	avel:	Array (ndv,3,n) of angular velocity vectors for each body.  	pos:	Array (ndv,3,n) of position vectors for each body.  	vel:	Array (ndv,3,n) of velocity vectors for each body.  	libv:	Array (ndv,3,n) of libration vectors for each body.  	lib:	Array (ndv,n) of libration phases for each body.  	dlibdt:	Array (ndv,n) of libration frequencies for each body.     OUTPUT: NONE    RETURN: 	Newly created or or freshly initialized body descriptors, depending 	on the presence of the bd keyword.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/bod/bod_create_descriptors.html#bod_create_descriptors", "bod_create_descriptors", 'routine in <a href="nv/obj/bod/bod_create_descriptors.html">bod_create_descriptors.pro</a>', "bod_create_descriptors.pro", "", "bod_create_descriptors", "", "crdbdn@bod__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/bod/bod_dlibdt.html", "bod_dlibdt.pro", '.pro file in <a href="nv/obj/bod/dir-overview.html">nv/obj/bod/ directory</a>', "bod_dlibdt.pro", "", "", " NAME: 	bod_dlibdt    PURPOSE:        Returns the frequency of each libration vector for each given        body descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	dlibdt = bod_dlibdt(bx)    ARGUMENTS:   INPUT: NONE 	bx:	 Array (nt) of any subclass of BODY descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN:        Values of the frequency of each libration vector associated        with each given body descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/bod/bod_dlibdt.html#bod_dlibdt", "bod_dlibdt", 'routine in <a href="nv/obj/bod/bod_dlibdt.html">bod_dlibdt.pro</a>', "bod_dlibdt.pro", "", "bod_dlibdt", "", "noeventbd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/bod/bod_evolve.html", "bod_evolve.pro", '.pro file in <a href="nv/obj/bod/dir-overview.html">nv/obj/bod/ directory</a>', "bod_evolve.pro", "", "", " NAME: 	bod_evolve    PURPOSE: 	Computes new body descriptors at the given time offsets from the 	given body descriptors using the taylor series expansion 	corresponding to the derivatives contained in the given body 	descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	bdt = bod_evolve(bx, dt)    ARGUMENTS:   INPUT: 	bx:	 Any subclass of BODY.  	dt:	 Time offset.    OUTPUT: NONE    KEYWORDS:   INPUT: 	nodv:	If set, derivatives will not be evolved.  	copy:	If set, the evolved descriptor is copied into the input 		descriptor and it is freed.  The input descriptor is returned.     OUTPUT: NONE    RETURN: 	Array (nbd,ndt) of newly allocated descriptors, of class BODY, 	evolved by time dt, where nbd is the number of bx, and ndt 	is the number of dt.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/bod/bod_evolve.html#bod_evolve", "bod_evolve", 'routine in <a href="nv/obj/bod/bod_evolve.html">bod_evolve.pro</a>', "bod_evolve.pro", "", "bod_evolve", "", "nodvcopybddt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/bod/bod_get_radec_ranges.html", "bod_get_radec_ranges.pro", '.pro file in <a href="nv/obj/bod/dir-overview.html">nv/obj/bod/ directory</a>', "bod_get_radec_ranges.pro", "", "", " NAME: 	bod_get_radec_ranges    PURPOSE: 	Returns ranges of valid  radec coordinates for the given BODY object.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	ranges = bod_get_radec_ranges(bx)    ARGUMENTS:   INPUT: 	bx:	 Any subclass of BODY.  One descriptor only.     OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Array (2 x 3) giving the ranges in radius, RA and DEC.    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/bod/bod_get_radec_ranges.html#bod_get_radec_ranges", "bod_get_radec_ranges", 'routine in <a href="nv/obj/bod/bod_get_radec_ranges.html">bod_get_radec_ranges.pro</a>', "bod_get_radec_ranges.pro", "", "bod_get_radec_ranges", "", "bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/bod/bod_ib_data.html", "bod_ib_data.pro", '.pro file in <a href="nv/obj/bod/dir-overview.html">nv/obj/bod/ directory</a>', "bod_ib_data.pro", "", "", " NAME: 	bod_ib_data    PURPOSE: 	Returns the function data for a body descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	data = bod_ib_data(bd)    ARGUMENTS:   INPUT: NONE 	bd:	 Body descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Function data associated with the given body descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Adapted by:	Spitale, 7/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/bod/bod_ib_data.html#bod_ib_data", "bod_ib_data", 'routine in <a href="nv/obj/bod/bod_ib_data.html">bod_ib_data.pro</a>', "bod_ib_data.pro", "", "bod_ib_data", "", "noeventbd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("vims_src_tmp/bod_image_to_inertial.html", "bod_image_to_inertial.pro", '.pro file in <a href="vims_src_tmp/dir-overview.html">vims_src_tmp/ directory</a>', "bod_image_to_inertial.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("vims_src_tmp/bod_image_to_inertial.html#bod_image_to_inertial", "bod_image_to_inertial", 'routine in <a href="vims_src_tmp/bod_image_to_inertial.html">bod_image_to_inertial.pro</a>', "bod_image_to_inertial.pro", "", "bod_image_to_inertial", "", "cdp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/bod/bod_inertial.html", "bod_inertial.pro", '.pro file in <a href="nv/obj/bod/dir-overview.html">nv/obj/bod/ directory</a>', "bod_inertial.pro", "", "", " NAME: 	bod_inertial    PURPOSE: 	Returns body descriptors defining te inertial coordinate system.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	bd = bod_inertial()    ARGUMENTS:   INPUT: 	nt : number of desriptors to return.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Body descriptor defining the inertial frame.  Note this descriptor is 	not allocated on the heap, so it should not be freed by the caller.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/bod/bod_inertial.html#bod_inertial", "bod_inertial", 'routine in <a href="nv/obj/bod/bod_inertial.html">bod_inertial.pro</a>', "bod_inertial.pro", "", "bod_inertial", "", "nt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/bod/bod_inertial_to_body.html", "bod_inertial_to_body.pro", '.pro file in <a href="nv/obj/bod/dir-overview.html">nv/obj/bod/ directory</a>', "bod_inertial_to_body.pro", "", "", " NAME: 	bod_inertial_to_body    PURPOSE: 	Transforms the given column vectors from the inertial coordinate 	system to the body coordinate system.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	body_pts = bod_inertial_to_body(bx, inertial_pts)    ARGUMENTS:   INPUT: 	bx:	 	Any subclass of BODY.  	inertial_pts:	Array (nv,3,nt) of column vectors in the inertial frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (nv,3,nt) of column vectors in the bx body frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/bod/bod_inertial_to_body.html#bod_inertial_to_body", "bod_inertial_to_body", 'routine in <a href="nv/obj/bod/bod_inertial_to_body.html">bod_inertial_to_body.pro</a>', "bod_inertial_to_body.pro", "", "bod_inertial_to_body", "", "_subbdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/bod/bod_inertial_to_body_default.html", "bod_inertial_to_body_default.pro", '.pro file in <a href="nv/obj/bod/dir-overview.html">nv/obj/bod/ directory</a>', "bod_inertial_to_body_default.pro", "", "", " NAME: 	bod_inertial_to_body_default    PURPOSE: 	Transforms the given column vectors from the inertial coordinate 	system to the body coordinate system.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	body_pts = bod_inertial_to_body_default(bx, inertial_pts)    ARGUMENTS:   INPUT: 	bx:	 	Any subclass of BODY.  	inertial_pts:	Array (nv,3,nt) of column vectors in the inertial frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (nv,3,nt) of column vectors in the bx body frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/bod/bod_inertial_to_body_default.html#bod_inertial_to_body_default", "bod_inertial_to_body_default", 'routine in <a href="nv/obj/bod/bod_inertial_to_body_default.html">bod_inertial_to_body_default.pro</a>', "bod_inertial_to_body_default.pro", "", "bod_inertial_to_body_default", "", "_subbdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/bod/bod_inertial_to_body_pos.html", "bod_inertial_to_body_pos.pro", '.pro file in <a href="nv/obj/bod/dir-overview.html">nv/obj/bod/ directory</a>', "bod_inertial_to_body_pos.pro", "", "", " NAME: 	bod_inertial_to_body_pos    PURPOSE:        Transforms the given column position vectors from the inertial        coordinate system to the body coordinate system.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	body_pts = bod_inertial_to_body_pos(bx, inertial_pts)    ARGUMENTS:   INPUT: 	bx:	 	Array (nt) of any subclass of BODY descriptors.  	inertial_pts:	Array (nv,3,nt) of column POSITION vectors in the inertial frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (nv,3,nt) of column position vectors in the bx body        frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/bod/bod_inertial_to_body_pos.html#bod_inertial_to_body_pos", "bod_inertial_to_body_pos", 'routine in <a href="nv/obj/bod/bod_inertial_to_body_pos.html">bod_inertial_to_body_pos.pro</a>', "bod_inertial_to_body_pos.pro", "", "bod_inertial_to_body_pos", "", "bdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/bod/bod_inertial_to_body_vel.html", "bod_inertial_to_body_vel.pro", '.pro file in <a href="nv/obj/bod/dir-overview.html">nv/obj/bod/ directory</a>', "bod_inertial_to_body_vel.pro", "", "", " NAME: 	bod_inertial_to_body_vel    PURPOSE:        Transforms the given column velocity vectors from the inertial        coordinate system to the body coordinate system.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	body_vel = bod_inertial_to_body_vel(bx, inertial_vel)    ARGUMENTS:   INPUT: 	bx:	 	Array (nt) of any subclass of BODY descriptors.  	inertial_vel:	Array (nv,3,nt) of column velocity vectors in the inertial frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (nv,3,nt) of column velocity vectors in the bx body        frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/bod/bod_inertial_to_body_vel.html#bod_inertial_to_body_vel", "bod_inertial_to_body_vel", 'routine in <a href="nv/obj/bod/bod_inertial_to_body_vel.html">bod_inertial_to_body_vel.pro</a>', "bod_inertial_to_body_vel.pro", "", "bod_inertial_to_body_vel", "", "bdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/bod/bod_lib.html", "bod_lib.pro", '.pro file in <a href="nv/obj/bod/dir-overview.html">nv/obj/bod/ directory</a>', "bod_lib.pro", "", "", " NAME: 	bod_lib    PURPOSE:        Returns the phase of the libration vector at body time for        each given body descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	lib = bod_lib(bx)    ARGUMENTS:   INPUT: NONE 	bx:	 Array (nt) of any subclass of BODY descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN:        Phase of the libraton vectors at body time associated with        each given body descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/bod/bod_lib.html#bod_lib", "bod_lib", 'routine in <a href="nv/obj/bod/bod_lib.html">bod_lib.pro</a>', "bod_lib.pro", "", "bod_lib", "", "noeventbd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/bod/bod_libv.html", "bod_libv.pro", '.pro file in <a href="nv/obj/bod/dir-overview.html">nv/obj/bod/ directory</a>', "bod_libv.pro", "", "", " NAME: 	bod_libv    PURPOSE: 	Returns the libration vector for each given body descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	libv = bod_libv(bx)    ARGUMENTS:   INPUT: NONE 	bx:	 Array (nt) of any subclass of BODY descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Libration vector associated with each given body descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/bod/bod_libv.html#bod_libv", "bod_libv", 'routine in <a href="nv/obj/bod/bod_libv.html">bod_libv.pro</a>', "bod_libv.pro", "", "bod_libv", "", "noeventbd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/bod/bod_ndv.html", "bod_ndv.pro", '.pro file in <a href="nv/obj/bod/dir-overview.html">nv/obj/bod/ directory</a>', "bod_ndv.pro", "", "", " NAME: 	bod_ndv    PURPOSE: 	Returns an integer indicating the maximum number of time derivatives 	allowed in the vel and avel fields of the body descriptor.  This number 	can be adjusted using the environment variable 'BOD_NDV'.  The default 	is 4.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	ndv = bod_ndv()    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: NONE     OUTPUT: NONE    ENVIRONMENT VARIABLES: 	BOD_NDV:	Sets the ndv value.    RETURN: 	Current ndv value.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/bod/bod_ndv.html#bod_ndv", "bod_ndv", 'routine in <a href="nv/obj/bod/bod_ndv.html">bod_ndv.pro</a>', "bod_ndv.pro", "", "bod_ndv", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/bod/bod_opaque.html", "bod_opaque.pro", '.pro file in <a href="nv/obj/bod/dir-overview.html">nv/obj/bod/ directory</a>', "bod_opaque.pro", "", "", " NAME: 	bod_opaque    PURPOSE: 	Returns the opaque value for each given body descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	opaque = bod_opaque(bx)    ARGUMENTS:   INPUT: NONE 	bx:	 Array (nt) of any subclass of BODY descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Opaque value associated with each given body descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/bod/bod_opaque.html#bod_opaque", "bod_opaque", 'routine in <a href="nv/obj/bod/bod_opaque.html">bod_opaque.pro</a>', "bod_opaque.pro", "", "bod_opaque", "", "noeventbd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/bod/bod_orient.html", "bod_orient.pro", '.pro file in <a href="nv/obj/bod/dir-overview.html">nv/obj/bod/ directory</a>', "bod_orient.pro", "", "", " NAME: 	bod_orient    PURPOSE: 	Returns the orientation matrix for each given body descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	orient = bod_orient(bx)    ARGUMENTS:   INPUT: NONE 	bx:	 Array (nt) of any subclass of BODY descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Orientation matrix associated with each given body descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/bod/bod_orient.html#bod_orient", "bod_orient", 'routine in <a href="nv/obj/bod/bod_orient.html">bod_orient.pro</a>', "bod_orient.pro", "", "bod_orient", "", "noeventbd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/bod/bod_pos.html", "bod_pos.pro", '.pro file in <a href="nv/obj/bod/dir-overview.html">nv/obj/bod/ directory</a>', "bod_pos.pro", "", "", " NAME: 	bod_pos    PURPOSE:        Returns the position of body center (in the inertial frame)        for each given body descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	pos = bod_pos(bx)    ARGUMENTS:   INPUT: NONE 	bx:	 Array (nt) of any subclass of BODY descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN:        Position of body center (in the inertial frame) associated        with each given body descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/bod/bod_pos.html#bod_pos", "bod_pos", 'routine in <a href="nv/obj/bod/bod_pos.html">bod_pos.pro</a>', "bod_pos.pro", "", "bod_pos", "", "noeventbd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/bod/bod_query.html", "bod_query.pro", '.pro file in <a href="nv/obj/bod/dir-overview.html">nv/obj/bod/ directory</a>', "bod_query.pro", "", "", " NAME: 	bod_query    PURPOSE: 	Returns the fields associated with a BODY object.  This is a 	convenient way of getting multiple fields in one call, and only a 	single event is generated.    CATEGORY: 	NV/OBJ/BOD    CALLING SEQUENCE: 	bod_query, bd, <keywords>=<values>    ARGUMENTS:   INPUT: 	bd:	BODY object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	BODY object fields to set.  	condition:	Structure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT object, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.  	cat:		If set, arrays from mulitple input objets are 			concatenated.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.  	noevent:	If set, no event is generated.    OUTPUT: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/bod/bod_query.html#bod_query", "bod_query", 'routine in <a href="nv/obj/bod/bod_query.html">bod_query.pro</a>', "bod_query.pro", "", "bod_query", "", "conditioncatnoeventxd@bod__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/bod/bod_radec_to_body.html", "bod_radec_to_body.pro", '.pro file in <a href="nv/obj/bod/dir-overview.html">nv/obj/bod/ directory</a>', "bod_radec_to_body.pro", "", "", " NAME: 	bod_radec_to_body    PURPOSE: 	Transforms the given column vectors from the RA/DEC coordinate        system associated to the body to the body coordinate system.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	body_pts = bod_radec_to_body(bx, radec_pts)    ARGUMENTS:   INPUT: 	bx:	 	Array (nt) of any subclass of BODY descriptors.  	radec_pts:	Array (nv,3,nt) of column vectors in the bx radec frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (nv,3,nt) of column vectors in the bx body frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/bod/bod_radec_to_body.html#bod_radec_to_body", "bod_radec_to_body", 'routine in <a href="nv/obj/bod/bod_radec_to_body.html">bod_radec_to_body.pro</a>', "bod_radec_to_body.pro", "", "bod_radec_to_body", "", "bdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/bod/bod_radec_to_body_vel.html", "bod_radec_to_body_vel.pro", '.pro file in <a href="nv/obj/bod/dir-overview.html">nv/obj/bod/ directory</a>', "bod_radec_to_body_vel.pro", "", "", " NAME: 	bod_radec_to_body_vel    PURPOSE: 	Transforms the given column velocity vectors from the RA/DEC coordinate        system associated to the body to the body coordinate system.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	body_pts = bod_radec_to_body_vel(bx, radec_pos, radec_vel)    ARGUMENTS:   INPUT: 	bx:	 	Array (nt) of any subclass of BODY descriptors.  	radec_pos:	Array (nv,3,nt) of column vectors in the bx radec frame.  	radec_vel:	Array (nv,3,nt) of column velocity vectors in the bx 			radec frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (nv,3,nt) of column velocity vectors in the bx body frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/bod/bod_radec_to_body_vel.html#bod_radec_to_body_vel", "bod_radec_to_body_vel", 'routine in <a href="nv/obj/bod/bod_radec_to_body_vel.html">bod_radec_to_body_vel.pro</a>', "bod_radec_to_body_vel.pro", "", "bod_radec_to_body_vel", "", "bdrv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/bod/bod_recenter.html", "bod_recenter.pro", '.pro file in <a href="nv/obj/bod/dir-overview.html">nv/obj/bod/ directory</a>', "bod_recenter.pro", "", "", " NAME: 	bod_recenter    PURPOSE: 	Transforms a body descriptor into another body frame.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	bod_recenter, bx, bx0    ARGUMENTS:   INPUT: 	bx:	Descriptor to transform, array (nt) of any subclass of BODY.  	bx0:	Frame to transform into, array (nt) of any subclass of BODY.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE   STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/bod/bod_recenter.html#bod_recenter", "bod_recenter", 'routine in <a href="nv/obj/bod/bod_recenter.html">bod_recenter.pro</a>', "bod_recenter.pro", "", "bod_recenter", "", "bxbx0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/bod/bod_reorient.html", "bod_reorient.pro", '.pro file in <a href="nv/obj/bod/dir-overview.html">nv/obj/bod/ directory</a>', "bod_reorient.pro", "", "", " NAME: 	bod_reorient    PURPOSE: 	Rotates the orientation matrix of each body such that the specified 	axis vector is parallel to the given vector.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	bod_reorient, bx, index, v    ARGUMENTS:   INPUT: 	bx:	Array (nt) of any subclass of BODY.  	index:	Integer giving the reference body axis: 0, 1, or 2.  	v:	Array (nv,3,nt) of column vectors to align with the 		each reference axis.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/bod/bod_reorient.html#bod_reorient", "bod_reorient", 'routine in <a href="nv/obj/bod/bod_reorient.html">bod_reorient.pro</a>', "bod_reorient.pro", "", "bod_reorient", "", "bxii_v", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/bod/bod_replicate.html", "bod_replicate.pro", '.pro file in <a href="nv/obj/bod/dir-overview.html">nv/obj/bod/ directory</a>', "bod_replicate.pro", "", "", " NAME: 	bod_replicate    PURPOSE: 	Replicates the given descriptor, producing an array of the given 	dimensions containing cloned versions of the input descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	xd = bod_replicate(bx, dim)    ARGUMENTS:   INPUT: 	bx:	 Any superclass of BODY.  	dim:	 Dimensions of the result.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Array of the given dimensions containing cloned versions of the input 	descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/bod/bod_replicate.html#bod_replicate", "bod_replicate", 'routine in <a href="nv/obj/bod/bod_replicate.html">bod_replicate.pro</a>', "bod_replicate.pro", "", "bod_replicate", "", "bddim", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/bod/bod_rotate.html", "bod_rotate.pro", '.pro file in <a href="nv/obj/bod/dir-overview.html">nv/obj/bod/ directory</a>', "bod_rotate.pro", "", "", " NAME: 	bod_rotate    PURPOSE: 	Rotates a body about one its axes.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	bod_rotate, bd, theta, axis=axis    ARGUMENTS:   INPUT: 	bx:	 	Any subclass of BODY (nt).  	theta:		Angle of rotation (nt).    OUTPUT: NONE    KEYWORDS:   INPUT: axis:		Body axis about which to rotate; default is 2.    OUTPUT: NONE    RETURN: 	NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2014  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/bod/bod_rotate.html#bod_rotate", "bod_rotate", 'routine in <a href="nv/obj/bod/bod_rotate.html">bod_rotate.pro</a>', "bod_rotate.pro", "", "bod_rotate", "", "axisbx_theta", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/bod/bod_set_aberration.html", "bod_set_aberration.pro", '.pro file in <a href="nv/obj/bod/dir-overview.html">nv/obj/bod/ directory</a>', "bod_set_aberration.pro", "", "", " NAME: 	bod_set_aberration    PURPOSE: 	Sets aberration flags for each given body descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	bod_set_aberration, bx, name    ARGUMENTS:   INPUT: 	bx:	 Any subclass of BODY.  	name:	 Name of aberration to set.    OUTPUT: NONE    KEYWORDS:   INPUT: 	unset:	If set, the named flag is unset.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/bod/bod_set_aberration.html#bod_set_aberration", "bod_set_aberration", 'routine in <a href="nv/obj/bod/bod_set_aberration.html">bod_set_aberration.pro</a>', "bod_set_aberration.pro", "", "bod_set_aberration", "", "unsetnoeventbdname", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/bod/bod_set_avel.html", "bod_set_avel.pro", '.pro file in <a href="nv/obj/bod/dir-overview.html">nv/obj/bod/ directory</a>', "bod_set_avel.pro", "", "", " NAME: 	bod_set_avel    PURPOSE: 	Replaces the angular velocity vector of each given body descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	bod_set_avel, bx, avel    ARGUMENTS:   INPUT: 	bx:	 Array (nt) of any subclass of BODY descriptors.  	avel:	 Array (ndv,3,nt) of new angular velocity vectors.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/bod/bod_set_avel.html#bod_set_avel", "bod_set_avel", 'routine in <a href="nv/obj/bod/bod_set_avel.html">bod_set_avel.pro</a>', "bod_set_avel.pro", "", "bod_set_avel", "", "noeventbdavel", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/bod/bod_set_dlibdt.html", "bod_set_dlibdt.pro", '.pro file in <a href="nv/obj/bod/dir-overview.html">nv/obj/bod/ directory</a>', "bod_set_dlibdt.pro", "", "", " NAME: 	bod_set_dlibdt    PURPOSE:        Replaces the frequency of each libration vector for each given        body descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	bod_set_dlibdt, bx, dlibdt    ARGUMENTS:   INPUT: 	bx:	 Array (nt) of any subclass of BODY descriptors.  	dlibdt:	 Array (ndv,nt) of new frequencies.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/bod/bod_set_dlibdt.html#bod_set_dlibdt", "bod_set_dlibdt", 'routine in <a href="nv/obj/bod/bod_set_dlibdt.html">bod_set_dlibdt.pro</a>', "bod_set_dlibdt.pro", "", "bod_set_dlibdt", "", "noeventbddlibdt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/bod/bod_set_ib_data.html", "bod_set_ib_data.pro", '.pro file in <a href="nv/obj/bod/dir-overview.html">nv/obj/bod/ directory</a>', "bod_set_ib_data.pro", "", "", " NAME: 	bod_set_ib_data    PURPOSE: 	Replaces the function data for a body descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	bod_set_ib_data, bd, data    ARGUMENTS:   INPUT: 	bd:	 Body descriptor.  	data:	 New function data.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Adapted by:	Spitale, 7/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/bod/bod_set_ib_data.html#bod_set_ib_data", "bod_set_ib_data", 'routine in <a href="nv/obj/bod/bod_set_ib_data.html">bod_set_ib_data.pro</a>', "bod_set_ib_data.pro", "", "bod_set_ib_data", "", "noeventbddata", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/bod/bod_set_lib.html", "bod_set_lib.pro", '.pro file in <a href="nv/obj/bod/dir-overview.html">nv/obj/bod/ directory</a>', "bod_set_lib.pro", "", "", " NAME: 	bod_set_lib    PURPOSE:        Replaces the phase of the libration vector at body time for        each given body descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	bod_set_lib, bx, lib    ARGUMENTS:   INPUT: 	bx:	 Array (nt) of any subclass of BODY descriptors.  	lib:	 Array (ndv,nt) of new phases of the libration vectors.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/bod/bod_set_lib.html#bod_set_lib", "bod_set_lib", 'routine in <a href="nv/obj/bod/bod_set_lib.html">bod_set_lib.pro</a>', "bod_set_lib.pro", "", "bod_set_lib", "", "noeventbdlib", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/bod/bod_set_libv.html", "bod_set_libv.pro", '.pro file in <a href="nv/obj/bod/dir-overview.html">nv/obj/bod/ directory</a>', "bod_set_libv.pro", "", "", " NAME: 	bod_set_libv    PURPOSE: 	Replaces the libration vector of each given body descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	bod_set_libv, bx, libv    ARGUMENTS:   INPUT: 	bx:	 Array (nt) of any subclass of BODY descriptors.  	libv:	 Array (ndv,3,nt) of new libration vectors.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/bod/bod_set_libv.html#bod_set_libv", "bod_set_libv", 'routine in <a href="nv/obj/bod/bod_set_libv.html">bod_set_libv.pro</a>', "bod_set_libv.pro", "", "bod_set_libv", "", "noeventbdlibv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/bod/bod_set_opaque.html", "bod_set_opaque.pro", '.pro file in <a href="nv/obj/bod/dir-overview.html">nv/obj/bod/ directory</a>', "bod_set_opaque.pro", "", "", " NAME: 	bod_set_opaque    PURPOSE: 	Replaces the opaque flag of each given body descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	bod_set_opaque, bx, opaque    ARGUMENTS:   INPUT: 	bx:	 Array (nt) of any subclass of BODY descriptors.  	avel:	 Array (nt) of new opaque values.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/bod/bod_set_opaque.html#bod_set_opaque", "bod_set_opaque", 'routine in <a href="nv/obj/bod/bod_set_opaque.html">bod_set_opaque.pro</a>', "bod_set_opaque.pro", "", "bod_set_opaque", "", "noeventbdopaque", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/bod/bod_set_orient.html", "bod_set_orient.pro", '.pro file in <a href="nv/obj/bod/dir-overview.html">nv/obj/bod/ directory</a>', "bod_set_orient.pro", "", "", " NAME: 	bod_set_orient    PURPOSE: 	Replaces the orientation matrix of each given body descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	bod_set_orient, bx, orient    ARGUMENTS:   INPUT: 	bx:	 Array (nt) of any subclass of BODY descriptors.  	orient:	 Array (3,3,nt) of new orientation matrices.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/bod/bod_set_orient.html#bod_set_orient", "bod_set_orient", 'routine in <a href="nv/obj/bod/bod_set_orient.html">bod_set_orient.pro</a>', "bod_set_orient.pro", "", "bod_set_orient", "", "noeventbdorient", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/bod/bod_set_pos.html", "bod_set_pos.pro", '.pro file in <a href="nv/obj/bod/dir-overview.html">nv/obj/bod/ directory</a>', "bod_set_pos.pro", "", "", " NAME: 	bod_set_pos    PURPOSE:        Replaces the position of body center (in the inertial frame)        of each given body descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	bod_set_pos, bx, pos    ARGUMENTS:   INPUT: 	bx:	 Array (nt) of any subclass of BODY descriptors.  	pos:	 Array (1,3,nt) of new position vectors.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/bod/bod_set_pos.html#bod_set_pos", "bod_set_pos", 'routine in <a href="nv/obj/bod/bod_set_pos.html">bod_set_pos.pro</a>', "bod_set_pos.pro", "", "bod_set_pos", "", "noeventbdpos", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/bod/bod_set_time.html", "bod_set_time.pro", '.pro file in <a href="nv/obj/bod/dir-overview.html">nv/obj/bod/ directory</a>', "bod_set_time.pro", "", "", " NAME: 	bod_set_time    PURPOSE: 	Replaces the time of each given body descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	bod_set_time, bx, time    ARGUMENTS:   INPUT: 	bx:	 Any subclass of BODY.  	time:	 New time value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/bod/bod_set_time.html#bod_set_time", "bod_set_time", 'routine in <a href="nv/obj/bod/bod_set_time.html">bod_set_time.pro</a>', "bod_set_time.pro", "", "bod_set_time", "", "noeventbdtime", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/bod/bod_set_vel.html", "bod_set_vel.pro", '.pro file in <a href="nv/obj/bod/dir-overview.html">nv/obj/bod/ directory</a>', "bod_set_vel.pro", "", "", " NAME: 	bod_set_vel    PURPOSE:        Replaces the velocity vector (of body center in the inertial        frame) of each given body descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	bod_set_vel, bx, vel    ARGUMENTS:   INPUT: 	bx:	 Array (nt) of any subclass of BODY descriptors.  	vel:	 Array (ndv,3,nt) of new velocity vectors.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/bod/bod_set_vel.html#bod_set_vel", "bod_set_vel", 'routine in <a href="nv/obj/bod/bod_set_vel.html">bod_set_vel.pro</a>', "bod_set_vel.pro", "", "bod_set_vel", "", "noeventbdvel", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/bod/bod_time.html", "bod_time.pro", '.pro file in <a href="nv/obj/bod/dir-overview.html">nv/obj/bod/ directory</a>', "bod_time.pro", "", "", " NAME: 	bod_time    PURPOSE: 	Returns the time for each given body descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	time = bod_time(bx)    ARGUMENTS:   INPUT: NONE 	bx:	 Any subclass of BODY.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Time value associated with each given body descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/bod/bod_time.html#bod_time", "bod_time", 'routine in <a href="nv/obj/bod/bod_time.html">bod_time.pro</a>', "bod_time.pro", "", "bod_time", "", "noeventbd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/bod/bod_vel.html", "bod_vel.pro", '.pro file in <a href="nv/obj/bod/dir-overview.html">nv/obj/bod/ directory</a>', "bod_vel.pro", "", "", " NAME: 	bod_vel    PURPOSE:        Returns the velocity of body center (in the inertial frame)        for each given body descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	vel = bod_vel(bx)    ARGUMENTS:   INPUT: NONE 	bx:	 Array (nt) of any subclass of BODY descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN:        Velocity of body center (in the inertial frame) associated        with each given body descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/bod/bod_vel.html#bod_vel", "bod_vel", 'routine in <a href="nv/obj/bod/bod_vel.html">bod_vel.pro</a>', "bod_vel.pro", "", "bod_vel", "", "noeventbd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/composite/body_radius.html", "body_radius.pro", '.pro file in <a href="nv/obj/tools/composite/dir-overview.html">nv/obj/tools/composite/ directory</a>', "body_radius.pro", "", "", " NAME:        body_radius    PURPOSE: 	Returns the sizes of the given bodies.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        body_radius(bx)    ARGUMENTS:   INPUT: 	bx:      Globe or Disk descriptor; nt.     OUTPUT: NONE    KEYWORDS:    INPUT: NONE     OUTPUT: NONE    RETURN: 	nt-element array giving the size of each body.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/composite/body_radius.html#body_radius", "body_radius", 'routine in <a href="nv/obj/tools/composite/body_radius.html">body_radius.pro</a>', "body_radius.pro", "", "body_radius", "", "bx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/composite/body_to_image_pos.html", "body_to_image_pos.pro", '.pro file in <a href="nv/obj/tools/composite/dir-overview.html">nv/obj/tools/composite/ directory</a>', "body_to_image_pos.pro", "", "", " NAME:        body_to_image_pos    PURPOSE:        Transforms vectors in body coordinates to image coordinates    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = body_to_image_pos(cd, bx, v, inertial=inertial)    ARGUMENTS:   INPUT:              cd:       Array of nt camera or map descriptors.               bx:       Array of nt object descriptors, subclass of BODY.                v:       Array (nv x 3 x nt) of position vectors.    OUTPUT: 	NONE   KEYWORDS:   INPUT: 	NONE    OUTPUT:        inertial:       Array (nv x 3 x nt) of Vectors in inertial coordinates.  	valid:	Indices of valid output points.    RETURN:        An array (2 x nv x nt) of points in image coordinates.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/composite/body_to_image_pos.html#body_to_image_pos", "body_to_image_pos", 'routine in <a href="nv/obj/tools/composite/body_to_image_pos.html">body_to_image_pos.pro</a>', "body_to_image_pos.pro", "", "body_to_image_pos", "", "inertialvalidcdbxv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/composite/body_to_surface.html", "body_to_surface.pro", '.pro file in <a href="nv/obj/tools/composite/dir-overview.html">nv/obj/tools/composite/ directory</a>', "body_to_surface.pro", "", "", " NAME:        body_to_surface    PURPOSE:        Transforms points in body coordinates to surface coordinates.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = body_to_surface(bx, body_pts)    ARGUMENTS:   INPUT: 	bx:      Array of nt object descriptors (subclass of BODY).  	body_pts:       Array (nv x 3 x nt) of body points.    OUTPUT:        NONE   KEYWORDS:    INPUT: NONE     OUTPUT: NONE    RETURN:        Array (nv x 3 x nt) of surface coordinates.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/composite/body_to_surface.html#body_to_surface", "body_to_surface", 'routine in <a href="nv/obj/tools/composite/body_to_surface.html">body_to_surface.pro</a>', "body_to_surface.pro", "", "body_to_surface", "", "bxp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("demo/boresight_example.html", "boresight_example.pro", '.pro file in <a href="demo/dir-overview.html">demo/ directory</a>', "boresight_example.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("nv/grim/brim.html", "brim.pro", '.pro file in <a href="nv/grim/dir-overview.html">nv/grim/ directory</a>', "brim.pro", "", "", " NAME: 	brim    PURPOSE: 	Image browser.    CATEGORY: 	NV/GR    CALLING SEQUENCE: 	brim, files    ARGUMENTS:   INPUT: 	files:	List of filenames and file specifications.  Only files whose 		filetypes can be detected are loaded.  If this argument is not 		given, the user is prompted for a list of files.  An array of 		data descriptors may also be specified.    OUTPUT: NONE    KEYWORDS:   INPUT: 	thumbsize:	Size of the thumbnal images.  Default is 100 pixels. 			Thumbnail images are alwasy square.  	labels:		Labels to use for each thumbnail.  If none given, the 			filename is used, is one exists.  	ids:		Array to identify each thumbnail.  If none given, the 			labels are used, if they exist.  	select_ids:	Ids of Initial thumbnail(s) to appear selected.  	left_fn:	Name of a procedure to call when the left mouse button 			is clicked on a thumbnail.  Default procedure selects 			that image and opens it in a new grim window.  The 			user procedure is called as follows:  				left_fn, fn_data, i, id, status=status  			fn_data is supplied by the caller through the fn_data 			keyword, i is the index of the thumbnail, id is the 			thumbnail id as given by the ids keyword, 			and status should return 0 if successful and nonzero 			otherwise.  	middle_fn:	Name of a procedure to call when the middle mouse button 			is clicked on a thumbnail.  There is no default.  	right_fn:	Name of a procedure to call when the right mouse button 			is clicked on a thumbnail.  There is no default.  	fn_data:	Data to be supplied to the above user procedures.  	exclusive_selection: 			If set, only one image may be selected at once. 			(Currently multiple image selection is not supported.)  	path:		Initial path to use for the file selection widget, 			which appears only if the file argument is not given.  	modal:		If set, only the brim widget may be used until it 			is closed.  	title:		Title to use for the brim widget instead of 'brim'.  	order:		Display order for thumbnails.  Default is 0.  	filter:		Initial filter to use when loading files.    OUTPUT: 	get_path:	Final path selected in the file selection widget.  	select_ids:	On return, select_ids contains the ids of the selected 			images.  If there are no selections, its value will be 			the null string: ''.    RETURN: 	NONE    PROCEDURE: 	brim may be run standalone or from within grim.  If no files or data 	descriptors are given, brim first prompts the user to select a list of 	files.  brim then displays thumbnails of all valid files.  Files may be 	selected by clicking with the left mouse button.  By default, the image 	is opened in a new grim window.  Alternate actions may be defined 	through procedures supplied by the caller.    EXAMPLES: 	To load files into brim using a file-selection widget:  	 IDL> brim   	To load all recognizeable images in the current directory into brim:  	 IDL> brim, '*'   	To browse a set of data descriptors:  	 IDL> dd = dat_read('*') 	 IDL> brim, dd    STATUS: 	Complete.    MODIFICATION HISTORY:  	Written by:	Spitale, 10/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/grim/brim.html#brim_display_image", "brim_display_image", 'routine in <a href="nv/grim/brim.html">brim.pro</a>', "brim.pro", "", "brim_display_image", "", "brim_data_iimage", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/brim.html#brim_resolve_ids", "brim_resolve_ids", 'routine in <a href="nv/grim/brim.html">brim.pro</a>', "brim.pro", "", "brim_resolve_ids", "", "brim_dataids", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/brim.html#brim_load", "brim_load", 'routine in <a href="nv/grim/brim.html">brim.pro</a>', "brim.pro", "", "brim_load", "", "displaybrim_datafiles", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/brim.html#brim_configure", "brim_configure", 'routine in <a href="nv/grim/brim.html">brim.pro</a>', "brim.pro", "", "brim_configure", "", "filesbasethumbsizelabelsselect_idsleft_fnright_fnmiddle_fnfn_dataexclusive_selectionpathget_pathmodaltitleidsorderfilterenable_selectionbrim_datan", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/brim.html#brim_select", "brim_select", 'routine in <a href="nv/grim/brim.html">brim.pro</a>', "brim.pro", "", "brim_select", "", "idddbrim_data_i", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/brim.html#brim_fn_grim", "brim_fn_grim", 'routine in <a href="nv/grim/brim.html">brim.pro</a>', "brim.pro", "", "brim_fn_grim", "", "statusbrim_datailabel", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/brim.html#brim_event", "brim_event", 'routine in <a href="nv/grim/brim.html">brim.pro</a>', "brim.pro", "", "brim_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/brim.html#brim_draw_event", "brim_draw_event", 'routine in <a href="nv/grim/brim.html">brim.pro</a>', "brim.pro", "", "brim_draw_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/brim.html#brim", "brim", 'routine in <a href="nv/grim/brim.html">brim.pro</a>', "brim.pro", "", "brim", "", "thumbsizelabelsselect_idsleft_fnright_fnmiddle_fnfn_dataexclusive_selectionpathget_pathmodaltitleidsorderfilterenable_selectionbasefiles", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/btabvect2.html", "btabvect2.pro", '.pro file in <a href="config/pds/Readpds_4.4/dir-overview.html">config/pds/Readpds_4.4/ directory</a>', "btabvect2.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/btabvect2.html#BTABVECT2", "BTABVECT2", 'routine in <a href="config/pds/Readpds_4.4/btabvect2.html">btabvect2.pro</a>', "btabvect2.pro", "", "BTABVECT2", "", "elementtyperowsbytesrepetitions", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/btest.html", "btest.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "btest.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/btest.html#btest", "btest", 'routine in <a href="util/btest.html">btest.pro</a>', "btest.pro", "", "btest", "", "xpos", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/byte_to_bit.html", "byte_to_bit.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "byte_to_bit.pro", "", "", " NAME: 	xx    PURPOSE: 	xx    CATEGORY: 	UTIL    CALLING SEQUENCE: 	result = xx(xx, xx) 	xx, xx, xx    ARGUMENTS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    KEYWORDS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    ENVIRONMENT VARIABLES: 	xx:	xx  	xx:	xx    RETURN: 	xx    COMMON BLOCKS: 	xx:	xx  	xx:	xx    SIDE EFFECTS: 	xx    RESTRICTIONS: 	xx    PROCEDURE: 	xx    EXAMPLE: 	xx    STATUS: 	xx    SEE ALSO: 	xx, xx, xx    MODIFICATION HISTORY:  	Written by:	xx, xx/xx/xxxx   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/byte_to_bit.html#byte_to_bit", "byte_to_bit", 'routine in <a href="util/byte_to_bit.html">byte_to_bit.pro</a>', "byte_to_bit.pro", "", "byte_to_bit", "", "_bytes", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/bytescl.html", "bytescl.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "bytescl.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/bytescl.html#bytescl", "bytescl", 'routine in <a href="util/bytescl.html">bytescl.pro</a>', "bytescl.pro", "", "bytescl", "", "topmaxmindoublex", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/c_correlate_2d.html", "c_correlate_2d.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "c_correlate_2d.pro", "", "", " NAME:        c_correlate_2d    PURPOSE:        Calculates the correlation coefficient between an image and        a model.    CATEGORY:        UTIL    CALLING SEQUENCE:        result = c_correlate_2d(image, model)    ARGUMENTS:   INPUT:        image:  Two dimensional image.         model:  The model to correlelate with the image (sm[1] x sm[2])    OUTPUT: 	NONE   KEYWORDS:   INPUT: 	NONE    OUTPUT:        sigma:  The sigma of the image in a box of size sm[1] x sm[2]                around each point          mean:  The mean of the image in a box of size sm[1] x sm[2]                around each point    RETURN:        The array of correlation coefficients.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/c_correlate_2d.html#c_correlate_2d", "c_correlate_2d", 'routine in <a href="util/c_correlate_2d.html">c_correlate_2d.pro</a>', "c_correlate_2d.pro", "", "c_correlate_2d", "", "sigmameanimagemodel", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/caller.html", "caller.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "caller.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/caller.html#caller", "caller", 'routine in <a href="util/caller.html">caller.pro</a>', "caller.pro", "", "caller", "", "n", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cam/cam_assign.html", "cam_assign.pro", '.pro file in <a href="nv/obj/cam/dir-overview.html">nv/obj/cam/ directory</a>', "cam_assign.pro", "", "", " NAME: 	cam_assign    PURPOSE: 	Replaces fields in a CAMERA object.  This is a convenient way of 	setting multiple fields in one call, and only a single event is 	generated.    CATEGORY: 	NV/OBJ/CAM    CALLING SEQUENCE: 	cam_assign, cd, <keywords>=<values>    ARGUMENTS:   INPUT: 	cd:		CAMERA object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	CAMERA fields to set.  	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	cam_set_*     MODIFICATION HISTORY:  	Written by:	Spitale		2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cam/cam_assign.html#cam_assign", "cam_assign", 'routine in <a href="nv/obj/cam/cam_assign.html">cam_assign.pro</a>', "cam_assign.pro", "", "cam_assign", "", "noeventxd@cam__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cam/cam_body_to_focal.html", "cam_body_to_focal.pro", '.pro file in <a href="nv/obj/cam/dir-overview.html">nv/obj/cam/ directory</a>', "cam_body_to_focal.pro", "", "", " NAME: 	cam_body_to_focal    PURPOSE:        Transforms the given column vectors from the body coordinate        system to the camera focal plane coordinate system.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	focal_pts = cam_body_to_focal(cd, body_pts)    ARGUMENTS:   INPUT: 	cd:	        Array (nt) of CAMERA descriptors.  	body_pts:	Array (nv,3,nt) of column vectors in the body frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (2,nv,nt) of points in the camera focal plane frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cam/cam_body_to_focal.html#cam_body_to_focal", "cam_body_to_focal", 'routine in <a href="nv/obj/cam/cam_body_to_focal.html">cam_body_to_focal.pro</a>', "cam_body_to_focal.pro", "", "cam_body_to_focal", "", "cdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cam/cam_create_descriptors.html", "cam_create_descriptors.pro", '.pro file in <a href="nv/obj/cam/dir-overview.html">nv/obj/cam/ directory</a>', "cam_create_descriptors.pro", "", "", " NAME: 	cam_create_descriptors    PURPOSE: 	Init method for the CAMERA class.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	cd = cam_create_descriptors(n)    ARGUMENTS:   INPUT: 	n:	Number of descriptors to create.    OUTPUT: NONE    KEYWORDS (in addition to those accepted by all superclasses):   INPUT: 	cd:	Camera descriptor(s) to initialize, instead of creating a new 		one.  	bd:	Body descriptor(s) to pass to bod_create_descriptors.  	crd:	Core descriptor(s) to pass to cor_create_descriptors.  	scale:	Array (2,n) of scales for each camera.  	oaxis:	Array (2,n) of optic axis values for each camera.  	exposure:	Array (n) of exposure times for each camera.  	size:	Array (2,n) of sizes for each camera.  	filters:	Array (nfilt,n) of filter names for each camera.  	fn_focal_to_image:	Array (n) of focal-to-image function names 				for each camera.  	fn_image_to_focal:	Array (n) of image-to-focal function names 				for each camera.  	fn_psf:	Array (n) of point-spread function names for each camera.     OUTPUT: NONE    RETURN: 	Newly created or or freshly initialized camera descriptors, depending 	on the presence of the cd keyword.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cam/cam_create_descriptors.html#cam_create_descriptors", "cam_create_descriptors", 'routine in <a href="nv/obj/cam/cam_create_descriptors.html">cam_create_descriptors.pro</a>', "cam_create_descriptors.pro", "", "cam_create_descriptors", "", "crdbdcdn@cam__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cam/cam_evolve.html", "cam_evolve.pro", '.pro file in <a href="nv/obj/cam/dir-overview.html">nv/obj/cam/ directory</a>', "cam_evolve.pro", "", "", " NAME: 	cam_evolve    PURPOSE:        Computes new camera descriptors at the given time offsets from        the given camera descriptors using the taylor series expansion        corresponding to the derivatives contained in the given camera        descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	cdt = cam_evolve(cd, dt)    ARGUMENTS:   INPUT: 	cd:	 Array (ncd) of CAMERA descriptors.  	dt:	 Array (ndt) of time offsets.    OUTPUT: NONE    KEYWORDS:   INPUT: 	nodv:	 If set, velocities will not be evolved.  	copy:	If set, the evolved descriptor is copied into the input 		descriptor and it is freed.  The input descriptor is returned.     OUTPUT: NONE    RETURN:        Array (ncd,ndt) of newly allocated camera descriptors evolved        by time dt, where ncd is the number of cd, and ndt is the        number of dt.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cam/cam_evolve.html#cam_evolve", "cam_evolve", 'routine in <a href="nv/obj/cam/cam_evolve.html">cam_evolve.pro</a>', "cam_evolve.pro", "", "cam_evolve", "", "nodvcopycddt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cam/cam_exposure.html", "cam_exposure.pro", '.pro file in <a href="nv/obj/cam/dir-overview.html">nv/obj/cam/ directory</a>', "cam_exposure.pro", "", "", " NAME: 	cam_exposure    PURPOSE:        Returns the exposure duration of each given camera descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	exposure = cam_exposure(cd)    ARGUMENTS:   INPUT: 	cd:	 Array (nt) of CAMERA descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN:        Exposure duration associated with each given camera descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cam/cam_exposure.html#cam_exposure", "cam_exposure", 'routine in <a href="nv/obj/cam/cam_exposure.html">cam_exposure.pro</a>', "cam_exposure.pro", "", "cam_exposure", "", "noeventcd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cam/cam_fi_data.html", "cam_fi_data.pro", '.pro file in <a href="nv/obj/cam/dir-overview.html">nv/obj/cam/ directory</a>', "cam_fi_data.pro", "", "", " NAME: 	cam_fi_data    PURPOSE: 	Returns the focal/image function data for a camera descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	data = cam_fi_data(cd)    ARGUMENTS:   INPUT: NONE 	cd:	 Camera descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Function data associated with the given camera descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Adapted by:	Spitale, 7/2016; adapted from cam_fi_data_p   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cam/cam_fi_data.html#cam_fi_data", "cam_fi_data", 'routine in <a href="nv/obj/cam/cam_fi_data.html">cam_fi_data.pro</a>', "cam_fi_data.pro", "", "cam_fi_data", "", "noeventcd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cam/cam_filters.html", "cam_filters.pro", '.pro file in <a href="nv/obj/cam/dir-overview.html">nv/obj/cam/ directory</a>', "cam_filters.pro", "", "", " NAME: 	cam_filters    PURPOSE: 	Returns the filter name(s) for a given camera descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	filters = cam_filers(cd, index)    ARGUMENTS:   INPUT: 	cd:	 Camera descriptor.  	index:	 Index of filter to return.  If not given, all are returned.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Names of requested filters.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cam/cam_filters.html#cam_filters", "cam_filters", 'routine in <a href="nv/obj/cam/cam_filters.html">cam_filters.pro</a>', "cam_filters.pro", "", "cam_filters", "", "noeventcdi", "          -1", "");
  
  

libdata[libdataItem++] = new Array("vims_src_tmp/cam_fn_body_to_image.html", "cam_fn_body_to_image.pro", '.pro file in <a href="vims_src_tmp/dir-overview.html">vims_src_tmp/ directory</a>', "cam_fn_body_to_image.pro", "", "", " NAME: 	cam_fn_body_to_image    PURPOSE:        Returns the name of the user-defined body --> image        transformation function for each given camera descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	fn = cam_fn_body_to_image(cd)    ARGUMENTS:   INPUT: 	cd:	 Array (nt) of CAMERA descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN:        Focal --> image transformation function associated with each        given camera descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("vims_src_tmp/cam_fn_body_to_image.html#cam_fn_body_to_image", "cam_fn_body_to_image", 'routine in <a href="vims_src_tmp/cam_fn_body_to_image.html">cam_fn_body_to_image.pro</a>', "cam_fn_body_to_image.pro", "", "cam_fn_body_to_image", "", "noeventcd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("vims_src_tmp/cam_fn_body_to_inertial.html", "cam_fn_body_to_inertial.pro", '.pro file in <a href="vims_src_tmp/dir-overview.html">vims_src_tmp/ directory</a>', "cam_fn_body_to_inertial.pro", "", "", " NAME: 	cam_fn_body_to_image    PURPOSE:        Returns the name of the user-defined body --> image        transformation function for each given camera descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	fn = cam_fn_body_to_image(cd)    ARGUMENTS:   INPUT: 	cd:	 Array (nt) of CAMERA descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN:        Focal --> image transformation function associated with each        given camera descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("vims_src_tmp/cam_fn_body_to_inertial.html#cam_fn_body_to_inertial", "cam_fn_body_to_inertial", 'routine in <a href="vims_src_tmp/cam_fn_body_to_inertial.html">cam_fn_body_to_inertial.pro</a>', "cam_fn_body_to_inertial.pro", "", "cam_fn_body_to_inertial", "", "noeventcd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cam/cam_fn_focal_to_image.html", "cam_fn_focal_to_image.pro", '.pro file in <a href="nv/obj/cam/dir-overview.html">nv/obj/cam/ directory</a>', "cam_fn_focal_to_image.pro", "", "", " NAME: 	cam_fn_focal_to_image    PURPOSE:        Returns the name of the user-defined focal --> image        transformation function for each given camera descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	fn = cam_fn_focal_to_image(cd)    ARGUMENTS:   INPUT: 	cd:	 Array (nt) of CAMERA descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN:        Focal --> image transformation function associated with each        given camera descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cam/cam_fn_focal_to_image.html#cam_fn_focal_to_image", "cam_fn_focal_to_image", 'routine in <a href="nv/obj/cam/cam_fn_focal_to_image.html">cam_fn_focal_to_image.pro</a>', "cam_fn_focal_to_image.pro", "", "cam_fn_focal_to_image", "", "noeventcd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cam/cam_fn_image_to_focal.html", "cam_fn_image_to_focal.pro", '.pro file in <a href="nv/obj/cam/dir-overview.html">nv/obj/cam/ directory</a>', "cam_fn_image_to_focal.pro", "", "", " NAME: 	cam_fn_image_to_focal    PURPOSE:        Returns the name of the user-defined image --> focal        transformation function for each given camera descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	fn = cam_fn_image_to_focal(cd)    ARGUMENTS:   INPUT: 	cd:	 Array (nt) of CAMERA descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN:        Image --> focal transformation function associated with each        given camera descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cam/cam_fn_image_to_focal.html#cam_fn_image_to_focal", "cam_fn_image_to_focal", 'routine in <a href="nv/obj/cam/cam_fn_image_to_focal.html">cam_fn_image_to_focal.pro</a>', "cam_fn_image_to_focal.pro", "", "cam_fn_image_to_focal", "", "noeventcd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cam/cam_fn_psf.html", "cam_fn_psf.pro", '.pro file in <a href="nv/obj/cam/dir-overview.html">nv/obj/cam/ directory</a>', "cam_fn_psf.pro", "", "", " NAME: 	cam_fn_psf    PURPOSE: 	Returns the user-defined psf function for the given camera descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	fn = cam_fn_psf(cd)    ARGUMENTS:   INPUT: NONE 	cd:	 Camera descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	PSF function associated with each given camera descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cam/cam_fn_psf.html#cam_fn_psf", "cam_fn_psf", 'routine in <a href="nv/obj/cam/cam_fn_psf.html">cam_fn_psf.pro</a>', "cam_fn_psf.pro", "", "cam_fn_psf", "", "noeventcd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cam/cam_focal_to_body.html", "cam_focal_to_body.pro", '.pro file in <a href="nv/obj/cam/dir-overview.html">nv/obj/cam/ directory</a>', "cam_focal_to_body.pro", "", "", " NAME: 	cam_focal_to_body    PURPOSE:        Transforms the given array of points from the camera focal        plane coordinate system to the body coordinate system.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	body_pts = cam_focal_to_body(cd, focal_pts)    ARGUMENTS:   INPUT: 	cd:	        Array (nt) of CAMERA descriptors.  	focal_pts:	Array (2,nv,nt) of points in the camera focal plane frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (nv,3,nt) of column vectors in the body frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cam/cam_focal_to_body.html#cam_focal_to_body", "cam_focal_to_body", 'routine in <a href="nv/obj/cam/cam_focal_to_body.html">cam_focal_to_body.pro</a>', "cam_focal_to_body.pro", "", "cam_focal_to_body", "", "cdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cam/cam_focal_to_image.html", "cam_focal_to_image.pro", '.pro file in <a href="nv/obj/cam/dir-overview.html">nv/obj/cam/ directory</a>', "cam_focal_to_image.pro", "", "", " NAME: 	cam_focal_to_image    PURPOSE: 	Transforms the given array of points in the focal plane        coordinate system to an array of points in the image        coordinate system using the fn_focal_to_image function of the        camera descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	image_pts = cam_focal_to_image(cd, focal_pts)    ARGUMENTS:   INPUT: 	cd:	        Array (nt) of CAMERA descriptors.  	focal_pts:	Array (2,nv,nt) of points in the camera focal frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (2,nv,nt) of points in the image coordinate system.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cam/cam_focal_to_image.html#cam_focal_to_image", "cam_focal_to_image", 'routine in <a href="nv/obj/cam/cam_focal_to_image.html">cam_focal_to_image.pro</a>', "cam_focal_to_image.pro", "", "cam_focal_to_image", "", "cdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cam/cam_focal_to_image_linear.html", "cam_focal_to_image_linear.pro", '.pro file in <a href="nv/obj/cam/dir-overview.html">nv/obj/cam/ directory</a>', "cam_focal_to_image_linear.pro", "", "", " NAME: 	cam_focal_to_image_linear    PURPOSE:        Transforms the given array of points in the focal plane        coordinate system to an array of points in the image        coordinate system using a linear model that assumes that        distances in the image are proportional to angles in the focal        plane.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	image_pts = cam_focal_to_image_linear(cd, focal_pts)    ARGUMENTS:   INPUT: 	cd:	        Array (nt) of CAMERA descriptors.  	focal_pts:	Array (2,nv,nt) of points in the camera focal frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (2,nv,nt) of points in the image coordinate system.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cam/cam_focal_to_image_linear.html#cam_focal_to_image_linear", "cam_focal_to_image_linear", 'routine in <a href="nv/obj/cam/cam_focal_to_image_linear.html">cam_focal_to_image_linear.pro</a>', "cam_focal_to_image_linear.pro", "", "cam_focal_to_image_linear", "", "cdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cam/cam_focal_to_image_poly.html", "cam_focal_to_image_poly.pro", '.pro file in <a href="nv/obj/cam/dir-overview.html">nv/obj/cam/ directory</a>', "cam_focal_to_image_poly.pro", "", "", " NAME: 	cam_focal_to_image_poly    PURPOSE:        Transforms the given array of points in the focal plane        coordinate system to an array of points in the image        coordinate system using a polynomial distortion model.   CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	image_pts = cam_focal_to_image_poly(cd, focal_pts)    ARGUMENTS:   INPUT: 	cd:	        Array (nt) of CAMERA descriptors.  	focal_pts:	Array (2,nv,nt) of points in the camera focal frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (2,nv,nt) of points in the image coordinate system.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cam/cam_focal_to_image_poly.html#cam_focal_to_image_poly", "cam_focal_to_image_poly", 'routine in <a href="nv/obj/cam/cam_focal_to_image_poly.html">cam_focal_to_image_poly.pro</a>', "cam_focal_to_image_poly.pro", "", "cam_focal_to_image_poly", "", "cdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cam/cam_focal_to_image_radial.html", "cam_focal_to_image_radial.pro", '.pro file in <a href="nv/obj/cam/dir-overview.html">nv/obj/cam/ directory</a>', "cam_focal_to_image_radial.pro", "", "", " NAME: 	cam_focal_to_image_radial    PURPOSE:        Transforms the given array of points in the focal plane        coordinate system to an array of points in the image        coordinate system using a radial distortion model.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	image_pts = cam_focal_to_image_radial(cd, focal_pts)    ARGUMENTS:   INPUT: 	cd:	        Array (nt) of CAMERA descriptors.  	focal_pts:	Array (2,nv,nt) of points in the camera focal frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (2,nv,nt) of points in the image coordinate system.    STATUS: 	**Incomplete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cam/cam_focal_to_image_radial.html#cam_focal_to_image_radial", "cam_focal_to_image_radial", 'routine in <a href="nv/obj/cam/cam_focal_to_image_radial.html">cam_focal_to_image_radial.pro</a>', "cam_focal_to_image_radial.pro", "", "cam_focal_to_image_radial", "", "cdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cam/cam_get_poly_matrices.html", "cam_get_poly_matrices.pro", '.pro file in <a href="nv/obj/cam/dir-overview.html">nv/obj/cam/ directory</a>', "cam_get_poly_matrices.pro", "", "", " NAME: 	cam_get_poly_matrices    PURPOSE:        Obtains the camera function data for the polynomial distortion model.   CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	cam_get_poly_matrices, cd, XX, YY, PP, QQ    ARGUMENTS:   INPUT: 	cd:	Array (nt) of and subclass of CAMERA.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT:         XX:     Polynominal distortion coefficients in x.         YY:     Polynominal distortion coefficients in y.         PP:     Inverse polynominal distortion coefficients in x.         QQ:     Inverse polynominal distortion coefficients in y.    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cam/cam_get_poly_matrices.html#cam_get_poly_matrices", "cam_get_poly_matrices", 'routine in <a href="nv/obj/cam/cam_get_poly_matrices.html">cam_get_poly_matrices.pro</a>', "cam_get_poly_matrices.pro", "", "cam_get_poly_matrices", "", "cdXXYYPPQQ", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cam/cam_get_radec_twist.html", "cam_get_radec_twist.pro", '.pro file in <a href="nv/obj/cam/dir-overview.html">nv/obj/cam/ directory</a>', "cam_get_radec_twist.pro", "", "", " NAME: 	cam_get_radec_twist    PURPOSE:        Computes camera Euler angles relative to the inertial frame.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	cam_get_radec_twist, cd, ra=ra, dec=dec, twist=twist    ARGUMENTS:   INPUT: 	cd:	        Array (nt) of CAMERA descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	ra:	Array (nt) of RA angles.  	dec:	Array (nt) of DEC angles.  	twist:	Array (nt) of TWIST angles.    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cam/cam_get_radec_twist.html#cam_get_radec_twist", "cam_get_radec_twist", 'routine in <a href="nv/obj/cam/cam_get_radec_twist.html">cam_get_radec_twist.pro</a>', "cam_get_radec_twist.pro", "", "cam_get_radec_twist", "", "radectwistcd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cam/cam_image_to_focal.html", "cam_image_to_focal.pro", '.pro file in <a href="nv/obj/cam/dir-overview.html">nv/obj/cam/ directory</a>', "cam_image_to_focal.pro", "", "", " NAME: 	cam_image_to_focal    PURPOSE:        Transforms the given array of points in the image coordinate        system to an array of points in the camera focal plane        coordinate system using the fn_image_to_focal function of the        camera descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	focal_pts = cam_image_to_focal(cd, image_pts)    ARGUMENTS:   INPUT: 	cd:	        Array (nt) of CAMERA descriptors.  	image_pts:	Array (2,nv,nt) of points in the image coordinate system.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (2,nv,nt) of points in the camera focal frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cam/cam_image_to_focal.html#cam_image_to_focal", "cam_image_to_focal", 'routine in <a href="nv/obj/cam/cam_image_to_focal.html">cam_image_to_focal.pro</a>', "cam_image_to_focal.pro", "", "cam_image_to_focal", "", "cdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cam/cam_image_to_focal_linear.html", "cam_image_to_focal_linear.pro", '.pro file in <a href="nv/obj/cam/dir-overview.html">nv/obj/cam/ directory</a>', "cam_image_to_focal_linear.pro", "", "", " NAME: 	cam_image_to_focal_linear    PURPOSE:        Transforms the given array of points in the image coordinate        system to an array of points in the camera focal plane        coordinate system using a linear model that assumes that        distances in the image are proportional to angles in the focal        plane.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	focal_pts = cam_image_to_focal_linear(cd, image_pts)    ARGUMENTS:   INPUT: 	cd:	        Array (nt) of CAMERA descriptors.  	image_pts:	Array (2,nv,nt) of points in the image coordinate system.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (2,nv,nt) of points in the camera focal frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cam/cam_image_to_focal_linear.html#cam_image_to_focal_linear", "cam_image_to_focal_linear", 'routine in <a href="nv/obj/cam/cam_image_to_focal_linear.html">cam_image_to_focal_linear.pro</a>', "cam_image_to_focal_linear.pro", "", "cam_image_to_focal_linear", "", "cdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cam/cam_image_to_focal_poly.html", "cam_image_to_focal_poly.pro", '.pro file in <a href="nv/obj/cam/dir-overview.html">nv/obj/cam/ directory</a>', "cam_image_to_focal_poly.pro", "", "", " NAME: 	cam_image_to_focal_poly    PURPOSE:        Transforms the given array of points in the image coordinate        system to an array of points in the camera focal plane        coordinate system using a polynomial distortion model.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	focal_pts = cam_image_to_focal_poly(cd, image_pts)    ARGUMENTS:   INPUT: 	cd:	        Array (nt) of CAMERA descriptors.  	image_pts:	Array (2,nv,nt) of points in the image coordinate system.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (2,nv,nt) of points in the camera focal frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cam/cam_image_to_focal_poly.html#cam_image_to_focal_poly", "cam_image_to_focal_poly", 'routine in <a href="nv/obj/cam/cam_image_to_focal_poly.html">cam_image_to_focal_poly.pro</a>', "cam_image_to_focal_poly.pro", "", "cam_image_to_focal_poly", "", "cdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cam/cam_image_to_focal_radial.html", "cam_image_to_focal_radial.pro", '.pro file in <a href="nv/obj/cam/dir-overview.html">nv/obj/cam/ directory</a>', "cam_image_to_focal_radial.pro", "", "", " NAME: 	cam_image_to_focal_radial    PURPOSE:        Transforms the given array of points in the image coordinate        system to an array of points in the camera focal plane        coordinate system using a radial distortion model.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	focal_pts = cam_image_to_focal_radial(cd, image_pts)    ARGUMENTS:   INPUT: 	cd:	        Array (nt) of CAMERA descriptors.  	image_pts:	Array (2,nv,nt) of points in the image coordinate system.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (2,nv,nt) of points in the camera focal frame.    STATUS: 	**Incomplete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cam/cam_image_to_focal_radial.html#cam_image_to_focal_radial", "cam_image_to_focal_radial", 'routine in <a href="nv/obj/cam/cam_image_to_focal_radial.html">cam_image_to_focal_radial.pro</a>', "cam_image_to_focal_radial.pro", "", "cam_image_to_focal_radial", "", "cdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cam/cam_nfilters.html", "cam_nfilters.pro", '.pro file in <a href="nv/obj/cam/dir-overview.html">nv/obj/cam/ directory</a>', "cam_nfilters.pro", "", "", " NAME: 	cam_nfilters    PURPOSE: 	Returns an integer indicating the maximum number of filters allowed 	in the 'filters' fields of the camera descriptor.  This number can 	be adjusted using the environment variable 'CAM_NFILTERS'.  The default 	is 4.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	nfilters = cam_nfilters()    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: NONE     OUTPUT: NONE    ENVIRONMENT VARIABLES: 	CAM_NFILTERS:	Sets the maximum number of filters.    RETURN: 	Current nfilters value.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cam/cam_nfilters.html#cam_nfilters", "cam_nfilters", 'routine in <a href="nv/obj/cam/cam_nfilters.html">cam_nfilters.pro</a>', "cam_nfilters.pro", "", "cam_nfilters", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cam/cam_oaxis.html", "cam_oaxis.pro", '.pro file in <a href="nv/obj/cam/dir-overview.html">nv/obj/cam/ directory</a>', "cam_oaxis.pro", "", "", " NAME: 	cam_oaxis    PURPOSE:        Returns the 2-element array giving the image coordinates (in        pixels) corresponding to the camera optic axis for each given        camera descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	oaxis = cam_oaxis(cd)    ARGUMENTS:   INPUT: 	cd:	 Array (nt) of CAMERA descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Oaxis array associated with each given camera descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cam/cam_oaxis.html#cam_oaxis", "cam_oaxis", 'routine in <a href="nv/obj/cam/cam_oaxis.html">cam_oaxis.pro</a>', "cam_oaxis.pro", "", "cam_oaxis", "", "noeventcd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cam/cam_origin.html", "cam_origin.pro", '.pro file in <a href="nv/obj/cam/dir-overview.html">nv/obj/cam/ directory</a>', "cam_origin.pro", "", "", " NAME: 	cam_origin    PURPOSE:        Returns the 2-element array giving the image coordinates (in        pixels) corresponding to the camera optic axis for each given        camera descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	origin = cam_origin(cd)    ARGUMENTS:   INPUT: 	cd:	 Array (nt) of CAMERA descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	origin array associated with each given camera descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cam/cam_origin.html#cam_origin", "cam_origin", 'routine in <a href="nv/obj/cam/cam_origin.html">cam_origin.pro</a>', "cam_origin.pro", "", "cam_origin", "", "noeventcd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cam/cam_psf.html", "cam_psf.pro", '.pro file in <a href="nv/obj/cam/dir-overview.html">nv/obj/cam/ directory</a>', "cam_psf.pro", "", "", " NAME: 	cam_psf    PURPOSE: 	Computes a point-spread function.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	psf = cam_psf(cd, x, y)    ARGUMENTS:   INPUT: 	cd:	 Camera descriptor.  	x:	 Array of x coordinates relative to the center of the PSF, 		 or a width in the x direction.  	y:	 Array of y coordinates relative to the center of the PSF, 		 or a width in the y direction.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Point-spread function values at each point specified by the x and y 	arguments.    PROCEDURE: 	The function indicated by the fn_psf field of the camera descriptor 	is called and its return value is passed through to the caller of 	cam_psf.  If x and y widths are given instead of arrays, the PSF 	will be centered, and the grid spacing will be one pixel.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cam/cam_psf.html#cam_psf", "cam_psf", 'routine in <a href="nv/obj/cam/cam_psf.html">cam_psf.pro</a>', "cam_psf.pro", "", "cam_psf", "", "noeventcd_x_y", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cam/cam_psf_attrib.html", "cam_psf_attrib.pro", '.pro file in <a href="nv/obj/cam/dir-overview.html">nv/obj/cam/ directory</a>', "cam_psf_attrib.pro", "", "", " NAME: 	cam_psf_attrib    PURPOSE: 	Computes attributes of a point-spread function.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	cam_psf_attrib, cd, <attribute keywords...>    ARGUMENTS:   INPUT: 	cd:	 Camera descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: 	fwhm:	Full-width at half maximum of the point-spread function.    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cam/cam_psf_attrib.html#cam_psf_attrib", "cam_psf_attrib", 'routine in <a href="nv/obj/cam/cam_psf_attrib.html">cam_psf_attrib.pro</a>', "cam_psf_attrib.pro", "", "cam_psf_attrib", "", "fwhmcd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/cam/cam_psf_attrib.html#__cam_psf_attrib", "__cam_psf_attrib", 'routine in <a href="nv/obj/cam/cam_psf_attrib.html">cam_psf_attrib.pro</a>', "cam_psf_attrib.pro", "", "__cam_psf_attrib", "", "fwhmcd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cam/cam_query.html", "cam_query.pro", '.pro file in <a href="nv/obj/cam/dir-overview.html">nv/obj/cam/ directory</a>', "cam_query.pro", "", "", " NAME: 	cam_query    PURPOSE: 	Returns the fields associated with a CAMERA object.  This is a 	convenient way of getting multiple fields in one call, and only a 	single event is generated.    CATEGORY: 	NV/OBJ/CAM    CALLING SEQUENCE: 	cam_query, cd, <keywords>=<values>    ARGUMENTS:   INPUT: 	cd:	CAMERA object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	CAMERA object fields to set.  	condition:	Structure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT object, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.  	cat:		If set, arrays from mulitple input objets are 			concatenated.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.  	noevent:	If set, no event is generated.    OUTPUT: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cam/cam_query.html#cam_query", "cam_query", 'routine in <a href="nv/obj/cam/cam_query.html">cam_query.pro</a>', "cam_query.pro", "", "cam_query", "", "conditioncatnoeventxd@cam__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cam/cam_rebin.html", "cam_rebin.pro", '.pro file in <a href="nv/obj/cam/dir-overview.html">nv/obj/cam/ directory</a>', "cam_rebin.pro", "", "", " NAME: 	cam_rebin    PURPOSE:        Modifies the camera parameters to reflect a re-binning of the pixels.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	cam_rebin, cd, bin    ARGUMENTS:   INPUT: 	cd:	    Array (nt) of CAMERA descriptors.         bin:        Binning factor, can be non-integer.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/2015  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cam/cam_rebin.html#cam_rebin", "cam_rebin", 'routine in <a href="nv/obj/cam/cam_rebin.html">cam_rebin.pro</a>', "cam_rebin.pro", "", "cam_rebin", "", "noeventcdbin", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cam/cam_reorient.html", "cam_reorient.pro", '.pro file in <a href="nv/obj/cam/dir-overview.html">nv/obj/cam/ directory</a>', "cam_reorient.pro", "", "", " NAME: 	cam_reorient    PURPOSE:        Repoints the camera orientiation matrix based on x,y, and theta 	image offsets.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	cam_reorient, cd, image_axis, dxy, dtheta    ARGUMENTS:   INPUT: 	cd:	Array (nt) of CAMERA descriptors.  	image_axis:	Array (2,1,nt) of image points corresponding to the 			rotation axis for each descriptor.  	dxy:	Array (2,1,nt) of image offsets in x and y.  	dheta:	Array (1,1,nt) of rotation angles.    OUTPUT: NONE    KEYWORDS:   INPUT: 	absolute: If set, the dxy argument represents and abosolute image 		  position rather than an offset.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cam/cam_reorient.html#cam_reorient", "cam_reorient", 'routine in <a href="nv/obj/cam/cam_reorient.html">cam_reorient.pro</a>', "cam_reorient.pro", "", "cam_reorient", "", "absolutensin_anglecos_anglecd0image_axisdxydtheta", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cam/cam_replicate.html", "cam_replicate.pro", '.pro file in <a href="nv/obj/cam/dir-overview.html">nv/obj/cam/ directory</a>', "cam_replicate.pro", "", "", " NAME: 	cam_replicate    PURPOSE: 	Replicates the given camera descriptor, producing an array of the given 	dimensions containing cloned versions of the input descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	new_cd = cam_replicate(cd, dim)    ARGUMENTS:   INPUT: 	cd:	 One CAMERA descriptor.  	dim:	 Dimensions of the result.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Array of the given dimensions containing cloned versions of the input 	camera descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cam/cam_replicate.html#cam_replicate", "cam_replicate", 'routine in <a href="nv/obj/cam/cam_replicate.html">cam_replicate.pro</a>', "cam_replicate.pro", "", "cam_replicate", "", "cddim", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cam/cam_rescale.html", "cam_rescale.pro", '.pro file in <a href="nv/obj/cam/dir-overview.html">nv/obj/cam/ directory</a>', "cam_rescale.pro", "", "", " NAME: 	cam_rescale    PURPOSE:        Produces a new camera descriptor describing an image of the same 	angluar dimensions, but with a new scale, specified by camera scale.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	cam_rescale, cd, scale    ARGUMENTS:   INPUT: 	cd:	Array (nt) of CAMERA descriptors to modify.  	scale:	Array (2,1,nt) of new camera scales.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cam/cam_rescale.html#cam_rescale", "cam_rescale", 'routine in <a href="nv/obj/cam/cam_rescale.html">cam_rescale.pro</a>', "cam_rescale.pro", "", "cam_rescale", "", "noeventcdscale", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cam/cam_resize.html", "cam_resize.pro", '.pro file in <a href="nv/obj/cam/dir-overview.html">nv/obj/cam/ directory</a>', "cam_resize.pro", "", "", " NAME: 	cam_resize    PURPOSE:        Produces a new camera descriptor describing an image of the same 	angluar dimensions, but with a new scale, specified by image size.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	cam_resize, cd, size    ARGUMENTS:   INPUT: 	cd:	Array (nt) of CAMERA descriptors to modify.  	size:	Array (2,1,nt) of new image sizes.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cam/cam_resize.html#cam_resize", "cam_resize", 'routine in <a href="nv/obj/cam/cam_resize.html">cam_resize.pro</a>', "cam_resize.pro", "", "cam_resize", "", "noeventcdsize", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cam/cam_scale.html", "cam_scale.pro", '.pro file in <a href="nv/obj/cam/dir-overview.html">nv/obj/cam/ directory</a>', "cam_scale.pro", "", "", " NAME: 	cam_scale    PURPOSE:        Returns the 2-element array giving the camera scale        (radians/pixel) in each direction for each given camera        descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	scale = cam_scale(cd)    ARGUMENTS:   INPUT: 	cd:	 Array (nt) of CAMERA descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Scale array associated with each given camera descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cam/cam_scale.html#cam_scale", "cam_scale", 'routine in <a href="nv/obj/cam/cam_scale.html">cam_scale.pro</a>', "cam_scale.pro", "", "cam_scale", "", "noeventcd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cam/cam_set_exposure.html", "cam_set_exposure.pro", '.pro file in <a href="nv/obj/cam/dir-overview.html">nv/obj/cam/ directory</a>', "cam_set_exposure.pro", "", "", " NAME: 	cam_set_exposure    PURPOSE:        Replaces the exposure duration for each given camera descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	cam_set_exposure,cd,exposure    ARGUMENTS:   INPUT: 	cd:	     Array (nt) of CAMERA descriptors.         exposure:    Array (nt) of new exposure values.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cam/cam_set_exposure.html#cam_set_exposure", "cam_set_exposure", 'routine in <a href="nv/obj/cam/cam_set_exposure.html">cam_set_exposure.pro</a>', "cam_set_exposure.pro", "", "cam_set_exposure", "", "noeventcdexposure", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cam/cam_set_fi_data.html", "cam_set_fi_data.pro", '.pro file in <a href="nv/obj/cam/dir-overview.html">nv/obj/cam/ directory</a>', "cam_set_fi_data.pro", "", "", " NAME: 	cam_set_fi_data    PURPOSE: 	Replaces the focal/image function data for a camera descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	cam_set_fi_data, cd, data    ARGUMENTS:   INPUT: 	cd:	 Camera descriptor.  	data:	 New function data.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Adapted by:	Spitale, 7/2016; adapted from cam_set_fi_data_p   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cam/cam_set_fi_data.html#cam_set_fi_data", "cam_set_fi_data", 'routine in <a href="nv/obj/cam/cam_set_fi_data.html">cam_set_fi_data.pro</a>', "cam_set_fi_data.pro", "", "cam_set_fi_data", "", "noeventcddata", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cam/cam_set_filters.html", "cam_set_filters.pro", '.pro file in <a href="nv/obj/cam/dir-overview.html">nv/obj/cam/ directory</a>', "cam_set_filters.pro", "", "", " NAME: 	cam_set_filters    PURPOSE: 	Sets the filter name(s) for a given camera descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	cam_set_filters, cd, filters, i    ARGUMENTS:   INPUT: 	cd:	 Camera descriptor.  	filters:	Name(s) of filters.  	index:	 Index of filter to set.  If not given, all are set.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: NONE   STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cam/cam_set_filters.html#cam_set_filters", "cam_set_filters", 'routine in <a href="nv/obj/cam/cam_set_filters.html">cam_set_filters.pro</a>', "cam_set_filters.pro", "", "cam_set_filters", "", "noeventcdfilteri", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cam/cam_set_fn_focal_to_image.html", "cam_set_fn_focal_to_image.pro", '.pro file in <a href="nv/obj/cam/dir-overview.html">nv/obj/cam/ directory</a>', "cam_set_fn_focal_to_image.pro", "", "", " NAME: 	cam_set_fn_focal_to_image    PURPOSE:        Sets the user-defined focal --> image transformation function        for the given camera descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	cam_set_fn_focal_to_image, cd, fn    ARGUMENTS:   INPUT: 	cd:	 Array (nt) of CAMERA descriptors.  	fn:	 Array (nt) of user-defined focal --> image functions.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cam/cam_set_fn_focal_to_image.html#cam_set_fn_focal_to_image", "cam_set_fn_focal_to_image", 'routine in <a href="nv/obj/cam/cam_set_fn_focal_to_image.html">cam_set_fn_focal_to_image.pro</a>', "cam_set_fn_focal_to_image.pro", "", "cam_set_fn_focal_to_image", "", "noeventcdfn_focal_to_image", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cam/cam_set_fn_image_to_focal.html", "cam_set_fn_image_to_focal.pro", '.pro file in <a href="nv/obj/cam/dir-overview.html">nv/obj/cam/ directory</a>', "cam_set_fn_image_to_focal.pro", "", "", " NAME: 	cam_set_fn_image_to_focal    PURPOSE:        Sets the user-defined image --> focal transformation function        for the given camera descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	cam_set_fn_image_to_focal, cd, fn    ARGUMENTS:   INPUT: 	cd:	 Array (nt) of CAMERA descriptors.  	fn:	 Array (nt) of user-defined image --> focal functions.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cam/cam_set_fn_image_to_focal.html#cam_set_fn_image_to_focal", "cam_set_fn_image_to_focal", 'routine in <a href="nv/obj/cam/cam_set_fn_image_to_focal.html">cam_set_fn_image_to_focal.pro</a>', "cam_set_fn_image_to_focal.pro", "", "cam_set_fn_image_to_focal", "", "noeventcdfn_image_to_focal", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cam/cam_set_fn_psf.html", "cam_set_fn_psf.pro", '.pro file in <a href="nv/obj/cam/dir-overview.html">nv/obj/cam/ directory</a>', "cam_set_fn_psf.pro", "", "", " NAME: 	cam_set_fn_psf    PURPOSE: 	Sets the user-defined PSF function for the given camera descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	cam_set_fn_psf, cd, fn    ARGUMENTS:   INPUT: 	cd:	 Camera descriptor.  	fn:	 Name of user-defined PSF function.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cam/cam_set_fn_psf.html#cam_set_fn_psf", "cam_set_fn_psf", 'routine in <a href="nv/obj/cam/cam_set_fn_psf.html">cam_set_fn_psf.pro</a>', "cam_set_fn_psf.pro", "", "cam_set_fn_psf", "", "noeventcdpsf", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cam/cam_set_oaxis.html", "cam_set_oaxis.pro", '.pro file in <a href="nv/obj/cam/dir-overview.html">nv/obj/cam/ directory</a>', "cam_set_oaxis.pro", "", "", " NAME: 	cam_set_oaxis    PURPOSE:        Replaces the oaxis array for each given camera descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	cam_set_oaxis, cd, oaxis    ARGUMENTS:   INPUT: 	cd:	Array (nt) of CAMERA descriptors.         oaxis:	Array (2,nt) of new oaxis values.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cam/cam_set_oaxis.html#cam_set_oaxis", "cam_set_oaxis", 'routine in <a href="nv/obj/cam/cam_set_oaxis.html">cam_set_oaxis.pro</a>', "cam_set_oaxis.pro", "", "cam_set_oaxis", "", "noeventcdoaxis", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cam/cam_set_origin.html", "cam_set_origin.pro", '.pro file in <a href="nv/obj/cam/dir-overview.html">nv/obj/cam/ directory</a>', "cam_set_origin.pro", "", "", " NAME: 	cam_set_origin    PURPOSE:        Replaces the origin array for each given camera descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	cam_set_origin, cd, origin    ARGUMENTS:   INPUT: 	cd:	Array (nt) of CAMERA descriptors.         origin:	Array (2,nt) of new origin values.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cam/cam_set_origin.html#cam_set_origin", "cam_set_origin", 'routine in <a href="nv/obj/cam/cam_set_origin.html">cam_set_origin.pro</a>', "cam_set_origin.pro", "", "cam_set_origin", "", "noeventcdorigin", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cam/cam_set_poly_matrices.html", "cam_set_poly_matrices.pro", '.pro file in <a href="nv/obj/cam/dir-overview.html">nv/obj/cam/ directory</a>', "cam_set_poly_matrices.pro", "", "", " NAME: 	cam_set_poly_matrices    PURPOSE:        Sets up the camera function data for the polynomial distortion model.   CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	cam_set_poly_matrices, cd, XX, YY, PP, QQ    ARGUMENTS:   INPUT: 	cd:	Array (nt) of and subclass of CAMERA.         XX:     Polynominal distortion coefficients in x.         YY:     Polynominal distortion coefficients in y.         PP:     Inverse polynominal distortion coefficients in x.         QQ:     Inverse polynominal distortion coefficients in y.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cam/cam_set_poly_matrices.html#cam_set_poly_matrices", "cam_set_poly_matrices", 'routine in <a href="nv/obj/cam/cam_set_poly_matrices.html">cam_set_poly_matrices.pro</a>', "cam_set_poly_matrices.pro", "", "cam_set_poly_matrices", "", "noeventcdXXYYPPQQ", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cam/cam_set_scale.html", "cam_set_scale.pro", '.pro file in <a href="nv/obj/cam/dir-overview.html">nv/obj/cam/ directory</a>', "cam_set_scale.pro", "", "", " NAME: 	cam_set_scale    PURPOSE:        Replaces the scale array for each given camera descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	cam_set_scale, cd, scale    ARGUMENTS:   INPUT: 	cd:	Array (nt) of CAMERA descriptors.  	scale:	Array (2,nt) of new scale values.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cam/cam_set_scale.html#cam_set_scale", "cam_set_scale", 'routine in <a href="nv/obj/cam/cam_set_scale.html">cam_set_scale.pro</a>', "cam_set_scale.pro", "", "cam_set_scale", "", "noeventcdscale", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cam/cam_set_size.html", "cam_set_size.pro", '.pro file in <a href="nv/obj/cam/dir-overview.html">nv/obj/cam/ directory</a>', "cam_set_size.pro", "", "", " NAME: 	cam_set_size    PURPOSE:        Replaces the size array for each given camera descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	cam_set_size, cd, size    ARGUMENTS:   INPUT: 	cd:	     Array (nt) of CAMERA descriptors.         size:        Array (2,nt) of new size values.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cam/cam_set_size.html#cam_set_size", "cam_set_size", 'routine in <a href="nv/obj/cam/cam_set_size.html">cam_set_size.pro</a>', "cam_set_size.pro", "", "cam_set_size", "", "noeventcdsize", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cam/cam_size.html", "cam_size.pro", '.pro file in <a href="nv/obj/cam/dir-overview.html">nv/obj/cam/ directory</a>', "cam_size.pro", "", "", " NAME: 	cam_size    PURPOSE: 	Returns the image size (in pixels) for each given camera descriptor.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	size = cam_size(cd)    ARGUMENTS:   INPUT: 	cd:	 Array (nt) of CAMERA descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Size array associated with each given camera descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cam/cam_size.html#cam_size", "cam_size", 'routine in <a href="nv/obj/cam/cam_size.html">cam_size.pro</a>', "cam_size.pro", "", "cam_size", "", "noeventnxnycd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cam/cam_subimage.html", "cam_subimage.pro", '.pro file in <a href="nv/obj/cam/dir-overview.html">nv/obj/cam/ directory</a>', "cam_subimage.pro", "", "", " NAME: 	cam_subimage    PURPOSE:        Produces a new camera descriptor corresponding to dividing the 	associated image as specified.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	cam_subimage, cd, p0, nxy    ARGUMENTS:   INPUT: 	cd:	Array (nt) of CAMERA descriptors to modify.  	p0:	Starting corner of subimage.  	size:	Array (2,1,nt) of image sizes.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 4/2015  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cam/cam_subimage.html#cam_subimage", "cam_subimage", 'routine in <a href="nv/obj/cam/cam_subimage.html">cam_subimage.pro</a>', "cam_subimage.pro", "", "cam_subimage", "", "noeventcdp0size", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/capture_png.html", "capture_png.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "capture_png.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/capture_png.html#capture_png", "capture_png", 'routine in <a href="util/capture_png.html">capture_png.pro</a>', "capture_png.pro", "", "capture_png", "", "filename", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/iss/cas_blocklowfreq.html", "cas_blocklowfreq.pro", '.pro file in <a href="config/cas/iss/dir-overview.html">config/cas/iss/ directory</a>', "cas_blocklowfreq.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/iss/cas_blocklowfreq.html#cas_blocklowfreq", "cas_blocklowfreq", 'routine in <a href="config/cas/iss/cas_blocklowfreq.html">cas_blocklowfreq.pro</a>', "cas_blocklowfreq.pro", "", "cas_blocklowfreq", "", "fwidthordertfhumin", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/iss/cas_cmat_to_orient_iss.html", "cas_cmat_to_orient_iss.pro", '.pro file in <a href="config/cas/iss/dir-overview.html">config/cas/iss/ directory</a>', "cas_cmat_to_orient_iss.pro", "", "", " NAME: 	cas_cmat_to_orient_iss    PURPOSE: 	Converts a Cassini ISS C matrix to an OMINAS camera orientation matrix.    CATEGORY: 	NV/CONFIG    CALLING SEQUENCE: 	result = cas_cmat_to_orient(cmat)    ARGUMENTS:   INPUT: 	cmat:	Cassini C matrix    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	NONE    OUTPUT: 	NONE    RETURN: 	OMINAS camera orientation matrix.    PROCEDURE:   					    / Zcm 					  / 			     Ycm ------		C matrix 					| 			   /|\		| 			    |		| Xcm 			  lines 			 --------- 			|	  | 	   		|	  |  samples --> 			|	  | 			 --------- 	    Z	| 		|     OMINAS	|  / Y 		|/ 		 ------- X     STATUS: 	Complete    SEE ALSO: 	cas_orient_to_cmat    MODIFICATION HISTORY:  	Written by:	Spitale, 1/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/iss/cas_cmat_to_orient_iss.html#cas_cmat_to_orient_iss", "cas_cmat_to_orient_iss", 'routine in <a href="config/cas/iss/cas_cmat_to_orient_iss.html">cas_cmat_to_orient_iss.pro</a>', "cas_cmat_to_orient_iss.pro", "", "cas_cmat_to_orient_iss", "", "cmat", "          -1", "");
  
  

libdata[libdataItem++] = new Array("vims_src_tmp/cas_cmat_to_orient_vims.html", "cas_cmat_to_orient_vims.pro", '.pro file in <a href="vims_src_tmp/dir-overview.html">vims_src_tmp/ directory</a>', "cas_cmat_to_orient_vims.pro", "", "", " NAME: 	cas_cmat_to_orient_vims    PURPOSE: 	Converts a Cassini ISS C matrix to an OMINAS camera orientation matrix.    CATEGORY: 	NV/CONFIG    CALLING SEQUENCE: 	result = cas_cmat_to_orient(cmat)    ARGUMENTS:   INPUT: 	cmat:	Cassini C matrix    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	NONE    OUTPUT: 	NONE    RETURN: 	OMINAS camera orientation matrix.    PROCEDURE:   					    / Zcm 					  / 			     Ycm ------		C matrix 					| 			   /|\		| 			    |		| Xcm 			  lines 			 --------- 			|	  | 	   		|	  |  samples --> 			|	  | 			 --------- 	    Z	| 		|     OMINAS	|  / Y 		|/ 		 ------- X     STATUS: 	Complete    SEE ALSO: 	cas_orient_to_cmat    MODIFICATION HISTORY:  	Written by:	Spitale, 1/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("vims_src_tmp/cas_cmat_to_orient_vims.html#cas_cmat_to_orient_vims", "cas_cmat_to_orient_vims", 'routine in <a href="vims_src_tmp/cas_cmat_to_orient_vims.html">cas_cmat_to_orient_vims.pro</a>', "cas_cmat_to_orient_vims.pro", "", "cas_cmat_to_orient_vims", "", "cmat", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/iss/cas_compute_psf.html", "cas_compute_psf.pro", '.pro file in <a href="config/cas/iss/dir-overview.html">config/cas/iss/ directory</a>', "cas_compute_psf.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/iss/cas_compute_psf.html#cas_compute_psf", "cas_compute_psf", 'routine in <a href="config/cas/iss/cas_compute_psf.html">cas_compute_psf.pro</a>', "cas_compute_psf.pro", "", "cas_compute_psf", "", "defaultonedimcdxy", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/iss/cas_debias.html", "cas_debias.pro", '.pro file in <a href="config/cas/iss/dir-overview.html">config/cas/iss/ directory</a>', "cas_debias.pro", "", "", " NAME: 	cas_debias    PURPOSE: 	To remove horizontal banding in Cassini images    CATEGORY: 	UTIL/CASSINI    CALLING SEQUENCE: 	result = debias(image, label, bpa)    ARGUMENTS:   INPUT: 	image:	Image data  	label:	Image label from read_vicar  	bpa:    Binary prefix bytes from read_vicar    OUTPUT: 	bias:	Bias calculated    KEYWORDS:   INPUT: 	average: Use average of overclocked pixels    RETURN: 	Real image with horizontal banding mostly subtracted.    PROCEDURE: 	This routine applies a digital filter to the overclocked 	pixel value found in the Binary prefix array (bpa) and then 	subtracts this from the image.     STATUS: 	xx    MODIFICATION HISTORY:  	Written by:	V. Haemmerle, 3/2000   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/iss/cas_debias.html#cas_debias", "cas_debias", 'routine in <a href="config/cas/iss/cas_debias.html">cas_debias.pro</a>', "cas_debias.pro", "", "cas_debias", "", "biasaverageimagelabelbpa", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/iss/cas_dedark.html", "cas_dedark.pro", '.pro file in <a href="config/cas/iss/dir-overview.html">config/cas/iss/ directory</a>', "cas_dedark.pro", "", "", " NAME: 	cas_dedark    PURPOSE: 	To remove horizontal banding and dark current in Cassini images    CATEGORY: 	UTIL/CASSINI    CALLING SEQUENCE: 	result = cas_dedark(image, label, bpa)    ARGUMENTS:   INPUT: 	image:	Image data  	label:	Image label from read_vicar  	bpa:    Binary prefix bytes from read_vicar    OUTPUT: 	bias:	Bias/dark calculated     RETURN: 	Real image with horizontal banding mostly subtracted.    PROCEDURE: 	This routine applies a digital filter to the extended 	pixel value found in the Binary prefix array (bpa) and then 	subtracts this from the image.     STATUS: 	xx    MODIFICATION HISTORY:  	Written by:	V. Haemmerle, 3/2000   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/iss/cas_dedark.html#cas_dedark", "cas_dedark", 'routine in <a href="config/cas/iss/cas_dedark.html">cas_dedark.pro</a>', "cas_dedark.pro", "", "cas_dedark", "", "biasimagelabelbpa", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/iss/cas_delut.html", "cas_delut.pro", '.pro file in <a href="config/cas/iss/dir-overview.html">config/cas/iss/ directory</a>', "cas_delut.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/iss/cas_delut.html#cas_delut", "cas_delut", 'routine in <a href="config/cas/iss/cas_delut.html">cas_delut.pro</a>', "cas_delut.pro", "", "cas_delut", "", "forceimagelabel", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/iss/cas_desky.html", "cas_desky.pro", '.pro file in <a href="config/cas/iss/dir-overview.html">config/cas/iss/ directory</a>', "cas_desky.pro", "", "", " NAME: 	cas_desky    PURPOSE: 	To remove horizontal banding in Cassini images by removing 	the background which includes the bias and dark current    CATEGORY: 	UTIL/CASSINI    CALLING SEQUENCE: 	result = cas_desky(image, sample)    ARGUMENTS:   INPUT: 	image:	Image data  	sample: Array of sample segments [start_x1, end_x1, start_x2, ...]    OUTPUT: 	NONE   KEYWORDS:   INPUT: 	tol:	DN tolerance around median to include in average  	maxsig:	Sigma tolerance above mean to include in average  	width:	If set, median is done using a box this size rather 		than across lines        smooth:  Smooth the calculated result vertically using this 	        number of pixels (should be odd number)  	 skip:  If specified, will skip the before and after pixel 	        of pixels that are thrown out.  /skip does not work 	        when using width.   RETURN: 	Real image with horizontal banding, bias and DC mostly subtracted.    PROCEDURE: 	This routine calculates an average background to subtract by 	median filtering (or sigma filtering) and averaging the image between 	the given sample ranges.  The averaging is done in the sample direction 	because both the horizontal banding and the dark current is nearly 	constant along this direction.  The area selection should be almost all 	sky for a reasonable result.  This routine may not work well in images 	with strong gradiants.    STATUS: 	Tweeks still being applied.    MODIFICATION HISTORY:  	Written by:	V. Haemmerle, 3/2000 	Modified by:    V. Haemmerle, 1/2001   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/iss/cas_desky.html#cas_desky", "cas_desky", 'routine in <a href="config/cas/iss/cas_desky.html">cas_desky.pro</a>', "cas_desky.pro", "", "cas_desky", "", "tolmaxsigwidthskipsmoothimagesample", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/iss/cas_filter.html", "cas_filter.pro", '.pro file in <a href="config/cas/iss/dir-overview.html">config/cas/iss/ directory</a>', "cas_filter.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/iss/cas_filter.html#cas_filter", "cas_filter", 'routine in <a href="config/cas/iss/cas_filter.html">cas_filter.pro</a>', "cas_filter.pro", "", "cas_filter", "", "defaultcdilambda", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/iss/cas_format_comment.html", "cas_format_comment.pro", '.pro file in <a href="config/cas/iss/dir-overview.html">config/cas/iss/ directory</a>', "cas_format_comment.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/iss/cas_format_comment.html#cas_format_comment", "cas_format_comment", 'routine in <a href="config/cas/iss/cas_format_comment.html">cas_format_comment.pro</a>', "cas_format_comment.pro", "", "cas_format_comment", "", "od", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/iss/cas_from_ominas.html", "cas_from_ominas.pro", '.pro file in <a href="config/cas/iss/dir-overview.html">config/cas/iss/ directory</a>', "cas_from_ominas.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/iss/cas_from_ominas.html#cas_from_ominas", "cas_from_ominas", 'routine in <a href="config/cas/iss/cas_from_ominas.html">cas_from_ominas.pro</a>', "cas_from_ominas.pro", "", "cas_from_ominas", "", "odorient_fn", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/iss/cas_lut.html", "cas_lut.pro", '.pro file in <a href="config/cas/iss/dir-overview.html">config/cas/iss/ directory</a>', "cas_lut.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/iss/cas_lut.html#cas_lut", "cas_lut", 'routine in <a href="config/cas/iss/cas_lut.html">cas_lut.pro</a>', "cas_lut.pro", "", "cas_lut", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/iss/cas_mx_wac_to_nac.html", "cas_mx_wac_to_nac.pro", '.pro file in <a href="config/cas/iss/dir-overview.html">config/cas/iss/ directory</a>', "cas_mx_wac_to_nac.pro", "", "", " NAME:        cas_mx_wac_to_nac    PURPOSE: 	Computes a matrix that rotates between cassini WAC and NAC orientations.    CATEGORY:        UTIL/CASSINI    CALLING SEQUENCE:        result = cas_mx_wac_to_nac()    ARGUMENTS: NONE   KEYWORDS: NONE    RETURN:         Transformation matrix.    STATUS:        Incomplete    MODIFICATION HISTORY:        Written by:     Spitale 8/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/iss/cas_mx_wac_to_nac.html#cas_mx_wac_to_nac", "cas_mx_wac_to_nac", 'routine in <a href="config/cas/iss/cas_mx_wac_to_nac.html">cas_mx_wac_to_nac.pro</a>', "cas_mx_wac_to_nac.pro", "", "cas_mx_wac_to_nac", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/iss/cas_nac_box.html", "cas_nac_box.pro", '.pro file in <a href="config/cas/iss/dir-overview.html">config/cas/iss/ directory</a>', "cas_nac_box.pro", "", "", " NAME:        cas_nac_box    PURPOSE: 	This procedure converts Cassini ISS NAC image corners into 	ISS WAC pixel locations.  Useful for plotting NAC FOV in WAC 	images.    CATEGORY:        UTIL/CASSINI    CALLING SEQUENCE:        result = cas_nac_box()    ARGUMENTS:   INPUT:        NONE    OUTPUT:        NONE   KEYWORDS:         NONE   RETURN:         Array of corner pixels.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Haemmerle 1/2000   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/iss/cas_nac_box.html#cas_nac_box", "cas_nac_box", 'routine in <a href="config/cas/iss/cas_nac_box.html">cas_nac_box.pro</a>', "cas_nac_box.pro", "", "cas_nac_box", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/iss/cas_nac_scale.html", "cas_nac_scale.pro", '.pro file in <a href="config/cas/iss/dir-overview.html">config/cas/iss/ directory</a>', "cas_nac_scale.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/iss/cas_nac_scale.html#cas_nac_scale", "cas_nac_scale", 'routine in <a href="config/cas/iss/cas_nac_scale.html">cas_nac_scale.pro</a>', "cas_nac_scale.pro", "", "cas_nac_scale", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/iss/cas_nac_to_wac.html", "cas_nac_to_wac.pro", '.pro file in <a href="config/cas/iss/dir-overview.html">config/cas/iss/ directory</a>', "cas_nac_to_wac.pro", "", "", " NAME:        cas_nac_to_wac    PURPOSE: 	This procedure converts Cassini ISS NAC pixel locations into 	ISS WAC pixel locations.    CATEGORY:        UTIL/CASSINI    CALLING SEQUENCE:        result = cas_nac_to_wac(points)    ARGUMENTS:   INPUT:        points:     Array of Position of sample (x) and line (y)     OUTPUT:        NONE   KEYWORDS:            mark:     Mark sample,line positions    RETURN:         Array of Sample (x) and line (y) of the resulting transformation.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Haemmerle 1/2000        Updated by:     Haemmerle 9/2000   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/iss/cas_nac_to_wac.html#cas_nac_to_wac", "cas_nac_to_wac", 'routine in <a href="config/cas/iss/cas_nac_to_wac.html">cas_nac_to_wac.pro</a>', "cas_nac_to_wac.pro", "", "cas_nac_to_wac", "", "marknpoints", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/iss/cas_orient_to_cmat_iss.html", "cas_orient_to_cmat_iss.pro", '.pro file in <a href="config/cas/iss/dir-overview.html">config/cas/iss/ directory</a>', "cas_orient_to_cmat_iss.pro", "", "", " NAME: 	cas_orient_to_cmat_iss    PURPOSE: 	Converts an OMINAS camera orientation matrix to a Cassini ISS C matrix.    CATEGORY: 	NV/CONFIG    CALLING SEQUENCE: 	result = cas_orient_to_cmat(cmat)    ARGUMENTS:   INPUT: 	orient:		OMINAS camera orientation matrix.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	NONE    OUTPUT: 	NONE    RETURN: 	Cassini C matrix.    PROCEDURE:   					    / Zcm 					  / 			     Ycm ------		C matrix 					| 			   /|\		| 			    |		| Xcm 			  lines 			 --------- 			|	  | 	   		|	  |  samples --> 			|	  | 			 --------- 	    Z	| 		|     OMINAS	|  / Y 		|/ 		 ------- X     STATUS: 	Complete    SEE ALSO: 	cas_cmat_to_orient    MODIFICATION HISTORY:  	Written by:	Spitale, 1/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/iss/cas_orient_to_cmat_iss.html#cas_orient_to_cmat_iss", "cas_orient_to_cmat_iss", 'routine in <a href="config/cas/iss/cas_orient_to_cmat_iss.html">cas_orient_to_cmat_iss.pro</a>', "cas_orient_to_cmat_iss.pro", "", "cas_orient_to_cmat_iss", "", "orient", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/iss/cas_psf-old.html", "cas_psf-old.pro", '.pro file in <a href="config/cas/iss/dir-overview.html">config/cas/iss/ directory</a>', "cas_psf-old.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/iss/cas_psf-old.html#cas_psf", "cas_psf", 'routine in <a href="config/cas/iss/cas_psf-old.html">cas_psf-old.pro</a>', "cas_psf-old.pro", "", "cas_psf", "", "inst", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/iss/cas_psf.html", "cas_psf.pro", '.pro file in <a href="config/cas/iss/dir-overview.html">config/cas/iss/ directory</a>', "cas_psf.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/iss/cas_psf.html#ccpsf_read", "ccpsf_read", 'routine in <a href="config/cas/iss/cas_psf.html">cas_psf.pro</a>', "cas_psf.pro", "", "ccpsf_read", "", "fnamesize", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/cas/iss/cas_psf.html#cas_psf", "cas_psf", 'routine in <a href="config/cas/iss/cas_psf.html">cas_psf.pro</a>', "cas_psf.pro", "", "cas_psf", "", "cdxy", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/iss/cas_query_lut.html", "cas_query_lut.pro", '.pro file in <a href="config/cas/iss/dir-overview.html">config/cas/iss/ directory</a>', "cas_query_lut.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/iss/cas_query_lut.html#cas_query_lut", "cas_query_lut", 'routine in <a href="config/cas/iss/cas_query_lut.html">cas_query_lut.pro</a>', "cas_query_lut.pro", "", "cas_query_lut", "", "label", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/radar/cas_radar_input.html", "cas_radar_input.pro", '.pro file in <a href="config/cas/radar/dir-overview.html">config/cas/radar/ directory</a>', "cas_radar_input.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/radar/cas_radar_input.html#cas_radar_planets", "cas_radar_planets", 'routine in <a href="config/cas/radar/cas_radar_input.html">cas_radar_input.pro</a>', "cas_radar_input.pro", "", "cas_radar_planets", "", "dd", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/cas/radar/cas_radar_input.html#cas_radar_lonlattolinesample", "cas_radar_lonlattolinesample", 'routine in <a href="config/cas/radar/cas_radar_input.html">cas_radar_input.pro</a>', "cas_radar_input.pro", "", "cas_radar_lonlattolinesample", "", "line_offsetsample_offsetmapreslonlat", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/cas/radar/cas_radar_input.html#cas_radar_linesampletolonlat", "cas_radar_linesampletolonlat", 'routine in <a href="config/cas/radar/cas_radar_input.html">cas_radar_input.pro</a>', "cas_radar_input.pro", "", "cas_radar_linesampletolonlat", "", "line_offsetsample_offsetmapreslinesample", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/cas/radar/cas_radar_input.html#cas_radar_maps", "cas_radar_maps", 'routine in <a href="config/cas/radar/cas_radar_input.html">cas_radar_input.pro</a>', "cas_radar_input.pro", "", "cas_radar_maps", "", "dd", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/cas/radar/cas_radar_input.html#cas_radar_input", "cas_radar_input", 'routine in <a href="config/cas/radar/cas_radar_input.html">cas_radar_input.pro</a>', "cas_radar_input.pro", "", "cas_radar_input", "", "n_objdimvaluesstatusddkeyword@nv_trs_keywords_include.pro", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/radar/cas_radar_transform.html", "cas_radar_transform.pro", '.pro file in <a href="config/cas/radar/dir-overview.html">config/cas/radar/ directory</a>', "cas_radar_transform.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/radar/cas_radar_transform.html#cas_radar_transform", "cas_radar_transform", 'routine in <a href="config/cas/radar/cas_radar_transform.html">cas_radar_transform.pro</a>', "cas_radar_transform.pro", "", "cas_radar_transform", "", "forceimalabel", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/iss/cas_relut.html", "cas_relut.pro", '.pro file in <a href="config/cas/iss/dir-overview.html">config/cas/iss/ directory</a>', "cas_relut.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/iss/cas_relut.html#cas_relut", "cas_relut", 'routine in <a href="config/cas/iss/cas_relut.html">cas_relut.pro</a>', "cas_relut.pro", "", "cas_relut", "", "forceimagelabel", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/iss/cas_removehum.html", "cas_removehum.pro", '.pro file in <a href="config/cas/iss/dir-overview.html">config/cas/iss/ directory</a>', "cas_removehum.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/iss/cas_removehum.html#cas_removehum", "cas_removehum", 'routine in <a href="config/cas/iss/cas_removehum.html">cas_removehum.pro</a>', "cas_removehum.pro", "", "cas_removehum", "", "maskbpaocextfwidthdccoupledhumnoisyimg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/iss/cas_removehum_oc.html", "cas_removehum_oc.pro", '.pro file in <a href="config/cas/iss/dir-overview.html">config/cas/iss/ directory</a>', "cas_removehum_oc.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/iss/cas_removehum_oc.html#cas_removehum_oc", "cas_removehum_oc", 'routine in <a href="config/cas/iss/cas_removehum_oc.html">cas_removehum_oc.pro</a>', "cas_removehum_oc.pro", "", "cas_removehum_oc", "", "skip_presmoothdccoupledhumnoisyimgbpa", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/iss/cas_reverse_lut.html", "cas_reverse_lut.pro", '.pro file in <a href="config/cas/iss/dir-overview.html">config/cas/iss/ directory</a>', "cas_reverse_lut.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/iss/cas_reverse_lut.html#cas_reverse_lut", "cas_reverse_lut", 'routine in <a href="config/cas/iss/cas_reverse_lut.html">cas_reverse_lut.pro</a>', "cas_reverse_lut.pro", "", "cas_reverse_lut", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/cas_spice_fk_detect.html", "cas_spice_fk_detect.pro", '.pro file in <a href="config/cas/dir-overview.html">config/cas/ directory</a>', "cas_spice_fk_detect.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/cas_spice_fk_detect.html#cas_spice_fk_detect", "cas_spice_fk_detect", 'routine in <a href="config/cas/cas_spice_fk_detect.html">cas_spice_fk_detect.pro</a>', "cas_spice_fk_detect.pro", "", "cas_spice_fk_detect", "", "sctimestrictallddkpath", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/cas_spice_ik_detect.html", "cas_spice_ik_detect.pro", '.pro file in <a href="config/cas/dir-overview.html">config/cas/ directory</a>', "cas_spice_ik_detect.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/cas_spice_ik_detect.html#cas_spice_ik_detect", "cas_spice_ik_detect", 'routine in <a href="config/cas/cas_spice_ik_detect.html">cas_spice_ik_detect.pro</a>', "cas_spice_ik_detect.pro", "", "cas_spice_ik_detect", "", "sctimestrictallddkpath", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/iss/cas_spice_input.html", "cas_spice_input.pro", '.pro file in <a href="config/cas/iss/dir-overview.html">config/cas/iss/ directory</a>', "cas_spice_input.pro", "", "", " NAME: 	cas_spice_input    PURPOSE: 	NAIF/SPICE input translator for Cassini.    CATEGORY: 	NV/CONFIG    CALLING SEQUENCE: 	result = cas_spice_input(dd, keyword)    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	keyword:	String giving the name of the translator quantity.     OUTPUT: 	NONE    KEYWORDS:   INPUT: 	key1:		Camera descriptor.    OUTPUT: 	status:		Zero if valid data is returned.     TRANSLATOR KEYWORDS: 	ref:		Name of the reference frame for the output quantities. 			Default is 'j2000'.  	j2000:		/j2000 is equivalent to specifying ref=j2000.  	b1950:		/b1950 is equivalent to specifying ref=b1950.  	klist:		Name of a file giving a list of SPICE kernels to use. 			If no path is included, the path is taken from the 			NV_SPICE_KER environment variable.  	ck_in:		List of input C kernel files to use.  List must be 			delineated by semimcolons with no space.  The kernel 			list file is still used, but these kernels take 			precedence.  Entries in this list may be file 			specification strings.  	planets:	List of planets to for which to request ephemeris. 			Must be delineated by semicolons with no space.  	reload:		If set, new kernels are loaded, as specified by the 			klist and ck_in keywords.    RETURN: 	Data associated with the requested keyword.    STATUS: 	Complete    SEE ALSO: 	cas_spice_output    MODIFICATION HISTORY:  	Written by:	Spitale, 10/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/iss/cas_spice_input.html#cas_spice_parse_labels", "cas_spice_parse_labels", 'routine in <a href="config/cas/iss/cas_spice_input.html">cas_spice_input.pro</a>', "cas_spice_input.pro", "", "cas_spice_parse_labels", "", "exposuresizefiltersoaxistargetdd_time", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/cas/iss/cas_spice_input.html#cas_spice_cameras", "cas_spice_cameras", 'routine in <a href="config/cas/iss/cas_spice_input.html">cas_spice_input.pro</a>', "cas_spice_input.pro", "", "cas_spice_cameras", "", "posconstantsn_objdimstatustimeorientobsddref", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/cas/iss/cas_spice_input.html#cas_spice_planets", "cas_spice_planets", 'routine in <a href="config/cas/iss/cas_spice_input.html">cas_spice_input.pro</a>', "cas_spice_input.pro", "", "cas_spice_planets", "", "timeplanetsn_objdimstatustarg_listconstantsobsddref", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/cas/iss/cas_spice_input.html#cas_spice_sun", "cas_spice_sun", 'routine in <a href="config/cas/iss/cas_spice_input.html">cas_spice_input.pro</a>', "cas_spice_input.pro", "", "cas_spice_sun", "", "n_objdimconstantsstatustimeobsddref", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/cas/iss/cas_spice_input.html#cas_spice_input", "cas_spice_input", 'routine in <a href="config/cas/iss/cas_spice_input.html">cas_spice_input.pro</a>', "cas_spice_input.pro", "", "cas_spice_input", "", "valuesstatusddkeyword@nv_trs_keywords_include.pro", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/iss/cas_spice_output.html", "cas_spice_output.pro", '.pro file in <a href="config/cas/iss/dir-overview.html">config/cas/iss/ directory</a>', "cas_spice_output.pro", "", "", " NAME: 	cas_spice_output    PURPOSE: 	NAIF/SPICE output translator for Cassini.    CATEGORY: 	NV/CONFIG    CALLING SEQUENCE(only to be called by nv_xx_value): 	cas_spice_output, dd, keyword, value    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	keyword:	String giving the name of the translator quantity.  	value:		The data to write.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	key1:		Camera descriptor.    OUTPUT: 	status:		Zero unless a problem occurs.     TRANSLATOR KEYWORDS: 	ref:		Name of the reference frame for the input quantities. 			Default is 'j2000'.  	j2000:		/j2000 is equivalent to specifying ref=j2000.  	b1950:		/b1950 is equivalent to specifying ref=b1950.  	ck_out:		String giving the name of the new C-kernel to write.    STATUS: 	Complete    SEE ALSO: 	cas_spice_input    MODIFICATION HISTORY:  	Written by:	Spitale, 10/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/iss/cas_spice_output.html#cas_spice_write_cameras", "cas_spice_write_cameras", 'routine in <a href="config/cas/iss/cas_spice_output.html">cas_spice_output.pro</a>', "cas_spice_output.pro", "", "cas_spice_write_cameras", "", "reloadn_objdimstatusddvaluerefck_file", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/cas/iss/cas_spice_output.html#cas_spice_output", "cas_spice_output", 'routine in <a href="config/cas/iss/cas_spice_output.html">cas_spice_output.pro</a>', "cas_spice_output.pro", "", "cas_spice_output", "", "statusddkeywordvalue@nv_trs_keywords_include.pro", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/iss/cas_spice_read_labels.html", "cas_spice_read_labels.pro", '.pro file in <a href="config/cas/iss/dir-overview.html">config/cas/iss/ directory</a>', "cas_spice_read_labels.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/iss/cas_spice_read_labels.html#csrl_label_struct__define", "csrl_label_struct__define", 'routine in <a href="config/cas/iss/cas_spice_read_labels.html">cas_spice_read_labels.pro</a>', "cas_spice_read_labels.pro", "", "csrl_label_struct__define", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/cas/iss/cas_spice_read_labels.html#csrl_getpar", "csrl_getpar", 'routine in <a href="config/cas/iss/cas_spice_read_labels.html">cas_spice_read_labels.pro</a>', "cas_spice_read_labels.pro", "", "csrl_getpar", "", "labelkeyword", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/cas/iss/cas_spice_read_labels.html#csrl_time_to_jd", "csrl_time_to_jd", 'routine in <a href="config/cas/iss/cas_spice_read_labels.html">cas_spice_read_labels.pro</a>', "cas_spice_read_labels.pro", "", "csrl_time_to_jd", "", "time", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/cas/iss/cas_spice_read_labels.html#cas_spice_read_labels", "cas_spice_read_labels", 'routine in <a href="config/cas/iss/cas_spice_read_labels.html">cas_spice_read_labels.pro</a>', "cas_spice_read_labels.pro", "", "cas_spice_read_labels", "", "files", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/cas_spice_sc.html", "cas_spice_sc.pro", '.pro file in <a href="config/cas/dir-overview.html">config/cas/ directory</a>', "cas_spice_sc.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/cas_spice_sc.html#cas_spice_sc", "cas_spice_sc", 'routine in <a href="config/cas/cas_spice_sc.html">cas_spice_sc.pro</a>', "cas_spice_sc.pro", "", "cas_spice_sc", "", "dd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/cas_spice_sck_detect.html", "cas_spice_sck_detect.pro", '.pro file in <a href="config/cas/dir-overview.html">config/cas/ directory</a>', "cas_spice_sck_detect.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/cas_spice_sck_detect.html#cas_spice_sck_detect", "cas_spice_sck_detect", 'routine in <a href="config/cas/cas_spice_sck_detect.html">cas_spice_sck_detect.pro</a>', "cas_spice_sck_detect.pro", "", "cas_spice_sck_detect", "", "sctimestrictallddkpath", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/cas_spice_sct2et.html", "cas_spice_sct2et.pro", '.pro file in <a href="config/cas/dir-overview.html">config/cas/ directory</a>', "cas_spice_sct2et.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/cas_spice_sct2et.html#cas_spice_sct2et", "cas_spice_sct2et", 'routine in <a href="config/cas/cas_spice_sct2et.html">cas_spice_sct2et.pro</a>', "cas_spice_sct2et.pro", "", "cas_spice_sct2et", "", "ddtimes", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/iss/cas_spice_time.html", "cas_spice_time.pro", '.pro file in <a href="config/cas/iss/dir-overview.html">config/cas/iss/ directory</a>', "cas_spice_time.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/iss/cas_spice_time.html#cas_spice_time", "cas_spice_time", 'routine in <a href="config/cas/iss/cas_spice_time.html">cas_spice_time.pro</a>', "cas_spice_time.pro", "", "cas_spice_time", "", "dtstringlabel", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/iss/cas_to_ominas.html", "cas_to_ominas.pro", '.pro file in <a href="config/cas/iss/dir-overview.html">config/cas/iss/ directory</a>', "cas_to_ominas.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/iss/cas_to_ominas.html#cas_to_ominas", "cas_to_ominas", 'routine in <a href="config/cas/iss/cas_to_ominas.html">cas_to_ominas.pro</a>', "cas_to_ominas.pro", "", "cas_to_ominas", "", "odorient_fn", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/iss/cas_wac_scale.html", "cas_wac_scale.pro", '.pro file in <a href="config/cas/iss/dir-overview.html">config/cas/iss/ directory</a>', "cas_wac_scale.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/iss/cas_wac_scale.html#cas_wac_scale", "cas_wac_scale", 'routine in <a href="config/cas/iss/cas_wac_scale.html">cas_wac_scale.pro</a>', "cas_wac_scale.pro", "", "cas_wac_scale", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/iss/cas_wac_to_nac.html", "cas_wac_to_nac.pro", '.pro file in <a href="config/cas/iss/dir-overview.html">config/cas/iss/ directory</a>', "cas_wac_to_nac.pro", "", "", " NAME:        cas_wac_to_nac    PURPOSE: 	This procedure converts Cassini ISS WAC pixel locations into 	ISS NAC pixel locations.    CATEGORY:        UTIL/CASSINI    CALLING SEQUENCE:        result = cas_wac_to_nac(points)    ARGUMENTS:   INPUT:        points:     Array of Position of sample (x) and line (y)     OUTPUT:        NONE   KEYWORDS:            mark:     Mark sample,line positions    RETURN:         Array of Sample (x) and line (y) of the resulting transformation.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Haemmerle 1/2000        Updated by:     Haemmmerle 9/2000   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/iss/cas_wac_to_nac.html#cas_wac_to_nac", "cas_wac_to_nac", 'routine in <a href="config/cas/iss/cas_wac_to_nac.html">cas_wac_to_nac.pro</a>', "cas_wac_to_nac.pro", "", "cas_wac_to_nac", "", "markwpoints", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/cat_indices.html", "cat_indices.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "cat_indices.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/cat_indices.html#cat_indices", "cat_indices", 'routine in <a href="util/cat_indices.html">cat_indices.pro</a>', "cat_indices.pro", "", "cat_indices", "", "indices", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/cat_points.html", "cat_points.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "cat_points.pro", "", "", " NAME:        cat_points    PURPOSE:        To concatenate arrays of image points.    CATEGORY:        UTIL    CALLING SEQUENCE:        result = cat_points(ps)    ARGUMENTS:   INPUT:        ps:     An array of image point arrays.    OUTPUT:        NONE   RETURN:        Concatenated array of image points.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/cat_points.html#cat_points", "cat_points", 'routine in <a href="util/cat_points.html">cat_points.pro</a>', "cat_points.pro", "", "cat_points", "", "flags_psps", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/cat_vectors.html", "cat_vectors.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "cat_vectors.pro", "", "", " NAME:        cat_vectors    PURPOSE:        To concatenate arrays of column vectors    CATEGORY:        UTIL    CALLING SEQUENCE:        result = cat_vectors(ps)    ARGUMENTS:   INPUT:        ps:     An array of vector arrays.    OUTPUT:        NONE   RETURN:        Concatenated array of column vectors.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/cat_vectors.html#cat_vectors", "cat_vectors", 'routine in <a href="util/cat_vectors.html">cat_vectors.pro</a>', "cat_vectors.pro", "", "cat_vectors", "", "ps", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/cc_threshold.html", "cc_threshold.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "cc_threshold.pro", "", "", " NAME:        cc_threshold    PURPOSE:        To threshold points by correlation coefficient.    CATEGORY:        UTIL    CALLING SEQUENCE:        result = cc_threshold(cc, min=min, max=max)    ARGUMENTS:   INPUT:         cc:    An array of image point arrays.    OUTPUT:        NONE    KEYWORDS:   INPUT:        min:    Minimum cc for threshold         max:    Maximum cc for threshold    relative:    If set, uses the maximum of the smoothed cc array,                and min and max are relative to this maximum.    OUTPUT:        NONE   RETURN:        Subscripts into the cc array that are between the input minimum        and maximum.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/cc_threshold.html#cc_threshold", "cc_threshold", 'routine in <a href="util/cc_threshold.html">cc_threshold.pro</a>', "cc_threshold.pro", "", "cc_threshold", "", "minmaxrelativecc", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/cd_to_radec_twist.html", "cd_to_radec_twist.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "cd_to_radec_twist.pro", "", "", " NAME:        cd_to_radec_twist    PURPOSE:        Computes Euler angles representing the orientation of a given 	camera descriptor.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        cd_to_radec_twist, cd, ra=ra, dec=dec, twist=twist    ARGUMENTS:   INPUT:             cd:       Array (nv,3,nt) of camera descriptors.    OUTPUT:        NONE    KEYOWRDS:   INPUT: NONE    OUTPUT:        ra:	Right ascension relative to the inertial frame.  	dec:	Declination relative to the inertial frame.  	twist:	Twist angle relative to the inertial frame.    RETURN: NONE    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/cd_to_radec_twist.html#cd_to_radec_twist", "cd_to_radec_twist", 'routine in <a href="nv/obj/tools/cd_to_radec_twist.html">cd_to_radec_twist.pro</a>', "cd_to_radec_twist.pro", "", "cd_to_radec_twist", "", "radectwistcd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/centric_to_graphic.html", "centric_to_graphic.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "centric_to_graphic.pro", "", "", " NAME: 	centric_to_graphic    PURPOSE: 	Converts planetocentric surface coordinates to planetographic.    CATEGORY: 	UTIL    CALLING SEQUENCE: 	result = centric_to_graphic(radii, latlon)    ARGUMENTS:   INPUT: 	radii:	Array (3,nt) of Ellipsoid radii.  	latlon:	Array (2,nv,nt) giving the planetocentric latitudes and 		longitudes.    OUTPUT: NONE    KEYWORDS: NONE    RETURN: 	Planetocentric coordinates.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2014   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/centric_to_graphic.html#centric_to_graphic", "centric_to_graphic", 'routine in <a href="util/centric_to_graphic.html">centric_to_graphic.pro</a>', "centric_to_graphic.pro", "", "centric_to_graphic", "", "radiiv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/centric_to_graphic_lat.html", "centric_to_graphic_lat.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "centric_to_graphic_lat.pro", "", "", " NAME: 	centric_to_graphic_lat    PURPOSE: 	Converts planetocentric latitudes to planetographic latitudes.    CATEGORY: 	UTIL    CALLING SEQUENCE: 	result = centric_to_graphic_lat(a, b, lat)    ARGUMENTS:   INPUT: 	a:	Polar radius.  	b:	Equatorial radius.  	lat:	Planetographic latitudes.    OUTPUT: NONE    KEYWORDS: NONE    RETURN: 	Planetocentric latitudes.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 11/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/centric_to_graphic_lat.html#centric_to_graphic_lat", "centric_to_graphic_lat", 'routine in <a href="util/centric_to_graphic_lat.html">centric_to_graphic_lat.pro</a>', "centric_to_graphic_lat.pro", "", "centric_to_graphic_lat", "", "ablat", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/fits/check_fits.html", "check_fits.pro", '.pro file in <a href="config/fits/dir-overview.html">config/fits/ directory</a>', "check_fits.pro", "", "", " NAME: 	check_fits    PURPOSE: 	Given a FITS array IM, and a associated FITS or STSDAS header HDR, this 	procedure will check that 		(1) HDR is a string array, and IM is defined and numeric 		(2) The NAXISi values in HDR are appropiate to the dimensions                    of IM 		(3) The BITPIX value in HDR is appropiate to the datatype of IM    CATEGORY: 	UTIL/FITS    CALLING SEQUENCE: 	check_fits, im, hdr, [ dimen, idltype, /UPDATE, /NOTYPE, /SDAS ]    ARGUMENTS:   INPUT: 	im:	FITS or  STSDAS array, (e.g. as read by SXREAD or READFITS ).  	hdr:	FITS or  STSDAS header (string array) associated with im.    OUTPUT: 	dimen:		Vector containing actual array dimensions  	idltype:	Data type of the FITS array as specified in the IDL SIZE 			function (1 for BYTE, 2 for INTEGER*2, 3 for INTEGER*4, 			etc.)    KEYWORDS:   INPUT: 	NOTYPE:	If this keyword is set, then only agreement of the array 		dimensions with the FITS header are checked, and not the 		data type.  	UPDATE:	If this keyword is set then the BITPIX, NAXIS and DATATYPE 		FITS keywords will be updated to agree with the array.  	SDAS:	If this keyword is set then the header is assumed to be from 		an SDAS (.hhh) file.    CHECK_FITS will then ensure that (1) 		a DATATYPE keyword is included in the header and (2) BITPIX 		is always written with positive values.  	FITS:	If this keyword is present then CHECK_FITS assumes that it is 		dealing with a FITS header and not an SDAS header, see notes 		below.    OUTPUT: NONE    RETURN: NONE    SIDE EFFECTS: 	If there is a fatal problem with the FITS array or header then !ERR is 	set to -1.   ( If the UPDATE keyword was supplied, and the header could 	be fixed then !ERR = 0.)    NOTES: 	An important distinction between an STSDAS header and a FITS header 	is that the BITPIX value in an STSDAS is always positive, e.g. BITPIX=32 	for REAL*4 data.    Users should use either the /SDAS or the /FITS 	keyword if it is important whether the STSDAS or FITS convention for 	REAL*4 data is used.  Otherwise, CHECK_FITS assumes that if a 	DATATYPE keyword is present then it is dealing with an STSDAS header.    PROCEDURE: 	Program checks the NAXIS1 and NAXIS2 parameters in the header to 	see if they match the image array dimensions.    STATUS: 	Complete    MODIFICATION HISTORY: 	Written, December 1991  W. Landsman Hughes/STX to replace CHKIMHD 	No error returned if NAXIS=0 and IM is a scalar   W. Landsman  Feb 93 	Fixed bug for REAL*8 STSDAS data W. Landsman July 93 	Make sure NAXIS agrees with NAXISi  W. Landsman  October 93   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/fits/check_fits.html#check_FITS", "check_FITS", 'routine in <a href="config/fits/check_fits.html">check_fits.pro</a>', "check_fits.pro", "", "check_FITS", "", "UPDATENOTYPESDASFITSimhdrdimenidltype", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/circle.html", "circle.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "circle.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/circle.html#circle", "circle", 'routine in <a href="util/circle.html">circle.pro</a>', "circle.pro", "", "circle", "", "npnoreformcenterradius", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/circle_fit.html", "circle_fit.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "circle_fit.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/circle_fit.html#cf_fn", "cf_fn", 'routine in <a href="util/circle_fit.html">circle_fit.pro</a>', "circle_fit.pro", "", "cf_fn", "", "iparmf", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/circle_fit.html#circle_fit", "circle_fit", 'routine in <a href="util/circle_fit.html">circle_fit.pro</a>', "circle_fit.pro", "", "circle_fit", "", "fixafixbfixrabrsigasigbsigr_x_ysigxsigy", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/cityplot.html", "cityplot.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "cityplot.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/cityplot.html#cityplot", "cityplot", 'routine in <a href="util/cityplot.html">cityplot.pro</a>', "cityplot.pro", "", "cityplot", "", "xrangeyrangeynozeroxstyleystylexy", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/clean.html", "clean.pro", '.pro file in <a href="config/pds/Readpds_4.4/dir-overview.html">config/pds/Readpds_4.4/ directory</a>', "clean.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/clean.html#clean", "clean", 'routine in <a href="config/pds/Readpds_4.4/clean.html">clean.pro</a>', "clean.pro", "", "clean", "", "SPACEtext", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/clean_fnames.html", "clean_fnames.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "clean_fnames.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/clean_fnames.html#clean_fnames", "clean_fnames", 'routine in <a href="util/clean_fnames.html">clean_fnames.pro</a>', "clean_fnames.pro", "", "clean_fnames", "", "_fnames", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/cleanarr.html", "cleanarr.pro", '.pro file in <a href="config/pds/Readpds_4.4/dir-overview.html">config/pds/Readpds_4.4/ directory</a>', "cleanarr.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/cleanarr.html#cleanarr", "cleanarr", 'routine in <a href="config/pds/Readpds_4.4/cleanarr.html">cleanarr.pro</a>', "cleanarr.pro", "", "cleanarr", "", "SPACEtextarr", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/sys/util/clget.html", "clget.pro", '.pro file in <a href="nv/sys/util/dir-overview.html">nv/sys/util/ directory</a>', "clget.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/sys/util/clget.html#clget", "clget", 'routine in <a href="nv/sys/util/clget.html">clget.pro</a>', "clget.pro", "", "clget", "", "foundodptag_name", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/clip.html", "clip.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "clip.pro", "", "", " NAME: 	clip    PURPOSE: 	Return array with first value clipped off.    CATEGORY: 	UTIL    CALLING SEQUENCE: 	result = clip(array)    ARGUMENTS:   INPUT: 	array:	array to be operated on    RETURN: 	If arr is a vector, returns it with the first element clipped off.    MODIFICATION HISTORY:  	Written by:	Tiscareno   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/clip.html#clip", "clip", 'routine in <a href="util/clip.html">clip.pro</a>', "clip.pro", "", "clip", "", "arr", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/clone_object.html", "clone_object.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "clone_object.pro", "", "", " NAME: 	clone_object    PURPOSE :   	Clones a data object by recursively descending through pointers and 	structures, creating new pontersand copying data.    CATEGORY: 	NV/UTIL    CALLING SEQUENCE :     result = clone_object(x)    ARGUMENTS   INPUT : 	x:	Object to be cloned.    OUTPUT : NONE     KEYWORDS   INPUT : NONE    OUTPUT : NONE    RETURN : 	An object identical to the input, with all new pointers.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/clone_object.html#co_recurse", "co_recurse", 'routine in <a href="util/clone_object.html">clone_object.pro</a>', "clone_object.pro", "", "co_recurse", "", "x", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/clone_object.html#clone_object", "clone_object", 'routine in <a href="util/clone_object.html">clone_object.pro</a>', "clone_object.pro", "", "clone_object", "", "x", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/sys/util/clset.html", "clset.pro", '.pro file in <a href="nv/sys/util/dir-overview.html">nv/sys/util/ directory</a>', "clset.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/sys/util/clset.html#clset", "clset", 'routine in <a href="nv/sys/util/clset.html">clset.pro</a>', "clset.pro", "", "clset", "", "foundodptag_namevalue", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/clusters.html", "clusters.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "clusters.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/clusters.html#clusters", "clusters", 'routine in <a href="util/clusters.html">clusters.pro</a>', "clusters.pro", "", "clusters", "", "pradius", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/colormap/cm_image.html", "cm_image.pro", '.pro file in <a href="util/colormap/dir-overview.html">util/colormap/ directory</a>', "cm_image.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/colormap/cm_image.html#cm_image", "cm_image", 'routine in <a href="util/colormap/cm_image.html">cm_image.pro</a>', "cm_image.pro", "", "cm_image", "", "n_colorstopbottomgammaimage", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/util/cmat_to_orient.html", "cmat_to_orient.pro", '.pro file in <a href="config/util/dir-overview.html">config/util/ directory</a>', "cmat_to_orient.pro", "", "", " NAME: 	cmat_to_orient    PURPOSE: 	xx    CATEGORY: 	UTIL    CALLING SEQUENCE: 	result = xx(xx, xx) 	xx, xx, xx    ARGUMENTS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    KEYWORDS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    RETURN: 	xx    PROCEDURE: 	The appropriate conversion routine is called based on the instrument 	field in the data desciptor.    STATUS: 	xx    SEE ALSO: 	orient_to_cmat    MODIFICATION HISTORY:  	Written by:	Spitale, 1/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/util/cmat_to_orient.html#cmat_to_orient", "cmat_to_orient", 'routine in <a href="config/util/cmat_to_orient.html">cmat_to_orient.pro</a>', "cmat_to_orient.pro", "", "cmat_to_orient", "", "ddcmat", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/gen/colgen.html", "colgen.pro", '.pro file in <a href="util/gen/dir-overview.html">util/gen/ directory</a>', "colgen.pro", "", "", " NAME: 	colgen    PURPOSE: 	Generates an array of subscripts to select only the desired column 	n-vectors from an array with dimensions nv x n x nt.   CATEGORY: 	UTIL/GEN    CALLING SEQUENCE: 	sub = colgen(nv, n, nt, w)    ARGUMENTS:   INPUT: 	nv, n, nt:	 Dimensions of array from which to select.  	w:	1-d array of nw subscripts selecting from the (nv x nt) 		column vectors.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Array (nw x n) of subscripts.    EXAMPLE: 	Define the (3 x 3 x 4) array x as follows:        	0       1       2        	0       1       2        	0       1       2         	3       4       5        	3       4       5        	3       4       5         	6       7       8        	6       7       8        	6       7       8         	9      10      11        	9      10      11        	9      10      11  	If c = colgen(3,3,4, [0,2,4,7]), then x[c] is the 4 x 3 array:        	0       2       4       7        	0       2       4       7        	0       2       4       7    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/gen/colgen.html#colgen", "colgen", 'routine in <a href="util/gen/colgen.html">colgen.pro</a>', "colgen.pro", "", "colgen", "", "nvnntw", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/coll_struct.html", "coll_struct.pro", '.pro file in <a href="config/pds/Readpds_4.4/dir-overview.html">config/pds/Readpds_4.4/ directory</a>', "coll_struct.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/coll_struct.html#coll_struct", "coll_struct", 'routine in <a href="config/pds/Readpds_4.4/coll_struct.html">coll_struct.pro</a>', "coll_struct.pro", "", "coll_struct", "", "labelobjectscount", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/collapse_array.html", "collapse_array.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "collapse_array.pro", "", "", " NAME: 	collapse_array    PURPOSE: 	Collapses an array (n,m) to an array (n,l), where l is the maximum 	number of nonzero elements in a row.  Rows with fewer nonzero elements 	are padded with zeroes.     CATEGORY: 	UTIL    CALLING SEQUENCE: 	result = xx(xx, xx) 	xx, xx, xx    ARGUMENTS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    KEYWORDS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    ENVIRONMENT VARIABLES: 	xx:	xx  	xx:	xx    RETURN: 	xx    COMMON BLOCKS: 	xx:	xx  	xx:	xx    SIDE EFFECTS: 	xx    RESTRICTIONS: 	xx    PROCEDURE: 	xx    EXAMPLE:  	The input array:  		1 0 0 1 0 1 0 		0 0 0 1 0 0 0 		0 0 0 0 0 0 0 		1 1 0 0 1 0 0  	would produce the output array:  		1 1 1 		1 0 0 		0 0 0 		1 1 1    STATUS: 	xx    SEE ALSO: 	xx, xx, xx    MODIFICATION HISTORY:  	Written by:	xx, xx/xx/xxxx   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/collapse_array.html#collapse_array", "collapse_array", 'routine in <a href="util/collapse_array.html">collapse_array.pro</a>', "collapse_array.pro", "", "collapse_array", "", "array", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/colorbar.html", "colorbar.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "colorbar.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/colorbar.html#colorbar", "colorbar", 'routine in <a href="util/colorbar.html">colorbar.pro</a>', "colorbar.pro", "", "colorbar", "", "colors", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/colormap/colormap_descriptor.html", "colormap_descriptor.pro", '.pro file in <a href="util/colormap/dir-overview.html">util/colormap/ directory</a>', "colormap_descriptor.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/colormap/colormap_descriptor.html#colormap_descriptor", "colormap_descriptor", 'routine in <a href="util/colormap/colormap_descriptor.html">colormap_descriptor.pro</a>', "colormap_descriptor.pro", "", "colormap_descriptor", "", "cmd0gammashadetopbottomn_colorsdata", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/colormap/colormap_descriptor__define.html", "colormap_descriptor__define.pro", '.pro file in <a href="util/colormap/dir-overview.html">util/colormap/ directory</a>', "colormap_descriptor__define.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/colormap/colormap_descriptor__define.html#colormap_descriptor__define", "colormap_descriptor__define", 'routine in <a href="util/colormap/colormap_descriptor__define.html">colormap_descriptor__define.pro</a>', "colormap_descriptor__define.pro", "", "colormap_descriptor__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/combine_duplicate_points.html", "combine_duplicate_points.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "combine_duplicate_points.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/combine_duplicate_points.html#combine_duplicate_points", "combine_duplicate_points", 'routine in <a href="util/combine_duplicate_points.html">combine_duplicate_points.pro</a>', "combine_duplicate_points.pro", "", "combine_duplicate_points", "", "epsilon_p", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/complement.html", "complement.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "complement.pro", "", "", " NAME:        complement    PURPOSE:        Determines the complement of an array of subscripts.    CATEGORY:        UTIL    CALLING SEQUENCE:        result = complement(array, sub)    ARGUMENTS:   INPUT:        array:  An array, to find the range of subscripts.           sub:  An array of subscripts.    OUTPUT:        NONE   RETURN:        An array of subscripts giving the complement of the input subscripts.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/complement.html#complement", "complement", 'routine in <a href="util/complement.html">complement.pro</a>', "complement.pro", "", "complement", "", "array_sub", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/compress_list.html", "compress_list.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "compress_list.pro", "", "", " NAME:        compress_list    PURPOSE:        To compress a list to n elements, removing elements with a value        of -1.    CATEGORY:        UTIL    CALLING SEQUENCE:        result = compress_list(list, n)    ARGUMENTS:   INPUT:        list:   List to compress.            n:   Size of the compressed list.    OUTPUT:        NONE   RETURN:        The resulting list contains n elements, the first of which are those        elements of list which are not -1.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/compress_list.html#compress_list", "compress_list", 'routine in <a href="util/compress_list.html">compress_list.pro</a>', "compress_list.pro", "", "compress_list", "", "listn", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/colormap/compute_colormap.html", "compute_colormap.pro", '.pro file in <a href="util/colormap/dir-overview.html">util/colormap/ directory</a>', "compute_colormap.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/colormap/compute_colormap.html#compute_colormap", "compute_colormap", 'routine in <a href="util/colormap/compute_colormap.html">compute_colormap.pro</a>', "compute_colormap.pro", "", "compute_colormap", "", "cmd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/compute_segments.html", "compute_segments.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "compute_segments.pro", "", "", " NAME: 	compute_segments    PURPOSE: 	Computes subscripts of segments in a continuous curve due to a subset of 	points being selected, or wrapping across an image.    CATEGORY: 	UTIL/    CALLING SEQUENCE: 	segments = compute_segments(p, subscripts)    ARGUMENTS:  	p:		Array of image points.  	subscripts:	Subscripts of selected points.     OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array of structures, each giving the start and stop subscripts for a 	segment.  The jth segment is addressed as:  		 segments[j].start:segments[j].stop  	Output aubscripts are relative to the input array.   STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/compute_segments.html#compute_segments", "compute_segments", 'routine in <a href="util/compute_segments.html">compute_segments.pro</a>', "compute_segments.pro", "", "compute_segments", "", "p_ii", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/consecutive.html", "consecutive.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "consecutive.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/consecutive.html#consecutive", "consecutive", 'routine in <a href="util/consecutive.html">consecutive.pro</a>', "consecutive.pro", "", "consecutive", "", "x", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/const/const_get.html", "const_get.pro", '.pro file in <a href="util/const/dir-overview.html">util/const/ directory</a>', "const_get.pro", "", "", " NAME:        const_get    PURPOSE:        Returns the values of physical constants relative to whatever system 	of units is selected.    CATEGORY:        UTIL/CONST    CALLING SEQUENCE:        result = const_get(name, units=units)    ARGUMENTS:   INPUT:        name:	String giving the name of the desired constant.    OUTPUT:        NONE    KEYWORDS:   INPUT:        units:	String giving the name of the unit system.  If not given, 		first the comomn block is checked for any unit system 		set using const_set_units.  If no unit system exists, then 		the environment variable CONST_UNITS is checked.  If still no 		unit system ecists, then it defaults to 'mks'.    OUTPUT:        NONE    ENVIRONMENT VARIABLES:        CONST_UNITS:    Selects the unit system to use if one has not been set 			using const_set_units.    RETURN:        The value of the named constant is returned relative to the selected 	unit system.    PROCEDURE: 	The name of the selected units system is taken as a prefix for 	the function <prefix>_const, which takes the name of a unit as input 	and returns the value of the selected constant.  See mks_const.pro 	for an example.    COMMON BLOCKS:        const_block:     Stores the name of the software-selected unit system.    STATUS:        Complete    SEE ALSO:        const_set_units, const_mks    MODIFICATION HISTORY:        Written by:     Spitale, 3/2006   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/const/const_get.html#const_get", "const_get", 'routine in <a href="util/const/const_get.html">const_get.pro</a>', "const_get.pro", "", "const_get", "", "unitsname", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/const/const_get_units.html", "const_get_units.pro", '.pro file in <a href="util/const/dir-overview.html">util/const/ directory</a>', "const_get_units.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/const/const_get_units.html#const_get_units", "const_get_units", 'routine in <a href="util/const/const_get_units.html">const_get_units.pro</a>', "const_get_units.pro", "", "const_get_units", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/const/const_mks.html", "const_mks.pro", '.pro file in <a href="util/const/dir-overview.html">util/const/ directory</a>', "const_mks.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/const/const_mks.html#const_mks", "const_mks", 'routine in <a href="util/const/const_mks.html">const_mks.pro</a>', "const_mks.pro", "", "const_mks", "", "name", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/const/const_set_units.html", "const_set_units.pro", '.pro file in <a href="util/const/dir-overview.html">util/const/ directory</a>', "const_set_units.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/const/const_set_units.html#const_set_units", "const_set_units", 'routine in <a href="util/const/const_set_units.html">const_set_units.pro</a>', "const_set_units.pro", "", "const_set_units", "", "units", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/construct_mosaic.html", "construct_mosaic.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "construct_mosaic.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/construct_mosaic.html#cm_combine_edge1", "cm_combine_edge1", 'routine in <a href="nv/obj/tools/construct_mosaic.html">construct_mosaic.pro</a>', "construct_mosaic.pro", "", "cm_combine_edge1", "", "mapsdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/tools/construct_mosaic.html#cm_combine_edge", "cm_combine_edge", 'routine in <a href="nv/obj/tools/construct_mosaic.html">construct_mosaic.pro</a>', "construct_mosaic.pro", "", "cm_combine_edge", "", "mapsdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/tools/construct_mosaic.html#cm_combine_emm", "cm_combine_emm", 'routine in <a href="nv/obj/tools/construct_mosaic.html">construct_mosaic.pro</a>', "construct_mosaic.pro", "", "cm_combine_emm", "", "mapsdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/tools/construct_mosaic.html#cm_combine_emm5", "cm_combine_emm5", 'routine in <a href="nv/obj/tools/construct_mosaic.html">construct_mosaic.pro</a>', "construct_mosaic.pro", "", "cm_combine_emm5", "", "mapsdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/tools/construct_mosaic.html#cm_wt_edge1", "cm_wt_edge1", 'routine in <a href="nv/obj/tools/construct_mosaic.html">construct_mosaic.pro</a>', "construct_mosaic.pro", "", "cm_wt_edge1", "", "mapsdataaux", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/tools/construct_mosaic.html#cm_wt_edge", "cm_wt_edge", 'routine in <a href="nv/obj/tools/construct_mosaic.html">construct_mosaic.pro</a>', "construct_mosaic.pro", "", "cm_wt_edge", "", "mapsdataaux", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/tools/construct_mosaic.html#cm_combine_median", "cm_combine_median", 'routine in <a href="nv/obj/tools/construct_mosaic.html">construct_mosaic.pro</a>', "construct_mosaic.pro", "", "cm_combine_median", "", "mapsdataaux", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/tools/construct_mosaic.html#cm_combine_sum", "cm_combine_sum", 'routine in <a href="nv/obj/tools/construct_mosaic.html">construct_mosaic.pro</a>', "construct_mosaic.pro", "", "cm_combine_sum", "", "mapsdataaux", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/tools/construct_mosaic.html#cm_combine_mean", "cm_combine_mean", 'routine in <a href="nv/obj/tools/construct_mosaic.html">construct_mosaic.pro</a>', "construct_mosaic.pro", "", "cm_combine_mean", "", "mapsdataaux", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/tools/construct_mosaic.html#cm_combine_overlay", "cm_combine_overlay", 'routine in <a href="nv/obj/tools/construct_mosaic.html">construct_mosaic.pro</a>', "construct_mosaic.pro", "", "cm_combine_overlay", "", "mapsdataaux", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/tools/construct_mosaic.html#cm_wt_rescale", "cm_wt_rescale", 'routine in <a href="nv/obj/tools/construct_mosaic.html">construct_mosaic.pro</a>', "construct_mosaic.pro", "", "cm_wt_rescale", "", "mapsdataaux", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/tools/construct_mosaic.html#cm_wt_emm", "cm_wt_emm", 'routine in <a href="nv/obj/tools/construct_mosaic.html">construct_mosaic.pro</a>', "construct_mosaic.pro", "", "cm_wt_emm", "", "mapsdataaux", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/tools/construct_mosaic.html#construct_mosaic", "construct_mosaic", 'routine in <a href="nv/obj/tools/construct_mosaic.html">construct_mosaic.pro</a>', "construct_mosaic.pro", "", "construct_mosaic", "", "combine_fnwt_fnsdataauxmaps", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/contiguous.html", "contiguous.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "contiguous.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/contiguous.html#ctg_separate", "ctg_separate", 'routine in <a href="util/contiguous.html">contiguous.pro</a>', "contiguous.pro", "", "ctg_separate", "", "xxiiiip", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/contiguous.html#contiguous", "contiguous", 'routine in <a href="util/contiguous.html">contiguous.pro</a>', "contiguous.pro", "", "contiguous", "", "x", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/contiguous_indices.html", "contiguous_indices.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "contiguous_indices.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/contiguous_indices.html#contiguous_indices", "contiguous_indices", 'routine in <a href="util/contiguous_indices.html">contiguous_indices.pro</a>', "contiguous_indices.pro", "", "contiguous_indices", "", "x", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/contiguous_values.html", "contiguous_values.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "contiguous_values.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/contiguous_values.html#contiguous_values", "contiguous_values", 'routine in <a href="util/contiguous_values.html">contiguous_values.pro</a>', "contiguous_values.pro", "", "contiguous_values", "", "arrayval", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/fits/conv_unix_vax.html", "conv_unix_vax.pro", '.pro file in <a href="config/fits/dir-overview.html">config/fits/ directory</a>', "conv_unix_vax.pro", "", "", " NAME: 	conv_unix_vax    PURPOSE: 	Converts Unix IDL data types to VAX IDL data types.    CATEGORY: 	UTIL/FITS    CALLING SEQUENCE: 	conv_unix_vax, variable, [ SOURCE_ARCH = SOURCE_ARCH ]    ARGUMENTS:   INPUT: 	variable:	The data variable to be converted.  This may be a scalar 			or an array.  Valid datatypes are integer, longword, 			floating point, and double precision. The result of the 			conversion is passed back in the original variable.    OUTPUT: NONE    KEYWORDS:   INPUT: 	SOURCE_ARCH:	name (string) of source architecture 			if using this function on a VAX, otherwise 			!VERSION.ARCH is used to determine the conversion. 			**If run on a VAX, the default is to assume the source 			to be a little-endian machine with IEEE floating point 			(e.g. MIPSEL or Alpha***).    OUTPUT: NONE    RETURN: NONE    RESTRICTIONS: 	Currently assumes the Unix IDL data type is IEEE standard in either 	big-endian or little-endian format.    EXAMPLE: 	Read a 100 by 100 matrix of floating point numbers from a data 	file created on a Sun.  Then convert the matrix values into 	VAX format.  	IDL> openr,1,'vax_float.dat 	IDL> data = fltarr(100,100) 	IDL> forrd,1,data 	IDL> CONV_UNIX_VAX,data,SOURCE_ARCH='sparc'    STATUS: 	Complete    SEE ALSO: 	conv_vax_unix, ieee_to_host, host_to_ieee    MODIFICATION HISTORY: 	Version 1	By John Hoegy		13-Jun-88 	04-May-90 - WTT:  Created CONV_UNIX_VAX from VAX2SUN,                          reversing floating point procedure.        Modified  P. Keegstra             September 1994            Implemented MIPSEL and ALPHA architecture,            distinguishing VMS and OSF        Modified  P. Keegstra             February 1995            Added 386 PC based architectures   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/fits/conv_unix_vax.html#CONV_UNIX_VAX", "CONV_UNIX_VAX", 'routine in <a href="config/fits/conv_unix_vax.html">conv_unix_vax.pro</a>', "conv_unix_vax.pro", "", "CONV_UNIX_VAX", "", "SOURCE_ARCHvariable", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/fits/conv_vax_unix.html", "conv_vax_unix.pro", '.pro file in <a href="config/fits/dir-overview.html">config/fits/ directory</a>', "conv_vax_unix.pro", "", "", " NAME: 	conv_vax_unix    PURPOSE: 	Converts VAX IDL data types to UNIX IDL data types.    CATEGORY: 	UTIL/FITS    CALLING SEQUENCE: 	var_unix = conv_vax_unix(var_vax, [TARGET_ARCH = TARGET_ARCH] )    ARGUMENTS:   INPUT: 	var_vax:	The data variable to be converted.  This may be a scalar 			or an array.  All IDL datatypes are valid (including 			structures).  The result of the conversion is returned 			by the function.    OUTPUT: NONE    KEYWORDS:   INPUT: 	TARGET_ARCH:	name (string) of target architecture 			if using this function on a VAX, otherwise 			!VERSION.ARCH is used to determine the conversion.    OUTPUT: NONE    RETURN: 	Converted data.    RESTRICTIONS:        The architecture  alpha  is ambiguous, since VMS alpha IDL        uses VAX D-float while OSF/1 alpha IDL uses little-endian IEEE.        The program uses !VERSION.OS to do the right thing when        converting to a representation appropriate for the current        platform.  To convert to a representation appropriate for        an OSF/1 alpha on a VAX or VMS alpha, please specify        the  mipsel  (or  i386 ) architecture.    EXAMPLE: 	Read a 100 by 100 matrix of floating point numbers from a data 	file created on a VAX.  Then convert the matrix values into Sun format.  	IDL> openr,1,'vax_float.dat' 	IDL> data = fltarr(100,100) 	IDL> forrd,1,data 	IDL> data = conv_vax_unix( data )    STATUS: 	Complete    SEE ALSO: 	conv_unix_vax, ieee_to_host, host_to_ieee    MODIFICATION HISTORY:        Written   F. Varosi               August 1990        Modified  P. Keegstra             April 1992            Implemented MIPSEL architecture        Modified  P. Keegstra             July 1994            Implemented ALPHA architecture, distinguishing VMS and OSF        Modified  P. Keegstra             February 1995            Added 386 PC based architectures        Modified  P. Keegstra             March 1995            Added note, restored and fixed old specifiers            for 386 PC based architectures 	Modified W. Landsman for VAX problems in V4.0        August 1995 	Work for double complex variables                    August 1995   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/fits/conv_vax_unix.html#conv_vax_unix", "conv_vax_unix", 'routine in <a href="config/fits/conv_vax_unix.html">conv_vax_unix.pro</a>', "conv_vax_unix.pro", "", "conv_vax_unix", "", "TARGET_ARCHvariable", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/sedr/create/convert_bcons.html", "convert_bcons.pro", '.pro file in <a href="config/sedr/create/dir-overview.html">config/sedr/create/ directory</a>', "convert_bcons.pro", "", "", " NAME: 	convert_bcons    PURPOSE: 	Create an IDL bcons file from the original VAX indexed file. 	The data are fixed length records of the form bcons, length 	165 bytes.  An index containing the planet and satellite number 	is also created.  The number is consistent with the SEDR target 	number (sat_num*10 + planet_num).   CATEGORY: 	UTIL/SEDR/CREATE    CALLING SEQUENCE: 	convert_bcons    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    PROCEDURE: 	The IDL bcons file has its float and double entries in XDR 	format and its integers in Network byte order.  The conversion 	is done by the sedr_unpack_bcons procedure.  WRITEU is used to create 	the file instead of ASSOC since the structure is byte-padded 	differently on different platforms.  The original file is called 	BODYCONST.DAT, the output files are bodyconst.dat_idl data 	file and bodyconst.dat_idx index file.    RESTRICTIONS: 	This procedure is meant to be run on a VAX computer running OpenVMS 	where the original data file was hosted.  The file is then moved 	to another platform via FTP in binary mode.    STATUS: 	Complete.    MODIFICATION HISTORY: 	Written by:    Haemmerle, 12/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/sedr/create/convert_bcons.html#convert_bcons", "convert_bcons", 'routine in <a href="config/sedr/create/convert_bcons.html">convert_bcons.pro</a>', "convert_bcons.pro", "", "convert_bcons", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/sedr/create/convert_sedr2.html", "convert_sedr2.pro", '.pro file in <a href="config/sedr/create/dir-overview.html">config/sedr/create/ directory</a>', "convert_sedr2.pro", "", "", " NAME: 	convert_sedr2    PURPOSE: 	Create an IDL sedr2 file from the original VAX indexed file. 	The data are fixed length records of the form sedr2, length 	134 bytes.  An index containing the sctime is also created.    CATEGORY: 	UTIL/SEDR/CREATE    CALLING SEQUENCE: 	convert_sedr2, planet    ARGUMENTS:   INPUT:  	planet:		String containing the central body of the sedr2 			file.  planet can be one of 'jupiter', 'saturn', 			'uranus' or 'neptune'.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    PROCEDURE: 	The IDL sedr2 file has its float and double entries in XDR 	format and its integers in Network byte order.  The conversion 	is done by the sedr_unpack_sedr2 procedure.  WRITEU is used to create 	the file instead of ASSOC since the structure is byte-padded 	differently on different platforms.  The original file is called 	'PLANET'.SDR2, the output files are 'planet'.sdr2_idl data 	file and 'planet'.sdr2_idx index file.    RESTRICTIONS: 	This procedure is meant to be run on a VAX computer running OpenVMS 	where the original data file was hosted. The file is then moved 	to another platform via FTP in binary mode.    STATUS: 	Complete.    MODIFICATION HISTORY: 	Written by:    Haemmerle, 12/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/sedr/create/convert_sedr2.html#convert_sedr2", "convert_sedr2", 'routine in <a href="config/sedr/create/convert_sedr2.html">convert_sedr2.pro</a>', "convert_sedr2.pro", "", "convert_sedr2", "", "planet", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/sedr/create/convert_sedrupd.html", "convert_sedrupd.pro", '.pro file in <a href="config/sedr/create/dir-overview.html">config/sedr/create/ directory</a>', "convert_sedrupd.pro", "", "", " NAME: 	convert_sedrupd    PURPOSE: 	Create an IDL sedrupd file from the original VAX indexed file. 	The data are fixed length records of the form sedrupd, length 	84 bytes.  An index containing the sctime is also created.    CATEGORY: 	UTIL/SEDR/CREATE    CALLING SEQUENCE: 	convert_sedrupd, planet    ARGUMENTS:   INPUT:  	planet:		String containing the central body of the sedr2 			file.  planet can be one of 'jupiter', 'saturn', 			'uranus' or 'neptune'.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    PROCEDURE: 	The IDL sedrupd file has its float and double entries in XDR 	format and its integers in Network byte order.  The conversion 	is done by the sedr_unpack_sedrupd procedure.  WRITEU is used to create 	the file instead of ASSOC since the structure is byte-padded 	differently on different platforms.  The original file is called 	'PLANET'.SDRU, the output files are 'planet'.sdru_idl data 	file and 'planet'.sdru_idx index file.    RESTRICTIONS: 	This procedure is meant to be run on a VAX computer running OpenVMS 	where the original data file was hosted.  The file is then moved 	to another platform via FTP in binary mode.    STATUS: 	Complete.    MODIFICATION HISTORY: 	Written by:    Haemmerle, 12/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/sedr/create/convert_sedrupd.html#convert_sedrupd", "convert_sedrupd", 'routine in <a href="config/sedr/create/convert_sedrupd.html">convert_sedrupd.pro</a>', "convert_sedrupd.pro", "", "convert_sedrupd", "", "planet", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/copy_overlays.html", "copy_overlays.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "copy_overlays.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/copy_overlays.html#copy_overlays", "copy_overlays", 'routine in <a href="util/copy_overlays.html">copy_overlays.pro</a>', "copy_overlays.pro", "", "copy_overlays", "", "src_pixmap", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cor/cor_abbrev.html", "cor_abbrev.pro", '.pro file in <a href="nv/obj/cor/dir-overview.html">nv/obj/cor/ directory</a>', "cor_abbrev.pro", "", "", " NAME: 	cor_abbrev    PURPOSE: 	Returns the abbrieviation for the given object class.    CATEGORY: 	NV/LIB/COR    CALLING SEQUENCE: 	abbrev = cor_abbrev(xd)    ARGUMENTS:   INPUT: 	xd:	 Descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	String giving the standard abbreviation for the given class, 	e.g., 'BOD'.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cor/cor_abbrev.html#cor_abbrev", "cor_abbrev", 'routine in <a href="nv/obj/cor/cor_abbrev.html">cor_abbrev.pro</a>', "cor_abbrev.pro", "", "cor_abbrev", "", "noeventcrd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/cor/cor_abbrev.html#_cor_abbrev", "_cor_abbrev", 'routine in <a href="nv/obj/cor/cor_abbrev.html">cor_abbrev.pro</a>', "cor_abbrev.pro", "", "_cor_abbrev", "", "xd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cor/cor_add_task.html", "cor_add_task.pro", '.pro file in <a href="nv/obj/cor/dir-overview.html">nv/obj/cor/ directory</a>', "cor_add_task.pro", "", "", " NAME: 	cor_add_task    PURPOSE: 	Adds a task to the descriptor task list.    CATEGORY: 	NV/LIB/COR    CALLING SEQUENCE: 	cor_add_task, crx, task    ARGUMENTS:   INPUT: 	crx:	 Any subclass of CORE.  Only one descriptor may be provided.  	task:	 String giving the name of a program that modified the 		 descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cor/cor_add_task.html#cor_add_task", "cor_add_task", 'routine in <a href="nv/obj/cor/cor_add_task.html">cor_add_task.pro</a>', "cor_add_task.pro", "", "cor_add_task", "", "noeventcrdtask", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cor/cor_assign.html", "cor_assign.pro", '.pro file in <a href="nv/obj/cor/dir-overview.html">nv/obj/cor/ directory</a>', "cor_assign.pro", "", "", " NAME: 	cor_assign    PURPOSE: 	Replaces fields in a POINT object.  This is a fast way of 	setting multiple fields in one call, and only a single event is 	generated.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	cor_assign, xd, <keywords>=<values>    ARGUMENTS:   INPUT: 	xd:		CORE object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	CORE fields to set.  	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	cor_set_*     MODIFICATION HISTORY:  	Written by:	Spitale		1/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cor/cor_assign.html#cor_assign", "cor_assign", 'routine in <a href="nv/obj/cor/cor_assign.html">cor_assign.pro</a>', "cor_assign.pro", "", "cor_assign", "", "noeventxd@cor__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cor/cor_cat_gd.html", "cor_cat_gd.pro", '.pro file in <a href="nv/obj/cor/dir-overview.html">nv/obj/cor/ directory</a>', "cor_cat_gd.pro", "", "", " NAME: 	cor_cat_gd    PURPOSE: 	Produces an array of object descriptors from a generic descriptor.    CATEGORY: 	NV/OBJ/COR    CALLING SEQUENCE: 	xds = cor_cat_gd(gd)    ARGUMENTS:   INPUT: 	gd:	Generic descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array of object descriptors taken from the given generic descriptors.     MODIFICATION HISTORY:  	Written by:	Spitale 	Moved to CORE	Spitale		2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cor/cor_cat_gd.html#cor_cat_gd", "cor_cat_gd", 'routine in <a href="nv/obj/cor/cor_cat_gd.html">cor_cat_gd.pro</a>', "cor_cat_gd.pro", "", "cor_cat_gd", "", "gd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cor/cor_class.html", "cor_class.pro", '.pro file in <a href="nv/obj/cor/dir-overview.html">nv/obj/cor/ directory</a>', "cor_class.pro", "", "", " NAME: 	cor_class    PURPOSE: 	Returns the class name for the given object class.    CATEGORY: 	NV/LIB/COR    CALLING SEQUENCE: 	class = cor_class(xd)    ARGUMENTS:   INPUT: 	xd:	 Descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	String giving the class name for the given class, without the OMINAS_ 	prefix.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale		4/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cor/cor_class.html#cor_class", "cor_class", 'routine in <a href="nv/obj/cor/cor_class.html">cor_class.pro</a>', "cor_class.pro", "", "cor_class", "", "xd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cor/cor_class_info.html", "cor_class_info.pro", '.pro file in <a href="nv/obj/cor/dir-overview.html">nv/obj/cor/ directory</a>', "cor_class_info.pro", "", "", " NAME: 	cor_class_info    PURPOSE: 	Returns information about OMINAS object classes.    CATEGORY: 	NV/OBJ/COR    CALLING SEQUENCE: 	cor_class_info, classes=classes, abbrev=abbrev, tags=tags    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	classes:	String array giving the names of all OMINAS classes.  	abbrev:		String array giving the abbreviations of OMINAS classes.  	tags:		String array giving the tag names of OMINAS classes.     RETURN: NONE      MODIFICATION HISTORY:  	Written by:	Spitale		2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cor/cor_class_info.html#cor_class_info", "cor_class_info", 'routine in <a href="nv/obj/cor/cor_class_info.html">cor_class_info.pro</a>', "cor_class_info.pro", "", "cor_class_info", "", "classesabbrevtags", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cor/cor_count_descriptors.html", "cor_count_descriptors.pro", '.pro file in <a href="nv/obj/cor/dir-overview.html">nv/obj/cor/ directory</a>', "cor_count_descriptors.pro", "", "", " NAME: 	cor_count_descriptors    PURPOSE: 	Determines dimensions of an array of input descriptors.    CATEGORY: 	NV/OBJ/COR    CALLING SEQUENCE: 	cor_count_descriptors, xds, nd=nd, nt=nt    ARGUMENTS:   INPUT: 	xds:		Array (nd,nt) of descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	nd:	First dimension, number of objects, default is 1.  	nt:	Second dimension, number of 'timesteps', default is 1.    RETURN: NONE     MODIFICATION HISTORY:  	Written by:	Spitale 	Copied to cor/:	Spitale 	2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cor/cor_count_descriptors.html#cor_count_descriptors", "cor_count_descriptors", 'routine in <a href="nv/obj/cor/cor_count_descriptors.html">cor_count_descriptors.pro</a>', "cor_count_descriptors.pro", "", "cor_count_descriptors", "", "ndntxds", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cor/cor_create_descriptors.html", "cor_create_descriptors.pro", '.pro file in <a href="nv/obj/cor/dir-overview.html">nv/obj/cor/ directory</a>', "cor_create_descriptors.pro", "", "", " NAME: 	cor_create_descriptors    PURPOSE: 	Init method for the CORE class.    CATEGORY: 	NV/LIB/COR    CALLING SEQUENCE: 	crd = cor_create_descriptors(n)    ARGUMENTS:   INPUT: 	n:	 Number of descriptors to create.    OUTPUT: NONE    KEYWORDS:   INPUT: 	crd:	Core descriptor(s) to initialize, instead of creating a new one.  	name:	 String giving the name of the descriptor.  	user:	 String giving the username for the descriptor.  	tasks:	 String array giving the initial task list.    OUTPUT: NONE    RETURN: 	Newly created or or freshly initialized core descriptors depending 	on the presence of the crd keyword.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cor/cor_create_descriptors.html#cor_create_descriptors", "cor_create_descriptors", 'routine in <a href="nv/obj/cor/cor_create_descriptors.html">cor_create_descriptors.pro</a>', "cor_create_descriptors.pro", "", "cor_create_descriptors", "", "crdn@cor__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cor/cor_create_gd.html", "cor_create_gd.pro", '.pro file in <a href="nv/obj/cor/dir-overview.html">nv/obj/cor/ directory</a>', "cor_create_gd.pro", "", "", " NAME: 	cor_create_gd    PURPOSE: 	Creates a generic descriptor from a set of given descriptors.    CATEGORY: 	NV/OBJ/COR    CALLING SEQUENCE: 	new_gd = cor_create_gd(xds, gd=gd, <descriptor output keywords>    ARGUMENTS:   INPUT: 	xds:	Array of descriptors.  If given, any generic descriptors 		contained within these descriptors are also included (unless 		/explicit).  A generic descriptor may also be given as the 		argument to this function.    OUTPUT: NONE    KEYWORDS:   INPUT: 	gd:	Generic descriptor.  Fields from this descriptor will be 		included in the output.  	<x>d:	Input keyword for each descriptor type to include in 		new generic descriptor.  	explicit: 		If set, generic descriptors contained in input descriptors 		are not included in the output.    OUTPUT: NONE    RETURN: 	Generic descriptor containing all of the input fields, and any 	descripors contained in gd.  Any invalid objects are culled out.     MODIFICATION HISTORY:  	Written by:	Spitale 	Moved to CORE	Spitale		2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cor/cor_create_gd.html#cor_create_gd", "cor_create_gd", 'routine in <a href="nv/obj/cor/cor_create_gd.html">cor_create_gd.pro</a>', "cor_create_gd.pro", "", "cor_create_gd", "", "gdexplicit_extra_xds", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/cor/cor_create_gd.html#___cor_create_gd", "___cor_create_gd", 'routine in <a href="nv/obj/cor/cor_create_gd.html">cor_create_gd.pro</a>', "cor_create_gd.pro", "", "___cor_create_gd", "", "gdexplicit_extra_xds", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cor/cor_cull.html", "cor_cull.pro", '.pro file in <a href="nv/obj/cor/dir-overview.html">nv/obj/cor/ directory</a>', "cor_cull.pro", "", "", " NAME: 	cor_cull    PURPOSE: 	Removes null objects from an array.    CATEGORY: 	NV/OBJ/COR    CALLING SEQUENCE: 	new_ptd = cor_cull(ptd)    ARGUMENTS:   INPUT: 	ptd:	Array of objects.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array objects, or !null if all were empty.     MODIFICATION HISTORY:   Spitale, 3/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cor/cor_cull.html#cor_cull", "cor_cull", 'routine in <a href="nv/obj/cor/cor_cull.html">cor_cull.pro</a>', "cor_cull.pro", "", "cor_cull", "", "crd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cor/cor_dereference.html", "cor_dereference.pro", '.pro file in <a href="nv/obj/cor/dir-overview.html">nv/obj/cor/ directory</a>', "cor_dereference.pro", "", "", " NAME: 	cor_dereference    PURPOSE: 	Turns an array of objects into an array of structures.    CATEGORY: 	NV/SYS/COR    CALLING SEQUENCE: 	result = cor_dereference(xd)    ARGUMENTS:   INPUT: 	xd:	Array of objects.  Objects may have different classes, but only 		their common fields are dereferenced.    OUTPUT: 	NONE    KEYWORDS: NONE    RETURN: 	Array of structures.    STATUS: 	Complete    SEE ALSO: 	cor_rereference    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2002  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cor/cor_dereference.html#cor_dereference", "cor_dereference", 'routine in <a href="nv/obj/cor/cor_dereference.html">cor_dereference.pro</a>', "cor_dereference.pro", "", "cor_dereference", "", "xd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cor/cor_dereference_gd.html", "cor_dereference_gd.pro", '.pro file in <a href="nv/obj/cor/dir-overview.html">nv/obj/cor/ directory</a>', "cor_dereference_gd.pro", "", "", " NAME: 	cor_dereference_gd    PURPOSE: 	Dereferences a generic descriptor.    CATEGORY: 	NV/PGS    CALLING SEQUENCE: 	xds = cor_dereference_gd(gd, <descriptor output keywords>)    ARGUMENTS:   INPUT: 	gd:	Generic descriptor.  	name:	If given, only descriptors whose names appear in this array 		will be returned.  If no descriptor keywords are 		speciied (see below), then all fields are searched for 		descriptors with these names.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<x>d:	Standard descriptor keywords.  Setting a keyword causes the 		corresponding field of the generic descriptor to be returned.    OUTPUT: NONE    RETURN: 	Array of descriptors or zero if no fields found.     MODIFICATION HISTORY: 	Moved to CORE	Spitale		2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cor/cor_dereference_gd.html#cor_dereference_gd", "cor_dereference_gd", 'routine in <a href="nv/obj/cor/cor_dereference_gd.html">cor_dereference_gd.pro</a>', "cor_dereference_gd.pro", "", "cor_dereference_gd", "", "name_ref_extragd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cor/cor_evolve.html", "cor_evolve.pro", '.pro file in <a href="nv/obj/cor/dir-overview.html">nv/obj/cor/ directory</a>', "cor_evolve.pro", "", "", " NAME: 	cor_evolve    PURPOSE: 	Calls the 'evolve' method appropriate for the given descriptor.    CATEGORY: 	NV/SYS/COR    CALLING SEQUENCE: 	xdt = cor_evolve(xd, dt)    ARGUMENTS:   INPUT: 	xd:	 Any subclass of BODY.  	dt:	 Time offset.    OUTPUT: NONE    KEYWORDS:   INPUT: 	nodv:	 If set, velocities will not be evolved.  	copy:	If set, the evolved descriptor is copied into the input 		descriptor and it is freed.  The input descriptor is returned.    OUTPUT: NONE    RETURN: 	Array (nxd,ndt) of newly allocated descriptors, of the same class 	as xd, evolved by time dt, where nxd is the number of xd, and ndt 	is the number of dt.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cor/cor_evolve.html#cor_evolve", "cor_evolve", 'routine in <a href="nv/obj/cor/cor_evolve.html">cor_evolve.pro</a>', "cor_evolve.pro", "", "cor_evolve", "", "nodvcopyxddt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cor/cor_gd.html", "cor_gd.pro", '.pro file in <a href="nv/obj/cor/dir-overview.html">nv/obj/cor/ directory</a>', "cor_gd.pro", "", "", " NAME: 	cor_gd    PURPOSE: 	Returns the generic descriptor for a CORE object.    CATEGORY: 	NV/PGS    CALLING SEQUENCE: 	gd = cor_gd(crd)    ARGUMENTS:   INPUT: 	crd:	Subclass of CORE.  Multiple descriptors may be given, 		but an error will result if their generic descriptors 		are incompatible.  	name:	If given, only descriptors whose names appear in this aray 		will be returned.  If no descriptor keywords are 		specified (see below), then all fields are searched for 		descriptors with these names.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<x>d:	Standard descriptor keywords.  Setting a keyword causes 		the corresponding field of the generic descriptor to be 		returned instead of the generic descriptor.  	noevent: 		If set, no event is generated.    OUTPUT: NONE     RETURN: 	Generic descriptor.     MODIFICATION HISTORY:  	Written by:	Spitale		2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cor/cor_gd.html#cor_gd", "cor_gd", 'routine in <a href="nv/obj/cor/cor_gd.html">cor_gd.pro</a>', "cor_gd.pro", "", "cor_gd", "", "namenoevent_ref_extracrd0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cor/cor_init_state.html", "cor_init_state.pro", '.pro file in <a href="nv/obj/cor/dir-overview.html">nv/obj/cor/ directory</a>', "cor_init_state.pro", "", "", " NAME: 	cor_init_state    PURPOSE: 	Initializes the CORE state structure.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	state = cor_init_state()    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	New core state structure.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale		5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cor/cor_init_state.html#cor_init_state", "cor_init_state", 'routine in <a href="nv/obj/cor/cor_init_state.html">cor_init_state.pro</a>', "cor_init_state.pro", "", "cor_init_state", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cor/cor_isa.html", "cor_isa.pro", '.pro file in <a href="nv/obj/cor/dir-overview.html">nv/obj/cor/ directory</a>', "cor_isa.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cor/cor_isa.html#cor_isa", "cor_isa", 'routine in <a href="nv/obj/cor/cor_isa.html">cor_isa.pro</a>', "cor_isa.pro", "", "cor_isa", "", "odclass", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cor/cor_match_gd.html", "cor_match_gd.pro", '.pro file in <a href="nv/obj/cor/dir-overview.html">nv/obj/cor/ directory</a>', "cor_match_gd.pro", "", "", " NAME: 	cor_match_gd    PURPOSE: 	Compares generic descriptors.    CATEGORY: 	NV/OBJ/COR    CALLING SEQUENCE: 	status = cor_match_gd(gd1, gd2)    ARGUMENTS:   INPUT: 	gd1, gd2:	Generic descriptors to compare, or object descriptors 			containing generic descriptors to compare.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	True if the generic descriptors match, false otherwise.  The 	fields in each structure do not have to be in the same order.     MODIFICATION HISTORY:  	Written by:	Spitale		2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cor/cor_match_gd.html#cmgd_compare", "cmgd_compare", 'routine in <a href="nv/obj/cor/cor_match_gd.html">cor_match_gd.pro</a>', "cor_match_gd.pro", "", "cmgd_compare", "", "gd1gd2", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/cor/cor_match_gd.html#cor_match_gd", "cor_match_gd", 'routine in <a href="nv/obj/cor/cor_match_gd.html">cor_match_gd.pro</a>', "cor_match_gd.pro", "", "cor_match_gd", "", "_gd1_gd2", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cor/cor_name.html", "cor_name.pro", '.pro file in <a href="nv/obj/cor/dir-overview.html">nv/obj/cor/ directory</a>', "cor_name.pro", "", "", " NAME: 	cor_name    PURPOSE: 	Returns the name for each given core descriptor.    CATEGORY: 	NV/LIB/COR    CALLING SEQUENCE: 	name = cor_name(crd)    ARGUMENTS:   INPUT: NONE 	crd:	 Any subclass of CORE.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Name associated with each given core descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 4/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cor/cor_name.html#cor_name", "cor_name", 'routine in <a href="nv/obj/cor/cor_name.html">cor_name.pro</a>', "cor_name.pro", "", "cor_name", "", "noeventcrd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cor/cor_query.html", "cor_query.pro", '.pro file in <a href="nv/obj/cor/dir-overview.html">nv/obj/cor/ directory</a>', "cor_query.pro", "", "", " NAME: 	cor_query    PURPOSE: 	Returns fields associated with a CORE object.  This is a 	fast way of retrieving multiple fields in one call, and only a 	single event is generated.    CATEGORY: 	NV/OBJ/COR    CALLING SEQUENCE: 	cor_query, xd, <keywords>=<values>    ARGUMENTS:   INPUT: 	xd:	CORE object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	POINT object fields to retrieve.  	noevent:	If set, no event is generated.    OUTPUT: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 1/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cor/cor_query.html#cor_query", "cor_query", 'routine in <a href="nv/obj/cor/cor_query.html">cor_query.pro</a>', "cor_query.pro", "", "cor_query", "", "noeventxd@cor__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cor/cor_replicate.html", "cor_replicate.pro", '.pro file in <a href="nv/obj/cor/dir-overview.html">nv/obj/cor/ directory</a>', "cor_replicate.pro", "", "", " NAME: 	cor_replicate    PURPOSE: 	Replicates the given descriptor, producing an array of the given 	dimensions containing cloned versions of the input descriptor.    CATEGORY: 	NV/LIB/COR    CALLING SEQUENCE: 	xd = cor_replicate(crx, dim)    ARGUMENTS:   INPUT: 	crx:	 Any subclass of CORE.  Only one descriptor may be provided.  	dim:	 Dimensions of the result.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Array of the given dimensions containing cloned versions of the input 	descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cor/cor_replicate.html#cor_replicate", "cor_replicate", 'routine in <a href="nv/obj/cor/cor_replicate.html">cor_replicate.pro</a>', "cor_replicate.pro", "", "cor_replicate", "", "crddim", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cor/cor_rereference.html", "cor_rereference.pro", '.pro file in <a href="nv/obj/cor/dir-overview.html">nv/obj/cor/ directory</a>', "cor_rereference.pro", "", "", " NAME: 	cor_rereference    PURPOSE: 	Copies an array of structures into an array of objects.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	cor_rereference, xd, _xd    ARGUMENTS:   INPUT: 	xd:	Array of objects.  	_xd:	Array of structures.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	new:	If set, new pointers will be allocated in xd.    OUTPUT: NONE    RETURN: 	NONE    STATUS: 	Complete    SEE ALSO: 	cor_dereference    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2002  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cor/cor_rereference.html#cor_rereference", "cor_rereference", 'routine in <a href="nv/obj/cor/cor_rereference.html">cor_rereference.pro</a>', "cor_rereference.pro", "", "cor_rereference", "", "newxd_xd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cor/cor_select.html", "cor_select.pro", '.pro file in <a href="nv/obj/cor/dir-overview.html">nv/obj/cor/ directory</a>', "cor_select.pro", "", "", " NAME: 	cor_select    PURPOSE: 	Selects descriptors based on given criteria.    CATEGORY: 	NV/SYS/COR    CALLING SEQUENCE: 	xd = cor_select(crx, key)    ARGUMENTS:   INPUT: 	crx:	 Array of descriptors of any subclass of CORE.  	key:	 Array of key to select.    OUTPUT: NONE    KEYWORDS:   INPUT: 	name:	Match by descriptor name.  	class:	Match by descriptor class.  	rm:	If set, the selected descriptors are removed from the 	        input array.     OUTPUT: NONE    RETURN: 	All descriptors in crx whose parameters match the given key. 	0 if no matches found.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Rewritten by:	Spitale, 4/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cor/cor_select.html#cor_select", "cor_select", 'routine in <a href="nv/obj/cor/cor_select.html">cor_select.pro</a>', "cor_select.pro", "", "cor_select", "", "indicesrmnoeventnameclasscrxkey", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cor/cor_set_field.html", "cor_set_field.pro", '.pro file in <a href="nv/obj/cor/dir-overview.html">nv/obj/cor/ directory</a>', "cor_set_field.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cor/cor_set_field.html#cor_set_field", "cor_set_field", 'routine in <a href="nv/obj/cor/cor_set_field.html">cor_set_field.pro</a>', "cor_set_field.pro", "", "cor_set_field", "", "foundnoeventodptag_namevalue", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cor/cor_set_gd.html", "cor_set_gd.pro", '.pro file in <a href="nv/obj/cor/dir-overview.html">nv/obj/cor/ directory</a>', "cor_set_gd.pro", "", "", " NAME: 	cor_set_gd    PURPOSE: 	Sets the generic descriptor in a CORE object.    CATEGORY: 	NV/OBJ/COR    CALLING SEQUENCE: 	cor_set_gd, crd, gd    ARGUMENTS:   INPUT: 	crd:		CORE object.  The fields from any existing generic 			descriptor in this object are retained in the new one. 			Only one object allowed.  	gd:		New gd.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<x>d:		Input keyword for each descriptor type.  	xds:		Array of objects to put in generic descriptor.  Generic 			descriptors in these objects are considered as well.  	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	cor_gd     MODIFICATION HISTORY:  	Written by:	Spitale		2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cor/cor_set_gd.html#cor_set_gd", "cor_set_gd", 'routine in <a href="nv/obj/cor/cor_set_gd.html">cor_set_gd.pro</a>', "cor_set_gd.pro", "", "cor_set_gd", "", "xdsnoeventdirect_ref_extracrd0gd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cor/cor_set_name.html", "cor_set_name.pro", '.pro file in <a href="nv/obj/cor/dir-overview.html">nv/obj/cor/ directory</a>', "cor_set_name.pro", "", "", " NAME: 	cor_set_name    PURPOSE: 	Replaces the name for each given core descriptor.    CATEGORY: 	NV/LIB/COR    CALLING SEQUENCE: 	cor_set_name, crx, name    ARGUMENTS:   INPUT: NONE 	crx:	 Any subclass of CORE.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cor/cor_set_name.html#cor_set_name", "cor_set_name", 'routine in <a href="nv/obj/cor/cor_set_name.html">cor_set_name.pro</a>', "cor_set_name.pro", "", "cor_set_name", "", "noeventcrdname", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cor/cor_set_udata.html", "cor_set_udata.pro", '.pro file in <a href="nv/obj/cor/dir-overview.html">nv/obj/cor/ directory</a>', "cor_set_udata.pro", "", "", " NAME: 	cor_set_udata    PURPOSE: 	Stores user data in a descriptor and associates it with the 	specified name. If multiple descriptors, then the trailing dimension 	must match the number of descriptors.    CATEGORY: 	NV/LIB/COR    CALLING SEQUENCE: 	cor_set_udata, crx, name, data    ARGUMENTS:   INPUT: 	crx:	 Any subclass of CORE.  Only one descriptor may be provided.  	name:	 Name to associate with the data.  If the name already exists, 		 then the data is overwritten.  	data:	 Data to store.  If multiple crx supplied, then the trailing 		 dimension must match the number of descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cor/cor_set_udata.html#cor_set_udata", "cor_set_udata", 'routine in <a href="nv/obj/cor/cor_set_udata.html">cor_set_udata.pro</a>', "cor_set_udata.pro", "", "cor_set_udata", "", "noeventcrdnameudata", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cor/cor_state.html", "cor_state.pro", '.pro file in <a href="nv/obj/cor/dir-overview.html">nv/obj/cor/ directory</a>', "cor_state.pro", "", "", " NAME: 	cor_state    PURPOSE: 	Builds a class tree for the given descriptor.    CATEGORY: 	NV/LIB/COR    CALLING SEQUENCE: 	cor_state, <options>    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: 	trace:	New value for the trace flag.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale		5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cor/cor_state.html#cor_state", "cor_state", 'routine in <a href="nv/obj/cor/cor_state.html">cor_state.pro</a>', "cor_state.pro", "", "cor_state", "", "trace", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cor/cor_tag.html", "cor_tag.pro", '.pro file in <a href="nv/obj/cor/dir-overview.html">nv/obj/cor/ directory</a>', "cor_tag.pro", "", "", " NAME: 	cor_tag    PURPOSE: 	Returns the tag name for the given object class.    CATEGORY: 	NV/OBJ/COR    CALLING SEQUENCE: 	tag = cor_tag(xd)    ARGUMENTS:   INPUT: 	xd:	 Descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: 	x:	If set, the generic form is returned, e.g, 'CRX'.    OUTPUT: NONE    RETURN: 	String giving the standard tag for the given class, e.g., 'CRD'.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cor/cor_tag.html#cor_tag", "cor_tag", 'routine in <a href="nv/obj/cor/cor_tag.html">cor_tag.pro</a>', "cor_tag.pro", "", "cor_tag", "", "xnoeventcrd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cor/cor_tasks.html", "cor_tasks.pro", '.pro file in <a href="nv/obj/cor/dir-overview.html">nv/obj/cor/ directory</a>', "cor_tasks.pro", "", "", " NAME: 	cor_tasks    PURPOSE: 	Returns the descriptor task list.    CATEGORY: 	NV/LIB/COR    CALLING SEQUENCE: 	tasks = cor_tasks(crx)    ARGUMENTS:   INPUT: 	crx:	 Any subclass of CORE.  Only one descriptor may be provided.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	String array containing the list of all programs that have modified 	the given descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cor/cor_tasks.html#cor_tasks", "cor_tasks", 'routine in <a href="nv/obj/cor/cor_tasks.html">cor_tasks.pro</a>', "cor_tasks.pro", "", "cor_tasks", "", "noeventcrd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cor/cor_test.html", "cor_test.pro", '.pro file in <a href="nv/obj/cor/dir-overview.html">nv/obj/cor/ directory</a>', "cor_test.pro", "", "", " NAME: 	cor_test    PURPOSE: 	Tests whether the input is an OMINAS object or object structure.    CATEGORY: 	NV/OBJ/COR    CALLING SEQUENCE: 	data = cor_test(xd)    ARGUMENTS:   INPUT: 	xd:	 Any subclass of CORE.  Only one descriptor may be provided.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	True if xd is an OMINAS object or object structure, false otherwise.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cor/cor_test.html#cor_test", "cor_test", 'routine in <a href="nv/obj/cor/cor_test.html">cor_test.pro</a>', "cor_test.pro", "", "cor_test", "", "noeventxd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cor/cor_test_gd.html", "cor_test_gd.pro", '.pro file in <a href="nv/obj/cor/dir-overview.html">nv/obj/cor/ directory</a>', "cor_test_gd.pro", "", "", " NAME: 	cor_test_gd    PURPOSE: 	Tests whether a generic descriptor field exists and contains a 	descriptor.    CATEGORY: 	NV/OBJ/COR    CALLING SEQUENCE: 	data = cor_test_gd(gd, tag)    ARGUMENTS:   INPUT: 	gd:	 Generic descriptor.  	tag:	 Name of field to test.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	True if gd contains the tag and it is a valid descriptor, false otherwise.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cor/cor_test_gd.html#cor_test_gd", "cor_test_gd", 'routine in <a href="nv/obj/cor/cor_test_gd.html">cor_test_gd.pro</a>', "cor_test_gd.pro", "", "cor_test_gd", "", "gdtag", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cor/cor_test_udata.html", "cor_test_udata.pro", '.pro file in <a href="nv/obj/cor/dir-overview.html">nv/obj/cor/ directory</a>', "cor_test_udata.pro", "", "", " NAME: 	cor_test_udata    PURPOSE: 	Tests the existence of data stored in a descriptor under the 	specified name.    CATEGORY: 	NV/LIB/COR    CALLING SEQUENCE: 	data = cor_test_udata(crx, name)    ARGUMENTS:   INPUT: 	crx:	 Any subclass of CORE.  Only one descriptor may be provided.  	name:	 Name associated with the data to test.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	True if the data is stored under the given name, false otherwise.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cor/cor_test_udata.html#cor_test_udata", "cor_test_udata", 'routine in <a href="nv/obj/cor/cor_test_udata.html">cor_test_udata.pro</a>', "cor_test_udata.pro", "", "cor_test_udata", "", "noeventcrdname", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cor/cor_tree.html", "cor_tree.pro", '.pro file in <a href="nv/obj/cor/dir-overview.html">nv/obj/cor/ directory</a>', "cor_tree.pro", "", "", " NAME: 	cor_tree    PURPOSE: 	Builds a class tree for the given descriptor.    CATEGORY: 	NV/SYS/COR    CALLING SEQUENCE: 	classes = cor_tree(od)    ARGUMENTS:   INPUT: 	od:	 Descriptor of any class.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	String array giving the names of all classes in od, in descending order.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cor/cor_tree.html#cor_tree", "cor_tree", 'routine in <a href="nv/obj/cor/cor_tree.html">cor_tree.pro</a>', "cor_tree.pro", "", "cor_tree", "", "od", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cor/cor_udata.html", "cor_udata.pro", '.pro file in <a href="nv/obj/cor/dir-overview.html">nv/obj/cor/ directory</a>', "cor_udata.pro", "", "", " NAME: 	cor_udata    PURPOSE: 	Retrieves user data stored in a descriptor under the specified name.    CATEGORY: 	NV/LIB/COR    CALLING SEQUENCE: 	data = cor_udata(crx, name)    ARGUMENTS:   INPUT: 	crx:	 Any subclass of CORE.  If multiple crx are provided, then 		 the trailing dimension represents each each descriptor.  	name:	 Name associated with the data.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Data associated with the given name.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cor/cor_udata.html#cor_udata", "cor_udata", 'routine in <a href="nv/obj/cor/cor_udata.html">cor_udata.pro</a>', "cor_udata.pro", "", "cor_udata", "", "noeventcrdname", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cor/cor_user.html", "cor_user.pro", '.pro file in <a href="nv/obj/cor/dir-overview.html">nv/obj/cor/ directory</a>', "cor_user.pro", "", "", " NAME: 	cor_user    PURPOSE: 	Returns the username for each given core descriptor.    CATEGORY: 	NV/LIB/COR    CALLING SEQUENCE: 	user = cor_user(crx)    ARGUMENTS:   INPUT: NONE 	crx:	 Any subclass of CORE.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Username associated with each given core descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cor/cor_user.html#cor_user", "cor_user", 'routine in <a href="nv/obj/cor/cor_user.html">cor_user.pro</a>', "cor_user.pro", "", "cor_user", "", "noeventcrd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cor/core_state_struct__define.html", "core_state_struct__define.pro", '.pro file in <a href="nv/obj/cor/dir-overview.html">nv/obj/cor/ directory</a>', "core_state_struct__define.pro", "", "", " NAME: 	core_state_struct__define    PURPOSE: 	Structure defining the CORE state.    CATEGORY: 	NV/LIB/COR    CALLING SEQUENCE: 	N/A    FIELDS: 	trace:		Specifies whether trace information is printed 			or object routines.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cor/core_state_struct__define.html#core_state_struct__define", "core_state_struct__define", 'routine in <a href="nv/obj/cor/core_state_struct__define.html">core_state_struct__define.pro</a>', "core_state_struct__define.pro", "", "core_state_struct__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/corot_to_disk.html", "corot_to_disk.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "corot_to_disk.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/corot_to_disk.html#corot_to_disk", "corot_to_disk", 'routine in <a href="nv/obj/tools/corot_to_disk.html">corot_to_disk.pro</a>', "corot_to_disk.pro", "", "corot_to_disk", "", "cddkxgbxt0dmldttimescorot_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/corot_to_disk_lon.html", "corot_to_disk_lon.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "corot_to_disk_lon.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/corot_to_disk_lon.html#corot_to_disk_lon", "corot_to_disk_lon", 'routine in <a href="nv/obj/tools/corot_to_disk_lon.html">corot_to_disk_lon.pro</a>', "corot_to_disk_lon.pro", "", "corot_to_disk_lon", "", "cddkxgbxt0dmldttimescorot_lons", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/correlate_images.html", "correlate_images.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "correlate_images.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/correlate_images.html#cim_variance", "cim_variance", 'routine in <a href="util/correlate_images.html">correlate_images.pro</a>', "correlate_images.pro", "", "cim_variance", "", "im0im", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/correlate_images.html#cim_ccorr", "cim_ccorr", 'routine in <a href="util/correlate_images.html">correlate_images.pro</a>', "correlate_images.pro", "", "cim_ccorr", "", "im0im", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/correlate_images.html#correlate_images", "correlate_images", 'routine in <a href="util/correlate_images.html">correlate_images.pro</a>', "correlate_images.pro", "", "correlate_images", "", "fnsize_im0_im", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/correlate_pairs.html", "correlate_pairs.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "correlate_pairs.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/correlate_pairs.html#correlate_pairs", "correlate_pairs", 'routine in <a href="util/correlate_pairs.html">correlate_pairs.pro</a>', "correlate_pairs.pro", "", "correlate_pairs", "", "complementmm_pairsradius", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/correlate_points.html", "correlate_points.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "correlate_points.pro", "", "", " NAME: 	correlate_points    PURPOSE: 	Searches for offset dxy that translates a set of model points so as 	to obtain the maximum correlation with a set of base points.    CATEGORY: 	UTIL    CALLING SEQUENCE: 	result = correlate_points(base_pts, model_pts)    ARGUMENTS:   INPUT: 	base_pts:	Array (2,nbase) of points to remain stationary.  	model_pts:	Array (2,nmodel) of points to be offset.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	bin:		Initial point density bin size.  Default is 100.  See 			procedure below.  	nsamples:	Number of samples in each direction in the grid search. 			See image_correlate.  	show:		If set, the grid search is displayed.  See 			image_correlate.  	xsize,ysize:	Dimensions of image from which points were extracted.  	max_density:	Maximum model point density.  Default = 5.    OUTPUT: 	NONE    RETURN: 	2-element array giving the offset [dx,dy] that shifts the model points 	so as to obtain the maxmimum correlation between the two sets of points.    PROCEDURE: 	The points are fit by using image_correlate to align point-density maps 	of the two arrays of points using a successively smaller bin size, 	starting with that given by the 'bin' keyword.  The search grid is 	narrowed as the bin size is reduced.  The procedure is repeated until 	the bin size falls below one pixel.    STATUS: 	Complete, but simulated annealing might be a better approach in some 	cases.    MODIFICATION HISTORY:  	Written by:	Spitale, 4/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/correlate_points.html#correlate_points", "correlate_points", 'routine in <a href="util/correlate_points.html">correlate_points.pro</a>', "correlate_points.pro", "", "correlate_points", "", "nsamplesshowxsizeysizebinmax_densityregionsigma_xsigma_yccmccbiasnosearchbase_pts_model_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/correlate_scan.html", "correlate_scan.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "correlate_scan.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/correlate_scan.html#correlate_scan", "correlate_scan", 'routine in <a href="util/correlate_scan.html">correlate_scan.pro</a>', "correlate_scan.pro", "", "correlate_scan", "", "scan1scan2sample", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/counter.html", "counter.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "counter.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/counter.html#counter", "counter", 'routine in <a href="util/counter.html">counter.pro</a>', "counter.pro", "", "counter", "", "resetprint", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/covariance.html", "covariance.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "covariance.pro", "", "", " NAME: 	covariance    PURPOSE: 	Computes a covariance matrix for the problem specified by the input 	matrix.    CATEGORY: 	UTIL/ICV    CALLING SEQUENCE: 	result = covariance(M)    ARGUMENTS:   INPUT: 	M:	Array (3,3,n) of coefficient matrices as computed by 		icv_coeff or ipt_coeff, as input to mbfit.  Coefficients from 		the two sources may be mixed.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	status:	0 is successful, -1 otherwise.    RETURN: 	Covariance matrix.    MODIFICATION HISTORY:  	Written by:	Spitale, 9/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/covariance.html#covariance", "covariance", 'routine in <a href="util/covariance.html">covariance.pro</a>', "covariance.pro", "", "covariance", "", "statusM", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/cr_correlation.html", "cr_correlation.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "cr_correlation.pro", "", "", " cr_correlation   PURPOSE : `   Computes the cross correlation function:                       /             R(t) =  | f(x) g(x+t) dx                     /   of f and g as a funtion of t.    f and g may be 1, 2, 3, or 4 dimensional, but they must  be of the same size and dimension.  g is shifted and wrapped  by t pixels and then the integration is performed.    CALLING SEQUENCE :    eta = cr_correlation(f, g, t)    ARGUMENTS   INPUT : f - reference function; 1, 2, 3, or 4 dimensional array.            g - function to be shifted, must be of same dimension as f            t - shift vector.    OUTPUT : NONE     KEYWORDS   INPUT : NONE    OUTPUT : NONE     RETURN : the cross correlation value; see PURPOSE above.     RESTRICTIONS:     PROCEDURES USED: NONE     KNOWN BUGS : NONE     ORIGINAL AUTHOR : J. Spitale ; 8/94   UPDATE HISTORY :   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/cr_correlation.html#cr_correlation", "cr_correlation", 'routine in <a href="util/cr_correlation.html">cr_correlation.pro</a>', "cr_correlation.pro", "", "cr_correlation", "", "normalizefgt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/create_struct_scalar.html", "create_struct_scalar.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "create_struct_scalar.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/create_struct_scalar.html#create_struct_scalar", "create_struct_scalar", 'routine in <a href="util/create_struct_scalar.html">create_struct_scalar.pro</a>', "create_struct_scalar.pro", "", "create_struct_scalar", "", "tagsvalues", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/cross_compare.html", "cross_compare.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "cross_compare.pro", "", "", " NAME:        cross_compare    PURPOSE:        To cross compare two lists generating two sets of indicies which        cross compare their elements.    CATEGORY:        UTIL    CALLING SEQUENCE:        cross_compare, list1, list2, indices1=indices1, indices2=indices2    ARGUMENTS:   INPUT:        list1:  First list.         list2:  Second list.    OUTPUT: 	NONE   KEYWORDS:   INPUT: 	NONE    OUTPUT:     indices1:  Each element of indices1 gives the index of the list2                element which matches that element of list1, or -1.      indices2:  visa verse as above but with list1    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/cross_compare.html#cross_compare", "cross_compare", 'routine in <a href="util/cross_compare.html">cross_compare.pro</a>', "cross_compare.pro", "", "cross_compare", "", "indices1indices2list1list2", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/cross_correlate_2d.html", "cross_correlate_2d.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "cross_correlate_2d.pro", "", "", " NAME:        cross_correlate_2d    PURPOSE:        Calculates the correlation coefficient between an image and        a model.    CATEGORY:        UTIL    CALLING SEQUENCE:        result = c_correlate_2d(image, model)    ARGUMENTS:   INPUT:        image:  Two dimensional image.         model:  The model to correlelate with the image (sm[1] x sm[2])    OUTPUT:        NONE   KEYWORDS:   INPUT:        NONE    OUTPUT:        sigma:  The sigma of the image in a box of size sm[1] x sm[2]                around each point          mean:  The mean of the image in a box of size sm[1] x sm[2]                around each point    RETURN:        The array of correlation coefficients.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/cross_correlate_2d.html#cross_correlate_2d", "cross_correlate_2d", 'routine in <a href="util/cross_correlate_2d.html">cross_correlate_2d.pro</a>', "cross_correlate_2d.pro", "", "cross_correlate_2d", "", "sigmameanimagemodel", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/ct/ctblack.html", "ctblack.pro", '.pro file in <a href="util/ct/dir-overview.html">util/ct/ directory</a>', "ctblack.pro", "", "", " NAME:        ctblack   PURPOSE:        To allocate/return the color black.    CATEGORY:        UTIL/CT    CALLING SEQUENCE:        return = ctblack()   RETURN:        The lookup table or true color value for black   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/ct/ctblack.html#ctblack", "ctblack", 'routine in <a href="util/ct/ctblack.html">ctblack.pro</a>', "ctblack.pro", "", "ctblack", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/ct/ctblue.html", "ctblue.pro", '.pro file in <a href="util/ct/dir-overview.html">util/ct/ directory</a>', "ctblue.pro", "", "", " NAME:        ctblue   PURPOSE:        To allocate/return the color blue.    CATEGORY:        UTIL/CT    CALLING SEQUENCE:        return = ctblue()   RETURN:        The lookup table or true color value for blue   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/ct/ctblue.html#ctblue", "ctblue", 'routine in <a href="util/ct/ctblue.html">ctblue.pro</a>', "ctblue.pro", "", "ctblue", "", "frac", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/ct/ctbrown.html", "ctbrown.pro", '.pro file in <a href="util/ct/dir-overview.html">util/ct/ directory</a>', "ctbrown.pro", "", "", " NAME: 	ctbrown   PURPOSE: 	To allocate/return the color brown.    CATEGORY:        UTIL/CT    CALLING SEQUENCE: 	return = ctbrown()   RETURN: 	The lookup table or true color value for cyan   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/ct/ctbrown.html#ctbrown", "ctbrown", 'routine in <a href="util/ct/ctbrown.html">ctbrown.pro</a>', "ctbrown.pro", "", "ctbrown", "", "frac", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/ct/ctcolor.html", "ctcolor.pro", '.pro file in <a href="util/ct/dir-overview.html">util/ct/ directory</a>', "ctcolor.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/ct/ctcolor.html#ctcolor", "ctcolor", 'routine in <a href="util/ct/ctcolor.html">ctcolor.pro</a>', "ctcolor.pro", "", "ctcolor", "", "_colorshade", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/ct/ctcolor.html#___ctcolor", "___ctcolor", 'routine in <a href="util/ct/ctcolor.html">ctcolor.pro</a>', "ctcolor.pro", "", "___ctcolor", "", "colorshade", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/ct/ctcyan.html", "ctcyan.pro", '.pro file in <a href="util/ct/dir-overview.html">util/ct/ directory</a>', "ctcyan.pro", "", "", " NAME: 	ctcyan   PURPOSE: 	To allocate/return the color cyan.    CATEGORY:        UTIL/CT    CALLING SEQUENCE: 	return = ctcyan()   RETURN: 	The lookup table or true color value for cyan   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/ct/ctcyan.html#ctcyan", "ctcyan", 'routine in <a href="util/ct/ctcyan.html">ctcyan.pro</a>', "ctcyan.pro", "", "ctcyan", "", "frac", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/ct/ctgray.html", "ctgray.pro", '.pro file in <a href="util/ct/dir-overview.html">util/ct/ directory</a>', "ctgray.pro", "", "", " NAME: 	ctgray   PURPOSE:        Allocate/return a gray level.    CATEGORY:        UTIL/CT    CALLING SEQUENCE:        return = ctgray(frac)   RETURN:        The lookup table or true color value for the specified gray level.   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/ct/ctgray.html#ctgray", "ctgray", 'routine in <a href="util/ct/ctgray.html">ctgray.pro</a>', "ctgray.pro", "", "ctgray", "", "frac", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/ct/ctgreen.html", "ctgreen.pro", '.pro file in <a href="util/ct/dir-overview.html">util/ct/ directory</a>', "ctgreen.pro", "", "", " NAME:        ctgreen   PURPOSE:        To allocate/return the color green.    CATEGORY:        UTIL/CT    CALLING SEQUENCE:        return = ctgreen()   RETURN:        The lookup table or true color value for green   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/ct/ctgreen.html#ctgreen", "ctgreen", 'routine in <a href="util/ct/ctgreen.html">ctgreen.pro</a>', "ctgreen.pro", "", "ctgreen", "", "frac", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/ct/ctlookup.html", "ctlookup.pro", '.pro file in <a href="util/ct/dir-overview.html">util/ct/ directory</a>', "ctlookup.pro", "", "", " NAME:        ctlookup   PURPOSE:        Returns a string giving the name of a color corresponding to a 	given color index.    CATEGORY:        UTIL/CT    CALLING SEQUENCE:        result = ctlookup(color)   ARGUMENTS:   INPUT:        color:	Color index to lookup.    OUTPUT:     NONE    RETURN: 	String giving the color name or '' if not found.   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/ct/ctlookup.html#ctlookup", "ctlookup", 'routine in <a href="util/ct/ctlookup.html">ctlookup.pro</a>', "ctlookup.pro", "", "ctlookup", "", "color", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/ct/ctmod.html", "ctmod.pro", '.pro file in <a href="util/ct/dir-overview.html">util/ct/ directory</a>', "ctmod.pro", "", "", " NAME:        ctmod   PURPOSE:        To get display visual type (8 or 24 bit) and reserve a number of        colors for overlay plotting in the lookup table (for 8 bit).    CATEGORY:        UTIL/CT    CALLING SEQUENCE:        cdmod, visual=visual, top=top  ARGUMENTS:   INPUT:        NONE    OUTPUT:     visual:  Number of planes in idl image device.         top:  New top of lookup table available to image display.     SIDE EFFECTS: 	The system variable !ct_top is set to the value of the 'top' output 	above.   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/ct/ctmod.html#ctmod", "ctmod", 'routine in <a href="util/ct/ctmod.html">ctmod.pro</a>', "ctmod.pro", "", "ctmod", "", "visualtopbwcolorct_r_g_b", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/ct/ctorange.html", "ctorange.pro", '.pro file in <a href="util/ct/dir-overview.html">util/ct/ directory</a>', "ctorange.pro", "", "", " NAME: 	ctorange   PURPOSE: 	To allocate/return the color orange.    CATEGORY:        UTIL/CT    CALLING SEQUENCE: 	return = ctorange()   RETURN: 	The lookup table or true color value for cyan   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/ct/ctorange.html#ctorange", "ctorange", 'routine in <a href="util/ct/ctorange.html">ctorange.pro</a>', "ctorange.pro", "", "ctorange", "", "frac", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/ct/ctpink.html", "ctpink.pro", '.pro file in <a href="util/ct/dir-overview.html">util/ct/ directory</a>', "ctpink.pro", "", "", " NAME: 	ctpink   PURPOSE: 	To allocate/return the color pink.    CATEGORY:        UTIL/CT    CALLING SEQUENCE: 	return = ctpink()   RETURN: 	The lookup table or true color value for cyan   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/ct/ctpink.html#ctpink", "ctpink", 'routine in <a href="util/ct/ctpink.html">ctpink.pro</a>', "ctpink.pro", "", "ctpink", "", "frac", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/ct/ctpurple.html", "ctpurple.pro", '.pro file in <a href="util/ct/dir-overview.html">util/ct/ directory</a>', "ctpurple.pro", "", "", " NAME:        ctpurple   PURPOSE:        To allocate/return the color purple.    CATEGORY:        UTIL/CT    CALLING SEQUENCE:        return = ctpurple()   RETURN:        The lookup table or true color value for purple   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/ct/ctpurple.html#ctpurple", "ctpurple", 'routine in <a href="util/ct/ctpurple.html">ctpurple.pro</a>', "ctpurple.pro", "", "ctpurple", "", "frac", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/ct/ctred.html", "ctred.pro", '.pro file in <a href="util/ct/dir-overview.html">util/ct/ directory</a>', "ctred.pro", "", "", " NAME:        ctred   PURPOSE:        To allocate/return the color red.    CATEGORY:        UTIL/CT    CALLING SEQUENCE:        return = ctred()   RETURN:        The lookup table or true color value for red   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/ct/ctred.html#ctred", "ctred", 'routine in <a href="util/ct/ctred.html">ctred.pro</a>', "ctred.pro", "", "ctred", "", "frac", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/ct/ctuser.html", "ctuser.pro", '.pro file in <a href="util/ct/dir-overview.html">util/ct/ directory</a>', "ctuser.pro", "", "", " NAME:        ctuser   PURPOSE:        Returns a user color that was allocated using ctmod.    CATEGORY:        UTIL/CT    CALLING SEQUENCE:        return = ctuser()   RETURN:        The lookup table or true color value for the user color with index i.   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/ct/ctuser.html#ctuser", "ctuser", 'routine in <a href="util/ct/ctuser.html">ctuser.pro</a>', "ctuser.pro", "", "ctuser", "", "i", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/ct/ctwhite.html", "ctwhite.pro", '.pro file in <a href="util/ct/dir-overview.html">util/ct/ directory</a>', "ctwhite.pro", "", "", " NAME:        ctwhite   PURPOSE:        To allocate/return the color white.    CATEGORY:        UTIL/CT    CALLING SEQUENCE:        return = ctwhite()   RETURN:        The lookup table or true color value for white   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/ct/ctwhite.html#ctwhite", "ctwhite", 'routine in <a href="util/ct/ctwhite.html">ctwhite.pro</a>', "ctwhite.pro", "", "ctwhite", "", "frac", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/ct/ctyellow.html", "ctyellow.pro", '.pro file in <a href="util/ct/dir-overview.html">util/ct/ directory</a>', "ctyellow.pro", "", "", " NAME:        ctyellow   PURPOSE:        To allocate/return the color yellow.    CATEGORY:        UTIL/CT    CALLING SEQUENCE:        return = ctyellow()   RETURN:        The lookup table or true color value for yellow   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/ct/ctyellow.html#ctyellow", "ctyellow", 'routine in <a href="util/ct/ctyellow.html">ctyellow.pro</a>', "ctyellow.pro", "", "ctyellow", "", "frac", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/cursor_move.html", "cursor_move.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "cursor_move.pro", "", "", " NAME:        cursor_move    PURPOSE:        Moves an array of points by using the cursor and then to output        the change from the original position when finished.  In moving        the cursor, the mouse buttons control the motion:  LEFT to translate,        MIDDLE to rotate, RIGHT to accept.    CATEGORY:        UTIL    CALLING SEQUENCE:        cursor_move, cx, cy, xpoints, ypoints, sub_xpoints, sub_ypoints, $                         dx=dx, dy=dy, dtheta=dtheta    ARGUMENTS:   INPUT:             cx:        x position of center of rotation.              cy:        y position of center of rotation.         xpoints:        x positions of array of points to display         ypoints:         y positions of  rray of points to display     sub_xpoints:        Sub-sampled x points to display.     sub_ypoints:        Sub-sampled y points to display.    KEYWORDS:        symbol:          symbol to use for marking points, default is period        star_sub:	If given, these subscripts (into the sub-sampled arrays) 			determine points that should be plotted using 			star_symbol.    OUTPUT:             dx:        Change in x in pixels.              dy:        Change in y in pixels.          dtheta:        Change in rotation angle in radians.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/cursor_move.html#cm_plots", "cm_plots", 'routine in <a href="util/cursor_move.html">cursor_move.pro</a>', "cursor_move.pro", "", "cm_plots", "", "colorcurve_symstar_symdatapsizefn_dataxpointsypointsstar_sub", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/cursor_move.html#cursor_move", "cursor_move", 'routine in <a href="util/cursor_move.html">cursor_move.pro</a>', "cursor_move.pro", "", "cursor_move", "", "wnumdxdydthetasymbolcolorstar_symbolstar_subxor_graphicspsizedrawfndatacxcyxpointsypointssub_xpointssub_ypoints", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/curve_rectify.html", "curve_rectify.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "curve_rectify.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/curve_rectify.html#curve_rectify", "curve_rectify", 'routine in <a href="util/curve_rectify.html">curve_rectify.pro</a>', "curve_rectify.pro", "", "curve_rectify", "", "subp", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/curve_rectify.html#___curve_rectify", "___curve_rectify", 'routine in <a href="util/curve_rectify.html">curve_rectify.pro</a>', "curve_rectify.pro", "", "___curve_rectify", "", "subp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/cw__form.html", "cw__form.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "cw__form.pro", "", "", " NAME: 	CW__FORM   PURPOSE: 	CW__FORM is a compound widget that simplifies creating 	small forms which contain text, numeric fields, buttons, 	lists and droplists.  Event handling is also simplified.   CATEGORY: 	Compound widgets.   CALLING SEQUENCE: 	widget = CW__FORM([Parent,] Desc)   INPUTS:        Parent:	The ID of the parent widget.  Omitted for a top level 		modal widget.  Desc: A string array describing the form.  Each element of the 	string array contains two or more comma-delimited fields.  The 	character '\' may be used to escape commas that appear within fields. 	To include the backslash character, escape it with a second 	backslash.  Field names are case insensitive.  	The fields are defined as follows:   Field 1: Depth: the digit 0, 1, 2, or 3.  0 continues the current 	level, 1 begins a new level, 2 denotes the last element of the 	current level, and 3 both begins a new level and is the last entry of 	the current level.  Nesting is used primarily with row or column 	bases for layout.  See the example below.  Field 2: Item type: BASE, BUTTON, DROPLIST, FLOAT, INTEGER, LABEL, LIST, 		or TEXT. 	The items return the following value types: 	BUTTON - For single buttons, 0 if clear, 1 if set. 		For multiple buttons, also called button groups, that are 		exclusive, the index of the currently set button is returned. 		For non-exclusive button groups, the value is an array 		with an element for each button, containing 1 		if the button is set, 0 otherwise. 	DROPLIST, LIST - a 0 based index indicating which item is selected. 	FLOAT, INTEGER, TEXT - return their respective data type.   Field 3: Initial value.  Omitted for bases. 	For BUTTON and DROPLIST items, the value field contains one 		or more item names, delimited by the | character. 	For FLOAT, INTEGER, LABEL, and TEXT items the value field contains the 		initial value of the field.   Fields 4 and following: Keywords or Keyword=value pairs that specify 	optional attributes or options.  Keywords are case insensitive 	and an optional leading '/' character is discarded. 	Possibilities include:  	COLUMN	If present, specifies column layout for bases or multiple 		buttons. 	EXCLUSIVE  If present makes an exclusive set of buttons.  The 		default is nonexclusive. 	EVENT=<name> specifies the name of a user-written event function that 		is called whenever the element is changed.  The function 		is called with one parameter, the event structure.  It may 		return an event structure or zero to indicate that no 		further event processing is desired. 	FONT=<font name>  If present, the font for the item is specified. 	FRAME:	If present, a frame is drawn around the item.  May be used 		with all items. 	LABEL_LEFT=<label>  annotate a button or button group with a label 		placed to the left of the buttons.  Valid with BUTTON, 		DROPLIST, FLOAT, INTEGER, LIST and TEXT items. 	LABEL_TOP=<label> annotate a button or button group with a label 		placed at the top of the buttons.  Valid with BUTTON, 		DROPLIST, FLOAT, INTEGER, LIST and TEXT items. 	LEFT, CENTER, or RIGHT   Specifies alignment of label items. 	QUIT	If present, when the user activiates this entry when it 		is activated as a modal widget, the form is destroyed 		and its value returned as the result of CW__FORM.  For non- 		modal form widgets, events generated by changing this item 		have their QUIT field set to 1. 	ROW	If present, specifies row layout for bases or multiple 		buttons. 	SCROLL:	If present, the base will have a scrollbar. 	SET_VALUE  Sets the initial value of button groups or droplists. 	TAG=<name>   the tag name  of this element.  The widget's value 		is a structure corresponding to the form.  Each form item 		has a corresponding tag-value pair in the widget's value. 		Default = TAGnnn, where nnn is the index of the item 		in the Desc array. 	WIDTH=n Specifies the width, in characters, of a TEXT, INTEGER, 		or FLOAT item. 	ALL_EVENTS Determines whether all events or just end-of-line events 	           are generated for TEXT, INTEGER, or FLOAT items.   KEYWORD PARAMETERS: 	COLUMN:		  If set the main orientation is vertical, otherwise 			  horizontal. 	IDS:		  A named variable into which the widget id of 				each widget corresponding to an element 				in desc is stored. 	tags:		  A named variable into which the structure tag of 				each widget corresponding to an element 				in desc is stored. 	TITLE:		  The title of the top level base.  Not used 			  if a parent widget is supplied. 	UVALUE:		  The user value to be associated with the widget.        UNAME:            The user name to be associated with the widget.   OUTPUTS:        If Parent is supplied, the result is the ID of the base containing 	the form.  If Parent is omitted, the form is realized as a modal 	top level widget. The function result is then a structure containing 	the value of each field in the form when the user finishes.  	This widget has a value that is a structure with a tag/value pair 	for each field in the form.  WIDGET_CONTROL, id, GET_VALUE=v may 	be used to read the current value of the form.  WIDGET_CONTROL, id, 	SET_VALUE={ Tagname: value, ..., Tagname: value} sets the values 	of one or more tags.   SIDE EFFECTS: 	Widgets are created.   RESTRICTIONS:   EXAMPLES: 	**** Define a form, with a label, followed by two vertical button 	groups one non-exclusive and the other exclusive, followed by a text 	field, and an integer field, followed lastly by OK and Done buttons. 	If either the OK or Done buttons are pressed, the form is exited.   		; String array describing the form 	desc = [ $ 	    '0, LABEL, Centered Label, CENTER', $ 		; Define a row base on a new depth.  All elements until a depth 		; of two are included in the row.  	    '1, BASE,, ROW, FRAME', $  	    '0, BUTTON, B1|B2|B3, LABEL_TOP=Nonexclusive:, COLUMN, ' + $                'TAG=bg1, ' + $                'SET_VALUE=[1\, 0\, 1]', $   ; set first and third buttons 		; This element terminates the row.  	    '2, BUTTON, E1|E2|E2, EXCLUSIVE,LABEL_TOP=Exclusive,COLUMN, ' + $                'TAG=bg2, ' + $                'SET_VALUE=1', $   ; set second button  	    '0, TEXT, , LABEL_LEFT=Enter File name:, WIDTH=12, TAG=fname', $ 	    '0, INTEGER, 0, LABEL_LEFT=File size:, WIDTH=6, TAG=fsize', $ 	    '1, BASE,, ROW', $ 	    '0, BUTTON, OK, QUIT,FONT=*helvetica-medium-r-*-180-*,TAG=OK', $ 	    '2, BUTTON, Cancel, QUIT']      To use the form in a modal manner: 	  a = CW__FORM(desc, /COLUMN) 	  help, /st,a     When the form is exited, (when the user presses the OK or Cancel buttons), 	the following structure is returned as the function's value: 		BG1             INT       Array(3)  (Set buttons = 1, else 0) 		BG2             INT              1  (Exclusive: a single index) 		FNAME           STRING    'test.dat' (text field) 		FSIZE           LONG               120 (integer field) 		OK              LONG                 1 (this button was pressed) 		TAG8            LONG                 0 (this button wasn't) 	Note that if the Cancel button is pressed, the widget is exited with 	the OK field set to 0.    *****************      To use CW__FORM inside another widget: 	    a = widget_base(title='Testing') 	    b = cw__form(a, desc, /COLUMN) 	    WIDGET_CONTROL, a, /real 	    xmanager, 'Test', a 	In this example, an event is generated each time the value of 	the form is changed.  The event has the following structure: 	   ID              LONG                <id of CW__FORM widget> 	   TOP             LONG                <id of top-level widget> 	   HANDLER         LONG                <internal use> 	   TAG             STRING    'xxx'	; name of field that changed 	   VALUE           INT       xxx	; new value of changed field 	   QUIT            INT              0	; quit flag     The event handling procedure (in this example, called TEST_EVENT), may use 	the TAG field of the event structure to determine which field 	changed and perform any data validation or special actions required. 	It can also get and set the value of the widget by calling 	WIDGET_CONTROL.     A simple event procedure might be written to monitor the QUIT field 	of events from the forms widget, and if set, read and save the 	widget's value, and finally destroy the widget.      To set or change a field within the form from a program, use a the 	WIDGET_CONTROL procedure: 	   	WIDGET_CONTROL, b, SET_VALUE={FNAME: 'junk.dat'} 	This statement sets the file name field of this example.   MODIFICATION HISTORY: 	January, 1995.  DMS, Written.        June, 1996.     MLR, allowed SET_VALUE to be specified in the                        description string for DROPLIST widgets. 	July, 2002.	Spitale, copied from cw_form. 	July, 2002.	Spitale, added 'tags' keyword. 	July, 2002.	Spitale, added 'all_events' keyword. 	July, 2002.	Spitale, noted lameness of 'goto' statement in 			cw__form_build 	Dec., 2002.	Spitale, added 'TAG' keyword functionality for bases 			and labels. 	Dec., 2002.	Spitale, added 'SCROLL' keyword for bases.   NOTICES: 	Portions 2017 Exelis Visual Information Solutions, Inc., provided 	under license to the Jet Propulsion Laboratory. THE EXELIS VISUAL 	INFORMATION SOLUTIONS, INC. CODE IS PROVIDED  AS IS  AND ANY EXPRESS 	OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 	WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 	ARE DISCLAIMED. IN NO EVENT SHALL EXELIS VISUAL INFORMATION SOLUTIONS, 	INC., ITS AFFILIATES, OFFICERS, DIRECTORS, EMPLOYEES, AGENTS, SUPPLIERS 	OR LICENSORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 	EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 	PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 	PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 	OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING 	NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 	SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/cw__form.html#CW__FORM_PARSE", "CW__FORM_PARSE", 'routine in <a href="util/cw__form.html">cw__form.pro</a>', "cw__form.pro", "", "CW__FORM_PARSE", "", "IndexExtraNameValue", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/cw__form.html#CW__FORM_APPEND", "CW__FORM_APPEND", 'routine in <a href="util/cw__form.html">cw__form.pro</a>', "cw__form.pro", "", "CW__FORM_APPEND", "", "USE_VALUEACTUAL_KEYWORDextraekeyword", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/cw__form.html#CW__FORM_LABEL", "CW__FORM_LABEL", 'routine in <a href="util/cw__form.html">cw__form.pro</a>', "cw__form.pro", "", "CW__FORM_LABEL", "", "parentnparenteframe", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/cw__form.html#CW__FORM_BUILD", "CW__FORM_BUILD", 'routine in <a href="util/cw__form.html">cw__form.pro</a>', "cw__form.pro", "", "CW__FORM_BUILD", "", "parentdesccuridstagslasttag", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/cw__form.html#CW__FORM_EVENT", "CW__FORM_EVENT", 'routine in <a href="util/cw__form.html">cw__form.pro</a>', "cw__form.pro", "", "CW__FORM_EVENT", "", "ev", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/cw__form.html#CW__FORM_SETV", "CW__FORM_SETV", 'routine in <a href="util/cw__form.html">cw__form.pro</a>', "cw__form.pro", "", "CW__FORM_SETV", "", "idvalue", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/cw__form.html#CW__FORM_GETV", "CW__FORM_GETV", 'routine in <a href="util/cw__form.html">cw__form.pro</a>', "cw__form.pro", "", "CW__FORM_GETV", "", "id", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/cw__form.html#cw__form_modal_event", "cw__form_modal_event", 'routine in <a href="util/cw__form.html">cw__form.pro</a>', "cw__form.pro", "", "cw__form_modal_event", "", "ev", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/cw__form.html#CW__FORM", "CW__FORM", 'routine in <a href="util/cw__form.html">cw__form.pro</a>', "cw__form.pro", "", "CW__FORM", "", "COLUMNIDSTITLEUVALUEUNAMEtagsparentdesc", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/cw__pdmenu.html", "cw__pdmenu.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "cw__pdmenu.pro", "", "", " NAME: 	CW__PDMENU   PURPOSE: 	CW__PDMENU is a compound widget that simplifies creating 	pulldown menus. It has a simpler interface than the XPDMENU 	procedure, which it is intended to replace. Events for the 	individual buttons are handled transparently, and a CW__PDMENU 	event returned. This event can return any one of the following:                - The Index of the button within the base.                - The widget ID of the button.                - The name of the button. 		- The fully qualified name of the button. This allows 		  different sub-menus to contain buttons with the same 		  name in an unambiguous way.  	In this modified program, cw__pdmenu, the name given for the event 	handler for each button widget is used as the X resource anme as well.     CATEGORY: 	Compound widgets.   CALLING SEQUENCE: 	widget = CW__PDMENU(Parent, Desc)   INPUTS:        Parent:	The ID of the parent widget. 	Desc:	An array of strings or structures.  Each element contains 		a menu description with two fields, a flag field, and 		the name of the item.  If a structure, each element 		is defined as follows: 			{ CW__PDMENU_S, flags:0, name:'' }  		The name tag gives the name of button. The flags 		field is a two-bit bitmask that controls how the button is 		interpreted:  		    Value	   Meaning 		    ------------------------------------------- 		     0     This button is neither the beginning 			   nor the end of a pulldown level. 		     1     This button is the root of a                           sub-pulldown menu. The sub-buttons 			   start with the next button. 		     2     This button is the last button at the 			   current pulldown level. The next button 			   belongs to the same level as the current 			   parent button. 			   If none or empty string is specified as a 			   the name, the button is not created, but 			   the next button belongs to the upward level. 		     3     This button is the root of a sub-pulldown 			   menu, but it is also the last entry of 			   the current level. 		     4     Same as 0, above, except that this button will 			   be preceeded by a separator as with the SEPARATOR 			   keyword to WIDGET_BUTTON. 		     5     Same as 1, above, except that this button will 			   be preceeded by a separator. 		     6     Same as 2, above, except that this button will 			   be preceeded by a separator. 		     7     Same as 3, above, except that this button will 			   be preceeded by a separator.  	If Desc is a string, each element contains the flag field 	followed by a backslash character, followed by the menu item's 	contents.  See the example below.  	EVENT PROCEDURES:  An event procedure may be specified for an 	element and all its children, by including a third field 	in Desc, if Desc is a string array.  Events for buttons without 	an event procedure, are dispatched normally. 	See the example below.   KEYWORD PARAMETERS: 	DELIMITER:        The character used to separate the parts of a 			  fully qualified name in returned events. The 			  default is to use the '.' character. 	FONT:		  The name of the font to be used for the button 			  titles. If this keyword is not specified, the 			  default font is used. 	HELP:		  If MBAR is specified and one of the buttons on the 			  menubar has the label  help  (case insensitive) then 			  that button is created with the /HELP keyword to 			  give it any special appearance it is supposed to 			  have on a menubar. For example, Motif expects 			  help buttons to be on the right. 	IDS:		  A named variable into which the button IDs will 			  be stored as a longword vector. 	MBAR:		  if constructing a menu-bar pulldown, set this 			  keyword.  In this case, the parent must be the 			  widget id of the menu bar of a top-level base, 			  returned by WIDGET_BASE(..., MBAR=mbar). 	RETURN_ID:	  If present and non-zero, the VALUE field of returned 			  events will be the widget ID of the button. 	RETURN_INDEX:	  If present and non-zero, the VALUE field of returned 			  events will be the zero-based index of the button 			  within the base. THIS IS THE DEFAULT. 	RETURN_NAME:	  If present and non-zero, the VALUE field of returned 			  events will be the name of the selected button. 	RETURN_FULL_NAME: If present and non-zero, the VALUE field of returned                	  events will be the fully qualified name of the 			  selected button. This means that the names of all 			  the buttons from the topmost button of the pulldown 			  menu to the selected one are concatenated with the 			  delimiter specified by the DELIMITER keyword. For 			  example, if the top button was named COLORS, the 			  second level button was named BLUE, and the selected 			  button was named LIGHT, the returned value would be  			  COLORS.BLUE.LIGHT  			  This allows different submenus to have buttons with 			  the same name (e.g. COLORS.RED.LIGHT). 	UVALUE:		  The user value to be associated with the widget.        UNAME:            The user name to be associated with the widget. 	XOFFSET:	  The X offset of the widget relative to its parent. 	YOFFSET:	  The Y offset of the widget relative to its parent.   OUTPUTS:        The ID of the top level button is returned.   SIDE EFFECTS: 	This widget generates event structures with the following definition:  		event = { ID:0L, TOP:0L, HANDLER:0L, VALUE:0 }  	VALUE is either the INDEX, ID, NAME, or FULL_NAME of the button, 	depending on how the widget was created.   RESTRICTIONS: 	Only buttons with textual names are handled by this widget. 	Bitmaps are not understood.   EXAMPLE: 	The following is the description of a menu bar with two buttons, 	 Colors  and  Quit . Colors is a pulldown containing the colors 	 Red ,  Green , Blue ,  Cyan , and  Magenta . Blue is a sub-pulldown 	containing  Light ,  Medium ,  Dark ,  Navy , and  Royal :  		; Make sure CW__PDMENU_S is defined 		junk = { CW__PDMENU_S, flags:0, name:'' }  		; The description 		desc = [ { CW__PDMENU_S, 1, 'Colors' }, $ 			     { CW__PDMENU_S, 0, 'Red' }, $ 			     { CW__PDMENU_S, 0, 'Green' }, $ 			     { CW__PDMENU_S, 5, 'Blue\BLUE_EVENT_PROC' }, $ 			         { CW__PDMENU_S, 0, 'Light' }, $ 			         { CW__PDMENU_S, 0, 'Medium' }, $ 			         { CW__PDMENU_S, 0, 'Dark' }, $ 			         { CW__PDMENU_S, 0, 'Navy' }, $ 			         { CW__PDMENU_S, 2, 'Royal' }, $ 			       { CW__PDMENU_S, 4, 'Cyan' }, $ 			       { CW__PDMENU_S, 2, 'Magenta\MAGENTA_EVENT_PROC' }, $ 			 { CW__PDMENU_S, 2, 'Quit' } ]  	The same menu may be defined as a string by equating the Desc parameter 	to the following string array:  	desc =[ '1\Colors' , $ 		'0\Red' , $ 		'0\Green' , $ 		'5\Blue\BLUE_EVENT_PROC' , $ 		'0\Light' , $ 		'0\Medium' , $ 		'0\Dark' , $ 		'0\Navy' , $ 		'2\Royal' , $ 		'4\Cyan' , $ 		'2\Magenta\MAGENTA_EVENT_PROC' , $ 		'2\Quit'  ]   	The following small program can be used with the above description 	to create the specified menu:   		base = widget_base() 		menu = cw__pdmenu(base, desc, /RETURN_FULL_NAME) 		WIDGET_CONTROL, /REALIZE, base 		repeat begin 		  ev = WIDGET_EVENT(base) 		  print, ev.value 		end until ev.value eq 'Quit' 		WIDGET_CONTROL, /DESTROY, base 		end  	Note that independent event procedures were specified for 	the multiple Blue buttons (blue_event_proc), and the Magenta button 	(magenta_event_proc).  MODIFICATION HISTORY: 	18 June 1992, AB 	16 Jan 1995, DMS, Added MBAR keyword, event procedures, 			and menu descriptor strings. 	2 July 1995, AB, Added HELP keyword. 	3 September 1996, LP, Added button-less end of current level 	May 2004, JNS, Renamed cw__pdmenu and added X resource names.   NOTICES: 	Portions 2017 Exelis Visual Information Solutions, Inc., provided 	under license to the Jet Propulsion Laboratory. THE EXELIS VISUAL 	INFORMATION SOLUTIONS, INC. CODE IS PROVIDED  AS IS  AND ANY EXPRESS 	OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 	WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 	ARE DISCLAIMED. IN NO EVENT SHALL EXELIS VISUAL INFORMATION SOLUTIONS, 	INC., ITS AFFILIATES, OFFICERS, DIRECTORS, EMPLOYEES, AGENTS, SUPPLIERS 	OR LICENSORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 	EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 	PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 	PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 	OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING 	NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 	SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/cw__pdmenu.html#CW__PDMENU_EVENT", "CW__PDMENU_EVENT", 'routine in <a href="util/cw__pdmenu.html">cw__pdmenu.pro</a>', "cw__pdmenu.pro", "", "CW__PDMENU_EVENT", "", "ev", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/cw__pdmenu.html#cw__pdmenu_event_capture", "cw__pdmenu_event_capture", 'routine in <a href="util/cw__pdmenu.html">cw__pdmenu.pro</a>', "cw__pdmenu.pro", "", "cw__pdmenu_event_capture", "", "ev", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/cw__pdmenu.html#CW__PDMENU_BUILD", "CW__PDMENU_BUILD", 'routine in <a href="util/cw__pdmenu.html">cw__pdmenu.pro</a>', "cw__pdmenu.pro", "", "CW__PDMENU_BUILD", "", "FONTcaptureparentdesccurnev_typefull_qual_strdelimidsmbarsHELP_KWuname", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/cw__pdmenu.html#CW__PDMENU", "CW__PDMENU", 'routine in <a href="util/cw__pdmenu.html">cw__pdmenu.pro</a>', "cw__pdmenu.pro", "", "CW__PDMENU", "", "COLUMNDELIMITERFONTIDSMBARHELPRETURN_IDRETURN_INDEXRETURN_NAMERETURN_FULL_NAMEUVALUEXOFFSETYOFFSETUNAMEcaptureparentdesc", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/d_undefined.html", "d_undefined.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "d_undefined.pro", "", "", " NAME:        d_undefined    PURPOSE:        Output the largest usable double floating value.    CATEGORY:        UTIL    CALLING SEQUENCE:        result = d_undefined()    ARGUMENTS:        NONE   RETURN:        The largest usable double floating value.   PROCEDURE:        Calls the idl function machar which determines machine-specific        parameters effecting floating-point arithmatic.  Uses the        field XMAX.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/d_undefined.html#d_undefined", "d_undefined", 'routine in <a href="util/d_undefined.html">d_undefined.pro</a>', "d_undefined.pro", "", "d_undefined", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_add_transient_keyvals.html", "dat_add_transient_keyvals.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_add_transient_keyvals.pro", "", "", " NAME: 	dat_add_transient_keyvals    PURPOSE: 	Records keyword/value pairs from a transient argument string.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_add_transient_keyvals, dd, trs    ARGUMENTS:   INPUT: 	dd:	Data descriptor in which to record transient keyvals.  	trs:	Transient argument string.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_add_transient_keyvals.html#dat_add_transient_keyvals", "dat_add_transient_keyvals", 'routine in <a href="nv/obj/dat/dat_add_transient_keyvals.html">dat_add_transient_keyvals.pro</a>', "dat_add_transient_keyvals.pro", "", "dat_add_transient_keyvals", "", "_ddtrs", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_assign.html", "dat_assign.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_assign.pro", "", "", " NAME: 	dat_assign    PURPOSE: 	Replaces fields in a CAMERA object.  This is a convenient way of 	setting multiple fields in one call, and only a single event is 	generated.    CATEGORY: 	NV/OBJ/CAM    CALLING SEQUENCE: 	dat_assign, cd, <keywords>=<values>    ARGUMENTS:   INPUT: 	cd:		CAMERA object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	CAMERA fields to set.  	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	dat_set_*     MODIFICATION HISTORY:  	Written by:	Spitale		2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_assign.html#dat_assign", "dat_assign", 'routine in <a href="nv/obj/dat/dat_assign.html">dat_assign.pro</a>', "dat_assign.pro", "", "dat_assign", "", "noeventxd@dat__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_cache.html", "dat_cache.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_cache.pro", "", "", " NAME: 	dat_cache    PURPOSE: 	Returns a long integer indicating the maximum size of a data array. 	This value may be adjusted using the environment variable 'DAT_CACHE'. 	-1 is returned if it cannot be determined.    CATEGORY: 	NV/OBJ/DAT    CALLING SEQUENCE: 	cache = dat_cache()    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: NONE     OUTPUT: NONE    ENVIRONMENT VARIABLES: 	DAT_CACHE:	Sets the size of the cache.    RETURN: 	Current cache value.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_cache.html#dat_cache", "dat_cache", 'routine in <a href="nv/obj/dat/dat_cache.html">dat_cache.pro</a>', "dat_cache.pro", "", "dat_cache", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_compress.html", "dat_compress.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_compress.pro", "", "", " NAME: 	dat_compress    PURPOSE: 	Returns the compression function suffix associated with a data 	descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	suffix = dat_compress(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	String giving the compression suffix.  The full name 	of the compression function is dat_compress_data_<suffix>.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_compress.html#dat_compress", "dat_compress", 'routine in <a href="nv/obj/dat/dat_compress.html">dat_compress.pro</a>', "dat_compress.pro", "", "dat_compress", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_compress_data_mask.html", "dat_compress_data_mask.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_compress_data_mask.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_compress_data_mask.html#dat_compress_data_mask", "dat_compress_data_mask", 'routine in <a href="nv/obj/dat/dat_compress_data_mask.html">dat_compress_data_mask.pro</a>', "dat_compress_data_mask.pro", "", "dat_compress_data_mask", "", "_dd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_create_descriptors.html", "dat_create_descriptors.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_create_descriptors.pro", "", "", " NAME: 	dat_create_descriptors    PURPOSE: 	Creates and initializes a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dd = dat_create_descriptors(n)    ARGUMENTS:   INPUT: 	n:	 Number of descriptors to create.    OUTPUT: NONE    KEYWORDS:   INPUT: 	filename:	Name of data file.  	dim:		Array giving the dimensions of the data array.  	typecode:	Integer giving the type code of the data array.  	data:		Data array.  	nhist:		Number of past version of the data array to archive. 			If not given, the environment variable NV_NHIST is 			used.  If that is not set, then nhist defaults to 1.  	header:		Header array.  	filetype:	Filetype identifier string.  If not given 			an attempt is made to detect it.  	input_fn:	Name of function to read data file.  	output_fn:	Name of function to write data file.  	keyword_fn:	Name of function to read/write header keywords.  	instrument:	Instrument string.  If not given an 			attempt is made to detect it.  	input_transforms:	String array giving the names of the 				input transforms.  	output_transforms:	String array giving the names of the 				output transforms.  	maintain:	Data maintenance mode.  	compress:	Compression suffix.     OUTPUT: NONE 	input_translators:	String array giving the names of the 				input translators.  	output_translators:	String array giving the names of the 				output translators.     RETURN: 	Newly created and initialized data descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_create_descriptors.html#dat_create_descriptors", "dat_create_descriptors", 'routine in <a href="nv/obj/dat/dat_create_descriptors.html">dat_create_descriptors.pro</a>', "dat_create_descriptors.pro", "", "dat_create_descriptors", "", "crdddn@dat__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_data.html", "dat_data.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_data.pro", "", "", " NAME: 	dat_data    PURPOSE: 	Returns the data array associated with a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	data = dat_data(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: 	samples:  Sampling indices.  If set, only these data elements are 		  returned.  May be 1D or the same number of dimensions as 		  the data array.  	slice:	  Slice coordinates.  	current:  If set, the current loaded samples are returned.  In this 		  case, the sample indices are returned in the  samples  		  keyword.  	nd:       If set, the samples input is taken to be an ND coordinate 	          rather than a 1D subscript.  dat_data can normally tell 	          the difference automatically, but there is an ambiguity 	          if a single ND point is requested.  In that case, dat_data 	          interprets that as an array of 1D subscripts, unless /nd 	          is set.  	true:     If set, the actual data array is returned, even if there is 	          a sampling function.    OUTPUT: 	abscissa: The abscissa is returned in this array.  	samples:  Output sample indices for /current.    RETURN: 	The data array associated with the data descriptor.    STATUS: 	Complete    SEE ALSO: 	dat_set_data    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_data.html#dat_data", "dat_data", 'routine in <a href="nv/obj/dat/dat_data.html">dat_data.pro</a>', "dat_data.pro", "", "dat_data", "", "samplescurrentslicendtruenoeventabscissadd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_detect_filetype.html", "dat_detect_filetype.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_detect_filetype.pro", "", "", " NAME: 	dat_detect_filetype    PURPOSE: 	Attempts to detect the type of the given file by calling the 	detectors in the filetype detectors table.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	filetype = dat_detect_filetype(dd)    ARGUMENTS:   INPUT: 	dd:		Data descriptor containing filename to test.    OUTPUT: NONE    KEYWORDS:   INPUT: 	default:	If set, the 'default' filetype is returned. 			The default filetype is the first item in the table 			whose action is not 'IGNORE'.  	all:	If set, all filetypes in the table are returned.    OUTPUT: NONE    RETURN: 	String giving the filetype, or null string if none detected.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_detect_filetype.html#dat_detect_filetype", "dat_detect_filetype", 'routine in <a href="nv/obj/dat/dat_detect_filetype.html">dat_detect_filetype.pro</a>', "dat_detect_filetype.pro", "", "dat_detect_filetype", "", "defaultallactiondd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_detect_instrument.html", "dat_detect_instrument.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_detect_instrument.pro", "", "", " NAME: 	dat_detect_instrument    PURPOSE: 	Attempts to detect the instrument for a data set by calling the 	detectors in the instrument detectors table.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	instrument = dat_detect_instrument(dd)    ARGUMENTS:   INPUT: 	dd:		Data descriptor containing header an filetype.  	filetype:	Filetype from dat_detect_filetype.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	String giving the instrument, or 'DEFAULT' if none detected.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_detect_instrument.html#dat_detect_instrument", "dat_detect_instrument", 'routine in <a href="nv/obj/dat/dat_detect_instrument.html">dat_detect_instrument.pro</a>', "dat_detect_instrument.pro", "", "dat_detect_instrument", "", "dd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_dh.html", "dat_dh.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_dh.pro", "", "", " NAME: 	dat_dh    PURPOSE: 	Returns the maintenance value associated with a data descriptor.    CATEGORY: 	NV/OBJ/DAT    CALLING SEQUENCE: 	data = dat_dh(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	The maintenance value associated with the data descriptor.    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 7/2008  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_dh.html#dat_dh", "dat_dh", 'routine in <a href="nv/obj/dat/dat_dh.html">dat_dh.pro</a>', "dat_dh.pro", "", "dat_dh", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_dim.html", "dat_dim.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_dim.pro", "", "", " NAME: 	dat_dim    PURPOSE: 	Returns the dimensions of the data array in the given data 	descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dim = dat_dim(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: 	true:	If set, the dimension function is not called and the true 	 	dimensions of the dat are returned.    OUTPUT: NONE    RETURN: 	Array giving the dimensions of the data in the data descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_dim.html#dat_dim", "dat_dim", 'routine in <a href="nv/obj/dat/dat_dim.html">dat_dim.pro</a>', "dat_dim.pro", "", "dat_dim", "", "truenoeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_dim_data.html", "dat_dim_data.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_dim_data.pro", "", "", " NAME: 	dat_dim_data    PURPOSE: 	Returns the dimension function associated with a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dim_data = dat_dim_data(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	The dim_data associated with the data descriptor.    STATUS: 	Complete    SEE ALSO: 	dat_set_dim_data    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_dim_data.html#dat_dim_data", "dat_dim_data", 'routine in <a href="nv/obj/dat/dat_dim_data.html">dat_dim_data.pro</a>', "dat_dim_data.pro", "", "dat_dim_data", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_dim_fn.html", "dat_dim_fn.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_dim_fn.pro", "", "", " NAME: 	dat_dim_fn    PURPOSE: 	Returns the dimension function associated with a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dim_fn = dat_dim_fn(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	The dim_fn associated with the data descriptor.    STATUS: 	Complete    SEE ALSO: 	dat_set_dim_fn    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_dim_fn.html#dat_dim_fn", "dat_dim_fn", 'routine in <a href="nv/obj/dat/dat_dim_fn.html">dat_dim_fn.pro</a>', "dat_dim_fn.pro", "", "dat_dim_fn", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_filename.html", "dat_filename.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_filename.pro", "", "", " NAME: 	dat_filename    PURPOSE: 	Returns the file name associated with a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	filename = dat_filename(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	String giving the filename.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 12/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_filename.html#dat_filename", "dat_filename", 'routine in <a href="nv/obj/dat/dat_filename.html">dat_filename.pro</a>', "dat_filename.pro", "", "dat_filename", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_filetype.html", "dat_filetype.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_filetype.pro", "", "", " NAME: 	dat_filetype    PURPOSE: 	Returns the filetype associated with a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	filetype = dat_filetype(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	String giving the filetype.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_filetype.html#dat_filetype", "dat_filetype", 'routine in <a href="nv/obj/dat/dat_filetype.html">dat_filetype.pro</a>', "dat_filetype.pro", "", "dat_filetype", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_gd.html", "dat_gd.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_gd.pro", "", "", " NAME: 	dat_gd    PURPOSE: 	Dereferences a given generic descriptor, or the generic descriptor 	contained in a data descriptor.  Similar to cor_gd, but data 	descriptors are handled specially.    CATEGORY: 	NV/OBJ/DAT    CALLING SEQUENCE: 	xd = dat_gd(gd, <descriptor keywords>)    ARGUMENTS:   INPUT: 	gd:	Generic descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: 	dd:	Data descriptor.  If gd is undefined, the generic descriptor 		contained in this data descriptor is used instead.  If this 		keyword is set (i.e., /dd), then it is treated like the 		other descriptor keywords and a data desctipro is returned 		if one exists in the generic descriptor.  	<x>d:	Standard descriptor keywords.  Setting a keyword causes the 		corresponding field of the generic descriptor to be returned 		in the output array.    OUTPUT: NONE    RETURN: Array of descriptors corresponding to the selected keywords.     MODIFICATION HISTORY:  	Written by:	Spitale		2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_gd.html#dat_gd", "dat_gd", 'routine in <a href="nv/obj/dat/dat_gd.html">dat_gd.pro</a>', "dat_gd.pro", "", "dat_gd", "", "dd_ref_extra_gd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_get_value.html", "dat_get_value.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_get_value.pro", "", "", " NAME: 	dat_get_value    PURPOSE: 	Calls input translators, supplying the given keyword, and builds 	a list of returned descriptors.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	xds = dat_get_value(dd, keyword)    ARGUMENTS:   INPUT: 	dd:		Data descriptors.  Must all have the same instrument 			string.  	keyword:	Keyword to pass to translators, describing the 			requested quantity.    OUTPUT: NONE    KEYWORDS:   INPUT: 	trs:		Transient argument string.  	tr_disable:	If set, dat_get_value returns without performing 			any action.  	tr_override:	Comma-delimited list of translators to use instead 			of those stored in dd.  	tr_first:	If set, dat_get_value returns after the first 			successful translator.  	tr_nosort:	By default, output descriptors are sorted to remove 			those with duplicate names, retaining only the first 			descriptor of a given name for each input data 			descriptor.  /tr_nosort disables this action.  	tr_order:	If set (and tr_nosort not set), dat_get_value selects 			the latest of any duplicately named output descriptors 			instead of the earliest.     OUTPUT: 	status:		0 if at least one translator call was successful, 			-1 otherwise.    RETURN: 	Array of descriptors returned from all successful translator calls. 	Descriptors are returned in the same order that the corresponding 	translators were called.  Each translator may produce multiple 	descriptors.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_get_value.html#dat_get_value", "dat_get_value", 'routine in <a href="nv/obj/dat/dat_get_value.html">dat_get_value.pro</a>', "dat_get_value.pro", "", "dat_get_value", "", "statustrsddkeyword@nv_trs_keywords_include.pro", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_gff.html", "dat_gff.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_gff.pro", "", "", " NAME: 	dat_gff    PURPOSE: 	Returns the maintenance value associated with a data descriptor.    CATEGORY: 	NV/OBJ/DAT    CALLING SEQUENCE: 	data = dat_gff(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	The maintenance value associated with the data descriptor.    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 7/2008  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_gff.html#dat_gff", "dat_gff", 'routine in <a href="nv/obj/dat/dat_gff.html">dat_gff.pro</a>', "dat_gff.pro", "", "dat_gff", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_header.html", "dat_header.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_header.pro", "", "", " NAME: 	dat_header    PURPOSE: 	Returns the header array associated with a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	header = dat_header(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	The header array associated with the data descriptor.    STATUS: 	Complete    SEE ALSO: 	dat_set_header    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_header.html#dat_header", "dat_header", 'routine in <a href="nv/obj/dat/dat_header.html">dat_header.pro</a>', "dat_header.pro", "", "dat_header", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_header_value.html", "dat_header_value.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_header_value.pro", "", "", " NAME: 	dat_header_value    PURPOSE: 	Reads and write header keyword values.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_header_value, dd, keyword, get=get, set=set    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	keyword:	String giving the name of the keyword to get or set.    OUTPUT: NONE    KEYWORDS:   INPUT: 	set:	New value to write to the specified keyword.     OUTPUT: NONE 	get:	Value of the specified keyword read from the header.     STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2013  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_header_value.html#dat_header_value", "dat_header_value", 'routine in <a href="nv/obj/dat/dat_header_value.html">dat_header_value.pro</a>', "dat_header_value.pro", "", "dat_header_value", "", "getsetnoeventddkeyword", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_input_fn.html", "dat_input_fn.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_input_fn.pro", "", "", " NAME: 	dat_input_fn    PURPOSE: 	Returns the input_fn value associated with a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	data = dat_input_fn(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	The input_fn value associated with the data descriptor.    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 10/2012  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_input_fn.html#dat_input_fn", "dat_input_fn", 'routine in <a href="nv/obj/dat/dat_input_fn.html">dat_input_fn.pro</a>', "dat_input_fn.pro", "", "dat_input_fn", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_input_keyvals.html", "dat_input_keyvals.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_input_keyvals.pro", "", "", " NAME: 	dat_input_keyvals    PURPOSE: 	Returns the maintenance value associated with a data descriptor.    CATEGORY: 	NV/OBJ/DAT    CALLING SEQUENCE: 	data = dat_input_keyvals(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	The maintenance value associated with the data descriptor.    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 7/2008  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_input_keyvals.html#dat_input_keyvals", "dat_input_keyvals", 'routine in <a href="nv/obj/dat/dat_input_keyvals.html">dat_input_keyvals.pro</a>', "dat_input_keyvals.pro", "", "dat_input_keyvals", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_input_transforms.html", "dat_input_transforms.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_input_transforms.pro", "", "", " NAME: 	dat_input_transforms    PURPOSE: 	Returns the maintenance value associated with a data descriptor.    CATEGORY: 	NV/OBJ/DAT    CALLING SEQUENCE: 	data = dat_input_transforms(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	The maintenance value associated with the data descriptor.    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 7/2008  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_input_transforms.html#dat_input_transforms", "dat_input_transforms", 'routine in <a href="nv/obj/dat/dat_input_transforms.html">dat_input_transforms.pro</a>', "dat_input_transforms.pro", "", "dat_input_transforms", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_input_translators.html", "dat_input_translators.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_input_translators.pro", "", "", " NAME: 	dat_input_translators    PURPOSE: 	Returns the maintenance value associated with a data descriptor.    CATEGORY: 	NV/OBJ/DAT    CALLING SEQUENCE: 	data = dat_input_translators(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	The maintenance value associated with the data descriptor.    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 7/2008  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_input_translators.html#dat_input_translators", "dat_input_translators", 'routine in <a href="nv/obj/dat/dat_input_translators.html">dat_input_translators.pro</a>', "dat_input_translators.pro", "", "dat_input_translators", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_instrument.html", "dat_instrument.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_instrument.pro", "", "", " NAME: 	dat_instrument    PURPOSE: 	Returns the instrument string associated with a data descriptor.    CATEGORY: 	NV/OBJ/COR    CALLING SEQUENCE: 	instrument = dat_instrument(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	The instrument string associated with the data descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 9/2001  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_instrument.html#dat_instrument", "dat_instrument", 'routine in <a href="nv/obj/dat/dat_instrument.html">dat_instrument.pro</a>', "dat_instrument.pro", "", "dat_instrument", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_keyword_fn.html", "dat_keyword_fn.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_keyword_fn.pro", "", "", " NAME: 	dat_keyword_fn    PURPOSE: 	Returns the keyword_fn value associated with a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	data = dat_keyword_fn(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	The keyword_fn value associated with the data descriptor.    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 10/2012  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_keyword_fn.html#dat_keyword_fn", "dat_keyword_fn", 'routine in <a href="nv/obj/dat/dat_keyword_fn.html">dat_keyword_fn.pro</a>', "dat_keyword_fn.pro", "", "dat_keyword_fn", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_load_data.html", "dat_load_data.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_load_data.pro", "", "", " NAME: 	dat_load_data    PURPOSE: 	Loads the data array for a given data descriptor.  Adds to 	NV state maintained list if maintain == 1.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	data = dat_load_data(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor to test.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Loaded data array.    KNOWN BUGS: 	Subsampling (ie. caching) is unreliable.  Lines or other anomalies 	often appear in subsampled images.  This does not seem to happen 	with integer sampling (e.g. integer zooms in tvim or grim), so it 	may be related to rounding or truncating of indices.  It may also be 	a problem with the set arithmetic.  Caching is currently disabled 	(see (*_dd.dd0p).cache = -1 below) until it can be fixed.    STATUS: 	Some bugs.    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_load_data.html#dat_load_data", "dat_load_data", 'routine in <a href="nv/obj/dat/dat_load_data.html">dat_load_data.pro</a>', "dat_load_data.pro", "", "dat_load_data", "", "sampledatadd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_lookup_io.html", "dat_lookup_io.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_lookup_io.pro", "", "", " NAME: 	dat_lookup_io    PURPOSE: 	Looks up the names of the data input and output functions in 	the I/O table.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_lookup_io, filetype, input_fn, output_fn    ARGUMENTS:   INPUT: 	filetype:	Filetype string from dat_detect_filetype.    OUTPUT: 	input_fn:	Name of the input function.  	output_fn:	Name of the output function.    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_lookup_io.html#dat_lookup_io", "dat_lookup_io", 'routine in <a href="nv/obj/dat/dat_lookup_io.html">dat_lookup_io.pro</a>', "dat_lookup_io.pro", "", "dat_lookup_io", "", "filetypeinput_fnoutput_fnkeyword_fn", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_lookup_transforms.html", "dat_lookup_transforms.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_lookup_transforms.pro", "", "", " NAME: 	dat_lookup_transforms    PURPOSE: 	Looks up the names of the data input and output functions in 	the I/O table.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_lookup_transforms, instrument, input_transforms, output_transforms    ARGUMENTS:   INPUT: 	instrument:	Instrument string from dat_detect_instrument.    OUTPUT: 	input_transforms:	Array giving the names of the input transform 				functions.  	output_transforms:	Array giving the names of the output transform 				functions.    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_lookup_transforms.html#dat_lookup_transforms", "dat_lookup_transforms", 'routine in <a href="nv/obj/dat/dat_lookup_transforms.html">dat_lookup_transforms.pro</a>', "dat_lookup_transforms.pro", "", "dat_lookup_transforms", "", "tab_transformsinstrumentinput_transformsoutput_transforms", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_lookup_translators.html", "dat_lookup_translators.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_lookup_translators.pro", "", "", " NAME: 	dat_lookup_translators    PURPOSE: 	Looks up the names of the data input and output tranlators in 	the translators table.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_lookup_translators, instrument, input_translators, output_translators    ARGUMENTS:   INPUT: 	instrument:	Instrument string from dat_detect_instrument.    OUTPUT: 	input_translators:	Array giving the names of the input translator 				functions.  	output_translators:	Array giving the names of the output translator 				functions.  	input_keyvals:	Array giving the keyword/value pairs the from the 			translators table, for each input translator.  	output_keyvals:	Array giving the keyword/value pairs the from the 			translators table, for each output translator.    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_lookup_translators.html#dltr_extract", "dltr_extract", 'routine in <a href="nv/obj/dat/dat_lookup_translators.html">dat_lookup_translators.pro</a>', "dat_lookup_translators.pro", "", "dltr_extract", "", "tableinstrumentinput_translatorsoutput_translatorsinput_keyvalsoutput_keyvals", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_lookup_translators.html#dat_lookup_translators", "dat_lookup_translators", 'routine in <a href="nv/obj/dat/dat_lookup_translators.html">dat_lookup_translators.pro</a>', "dat_lookup_translators.pro", "", "dat_lookup_translators", "", "tab_translatorsinstrumentinput_translatorsoutput_translatorsinput_keyvalsoutput_keyvals", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_maintain.html", "dat_maintain.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_maintain.pro", "", "", " NAME: 	dat_maintain    PURPOSE: 	Returns the maintenance value associated with a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	data = dat_maintain(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	The maintenance value associated with the data descriptor.    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 7/2008  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_maintain.html#dat_maintain", "dat_maintain", 'routine in <a href="nv/obj/dat/dat_maintain.html">dat_maintain.pro</a>', "dat_maintain.pro", "", "dat_maintain", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_manage_dd.html", "dat_manage_dd.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_manage_dd.pro", "", "", " NAME: 	dat_manage_dd    PURPOSE: 	Adds a data descriptor to the NV state maintained list.  If the list 	is full, the oldest descriptor is unloaded and removed.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_manage_dd, dd    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_manage_dd.html#dat_manage_dd", "dat_manage_dd", 'routine in <a href="nv/obj/dat/dat_manage_dd.html">dat_manage_dd.pro</a>', "dat_manage_dd.pro", "", "dat_manage_dd", "", "dd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_max.html", "dat_max.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_max.pro", "", "", " NAME: 	dat_max    PURPOSE: 	Returns the max value associated with a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	data = dat_max(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	The max value associated with the data descriptor.    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 10/2012  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_max.html#dat_max", "dat_max", 'routine in <a href="nv/obj/dat/dat_max.html">dat_max.pro</a>', "dat_max.pro", "", "dat_max", "", "noeventabscissadd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_min.html", "dat_min.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_min.pro", "", "", " NAME: 	dat_min    PURPOSE: 	Returns the min value associated with a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	data = dat_min(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	The min value associated with the data descriptor.    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 10/2012  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_min.html#dat_min", "dat_min", 'routine in <a href="nv/obj/dat/dat_min.html">dat_min.pro</a>', "dat_min.pro", "", "dat_min", "", "noeventabscissadd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_n.html", "dat_n.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_n.pro", "", "", " NAME: 	dat_n    PURPOSE: 	Returns the number of elements in the data array in the given data 	descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dim = dat_n(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: 	true:	If set, the dimension function is not called and the true 	 	length of the data is returned.    OUTPUT: NONE    RETURN: 	Number of elements in the data in the data descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_n.html#dat_n", "dat_n", 'routine in <a href="nv/obj/dat/dat_n.html">dat_n.pro</a>', "dat_n.pro", "", "dat_n", "", "truenoeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_ndd.html", "dat_ndd.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_ndd.pro", "", "", " NAME: 	dat_ndd    PURPOSE: 	Returns the global maintenance ndd value.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	data = dat_ndd(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	The global maintenance ndd value.    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 7/2008  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_ndd.html#dat_ndd", "dat_ndd", 'routine in <a href="nv/obj/dat/dat_ndd.html">dat_ndd.pro</a>', "dat_ndd.pro", "", "dat_ndd", "", "dd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_nhist.html", "dat_nhist.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_nhist.pro", "", "", " NAME: 	dat_nhist    PURPOSE: 	Returns the number of archived data states.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	nhist = dat_nhist(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Integer giving the number of past data states archived 	in the data descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_nhist.html#dat_nhist", "dat_nhist", 'routine in <a href="nv/obj/dat/dat_nhist.html">dat_nhist.pro</a>', "dat_nhist.pro", "", "dat_nhist", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_output_fn.html", "dat_output_fn.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_output_fn.pro", "", "", " NAME: 	dat_output_fn    PURPOSE: 	Returns the output_fn value associated with a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	data = dat_output_fn(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	The output_fn value associated with the data descriptor.    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 10/2012  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_output_fn.html#dat_output_fn", "dat_output_fn", 'routine in <a href="nv/obj/dat/dat_output_fn.html">dat_output_fn.pro</a>', "dat_output_fn.pro", "", "dat_output_fn", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_output_keyvals.html", "dat_output_keyvals.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_output_keyvals.pro", "", "", " NAME: 	dat_output_keyvals    PURPOSE: 	Returns the maintenance value associated with a data descriptor.    CATEGORY: 	NV/OBJ/DAT    CALLING SEQUENCE: 	data = dat_output_keyvals(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	The maintenance value associated with the data descriptor.    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 7/2008  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_output_keyvals.html#dat_output_keyvals", "dat_output_keyvals", 'routine in <a href="nv/obj/dat/dat_output_keyvals.html">dat_output_keyvals.pro</a>', "dat_output_keyvals.pro", "", "dat_output_keyvals", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_output_transforms.html", "dat_output_transforms.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_output_transforms.pro", "", "", " NAME: 	dat_output_transforms    PURPOSE: 	Returns the maintenance value associated with a data descriptor.    CATEGORY: 	NV/OBJ/DAT    CALLING SEQUENCE: 	data = dat_output_transforms(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	The maintenance value associated with the data descriptor.    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 7/2008  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_output_transforms.html#dat_output_transforms", "dat_output_transforms", 'routine in <a href="nv/obj/dat/dat_output_transforms.html">dat_output_transforms.pro</a>', "dat_output_transforms.pro", "", "dat_output_transforms", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_output_translators.html", "dat_output_translators.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_output_translators.pro", "", "", " NAME: 	dat_output_translators    PURPOSE: 	Returns the maintenance value associated with a data descriptor.    CATEGORY: 	NV/OBJ/DAT    CALLING SEQUENCE: 	data = dat_output_translators(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	The maintenance value associated with the data descriptor.    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 7/2008  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_output_translators.html#dat_output_translators", "dat_output_translators", 'routine in <a href="nv/obj/dat/dat_output_translators.html">dat_output_translators.pro</a>', "dat_output_translators.pro", "", "dat_output_translators", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_parse_keyval.html", "dat_parse_keyval.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_parse_keyval.pro", "", "", " NAME: 	dat_parse_keyval    PURPOSE: 	Parses a string containing a keyword=value pair.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_parse_keyval, keyval, keyword, value    ARGUMENTS:   INPUT: 	keyval:		String of the form <keyword>=<value>.    OUTPUT: 	keyword:	String giving the keyword.  	value:		String giving the value.    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_parse_keyval.html#dat_parse_keyval", "dat_parse_keyval", 'routine in <a href="nv/obj/dat/dat_parse_keyval.html">dat_parse_keyval.pro</a>', "dat_parse_keyval.pro", "", "dat_parse_keyval", "", "_keyvalkeywordvalue", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_parse_keyvals.html", "dat_parse_keyvals.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_parse_keyvals.pro", "", "", " NAME: 	dat_parse_keyvals    PURPOSE: 	Parses an array strings containing keyword=value pairs.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	kv = dat_parse_keyvals(keyvals)    ARGUMENTS:   INPUT: 	keyvals:	Array of strings of the form <keyword>=<value>.    OUTPUT:    KEYWORDS:   INPUT: NONE    OUTPUT: 	keywords:	Array of keywords.    RETURN: 	Array of type keyval_struct containing the parsed keywords 	and values.  One element per input array element.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_parse_keyvals.html#dat_parse_keyvals", "dat_parse_keyvals", 'routine in <a href="nv/obj/dat/dat_parse_keyvals.html">dat_parse_keyvals.pro</a>', "dat_parse_keyvals.pro", "", "dat_parse_keyvals", "", "keywordskeyvals", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_parse_transient_keyvals.html", "dat_parse_transient_keyvals.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_parse_transient_keyvals.pro", "", "", " NAME: 	dat_parse_transient_keyvals    PURPOSE: 	Parses a comma-delimited transient argument string into an of array 	of strings containing keyword=value pairs.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	keyvals = dat_parse_transient_keyvals(trs)    ARGUMENTS:   INPUT: 	trs:	Transient argument string.    OUTPUT:    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array of strings containing keyword=value pairs.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_parse_transient_keyvals.html#dat_parse_transient_keyvals", "dat_parse_transient_keyvals", 'routine in <a href="nv/obj/dat/dat_parse_transient_keyvals.html">dat_parse_transient_keyvals.pro</a>', "dat_parse_transient_keyvals.pro", "", "dat_parse_transient_keyvals", "", "trs", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_put_value.html", "dat_put_value.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_put_value.pro", "", "", " NAME: 	dat_put_value    PURPOSE: 	Calls output translators, supplying the given keyword and value.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_put_value, dd, keyword, value    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	keyword:	Keyword to pass to translators, describing the 			requested quantity.  	value:		Value to write through the translators.    OUTPUT: NONE    KEYWORDS:   INPUT: 	trs:		Transient argument string.  	tr_disable:	If set, dat_get_value returns without performing 			any action.  	tr_override:	Comma-delimited list of translators to use instead 			of those stored in dd.    OUTPUT: 	status:		0 if at least one translator call was successful, 			-1 otherwise.    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_put_value.html#dat_put_value", "dat_put_value", 'routine in <a href="nv/obj/dat/dat_put_value.html">dat_put_value.pro</a>', "dat_put_value.pro", "", "dat_put_value", "", "trsstatusddkeywordvalue@nv_trs_keywords_include.pro", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_query.html", "dat_query.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_query.pro", "", "", " NAME: 	dat_query    PURPOSE: 	Returns the fields associated with a CAMERA object.  This is a 	convenient way of getting multiple fields in one call, and only a 	single event is generated.    CATEGORY: 	NV/OBJ/CAM    CALLING SEQUENCE: 	dat_query, cd, <keywords>=<values>    ARGUMENTS:   INPUT: 	cd:	CAMERA object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	CAMERA object fields to set.  	condition:	Structure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT object, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.  	cat:		If set, arrays from mulitple input objets are 			concatenated.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.  	noevent:	If set, no event is generated.    OUTPUT: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_query.html#dat_query", "dat_query", 'routine in <a href="nv/obj/dat/dat_query.html">dat_query.pro</a>', "dat_query.pro", "", "dat_query", "", "conditioncatnoeventxd@dat__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_read.html", "dat_read.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_read.pro", "", "", " NAME: 	dat_read    PURPOSE: 	Reads a data file of arbitrary format and produces a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dd = dat_read(filespec [, data, header])    ARGUMENTS:   INPUT: 	filespec:	Array of strings giving file specifications for 			file to read.    OUTPUT: 	data:		Data array from the last file read.  This is provided 			as a convenience when reading single files so that 			it is not necessary to call dat_data to get the array.  	header:		Header array from the last file read.  This is provided 			as a convenience when reading single files so that 			it is not necessary to call dat_header to get the array.    KEYWORDS:   INPUT: 	filetype:	Overrides automatic filetype detection.  	input_fn:	Overrides input function lookup.  	output_fn:	Overrides output function lookup.  	tab_translators:	Name of translators table to use instead of 				that given by the environment variable 				NV_TRANSLATORS.  If no path is given, then the 				file is assumed to reside in the same directory 				as the translator named by the NV_TRANSLATORS 				environment variable.  	input_translator:	Use this input translator name instead of 				looking it up in the table.  	output_translator:	Use this output translator name instead of 				looking it up in the table.  	instrument:	Use this instrument name instead of attempting to 			detect it.  	sample:		Vector giving the sampling indices in the input data 			file.  This parameter is passed through to the input 			function, which may choose to ignore it.  	extensions:	If given, these extensions are attempted for each file. 			If a file with the extension is not found, then the next 			extension is tried until no extensions are left to try. 			If no extensions work, then the raw filename is attemtped.     OUTPUT: NONE     ENVIRONMENT VARIABLES: 	NV_TRANSLATORS:		Name(s) of the translators table(s) to use unless 				overridden by the tab_translators keyword. 				Multiple table names are delimited with ':'.  	NV_FTP_DETECT:		Name(s) of the filetype detectors table(s). 				Multiple table names are delimited with ':'.  	NV_IO:			Name(s) of the I/O table(s). 				Multiple table names are delimited with ':'.  	NV_INS_DETECT:		Name(s) of the instrument detectors table(s). 				Multiple table names are delimited with ':'.    RETURN: 	Array of data descriptors - one for each file resulting from the 	expansion of the given file specifications.    PROCEDURE: 	dat_read expands all file specifications and then attempts to detect 	the filetype for each resulting filename using the filetype detectors 	table.  If a filetype is detected, dat_read looks up the I/O functions 	and calls the input function to read the file.  Finally, it calls 	nv_init_descriptor to obtain a data descriptor.    STATUS: 	Complete    SEE ALSO: 	dat_write    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_read.html#drd_read", "drd_read", 'routine in <a href="nv/obj/dat/dat_read.html">dat_read.pro</a>', "dat_read.pro", "", "drd_read", "", "filetypeinput_fnoutput_fnkeyword_fninstrumentinput_translatorsoutput_translatorsinput_transformsoutput_transformstab_translatorsmaintaincompresssamplenodatanamenhistextensions_filenamedataheader", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_read.html#dat_read", "dat_read", 'routine in <a href="nv/obj/dat/dat_read.html">dat_read.pro</a>', "dat_read.pro", "", "dat_read", "", "filetypeinput_fnoutput_fnkeyword_fninstrumentinput_translatorsoutput_translatorsinput_transformsoutput_transformstab_translatorsmaintaincompresssamplenodatanamenhistextensionsfilespecdataheader", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_read_config.html", "dat_read_config.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_read_config.pro", "", "", " NAME: 	dat_read_config    PURPOSE: 	Reads an NV configuration table.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_read_config, env, table_p, filenames_p    ARGUMENTS:   INPUT: 	env:	Name of an environment variable giving the names of the 		configuration files to read, delimited by ':'.    OUTPUT: 	table_p:	Pointer to the configuration table contructed by 			concatenating the contents of each file.  	filenames_p:	List of configuration filenames that were read.    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_read_config.html#dat_read_config", "dat_read_config", 'routine in <a href="nv/obj/dat/dat_read_config.html">dat_read_config.pro</a>', "dat_read_config.pro", "", "dat_read_config", "", "continuestatusenvtable_pfilenames_p", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_redo.html", "dat_redo.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_redo.pro", "", "", " NAME: 	dat_redo    PURPOSE: 	Decrements the data archive index in the data descriptor.    CATEGORY: 	NV/OBJ/DAT    CALLING SEQUENCE: 	dat_redo, dd    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 7/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_redo.html#dat_redo", "dat_redo", 'routine in <a href="nv/obj/dat/dat_redo.html">dat_redo.pro</a>', "dat_redo.pro", "", "dat_redo", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_replicate.html", "dat_replicate.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_replicate.pro", "", "", " NAME: 	dat_replicate    PURPOSE: 	Replicates the given descriptor, producing an array of the given 	dimensions containing cloned versions of the input descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	dds = dat_replicate(dd, dim)    ARGUMENTS:   INPUT: 	dd:	 Data deccriptor to replicate.  	dim:	 Dimensions of the result.    OUTPUT: NONE    KEYWORDS:   INPUT: 	fn:	Name of the cloning function.  Default is nv_clone.    OUTPUT: NONE    RETURN: 	Array of the given dimensions containing cloned versions of the input 	data descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_replicate.html#dat_replicate", "dat_replicate", 'routine in <a href="nv/obj/dat/dat_replicate.html">dat_replicate.pro</a>', "dat_replicate.pro", "", "dat_replicate", "", "fndddim", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_sampling_data.html", "dat_sampling_data.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_sampling_data.pro", "", "", " NAME: 	dat_sampling_data    PURPOSE: 	Returns the sampling function associated with a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	sampling_data = dat_sampling_data(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	The sampling_data associated with the data descriptor.    STATUS: 	Complete    SEE ALSO: 	dat_set_sampling_data    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_sampling_data.html#dat_sampling_data", "dat_sampling_data", 'routine in <a href="nv/obj/dat/dat_sampling_data.html">dat_sampling_data.pro</a>', "dat_sampling_data.pro", "", "dat_sampling_data", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_sampling_fn.html", "dat_sampling_fn.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_sampling_fn.pro", "", "", " NAME: 	dat_sampling_fn    PURPOSE: 	Returns the sampling function associated with a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	sampling_fn = dat_sampling_fn(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	The sampling_fn associated with the data descriptor.    STATUS: 	Complete    SEE ALSO: 	dat_set_sampling_fn    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_sampling_fn.html#dat_sampling_fn", "dat_sampling_fn", 'routine in <a href="nv/obj/dat/dat_sampling_fn.html">dat_sampling_fn.pro</a>', "dat_sampling_fn.pro", "", "dat_sampling_fn", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_compress.html", "dat_set_compress.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_set_compress.pro", "", "", " NAME: 	dat_set_compress    PURPOSE: 	Replaces the name of the compression function in a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_compress, dd, compress    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	compress:	String giving the name of a new compression function.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_compress.html#dat_set_compress", "dat_set_compress", 'routine in <a href="nv/obj/dat/dat_set_compress.html">dat_set_compress.pro</a>', "dat_set_compress.pro", "", "dat_set_compress", "", "ddcompress", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_data.html", "dat_set_data.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_set_data.pro", "", "", " NAME: 	dat_set_data    PURPOSE: 	Replaces the data array associated with a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_data, dd, data    ARGUMENTS:   INPUT: 	dd:	Data descriptor.  	data:	New data array.    OUTPUT: 	dd:	Modified data descriptor.    KEYWORDS:   INPUT: 	abscissa: If set, the given array is taken as the abscissa.  	update:	Update mode flag.  If not given, it will be taken from dd.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Does not yet support sampling.    SEE ALSO: 	dat_data    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_data.html#dat_set_data", "dat_set_data", 'routine in <a href="nv/obj/dat/dat_set_data.html">dat_set_data.pro</a>', "dat_set_data.pro", "", "dat_set_data", "", "updatenoeventabscissasampledd_data", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_dh.html", "dat_set_dh.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_set_dh.pro", "", "", " NAME: 	dat_set_dh    PURPOSE: 	Replaces the dh value in a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_dh, dd, dh    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	dh:	New dh value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_dh.html#dat_set_dh", "dat_set_dh", 'routine in <a href="nv/obj/dat/dat_set_dh.html">dat_set_dh.pro</a>', "dat_set_dh.pro", "", "dat_set_dh", "", "noeventdddh", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_dim.html", "dat_set_dim.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_set_dim.pro", "", "", " NAME: 	dat_set_dim    PURPOSE: 	Replaces the dimensions in a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_dim, dd, dim    ARGUMENTS:   INPUT: 	dd:	Data descriptor.  	dim:	New dimensions.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_dim.html#dat_set_dim", "dat_set_dim", 'routine in <a href="nv/obj/dat/dat_set_dim.html">dat_set_dim.pro</a>', "dat_set_dim.pro", "", "dat_set_dim", "", "noeventdddim", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_dim_data.html", "dat_set_dim_data.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_set_dim_data.pro", "", "", " NAME: 	dat_set_dim_data    PURPOSE: 	Replaces the dimension function data associated with a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_dim_data, dd, dim_data    ARGUMENTS:   INPUT: 	dd:			Data descriptor.  	dim_data:	New sampling function data.    OUTPUT: 	dd:	Modified data descriptor.    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	dat_dim_data    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_dim_data.html#dat_set_dim_data", "dat_set_dim_data", 'routine in <a href="nv/obj/dat/dat_set_dim_data.html">dat_set_dim_data.pro</a>', "dat_set_dim_data.pro", "", "dat_set_dim_data", "", "noeventdddata", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_dim_fn.html", "dat_set_dim_fn.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_set_dim_fn.pro", "", "", " NAME: 	dat_set_dim_fn    PURPOSE: 	Replaces the dimension function associated with a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_dim_fn, dd, dim_fn    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	dim_fn:	New sampling function.    OUTPUT: 	dd:	Modified data descriptor.    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	dat_dim_fn    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_dim_fn.html#dat_set_dim_fn", "dat_set_dim_fn", 'routine in <a href="nv/obj/dat/dat_set_dim_fn.html">dat_set_dim_fn.pro</a>', "dat_set_dim_fn.pro", "", "dat_set_dim_fn", "", "noeventdddim_fn", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_filename.html", "dat_set_filename.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_set_filename.pro", "", "", " NAME: 	dat_set_filename    PURPOSE: 	Changes the file name associated with a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_filename, dd, filename    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	filename:	New file name.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_filename.html#dat_set_filename", "dat_set_filename", 'routine in <a href="nv/obj/dat/dat_set_filename.html">dat_set_filename.pro</a>', "dat_set_filename.pro", "", "dat_set_filename", "", "noeventddfilename", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_filetype.html", "dat_set_filetype.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_set_filetype.pro", "", "", " NAME: 	dat_set_filetype    PURPOSE: 	Changes the file name associated with a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_filetype, dd, filetype    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	filetype:	New file name.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_filetype.html#dat_set_filetype", "dat_set_filetype", 'routine in <a href="nv/obj/dat/dat_set_filetype.html">dat_set_filetype.pro</a>', "dat_set_filetype.pro", "", "dat_set_filetype", "", "noeventddfiletype", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_gd.html", "dat_set_gd.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_set_gd.pro", "", "", " NAME: 	dat_set_gd    PURPOSE: 	Updates a generic descriptor contained in an object.  Similar to 	cor_set_gd, except descriptor inputs are sorted according to the 	data descriptors contained in their generic descriptors.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	dat_set_gd, xd, gd, <descriptor keywords>    ARGUMENTS:   INPUT: 	xd:	Objects to modify.  The fields from any existing generic 		descriptors in these objects are retained in the new ones.  	gd:	New generic descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<x>d:	Input keyword for each descriptor type.  These are sorted 		according to associated data descriptors.     OUTPUT: NONE    RETURN: NONE     MODIFICATION HISTORY:  	Written by:	Spitale		2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_gd.html#dat_set_gd", "dat_set_gd", 'routine in <a href="nv/obj/dat/dat_set_gd.html">dat_set_gd.pro</a>', "dat_set_gd.pro", "", "dat_set_gd", "", "_extraxdgd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_gff.html", "dat_set_gff.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_set_gff.pro", "", "", " NAME: 	dat_set_gff    PURPOSE: 	Replaces the gff value in a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_gff, dd, gff    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	gff:	New gff value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_gff.html#dat_set_gff", "dat_set_gff", 'routine in <a href="nv/obj/dat/dat_set_gff.html">dat_set_gff.pro</a>', "dat_set_gff.pro", "", "dat_set_gff", "", "noeventddgff", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_header.html", "dat_set_header.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_set_header.pro", "", "", " NAME: 	dat_set_header    PURPOSE: 	Replaces the header array associated with a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_header, dd, header    ARGUMENTS:   INPUT: 	dd:	Data descriptor.  	header:	New header array.    OUTPUT: 	dd:	Modified data descriptor.    KEYWORDS:   INPUT: 	update:	Update mode flag.  If not given, it will be taken from dd.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	dat_header    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_header.html#dat_set_header", "dat_set_header", 'routine in <a href="nv/obj/dat/dat_set_header.html">dat_set_header.pro</a>', "dat_set_header.pro", "", "dat_set_header", "", "updatenoeventddheader", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_input_fn.html", "dat_set_input_fn.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_set_input_fn.pro", "", "", " NAME: 	dat_set_input_fn    PURPOSE: 	Replaces the input_fn value in a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_input_fn, dd, input_fn    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	input_fn:	New input_fn value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_input_fn.html#dat_set_input_fn", "dat_set_input_fn", 'routine in <a href="nv/obj/dat/dat_set_input_fn.html">dat_set_input_fn.pro</a>', "dat_set_input_fn.pro", "", "dat_set_input_fn", "", "noeventddinput_fn", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_input_keyvals.html", "dat_set_input_keyvals.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_set_input_keyvals.pro", "", "", " NAME: 	dat_set_input_keyvals    PURPOSE: 	Replaces the input_keyvals value in a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_input_keyvals, dd, input_keyvals    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	input_keyvals:	New input_keyvals value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_input_keyvals.html#dat_set_input_keyvals", "dat_set_input_keyvals", 'routine in <a href="nv/obj/dat/dat_set_input_keyvals.html">dat_set_input_keyvals.pro</a>', "dat_set_input_keyvals.pro", "", "dat_set_input_keyvals", "", "noeventddinput_keyvals", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_input_transforms.html", "dat_set_input_transforms.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_set_input_transforms.pro", "", "", " NAME: 	dat_set_input_transforms    PURPOSE: 	Replaces the input_transforms value in a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_input_transforms, dd, input_transforms    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	input_transforms:	New input_transforms value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_input_transforms.html#dat_set_input_transforms", "dat_set_input_transforms", 'routine in <a href="nv/obj/dat/dat_set_input_transforms.html">dat_set_input_transforms.pro</a>', "dat_set_input_transforms.pro", "", "dat_set_input_transforms", "", "noeventddinput_transforms", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_input_translators.html", "dat_set_input_translators.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_set_input_translators.pro", "", "", " NAME: 	dat_set_input_translators    PURPOSE: 	Replaces the input_translators value in a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_input_translators, dd, input_translators    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	input_translators:	New input_translators value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_input_translators.html#dat_set_input_translators", "dat_set_input_translators", 'routine in <a href="nv/obj/dat/dat_set_input_translators.html">dat_set_input_translators.pro</a>', "dat_set_input_translators.pro", "", "dat_set_input_translators", "", "noeventddinput_translators", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_instrument.html", "dat_set_instrument.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_set_instrument.pro", "", "", " NAME: 	dat_set_instrument    PURPOSE: 	Changes the file name associated with a data descriptor.    CATEGORY: 	NV/OBJ/COR    CALLING SEQUENCE: 	dat_set_instrument, dd, instrument    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	instrument:	New instrument name.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_instrument.html#dat_set_instrument", "dat_set_instrument", 'routine in <a href="nv/obj/dat/dat_set_instrument.html">dat_set_instrument.pro</a>', "dat_set_instrument.pro", "", "dat_set_instrument", "", "noeventddinstrument", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_keyword_fn.html", "dat_set_keyword_fn.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_set_keyword_fn.pro", "", "", " NAME: 	dat_set_keyword_fn    PURPOSE: 	Replaces the keyword_fn value in a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_keyword_fn, dd, keyword_fn    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	keyword_fn:	New keyword_fn value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_keyword_fn.html#dat_set_keyword_fn", "dat_set_keyword_fn", 'routine in <a href="nv/obj/dat/dat_set_keyword_fn.html">dat_set_keyword_fn.pro</a>', "dat_set_keyword_fn.pro", "", "dat_set_keyword_fn", "", "noeventddkeyword_fn", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_maintain.html", "dat_set_maintain.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_set_maintain.pro", "", "", " NAME: 	dat_set_maintain    PURPOSE: 	Replaces the maintain flag in a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_maintain, dd, maintain    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	maintain:	New maintain flag.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_maintain.html#dat_set_maintain", "dat_set_maintain", 'routine in <a href="nv/obj/dat/dat_set_maintain.html">dat_set_maintain.pro</a>', "dat_set_maintain.pro", "", "dat_set_maintain", "", "noeventddmaintain", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_max.html", "dat_set_max.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_set_max.pro", "", "", " NAME: 	dat_set_max    PURPOSE: 	Replaces the max value in a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_max, dd, max    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	max:	New max value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_max.html#dat_set_max", "dat_set_max", 'routine in <a href="nv/obj/dat/dat_set_max.html">dat_set_max.pro</a>', "dat_set_max.pro", "", "dat_set_max", "", "noeventabscissaddmax", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_min.html", "dat_set_min.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_set_min.pro", "", "", " NAME: 	dat_set_min    PURPOSE: 	Replaces the min value in a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_min, dd, min    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	min:	New min value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_min.html#dat_set_min", "dat_set_min", 'routine in <a href="nv/obj/dat/dat_set_min.html">dat_set_min.pro</a>', "dat_set_min.pro", "", "dat_set_min", "", "noeventabscissaddmin", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_ndd.html", "dat_set_ndd.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_set_ndd.pro", "", "", " NAME: 	dat_set_ndd    PURPOSE: 	Sets a new ndd value in the NV state structure.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_ndd, ndd    ARGUMENTS:   INPUT: 	ndd:	New ndd value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_ndd.html#dat_set_ndd", "dat_set_ndd", 'routine in <a href="nv/obj/dat/dat_set_ndd.html">dat_set_ndd.pro</a>', "dat_set_ndd.pro", "", "dat_set_ndd", "", "ndd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_nhist.html", "dat_set_nhist.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_set_nhist.pro", "", "", " NAME: 	dat_set_nhist    PURPOSE: 	Changes the number of past states archived in a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_nhist, dd, nhist    ARGUMENTS:   INPUT: 	dd:	Data descriptor.  	nhist:	New nhist value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_nhist.html#dat_set_nhist", "dat_set_nhist", 'routine in <a href="nv/obj/dat/dat_set_nhist.html">dat_set_nhist.pro</a>', "dat_set_nhist.pro", "", "dat_set_nhist", "", "noeventddnhist", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_output_fn.html", "dat_set_output_fn.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_set_output_fn.pro", "", "", " NAME: 	dat_set_output_fn    PURPOSE: 	Replaces the output_fn value in a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_output_fn, dd, output_fn    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	output_fn:	New output_fn value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_output_fn.html#dat_set_output_fn", "dat_set_output_fn", 'routine in <a href="nv/obj/dat/dat_set_output_fn.html">dat_set_output_fn.pro</a>', "dat_set_output_fn.pro", "", "dat_set_output_fn", "", "noeventddoutput_fn", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_output_keyvals.html", "dat_set_output_keyvals.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_set_output_keyvals.pro", "", "", " NAME: 	dat_set_output_keyvals    PURPOSE: 	Replaces the output_keyvals value in a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_output_keyvals, dd, output_keyvals    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	output_keyvals:	New output_keyvals value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_output_keyvals.html#dat_set_output_keyvals", "dat_set_output_keyvals", 'routine in <a href="nv/obj/dat/dat_set_output_keyvals.html">dat_set_output_keyvals.pro</a>', "dat_set_output_keyvals.pro", "", "dat_set_output_keyvals", "", "noeventddoutput_keyvals", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_output_transforms.html", "dat_set_output_transforms.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_set_output_transforms.pro", "", "", " NAME: 	dat_set_output_transforms    PURPOSE: 	Replaces the output_transforms value in a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_output_transforms, dd, output_transforms    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	output_transforms:	New output_transforms value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_output_transforms.html#dat_set_output_transforms", "dat_set_output_transforms", 'routine in <a href="nv/obj/dat/dat_set_output_transforms.html">dat_set_output_transforms.pro</a>', "dat_set_output_transforms.pro", "", "dat_set_output_transforms", "", "noeventddoutput_transforms", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_output_translators.html", "dat_set_output_translators.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_set_output_translators.pro", "", "", " NAME: 	dat_set_output_translators    PURPOSE: 	Replaces the output_translators value in a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_output_translators, dd, output_translators    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	output_translators:	New output_translators value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_output_translators.html#dat_set_output_translators", "dat_set_output_translators", 'routine in <a href="nv/obj/dat/dat_set_output_translators.html">dat_set_output_translators.pro</a>', "dat_set_output_translators.pro", "", "dat_set_output_translators", "", "noeventddoutput_translators", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_sampling_data.html", "dat_set_sampling_data.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_set_sampling_data.pro", "", "", " NAME: 	dat_set_sampling_data    PURPOSE: 	Replaces the sampling function data associated with a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_sampling_data, dd, sampling_data    ARGUMENTS:   INPUT: 	dd:			Data descriptor.  	sampling_data:	New sampling function data.    OUTPUT: 	dd:	Modified data descriptor.    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	dat_sampling_data    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_sampling_data.html#dat_set_sampling_data", "dat_set_sampling_data", 'routine in <a href="nv/obj/dat/dat_set_sampling_data.html">dat_set_sampling_data.pro</a>', "dat_set_sampling_data.pro", "", "dat_set_sampling_data", "", "noeventdddata", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_sampling_fn.html", "dat_set_sampling_fn.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_set_sampling_fn.pro", "", "", " NAME: 	dat_set_sampling_fn    PURPOSE: 	Replaces the sampling function associated with a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_sampling_fn, dd, sampling_fn    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	sampling_fn:	New sampling function.    OUTPUT: 	dd:	Modified data descriptor.    KEYWORDS:   INPUT: 	data 	Data to be sent to the sampling function.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	dat_sampling_fn    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_sampling_fn.html#dat_set_sampling_fn", "dat_set_sampling_fn", 'routine in <a href="nv/obj/dat/dat_set_sampling_fn.html">dat_set_sampling_fn.pro</a>', "dat_set_sampling_fn.pro", "", "dat_set_sampling_fn", "", "datanoeventddsampling_fn", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_sibling.html", "dat_set_sibling.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_set_sibling.pro", "", "", " NAME: 	dat_set_sibling    PURPOSE: 	Changes the sibling in a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_sibling, dd, dd_sibling    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	dd_sibling:	Data descriptor of new sibling.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_sibling.html#dat_set_sibling", "dat_set_sibling", 'routine in <a href="nv/obj/dat/dat_set_sibling.html">dat_set_sibling.pro</a>', "dat_set_sibling.pro", "", "dat_set_sibling", "", "noeventdddd_sibling", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_slice.html", "dat_set_slice.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_set_slice.pro", "", "", " NAME: 	dat_set_slice    PURPOSE: 	Sets slice coordinates in a data descriptor.    CATEGORY: 	NV/OBJ/DAT    CALLING SEQUENCE: 	dat_set_slice, dd, dd0, slice    ARGUMENTS:   INPUT: 	dd:	Data descriptorin which to set the slice coordinates.  	dd0:	Data descriptorin describing the source data array.  	slice:	Array giving the slice coordinates.    OUTPUT: NONE    KEYWORDS:   INPUT: 	new:	If set, a new slice pointer is allocated instead of overwriting 		the exiting data.    OUTPUT: NONE    RETURN: NONE    MODIFICATION HISTORY:  	Written by:	Spitale		6/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_slice.html#dat_set_slice", "dat_set_slice", 'routine in <a href="nv/obj/dat/dat_set_slice.html">dat_set_slice.pro</a>', "dat_set_slice.pro", "", "dat_set_slice", "", "newdddd0slice", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_typecode.html", "dat_set_typecode.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_set_typecode.pro", "", "", " NAME: 	dat_set_typecode    PURPOSE: 	Replaces the typecode value in a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_typecode, dd, typecode    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	typecode:	New typecode value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_typecode.html#dat_set_typecode", "dat_set_typecode", 'routine in <a href="nv/obj/dat/dat_set_typecode.html">dat_set_typecode.pro</a>', "dat_set_typecode.pro", "", "dat_set_typecode", "", "noeventddtypecode", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_update.html", "dat_set_update.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_set_update.pro", "", "", " NAME: 	dat_set_update    PURPOSE: 	Changes the update flag in a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_set_update, dd, update    ARGUMENTS:   INPUT: 	dd:	Data descriptor.  	update:	New update flag.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_set_update.html#dat_set_update", "dat_set_update", 'routine in <a href="nv/obj/dat/dat_set_update.html">dat_set_update.pro</a>', "dat_set_update.pro", "", "dat_set_update", "", "noeventddupdate", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_sibling.html", "dat_sibling.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_sibling.pro", "", "", " NAME: 	dat_sibling    PURPOSE: 	Returns the sibling data descriptor associated with a data 	descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	sibling_dd = dat_sibling(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Data descriptor of the sibling.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_sibling.html#dat_sibling", "dat_sibling", 'routine in <a href="nv/obj/dat/dat_sibling.html">dat_sibling.pro</a>', "dat_sibling.pro", "", "dat_sibling", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_slice.html", "dat_slice.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_slice.pro", "", "", " NAME: 	dat_slice    PURPOSE: 	Returns the slice coordinates for the given data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dim = dat_slice(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array giving the slice coordinates for the data descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_slice.html#dat_slice", "dat_slice", 'routine in <a href="nv/obj/dat/dat_slice.html">dat_slice.pro</a>', "dat_slice.pro", "", "dat_slice", "", "dd0noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_slice__define.html", "dat_slice__define.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_slice__define.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_slice__define.html#dat_slice__define", "dat_slice__define", 'routine in <a href="nv/obj/dat/dat_slice__define.html">dat_slice__define.pro</a>', "dat_slice__define.pro", "", "dat_slice__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_slice_offset.html", "dat_slice_offset.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_slice_offset.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_slice_offset.html#dat_slice_offset", "dat_slice_offset", 'routine in <a href="nv/obj/dat/dat_slice_offset.html">dat_slice_offset.pro</a>', "dat_slice_offset.pro", "", "dat_slice_offset", "", "arg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_slices.html", "dat_slices.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_slices.pro", "", "", " NAME: 	dat_slices    PURPOSE: 	Creates new data descriptors that point to a subarray slices in a given 	data descriptor.    CATEGORY: 	NV/OBJ/DAT    CALLING SEQUENCE: 	new_dd = dat_slices(dd, h, q)    ARGUMENTS:   INPUT: 	dd:	Data descriptor containing N-dimensional data array.  	slice:	m x n array giving coordinates of n m-dimensional arrays to 		select. If not given, the original data array is sliced into 		arrays of one dimension smaller, i.e., a cube is sliced 		into its constituent images, and an image is sliced into its 		constituent lines etc.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	New data descriptors for the selected data arrays.  Dimensions are N - m. 	Note that new data arrays are not allocated.  Instead, the returned 	descriptors point to the subarray within the data array of the input 	data descriptor.    EXAMPLE: 	1) Extract the ith image of a 3-dimensional data cube:  		new_dd = dat_slices(dd, i)  	2) Extract the ith cube of a 4-dimensional data array:  		new_dd = dat_slices(dd, i)  	3) Extract the ith image in the jth cube of a 4-dimensional data array:  		new_dd = dat_slices(dd, [i,j])     MODIFICATION HISTORY:  	Written by:	Spitale		6/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_slices.html#dat_slices", "dat_slices", 'routine in <a href="nv/obj/dat/dat_slices.html">dat_slices.pro</a>', "dat_slices.pro", "", "dat_slices", "", "dd0slice", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_test_dd.html", "dat_test_dd.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_test_dd.pro", "", "", " NAME: 	dat_test_dd    PURPOSE: 	Determines whether the argument is a valid data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	test = dat_test_dd(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor to test.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	True if the argument is present, is a valid pointer, and 	points to a data descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_test_dd.html#dat_test_dd", "dat_test_dd", 'routine in <a href="nv/obj/dat/dat_test_dd.html">dat_test_dd.pro</a>', "dat_test_dd.pro", "", "dat_test_dd", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_transform_input.html", "dat_transform_input.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_transform_input.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_transform_input.html#dat_transform_input", "dat_transform_input", 'routine in <a href="nv/obj/dat/dat_transform_input.html">dat_transform_input.pro</a>', "dat_transform_input.pro", "", "dat_transform_input", "", "_dddataheader", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_transform_output.html", "dat_transform_output.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_transform_output.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_transform_output.html#dat_transform_output", "dat_transform_output", 'routine in <a href="nv/obj/dat/dat_transform_output.html">dat_transform_output.pro</a>', "dat_transform_output.pro", "", "dat_transform_output", "", "_dddataheader", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_typecode.html", "dat_typecode.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_typecode.pro", "", "", " NAME: 	dat_typecode    PURPOSE: 	Returns the type code associated with a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	typecode = dat_typecode(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Integer giving the typecode.    STATUS: Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_typecode.html#dat_typecode", "dat_typecode", 'routine in <a href="nv/obj/dat/dat_typecode.html">dat_typecode.pro</a>', "dat_typecode.pro", "", "dat_typecode", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_uncompress_data_mask.html", "dat_uncompress_data_mask.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_uncompress_data_mask.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_uncompress_data_mask.html#dat_uncompress_data_mask", "dat_uncompress_data_mask", 'routine in <a href="nv/obj/dat/dat_uncompress_data_mask.html">dat_uncompress_data_mask.pro</a>', "dat_uncompress_data_mask.pro", "", "dat_uncompress_data_mask", "", "_dd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_undo.html", "dat_undo.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_undo.pro", "", "", " NAME: 	dat_undo    PURPOSE: 	Increments the data archive index in the data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_undo, dd    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_undo.html#dat_undo", "dat_undo", 'routine in <a href="nv/obj/dat/dat_undo.html">dat_undo.pro</a>', "dat_undo.pro", "", "dat_undo", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_unload_data.html", "dat_unload_data.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_unload_data.pro", "", "", " NAME: 	dat_unload_data    PURPOSE: 	Unloads the dat descriptor data array and removes dd from the NV 	state maintained list if present.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_unload_data, dd    ARGUMENTS:   INPUT: 	dd:	Data descriptor to test.    OUTPUT: NONE    KEYWORDS:   INPUT: 	all:	If set, all maintained data descriptors are unloaded.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_unload_data.html#dat_unload_data", "dat_unload_data", 'routine in <a href="nv/obj/dat/dat_unload_data.html">dat_unload_data.pro</a>', "dat_unload_data.pro", "", "dat_unload_data", "", "alldd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_update.html", "dat_update.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_update.pro", "", "", " NAME: 	dat_update    PURPOSE: 	Returns the update flag associated with a data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	update = dat_update(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Data descriptor update flag.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_update.html#dat_update", "dat_update", 'routine in <a href="nv/obj/dat/dat_update.html">dat_update.pro</a>', "dat_update.pro", "", "dat_update", "", "noeventdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_valid_descriptor.html", "dat_valid_descriptor.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_valid_descriptor.pro", "", "", " NAME: 	dat_valid_descriptor    PURPOSE: 	Determines whether the argument is a valid data descriptor, 	or data descriptor structure.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	test = dat_valid_descriptor(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor to test.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	True if the argument is a data descriptor structure or a 	pointer to one.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_valid_descriptor.html#dat_valid_descriptor", "dat_valid_descriptor", 'routine in <a href="nv/obj/dat/dat_valid_descriptor.html">dat_valid_descriptor.pro</a>', "dat_valid_descriptor.pro", "", "dat_valid_descriptor", "", "ddp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dat_write.html", "dat_write.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "dat_write.pro", "", "", " NAME: 	dat_write    PURPOSE: 	Writes a data file of arbitrary format.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	dat_write, filespec, dd 	dat_write, dd    ARGUMENTS:   INPUT: 	filespec:	Array of strings giving file specifications for 			file to write.  Data descriptor filespec is 			updated unless /override.  	dd:		Array of data descriptors.  dd can also be given as the 			first argument, in which case, the file specifications 			are taken from the filename field of dd.    OUTPUT: NONE    KEYWORDS:   INPUT: 	filetype:	Overrides data descriptor filetype (and thus the 			output function).  Data descriptor filetype is 			updated unless /override.  	output_fn:	Overrides data descriptor output function.  Data 			descriptor output_fn is updated unless /override.  	override:	If set, filespec, filetype, and output_fn inputs 			are used for this call, but not updated in the data 			descriptor.     OUTPUT: NONE    RETURN: NONE    PROCEDURE: 	dat_write expands all file specifications and attempts to write a 	file corresponding to each given data descriptor.  An error results 	if the filespec expands to a different number of files than the number 	of given data descriptors.    STATUS: 	Complete    SEE ALSO: 	dat_read    MODIFICATION HISTORY:  	Written by:	Spitale, 7/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dat_write.html#dat_write", "dat_write", 'routine in <a href="nv/obj/dat/dat_write.html">dat_write.pro</a>', "dat_write.pro", "", "dat_write", "", "nodatafiletypeoutput_fnoverridearg1arg2", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/data_archive/data_archive_clone.html", "data_archive_clone.pro", '.pro file in <a href="util/data_archive/dir-overview.html">util/data_archive/ directory</a>', "data_archive_clone.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/data_archive/data_archive_clone.html#data_archive_clone", "data_archive_clone", 'routine in <a href="util/data_archive/data_archive_clone.html">data_archive_clone.pro</a>', "data_archive_clone.pro", "", "data_archive_clone", "", "dap", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/data_archive/data_archive_defined.html", "data_archive_defined.pro", '.pro file in <a href="util/data_archive/dir-overview.html">util/data_archive/ directory</a>', "data_archive_defined.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/data_archive/data_archive_defined.html#data_archive_defined", "data_archive_defined", 'routine in <a href="util/data_archive/data_archive_defined.html">data_archive_defined.pro</a>', "data_archive_defined.pro", "", "data_archive_defined", "", "dapindex", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/data_archive/data_archive_free.html", "data_archive_free.pro", '.pro file in <a href="util/data_archive/dir-overview.html">util/data_archive/ directory</a>', "data_archive_free.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/data_archive/data_archive_free.html#data_archive_free", "data_archive_free", 'routine in <a href="util/data_archive/data_archive_free.html">data_archive_free.pro</a>', "data_archive_free.pro", "", "data_archive_free", "", "dap", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/data_archive/data_archive_get.html", "data_archive_get.pro", '.pro file in <a href="util/data_archive/dir-overview.html">util/data_archive/ directory</a>', "data_archive_get.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/data_archive/data_archive_get.html#data_archive_get", "data_archive_get", 'routine in <a href="util/data_archive/data_archive_get.html">data_archive_get.pro</a>', "data_archive_get.pro", "", "data_archive_get", "", "samplesdapindex", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/data_archive/data_archive_set.html", "data_archive_set.pro", '.pro file in <a href="util/data_archive/dir-overview.html">util/data_archive/ directory</a>', "data_archive_set.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/data_archive/data_archive_set.html#data_archive_set", "data_archive_set", 'routine in <a href="util/data_archive/data_archive_set.html">data_archive_set.pro</a>', "data_archive_set.pro", "", "data_archive_set", "", "nhistindexnoarchivedapdata", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/data_to_device.html", "data_to_device.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "data_to_device.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/data_to_device.html#data_to_device", "data_to_device", 'routine in <a href="util/data_to_device.html">data_to_device.pro</a>', "data_to_device.pro", "", "data_to_device", "", "p", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/dawn/dawn_cmat_to_orient_fc.html", "dawn_cmat_to_orient_fc.pro", '.pro file in <a href="config/dawn/dir-overview.html">config/dawn/ directory</a>', "dawn_cmat_to_orient_fc.pro", "", "", " NAME: 	dawn_cmat_to_orient_fc    PURPOSE: 	Converts Dawn C matrix to a OMINAS camera orientation matrix.    CATEGORY: 	NV/CONFIG    CALLING SEQUENCE: 	result = dawn_cmat_to_orient(cmat)    ARGUMENTS:   INPUT: 	cmat:	Dawn C matrix    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	NONE    OUTPUT: 	NONE    RETURN: 	OMINAS camera orientation matrix.    PROCEDURE:   					    / Zcm 					  / 			         	  ------ Xcm 	C matrix 					| 			   /|\		| 			    |		| Ycm 			  lines 			 --------- 			|	  | 	   		|	  |  samples --> 			|	  | 			 --------- 	    Z	| 		|     OMINAS	|  / Y 		|/ 		 ------- X     STATUS: 	Complete    SEE ALSO: 	dawn_orient_to_cmat    MODIFICATION HISTORY:  	Written by:	Spitale, 1/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/dawn/dawn_cmat_to_orient_fc.html#dawn_cmat_to_orient_fc", "dawn_cmat_to_orient_fc", 'routine in <a href="config/dawn/dawn_cmat_to_orient_fc.html">dawn_cmat_to_orient_fc.pro</a>', "dawn_cmat_to_orient_fc.pro", "", "dawn_cmat_to_orient_fc", "", "cmat", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/dawn/dawn_compute_psf.html", "dawn_compute_psf.pro", '.pro file in <a href="config/dawn/dir-overview.html">config/dawn/ directory</a>', "dawn_compute_psf.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/dawn/dawn_compute_psf.html#dawn_compute_psf", "dawn_compute_psf", 'routine in <a href="config/dawn/dawn_compute_psf.html">dawn_compute_psf.pro</a>', "dawn_compute_psf.pro", "", "dawn_compute_psf", "", "defaultcdxy", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/dawn/dawn_filter.html", "dawn_filter.pro", '.pro file in <a href="config/dawn/dir-overview.html">config/dawn/ directory</a>', "dawn_filter.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/dawn/dawn_filter.html#dawn_filter", "dawn_filter", 'routine in <a href="config/dawn/dawn_filter.html">dawn_filter.pro</a>', "dawn_filter.pro", "", "dawn_filter", "", "defaultcdilambda", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/dawn/dawn_format_comment.html", "dawn_format_comment.pro", '.pro file in <a href="config/dawn/dir-overview.html">config/dawn/ directory</a>', "dawn_format_comment.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/dawn/dawn_format_comment.html#dawn_format_comment", "dawn_format_comment", 'routine in <a href="config/dawn/dawn_format_comment.html">dawn_format_comment.pro</a>', "dawn_format_comment.pro", "", "dawn_format_comment", "", "od", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/dawn/dawn_from_ominas.html", "dawn_from_ominas.pro", '.pro file in <a href="config/dawn/dir-overview.html">config/dawn/ directory</a>', "dawn_from_ominas.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/dawn/dawn_from_ominas.html#dawn_from_ominas", "dawn_from_ominas", 'routine in <a href="config/dawn/dawn_from_ominas.html">dawn_from_ominas.pro</a>', "dawn_from_ominas.pro", "", "dawn_from_ominas", "", "odorient_fn", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/dawn/dawn_orient_to_cmat_fc.html", "dawn_orient_to_cmat_fc.pro", '.pro file in <a href="config/dawn/dir-overview.html">config/dawn/ directory</a>', "dawn_orient_to_cmat_fc.pro", "", "", " NAME: 	dawn_orient_to_cmat_fc    PURPOSE: 	Converts Dawn C matrix to a OMINAS camera orientation matrix.    CATEGORY: 	NV/CONFIG    CALLING SEQUENCE: 	result = dawn_orient_to_cmat(cmat)    ARGUMENTS:   INPUT: 	orient:		OMINAS camera orientation matrix.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	NONE    OUTPUT: 	NONE    RETURN: 	Dawn C matrix.    PROCEDURE:   					    / Zcm 					  / 			         	  ------ Xcm 	C matrix 					| 			   /|\		| 			    |		| Ycm 			  lines 			 --------- 			|	  | 	   		|	  |  samples --> 			|	  | 			 --------- 	    Z	| 		|     OMINAS	|  / Y 		|/ 		 ------- X     STATUS: 	Complete    SEE ALSO: 	dawn_cmat_to_orient    MODIFICATION HISTORY:  	Written by:	Spitale, 1/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/dawn/dawn_orient_to_cmat_fc.html#dawn_orient_to_cmat_fc", "dawn_orient_to_cmat_fc", 'routine in <a href="config/dawn/dawn_orient_to_cmat_fc.html">dawn_orient_to_cmat_fc.pro</a>', "dawn_orient_to_cmat_fc.pro", "", "dawn_orient_to_cmat_fc", "", "orient", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/dawn/dawn_psf.html", "dawn_psf.pro", '.pro file in <a href="config/dawn/dir-overview.html">config/dawn/ directory</a>', "dawn_psf.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/dawn/dawn_psf.html#dawn_psf", "dawn_psf", 'routine in <a href="config/dawn/dawn_psf.html">dawn_psf.pro</a>', "dawn_psf.pro", "", "dawn_psf", "", "cdxy", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/dawn/dawn_spice_ck_detect.html", "dawn_spice_ck_detect.pro", '.pro file in <a href="config/dawn/dir-overview.html">config/dawn/ directory</a>', "dawn_spice_ck_detect.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/dawn/dawn_spice_ck_detect.html#dawn_spice_ck_components", "dawn_spice_ck_components", 'routine in <a href="config/dawn/dawn_spice_ck_detect.html">dawn_spice_ck_detect.pro</a>', "dawn_spice_ck_detect.pro", "", "dawn_spice_ck_components", "", "scjd_startjd_stopall_names", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/dawn/dawn_spice_ck_detect.html#dawn_spice_ck_detect", "dawn_spice_ck_detect", 'routine in <a href="config/dawn/dawn_spice_ck_detect.html">dawn_spice_ck_detect.pro</a>', "dawn_spice_ck_detect.pro", "", "dawn_spice_ck_detect", "", "djdtimeallstrictddckpath", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/dawn/dawn_spice_fk_detect.html", "dawn_spice_fk_detect.pro", '.pro file in <a href="config/dawn/dir-overview.html">config/dawn/ directory</a>', "dawn_spice_fk_detect.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/dawn/dawn_spice_fk_detect.html#dawn_spice_fk_detect", "dawn_spice_fk_detect", 'routine in <a href="config/dawn/dawn_spice_fk_detect.html">dawn_spice_fk_detect.pro</a>', "dawn_spice_fk_detect.pro", "", "dawn_spice_fk_detect", "", "sctimestrictallddkpath", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/dawn/dawn_spice_ik_detect.html", "dawn_spice_ik_detect.pro", '.pro file in <a href="config/dawn/dir-overview.html">config/dawn/ directory</a>', "dawn_spice_ik_detect.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/dawn/dawn_spice_ik_detect.html#dawn_spice_ik_detect", "dawn_spice_ik_detect", 'routine in <a href="config/dawn/dawn_spice_ik_detect.html">dawn_spice_ik_detect.pro</a>', "dawn_spice_ik_detect.pro", "", "dawn_spice_ik_detect", "", "sctimestrictallddkpath", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/dawn/dawn_spice_input.html", "dawn_spice_input.pro", '.pro file in <a href="config/dawn/dir-overview.html">config/dawn/ directory</a>', "dawn_spice_input.pro", "", "", " NAME: 	dawn_spice_input    PURPOSE: 	NAIF/SPICE input translator for Dawn.    CATEGORY: 	NV/CONFIG    CALLING SEQUENCE: 	result = dawn_spice_input(dd, keyword)    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	keyword:	String giving the name of the translator quantity.     OUTPUT: 	NONE    KEYWORDS:   INPUT: 	key1:		Camera descriptor.    OUTPUT: 	status:		Zero if valid data is returned.     TRANSLATOR KEYWORDS: 	ref:		Name of the reference frame for the output quantities. 			Default is 'j2000'.  	j2000:		/j2000 is equivalent to specifying ref=j2000.  	b1950:		/b1950 is equivalent to specifying ref=b1950.  	klist:		Name of a file giving a list of SPICE kernels to use. 			If no path is included, the path is taken from the 			NV_SPICE_KER environment variable.  	ck_in:		List of input C kernel files to use.  List must be 			delineated by semimcolons with no space.  The kernel 			list file is still used, but these kernels take 			precedence.  Entries in this list may be file 			specification strings.  	planets:	List of planets to for which to request ephemeris. 			Must be delineated by semicolons with no space.  	reload:		If set, new kernels are loaded, as specified by the 			klist and ck_in keywords.    RETURN: 	Data associated with the requested keyword.    STATUS: 	Complete    SEE ALSO: 	dawn_spice_output    MODIFICATION HISTORY:  	Written by:	Spitale, 10/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/dawn/dawn_spice_input.html#dawn_spice_parse_labels", "dawn_spice_parse_labels", 'routine in <a href="config/dawn/dawn_spice_input.html">dawn_spice_input.pro</a>', "dawn_spice_input.pro", "", "dawn_spice_parse_labels", "", "sizesizefiltersoaxistargetdd_time", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/dawn/dawn_spice_input.html#dawn_spice_cameras", "dawn_spice_cameras", 'routine in <a href="config/dawn/dawn_spice_input.html">dawn_spice_input.pro</a>', "dawn_spice_input.pro", "", "dawn_spice_cameras", "", "posconstantsn_objdimstatustimeorientobsddref", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/dawn/dawn_spice_input.html#dawn_spice_planets", "dawn_spice_planets", 'routine in <a href="config/dawn/dawn_spice_input.html">dawn_spice_input.pro</a>', "dawn_spice_input.pro", "", "dawn_spice_planets", "", "timeplanetsn_objdimstatustarg_listconstantsobsddref", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/dawn/dawn_spice_input.html#dawn_spice_sun", "dawn_spice_sun", 'routine in <a href="config/dawn/dawn_spice_input.html">dawn_spice_input.pro</a>', "dawn_spice_input.pro", "", "dawn_spice_sun", "", "n_objdimconstantsstatustimeobsddref", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/dawn/dawn_spice_input.html#dawn_spice_input", "dawn_spice_input", 'routine in <a href="config/dawn/dawn_spice_input.html">dawn_spice_input.pro</a>', "dawn_spice_input.pro", "", "dawn_spice_input", "", "valuesstatusddkeyword@nv_trs_keywords_include.pro", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/dawn/dawn_spice_output.html", "dawn_spice_output.pro", '.pro file in <a href="config/dawn/dir-overview.html">config/dawn/ directory</a>', "dawn_spice_output.pro", "", "", " NAME: 	dawn_spice_output    PURPOSE: 	NAIF/SPICE output translator for Dawn.    CATEGORY: 	NV/CONFIG    CALLING SEQUENCE(only to be called by nv_xx_value): 	dawn_spice_output, dd, keyword, value    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	keyword:	String giving the name of the translator quantity.  	value:		The data to write.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	key1:		Camera descriptor.    OUTPUT: 	status:		Zero unless a problem occurs.     TRANSLATOR KEYWORDS: 	ref:		Name of the reference frame for the input quantities. 			Default is 'j2000'.  	j2000:		/j2000 is equivalent to specifying ref=j2000.  	b1950:		/b1950 is equivalent to specifying ref=b1950.  	ck_out:		String giving the name of the new C-kernel to write.    STATUS: 	Complete    SEE ALSO: 	dawn_spice_input    MODIFICATION HISTORY:  	Written by:	Spitale, 10/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/dawn/dawn_spice_output.html#dawn_spice_write_cameras", "dawn_spice_write_cameras", 'routine in <a href="config/dawn/dawn_spice_output.html">dawn_spice_output.pro</a>', "dawn_spice_output.pro", "", "dawn_spice_write_cameras", "", "reloadn_objdimstatusddvaluerefck_file", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/dawn/dawn_spice_output.html#dawn_spice_output", "dawn_spice_output", 'routine in <a href="config/dawn/dawn_spice_output.html">dawn_spice_output.pro</a>', "dawn_spice_output.pro", "", "dawn_spice_output", "", "statusddkeywordvalue@nv_trs_keywords_include.pro", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/dawn/dawn_spice_sc.html", "dawn_spice_sc.pro", '.pro file in <a href="config/dawn/dir-overview.html">config/dawn/ directory</a>', "dawn_spice_sc.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/dawn/dawn_spice_sc.html#dawn_spice_sc", "dawn_spice_sc", 'routine in <a href="config/dawn/dawn_spice_sc.html">dawn_spice_sc.pro</a>', "dawn_spice_sc.pro", "", "dawn_spice_sc", "", "dd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/dawn/dawn_spice_scale.html", "dawn_spice_scale.pro", '.pro file in <a href="config/dawn/dir-overview.html">config/dawn/ directory</a>', "dawn_spice_scale.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/dawn/dawn_spice_scale.html#dawn_spice_scale", "dawn_spice_scale", 'routine in <a href="config/dawn/dawn_spice_scale.html">dawn_spice_scale.pro</a>', "dawn_spice_scale.pro", "", "dawn_spice_scale", "", "inst", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/dawn/dawn_spice_sck_detect.html", "dawn_spice_sck_detect.pro", '.pro file in <a href="config/dawn/dir-overview.html">config/dawn/ directory</a>', "dawn_spice_sck_detect.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/dawn/dawn_spice_sck_detect.html#dawn_spice_sck_detect", "dawn_spice_sck_detect", 'routine in <a href="config/dawn/dawn_spice_sck_detect.html">dawn_spice_sck_detect.pro</a>', "dawn_spice_sck_detect.pro", "", "dawn_spice_sck_detect", "", "sctimestrictallddkpath", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/dawn/dawn_spice_sct2et.html", "dawn_spice_sct2et.pro", '.pro file in <a href="config/dawn/dir-overview.html">config/dawn/ directory</a>', "dawn_spice_sct2et.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/dawn/dawn_spice_sct2et.html#dawn_spice_sct2et", "dawn_spice_sct2et", 'routine in <a href="config/dawn/dawn_spice_sct2et.html">dawn_spice_sct2et.pro</a>', "dawn_spice_sct2et.pro", "", "dawn_spice_sct2et", "", "ddtimes", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/dawn/dawn_spice_spk_detect.html", "dawn_spice_spk_detect.pro", '.pro file in <a href="config/dawn/dir-overview.html">config/dawn/ directory</a>', "dawn_spice_spk_detect.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/dawn/dawn_spice_spk_detect.html#dawn_spice_spk_components", "dawn_spice_spk_components", 'routine in <a href="config/dawn/dawn_spice_spk_detect.html">dawn_spice_spk_detect.pro</a>', "dawn_spice_spk_detect.pro", "", "dawn_spice_spk_components", "", "jd_startjd_stopjd_releaseall_names", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/dawn/dawn_spice_spk_detect.html#dawn_spice_spk_detect", "dawn_spice_spk_detect", 'routine in <a href="config/dawn/dawn_spice_spk_detect.html">dawn_spice_spk_detect.pro</a>', "dawn_spice_spk_detect.pro", "", "dawn_spice_spk_detect", "", "scdjdtimeallstrictddspkpath", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/dawn/dawn_spice_time.html", "dawn_spice_time.pro", '.pro file in <a href="config/dawn/dir-overview.html">config/dawn/ directory</a>', "dawn_spice_time.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/dawn/dawn_spice_time.html#dawn_spice_time", "dawn_spice_time", 'routine in <a href="config/dawn/dawn_spice_time.html">dawn_spice_time.pro</a>', "dawn_spice_time.pro", "", "dawn_spice_time", "", "dtstringlabel", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/dawn/dawn_to_ominas.html", "dawn_to_ominas.pro", '.pro file in <a href="config/dawn/dir-overview.html">config/dawn/ directory</a>', "dawn_to_ominas.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/dawn/dawn_to_ominas.html#dawn_to_ominas", "dawn_to_ominas", 'routine in <a href="config/dawn/dawn_to_ominas.html">dawn_to_ominas.pro</a>', "dawn_to_ominas.pro", "", "dawn_to_ominas", "", "odorient_fn", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/dd/dd_add.html", "dd_add.pro", '.pro file in <a href="util/dd/dir-overview.html">util/dd/ directory</a>', "dd_add.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/dd/dd_add.html#dd_add", "dd_add", 'routine in <a href="util/dd/dd_add.html">dd_add.pro</a>', "dd_add.pro", "", "dd_add", "", "aabb", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/dd/dd_div.html", "dd_div.pro", '.pro file in <a href="util/dd/dir-overview.html">util/dd/ directory</a>', "dd_div.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/dd/dd_div.html#dd_div", "dd_div", 'routine in <a href="util/dd/dd_div.html">dd_div.pro</a>', "dd_div.pro", "", "dd_div", "", "aabb", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/dd/dd_div.html#___dd_div", "___dd_div", 'routine in <a href="util/dd/dd_div.html">dd_div.pro</a>', "dd_div.pro", "", "___dd_div", "", "aabb", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/dd/dd_errsum.html", "dd_errsum.pro", '.pro file in <a href="util/dd/dir-overview.html">util/dd/ directory</a>', "dd_errsum.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/dd/dd_errsum.html#dd_errsum", "dd_errsum", 'routine in <a href="util/dd/dd_errsum.html">dd_errsum.pro</a>', "dd_errsum.pro", "", "dd_errsum", "", "exy", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/dd/dd_mult.html", "dd_mult.pro", '.pro file in <a href="util/dd/dir-overview.html">util/dd/ directory</a>', "dd_mult.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/dd/dd_mult.html#dd_mult", "dd_mult", 'routine in <a href="util/dd/dd_mult.html">dd_mult.pro</a>', "dd_mult.pro", "", "dd_mult", "", "aabb", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/dd/dd_mult_d_dd.html", "dd_mult_d_dd.pro", '.pro file in <a href="util/dd/dir-overview.html">util/dd/ directory</a>', "dd_mult_d_dd.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/dd/dd_mult_d_dd.html#dd_mult_dd_d", "dd_mult_dd_d", 'routine in <a href="util/dd/dd_mult_d_dd.html">dd_mult_d_dd.pro</a>', "dd_mult_d_dd.pro", "", "dd_mult_dd_d", "", "aab", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/dd/dd_mult_dd_d.html", "dd_mult_dd_d.pro", '.pro file in <a href="util/dd/dir-overview.html">util/dd/ directory</a>', "dd_mult_dd_d.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/dd/dd_mult_dd_d.html#dd_mult_dd_d", "dd_mult_dd_d", 'routine in <a href="util/dd/dd_mult_dd_d.html">dd_mult_dd_d.pro</a>', "dd_mult_dd_d.pro", "", "dd_mult_dd_d", "", "aab", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/dd/dd_neg.html", "dd_neg.pro", '.pro file in <a href="util/dd/dir-overview.html">util/dd/ directory</a>', "dd_neg.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/dd/dd_neg.html#dd_neg", "dd_neg", 'routine in <a href="util/dd/dd_neg.html">dd_neg.pro</a>', "dd_neg.pro", "", "dd_neg", "", "aa", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/dd/dd_prod.html", "dd_prod.pro", '.pro file in <a href="util/dd/dir-overview.html">util/dd/ directory</a>', "dd_prod.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/dd/dd_prod.html#dd_prod", "dd_prod", 'routine in <a href="util/dd/dd_prod.html">dd_prod.pro</a>', "dd_prod.pro", "", "dd_prod", "", "xxyy", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/dd/dd_quick_two_sum.html", "dd_quick_two_sum.pro", '.pro file in <a href="util/dd/dir-overview.html">util/dd/ directory</a>', "dd_quick_two_sum.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/dd/dd_quick_two_sum.html#dd_quick_two_sum", "dd_quick_two_sum", 'routine in <a href="util/dd/dd_quick_two_sum.html">dd_quick_two_sum.pro</a>', "dd_quick_two_sum.pro", "", "dd_quick_two_sum", "", "eab", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/dd/dd_quotient.html", "dd_quotient.pro", '.pro file in <a href="util/dd/dir-overview.html">util/dd/ directory</a>', "dd_quotient.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/dd/dd_quotient.html#dd_quotient", "dd_quotient", 'routine in <a href="util/dd/dd_quotient.html">dd_quotient.pro</a>', "dd_quotient.pro", "", "dd_quotient", "", "xxyy", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/dd/dd_real.html", "dd_real.pro", '.pro file in <a href="util/dd/dir-overview.html">util/dd/ directory</a>', "dd_real.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/dd/dd_real.html#dd_real", "dd_real", 'routine in <a href="util/dd/dd_real.html">dd_real.pro</a>', "dd_real.pro", "", "dd_real", "", "ab", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/dd/dd_reduce.html", "dd_reduce.pro", '.pro file in <a href="util/dd/dir-overview.html">util/dd/ directory</a>', "dd_reduce.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/dd/dd_reduce.html#dd_reduce", "dd_reduce", 'routine in <a href="util/dd/dd_reduce.html">dd_reduce.pro</a>', "dd_reduce.pro", "", "dd_reduce", "", "aa", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/dd/dd_renorm.html", "dd_renorm.pro", '.pro file in <a href="util/dd/dir-overview.html">util/dd/ directory</a>', "dd_renorm.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/dd/dd_renorm.html#dd_renorm", "dd_renorm", 'routine in <a href="util/dd/dd_renorm.html">dd_renorm.pro</a>', "dd_renorm.pro", "", "dd_renorm", "", "x0x1x2", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/dd/dd_split.html", "dd_split.pro", '.pro file in <a href="util/dd/dir-overview.html">util/dd/ directory</a>', "dd_split.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/dd/dd_split.html#dd_split", "dd_split", 'routine in <a href="util/dd/dd_split.html">dd_split.pro</a>', "dd_split.pro", "", "dd_split", "", "a", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/dd/dd_split.html#dd_split", "dd_split", 'routine in <a href="util/dd/dd_split.html">dd_split.pro</a>', "dd_split.pro", "", "dd_split", "", "a", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/dd/dd_square.html", "dd_square.pro", '.pro file in <a href="util/dd/dir-overview.html">util/dd/ directory</a>', "dd_square.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/dd/dd_square.html#dd_square", "dd_square", 'routine in <a href="util/dd/dd_square.html">dd_square.pro</a>', "dd_square.pro", "", "dd_square", "", "aa", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/dd/dd_two_prod.html", "dd_two_prod.pro", '.pro file in <a href="util/dd/dir-overview.html">util/dd/ directory</a>', "dd_two_prod.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/dd/dd_two_prod.html#dd_two_prod", "dd_two_prod", 'routine in <a href="util/dd/dd_two_prod.html">dd_two_prod.pro</a>', "dd_two_prod.pro", "", "dd_two_prod", "", "eab", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/dd/dd_two_sum.html", "dd_two_sum.pro", '.pro file in <a href="util/dd/dir-overview.html">util/dd/ directory</a>', "dd_two_sum.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/dd/dd_two_sum.html#dd_two_sum", "dd_two_sum", 'routine in <a href="util/dd/dd_two_sum.html">dd_two_sum.pro</a>', "dd_two_sum.pro", "", "dd_two_sum", "", "eab", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/ddmmmyyyy_to_jd.html", "ddmmmyyyy_to_jd.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "ddmmmyyyy_to_jd.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/ddmmmyyyy_to_jd.html#ddmmmyyyy_to_jd", "ddmmmyyyy_to_jd", 'routine in <a href="util/ddmmmyyyy_to_jd.html">ddmmmyyyy_to_jd.pro</a>', "ddmmmyyyy_to_jd.pro", "", "ddmmmyyyy_to_jd", "", "ddmmmyyyy", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/decrapify.html", "decrapify.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "decrapify.pro", "", "", " NAME:        decrapify   PURPOSE:        Circumvents a quirk of idl, returns first value of input if number        of elements in array is 1.    CATEGORY:        UTIL    CALLING SEQUENCE:        result = decrapify(val)    ARGUMENTS:   INPUT:        val:  An array.    OUTPUT:        NONE   RETURN:        val unchanged, unless n_elements(val) equals 1, if so, returns        val[0]   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/decrapify.html#decrapify", "decrapify", 'routine in <a href="util/decrapify.html">decrapify.pro</a>', "decrapify.pro", "", "decrapify", "", "val", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/defined.html", "defined.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "defined.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/defined.html#defined", "defined", 'routine in <a href="util/defined.html">defined.pro</a>', "defined.pro", "", "defined", "", "val", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/defval.html", "defval.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "defval.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/defval.html#defval", "defval", 'routine in <a href="util/defval.html">defval.pro</a>', "defval.pro", "", "defval", "", "valuedefault_value", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/deg_to_degmmss.html", "deg_to_degmmss.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "deg_to_degmmss.pro", "", "", " NAME: 	xx    PURPOSE: 	xx    CATEGORY: 	UTIL    CALLING SEQUENCE: 	result = xx(xx, xx) 	xx, xx, xx    ARGUMENTS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    KEYWORDS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    RETURN: 	xx    COMMON BLOCKS: 	xx:	xx  	xx:	xx    SIDE EFFECTS: 	xx    RESTRICTIONS: 	xx    PROCEDURE: 	xx    EXAMPLE: 	xx    STATUS: 	xx    SEE ALSO: 	xx, xx, xx    MODIFICATION HISTORY:  	Written by:	xx, xx/xx/xxxx   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/deg_to_degmmss.html#deg_to_degmmss", "deg_to_degmmss", 'routine in <a href="util/deg_to_degmmss.html">deg_to_degmmss.pro</a>', "deg_to_degmmss.pro", "", "deg_to_degmmss", "", "degminsec_deg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/deg_to_hhmmss.html", "deg_to_hhmmss.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "deg_to_hhmmss.pro", "", "", " NAME: 	xx    PURPOSE: 	xx    CATEGORY: 	UTIL    CALLING SEQUENCE: 	result = xx(xx, xx) 	xx, xx, xx    ARGUMENTS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    KEYWORDS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    RETURN: 	xx    COMMON BLOCKS: 	xx:	xx  	xx:	xx    SIDE EFFECTS: 	xx    RESTRICTIONS: 	xx    PROCEDURE: 	xx    EXAMPLE: 	xx    STATUS: 	xx    SEE ALSO: 	xx, xx, xx    MODIFICATION HISTORY:  	Written by:	xx, xx/xx/xxxx   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/deg_to_hhmmss.html#deg_to_hhmmss", "deg_to_hhmmss", 'routine in <a href="util/deg_to_hhmmss.html">deg_to_hhmmss.pro</a>', "deg_to_hhmmss.pro", "", "deg_to_hhmmss", "", "hoursminsecdeg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/degen.html", "degen.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "degen.pro", "", "", " NAME:        degen   PURPOSE:        Removes degenerate trailing dimensions.    CATEGORY:        UTIL    CALLING SEQUENCE:        result = degen(array)    ARGUMENTS:   INPUT:        array:  An array.    OUTPUT:        NONE    RETURN:        Array, with any trailing dimensions of length 1 removed.    SIDE EFFECTS: 	The input array is modified.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale; 6/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/degen.html#degen", "degen", 'routine in <a href="util/degen.html">degen.pro</a>', "degen.pro", "", "degen", "", "array", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/degen_array.html", "degen_array.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "degen_array.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/degen_array.html#degen_array", "degen_array", 'routine in <a href="util/degen_array.html">degen_array.pro</a>', "degen_array.pro", "", "degen_array", "", "array", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/degmmss_to_deg.html", "degmmss_to_deg.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "degmmss_to_deg.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/degmmss_to_deg.html#degmmss_to_deg", "degmmss_to_deg", 'routine in <a href="util/degmmss_to_deg.html">degmmss_to_deg.pro</a>', "degmmss_to_deg.pro", "", "degmmss_to_deg", "", "degmmss", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/delete_file.html", "delete_file.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "delete_file.pro", "", "", " NAME: 	delete_file    PURPOSE: 	Deletes the specified file.    CATEGORY: 	UTIL    CALLING SEQUENCE: 	delete_file, fname    ARGUMENTS:   INPUT: 	fname:	Name of file to delete    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 11/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/delete_file.html#delete_file", "delete_file", 'routine in <a href="util/delete_file.html">delete_file.pro</a>', "delete_file.pro", "", "delete_file", "", "fname", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/downloader/delete_ominas_files.html", "delete_ominas_files.pro", '.pro file in <a href="util/downloader/dir-overview.html">util/downloader/ directory</a>', "delete_ominas_files.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/downloader/delete_ominas_files.html#delete_ominas_files", "delete_ominas_files", 'routine in <a href="util/downloader/delete_ominas_files.html">delete_ominas_files.pro</a>', "delete_ominas_files.pro", "", "delete_ominas_files", "", "confdir", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/despike.html", "despike.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "despike.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/despike.html#despike", "despike", 'routine in <a href="util/despike.html">despike.pro</a>', "despike.pro", "", "despike", "", "scalenweight_imagep", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/detectors/detect_cas_iss.html", "detect_cas_iss.pro", '.pro file in <a href="config/cas/detectors/dir-overview.html">config/cas/detectors/ directory</a>', "detect_cas_iss.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/detectors/detect_cas_iss.html#detect_cas_iss", "detect_cas_iss", 'routine in <a href="config/cas/detectors/detect_cas_iss.html">detect_cas_iss.pro</a>', "detect_cas_iss.pro", "", "detect_cas_iss", "", "dd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/detectors/detect_cas_radar.html", "detect_cas_radar.pro", '.pro file in <a href="config/cas/detectors/dir-overview.html">config/cas/detectors/ directory</a>', "detect_cas_radar.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/detectors/detect_cas_radar.html#detect_cas_radar", "detect_cas_radar", 'routine in <a href="config/cas/detectors/detect_cas_radar.html">detect_cas_radar.pro</a>', "detect_cas_radar.pro", "", "detect_cas_radar", "", "dd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/detectors/detect_cas_uvis.html", "detect_cas_uvis.pro", '.pro file in <a href="config/cas/detectors/dir-overview.html">config/cas/detectors/ directory</a>', "detect_cas_uvis.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/detectors/detect_cas_uvis.html#detect_cas_uvis", "detect_cas_uvis", 'routine in <a href="config/cas/detectors/detect_cas_uvis.html">detect_cas_uvis.pro</a>', "detect_cas_uvis.pro", "", "detect_cas_uvis", "", "dd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/detectors/detect_cas_vims.html", "detect_cas_vims.pro", '.pro file in <a href="config/cas/detectors/dir-overview.html">config/cas/detectors/ directory</a>', "detect_cas_vims.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/detectors/detect_cas_vims.html#detect_cas_vims", "detect_cas_vims", 'routine in <a href="config/cas/detectors/detect_cas_vims.html">detect_cas_vims.pro</a>', "detect_cas_vims.pro", "", "detect_cas_vims", "", "dd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/detectors/detect_ctio.html", "detect_ctio.pro", '.pro file in <a href="config/detectors/dir-overview.html">config/detectors/ directory</a>', "detect_ctio.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/detectors/detect_ctio.html#detect_ctio", "detect_ctio", 'routine in <a href="config/detectors/detect_ctio.html">detect_ctio.pro</a>', "detect_ctio.pro", "", "detect_ctio", "", "dd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/dawn/detectors/detect_dawn.html", "detect_dawn.pro", '.pro file in <a href="config/dawn/detectors/dir-overview.html">config/dawn/detectors/ directory</a>', "detect_dawn.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/dawn/detectors/detect_dawn.html#detect_dawn", "detect_dawn", 'routine in <a href="config/dawn/detectors/detect_dawn.html">detect_dawn.pro</a>', "detect_dawn.pro", "", "detect_dawn", "", "dd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dh/util/detect_dh.html", "detect_dh.pro", '.pro file in <a href="nv/obj/dat/dh/util/dir-overview.html">nv/obj/dat/dh/util/ directory</a>', "detect_dh.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dh/util/detect_dh.html#detect_dh", "detect_dh", 'routine in <a href="nv/obj/dat/dh/util/detect_dh.html">detect_dh.pro</a>', "detect_dh.pro", "", "detect_dh", "", "ddudata", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/ext/detect_ext.html", "detect_ext.pro", '.pro file in <a href="config/ext/dir-overview.html">config/ext/ directory</a>', "detect_ext.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/ext/detect_ext.html#detect_ext", "detect_ext", 'routine in <a href="config/ext/detect_ext.html">detect_ext.pro</a>', "detect_ext.pro", "", "detect_ext", "", "dd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/fits/detect_fits.html", "detect_fits.pro", '.pro file in <a href="config/fits/dir-overview.html">config/fits/ directory</a>', "detect_fits.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/fits/detect_fits.html#detect_fits", "detect_fits", 'routine in <a href="config/fits/detect_fits.html">detect_fits.pro</a>', "detect_fits.pro", "", "detect_fits", "", "dd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/gll/detectors/detect_gll_ssi.html", "detect_gll_ssi.pro", '.pro file in <a href="config/gll/detectors/dir-overview.html">config/gll/detectors/ directory</a>', "detect_gll_ssi.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/gll/detectors/detect_gll_ssi.html#detect_gll_ssi", "detect_gll_ssi", 'routine in <a href="config/gll/detectors/detect_gll_ssi.html">detect_gll_ssi.pro</a>', "detect_gll_ssi.pro", "", "detect_gll_ssi", "", "dd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/isis/detect_isis.html", "detect_isis.pro", '.pro file in <a href="config/isis/dir-overview.html">config/isis/ directory</a>', "detect_isis.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/isis/detect_isis.html#detect_isis", "detect_isis", 'routine in <a href="config/isis/detect_isis.html">detect_isis.pro</a>', "detect_isis.pro", "", "detect_isis", "", "dd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/detectors/detect_map.html", "detect_map.pro", '.pro file in <a href="config/detectors/dir-overview.html">config/detectors/ directory</a>', "detect_map.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/detectors/detect_map.html#detect_map", "detect_map", 'routine in <a href="config/detectors/detect_map.html">detect_map.pro</a>', "detect_map.pro", "", "detect_map", "", "dd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/mask/detect_mask.html", "detect_mask.pro", '.pro file in <a href="config/mask/dir-overview.html">config/mask/ directory</a>', "detect_mask.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/mask/detect_mask.html#detect_mask", "detect_mask", 'routine in <a href="config/mask/detect_mask.html">detect_mask.pro</a>', "detect_mask.pro", "", "detect_mask", "", "dd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/detectors/detect_mirac.html", "detect_mirac.pro", '.pro file in <a href="config/detectors/dir-overview.html">config/detectors/ directory</a>', "detect_mirac.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/detectors/detect_mirac.html#detect_mirac", "detect_mirac", 'routine in <a href="config/detectors/detect_mirac.html">detect_mirac.pro</a>', "detect_mirac.pro", "", "detect_mirac", "", "dd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/multi/detect_multi.html", "detect_multi.pro", '.pro file in <a href="config/multi/dir-overview.html">config/multi/ directory</a>', "detect_multi.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/multi/detect_multi.html#detect_multi", "detect_multi", 'routine in <a href="config/multi/detect_multi.html">detect_multi.pro</a>', "detect_multi.pro", "", "detect_multi", "", "dd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/occ/detect_occ.html", "detect_occ.pro", '.pro file in <a href="config/occ/dir-overview.html">config/occ/ directory</a>', "detect_occ.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/occ/detect_occ.html#detect_occ", "detect_occ", 'routine in <a href="config/occ/detect_occ.html">detect_occ.pro</a>', "detect_occ.pro", "", "detect_occ", "", "dd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/pds/detect_pds.html", "detect_pds.pro", '.pro file in <a href="config/pds/dir-overview.html">config/pds/ directory</a>', "detect_pds.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/pds/detect_pds.html#detect_pds", "detect_pds", 'routine in <a href="config/pds/detect_pds.html">detect_pds.pro</a>', "detect_pds.pro", "", "detect_pds", "", "dd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/detectors/detect_spdr.html", "detect_spdr.pro", '.pro file in <a href="config/detectors/dir-overview.html">config/detectors/ directory</a>', "detect_spdr.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/detectors/detect_spdr.html#detect_spdr", "detect_spdr", 'routine in <a href="config/detectors/detect_spdr.html">detect_spdr.pro</a>', "detect_spdr.pro", "", "detect_spdr", "", "dd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/tdl/detect_tdl.html", "detect_tdl.pro", '.pro file in <a href="config/tdl/dir-overview.html">config/tdl/ directory</a>', "detect_tdl.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/tdl/detect_tdl.html#detect_tdl", "detect_tdl", 'routine in <a href="config/tdl/detect_tdl.html">detect_tdl.pro</a>', "detect_tdl.pro", "", "detect_tdl", "", "dd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/vgr/detectors/detect_vgr.html", "detect_vgr.pro", '.pro file in <a href="config/vgr/detectors/dir-overview.html">config/vgr/detectors/ directory</a>', "detect_vgr.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/vgr/detectors/detect_vgr.html#detect_vgr", "detect_vgr", 'routine in <a href="config/vgr/detectors/detect_vgr.html">detect_vgr.pro</a>', "detect_vgr.pro", "", "detect_vgr", "", "labeludata", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/vgr/detectors/detect_vgr_cd.html", "detect_vgr_cd.pro", '.pro file in <a href="config/vgr/detectors/dir-overview.html">config/vgr/detectors/ directory</a>', "detect_vgr_cd.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/vgr/detectors/detect_vgr_cd.html#detect_vgr_cd", "detect_vgr_cd", 'routine in <a href="config/vgr/detectors/detect_vgr_cd.html">detect_vgr_cd.pro</a>', "detect_vgr_cd.pro", "", "detect_vgr_cd", "", "dd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/vgr/detectors/detect_vgr_iss.html", "detect_vgr_iss.pro", '.pro file in <a href="config/vgr/detectors/dir-overview.html">config/vgr/detectors/ directory</a>', "detect_vgr_iss.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/vgr/detectors/detect_vgr_iss.html#detect_vgr_iss", "detect_vgr_iss", 'routine in <a href="config/vgr/detectors/detect_vgr_iss.html">detect_vgr_iss.pro</a>', "detect_vgr_iss.pro", "", "detect_vgr_iss", "", "dd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/vgr/detectors/detect_vgr_pps.html", "detect_vgr_pps.pro", '.pro file in <a href="config/vgr/detectors/dir-overview.html">config/vgr/detectors/ directory</a>', "detect_vgr_pps.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/vgr/detectors/detect_vgr_pps.html#detect_vgr_pps", "detect_vgr_pps", 'routine in <a href="config/vgr/detectors/detect_vgr_pps.html">detect_vgr_pps.pro</a>', "detect_vgr_pps.pro", "", "detect_vgr_pps", "", "dd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/vgr/detectors/detect_vgr_rss.html", "detect_vgr_rss.pro", '.pro file in <a href="config/vgr/detectors/dir-overview.html">config/vgr/detectors/ directory</a>', "detect_vgr_rss.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/vgr/detectors/detect_vgr_rss.html#detect_vgr_rss", "detect_vgr_rss", 'routine in <a href="config/vgr/detectors/detect_vgr_rss.html">detect_vgr_rss.pro</a>', "detect_vgr_rss.pro", "", "detect_vgr_rss", "", "dd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/vicar/detect_vicar.html", "detect_vicar.pro", '.pro file in <a href="config/vicar/dir-overview.html">config/vicar/ directory</a>', "detect_vicar.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/vicar/detect_vicar.html#detect_vicar", "detect_vicar", 'routine in <a href="config/vicar/detect_vicar.html">detect_vicar.pro</a>', "detect_vicar.pro", "", "detect_vicar", "", "dd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/device_cursor_scan.html", "device_cursor_scan.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "device_cursor_scan.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/device_cursor_scan.html#device_cursor_scan", "device_cursor_scan", 'routine in <a href="util/device_cursor_scan.html">device_cursor_scan.pro</a>', "device_cursor_scan.pro", "", "device_cursor_scan", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/device_to_data.html", "device_to_data.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "device_to_data.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/device_to_data.html#device_to_data", "device_to_data", 'routine in <a href="util/device_to_data.html">device_to_data.pro</a>', "device_to_data.pro", "", "device_to_data", "", "p", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dh/util/dh_create.html", "dh_create.pro", '.pro file in <a href="nv/obj/dat/dh/util/dir-overview.html">nv/obj/dat/dh/util/ directory</a>', "dh_create.pro", "", "", " NAME: 	dh_create    PURPOSE: 	Creates a minimal detached header.    CATEGORY: 	UTIL/DH    CALLING SEQUENCE: 	result = dh_create()    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	String array in which each element is a line of the detached header.    PROCEDURE: 	dh_create creates a detached header containing a history line and 	the '<updates>' separator.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dh/util/dh_create.html#dh_create", "dh_create", 'routine in <a href="nv/obj/dat/dh/util/dh_create.html">dh_create.pro</a>', "dh_create.pro", "", "dh_create", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dh/util/dh_create_section.html", "dh_create_section.pro", '.pro file in <a href="nv/obj/dat/dh/util/dir-overview.html">nv/obj/dat/dh/util/ directory</a>', "dh_create_section.pro", "", "", " NAME: 	dh_create_section    PURPOSE: 	Creates a minimal detached header section.    CATEGORY: 	UTIL/DH    CALLING SEQUENCE: 	result = dh_create_section(section)    ARGUMENTS:   INPUT: 	section:	Name of section to create.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	String array in which each element is a line of the new section.     STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 12/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dh/util/dh_create_section.html#dh_create_section", "dh_create_section", 'routine in <a href="nv/obj/dat/dh/util/dh_create_section.html">dh_create_section.pro</a>', "dh_create_section.pro", "", "dh_create_section", "", "section", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dh/util/dh_field_name.html", "dh_field_name.pro", '.pro file in <a href="nv/obj/dat/dh/util/dir-overview.html">nv/obj/dat/dh/util/ directory</a>', "dh_field_name.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dh/util/dh_field_name.html#dh_field_name", "dh_field_name", 'routine in <a href="nv/obj/dat/dh/util/dh_field_name.html">dh_field_name.pro</a>', "dh_field_name.pro", "", "dh_field_name", "", "fieldprefix", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dh/util/dh_fname.html", "dh_fname.pro", '.pro file in <a href="nv/obj/dat/dh/util/dir-overview.html">nv/obj/dat/dh/util/ directory</a>', "dh_fname.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dh/util/dh_fname.html#dhfn_findfile", "dhfn_findfile", 'routine in <a href="nv/obj/dat/dh/util/dh_fname.html">dh_fname.pro</a>', "dh_fname.pro", "", "dhfn_findfile", "", "dirnameext", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dh/util/dh_fname.html#dh_fname", "dh_fname", 'routine in <a href="nv/obj/dat/dh/util/dh_fname.html">dh_fname.pro</a>', "dh_fname.pro", "", "dh_fname", "", "writefilename", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dh/dh_format_comment.html", "dh_format_comment.pro", '.pro file in <a href="nv/obj/dat/dh/dir-overview.html">nv/obj/dat/dh/ directory</a>', "dh_format_comment.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dh/dh_format_comment.html#dh_format_comment", "dh_format_comment", 'routine in <a href="nv/obj/dat/dh/dh_format_comment.html">dh_format_comment.pro</a>', "dh_format_comment.pro", "", "dh_format_comment", "", "formatvalue", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dh/dh_from_ominas.html", "dh_from_ominas.pro", '.pro file in <a href="nv/obj/dat/dh/dir-overview.html">nv/obj/dat/dh/ directory</a>', "dh_from_ominas.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dh/dh_from_ominas.html#dh_from_ominas", "dh_from_ominas", 'routine in <a href="nv/obj/dat/dh/dh_from_ominas.html">dh_from_ominas.pro</a>', "dh_from_ominas.pro", "", "dh_from_ominas", "", "formatvalue", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dh/util/dh_get_string.html", "dh_get_string.pro", '.pro file in <a href="nv/obj/dat/dh/util/dir-overview.html">nv/obj/dat/dh/util/ directory</a>', "dh_get_string.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dh/util/dh_get_string.html#dh_get_string", "dh_get_string", 'routine in <a href="nv/obj/dat/dh/util/dh_get_string.html">dh_get_string.pro</a>', "dh_get_string.pro", "", "dh_get_string", "", "history_indexn_objdimstatussectiondhkeyword", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dh/util/dh_get_value.html", "dh_get_value.pro", '.pro file in <a href="nv/obj/dat/dh/util/dir-overview.html">nv/obj/dat/dh/util/ directory</a>', "dh_get_value.pro", "", "", " NAME: 	dh_get_value    PURPOSE: 	Gets the value of a specified keyword.    CATEGORY: 	UTIL/DH    CALLING SEQUENCE: 	result = dh_get_value(dh, keyword)    ARGUMENTS:   INPUT: 	dh:		String giving the detached header.  	keyword:	String giving the keyword whose value is to be obtained.    OUTPUT: NONE    KEYWORDS:   INPUT: 	n_match:	Maximum number of matches to return.  If not given, 			all matches are returned.  	all_match:	If set, match all occurrences.  	all_object:	If set, match all object indices.  If not set, then 			match only object index 0.  	all_history:	If set, match all history indices.  If not set, then 			only the highest history index is matched.  	object_index:	If given, then match only this object index.  	history_index:	If given, then match only this history index.  	prefix:		If set, then match any keyword that begins with the 			given keyword string instead of requiring an exact 			match.  	section:	Name of detached header section from which to read the 			data.  If not specified, the data is read from the 			'updates' section.     OUTPUT: 	count:		Integer giving the numebr of keywords matched.  	match_keys:	String array giving the names of the keywords that were 			matched.  	match_objects:	Array giving the object index for each keyword returned 			in match_keywords.  	match_hist:	Array giving the history index for each keyword returned 			in match_keywords.    RETURN: 	Array giving values for all matching keywords.  The type of array is 	determined by the value found in the detached header.  Strings are 	returned as strings, numeric values are converted to double.    STATUS: 	Complete    SEE ALSO: 	dh_put_value, dh_rm_value    MODIFICATION HISTORY:  	Written by:	Spitale, 7/1998 	Added 'section' keyword: Spitale; 11/2001   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dh/util/dh_get_value.html#dhgv_convert_value", "dhgv_convert_value", 'routine in <a href="nv/obj/dat/dh/util/dh_get_value.html">dh_get_value.pro</a>', "dh_get_value.pro", "", "dhgv_convert_value", "", "val", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dh/util/dh_get_value.html#dh_get_value", "dh_get_value", 'routine in <a href="nv/obj/dat/dh/util/dh_get_value.html">dh_get_value.pro</a>', "dh_get_value.pro", "", "dh_get_value", "", "n_matchall_matchall_objectall_historymatch_keyscountmatch_objectsmatch_historiesobject_indexhistory_indexprefixsection_dhkeyword", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/pds/dh_pdspar.html", "dh_pdspar.pro", '.pro file in <a href="config/pds/dir-overview.html">config/pds/ directory</a>', "dh_pdspar.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/pds/dh_pdspar.html#dh_pdspar", "dh_pdspar", 'routine in <a href="config/pds/dh_pdspar.html">dh_pdspar.pro</a>', "dh_pdspar.pro", "", "dh_pdspar", "", "getsetlabelkeyword", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dh/util/dh_put_value.html", "dh_put_value.pro", '.pro file in <a href="nv/obj/dat/dh/util/dir-overview.html">nv/obj/dat/dh/util/ directory</a>', "dh_put_value.pro", "", "", " NAME: 	dh_put_value    PURPOSE: 	Sets the value of a specified keyword.    CATEGORY: 	UTIL/DH    CALLING SEQUENCE: 	dh_put_value, dh, keyword, value, $                          object_index=object_index, comment=comment    ARGUMENTS:   INPUT: 	dh:		String array giving the detached header.  If undefined, 			a minimal detached header is first created.  	keyword:	String giving the keyword whose value is to be updated.  	value:		Value to associate with this keyword.    OUTPUT: 	dh:		The dh argument is modified on return.    KEYWORDS:   INPUT: 	object_index:	Object index to use for this update.  Default is 0.  	comment:	String giving optional comment.  	section:	Section in which to place the data.  If not specified, 			the data is placed in the 'updates' section.  If 			the specified section does not exist, it is created.     OUTPUT: NONE    RETURN: NONE    SIDE EFFECTS: 	See procedure below; 'utime' and 'history' keywords are modified.    PROCEDURE: 	The data is appended to the top of the specified section of the detached 	header using the given object index and a history index that is one 	greater than the current value found in the detached header for this 	keyword.  The value of the 'utime' keyword corresponding to this history 	index is modified to reflect the current time.  If this history index is 	greater than that given by the 'history' keyword, then that value is 	modified as well.  	If 'value' is an array, then each element is written on a different line 	using the keyword with the same object index, history index, and 	comment, but whose element indices reflect the order that the data 	appear in the array.  	If 'value' is of string type, then each entry is enclosed in quotes.    EXAMPLE: 	The following commands:  		IDL> val=[7,6,5,4,3] 		IDL> dh_put_value, dh, 'test_key', val  	produce the following detached header:  	 history = -1 / Current history value 	 <updates> 	 utime = 2451022.404086 / Julian day of update - Mon Jul 27 9:41:53 1998 	 test_key(0) = 7 	 test_key(1) = 6 	 test_key(2) = 5 	 test_key(3) = 4 	 test_key(4) = 3     STATUS: 	Complete    SEE ALSO: 	dh_get_value, dh_rm_value    MODIFICATION HISTORY:  	Written by:	Spitale, 7/1998 	Added 'section' keyword: Spitale; 11/2001   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dh/util/dh_put_value.html#dhpv_put", "dhpv_put", 'routine in <a href="nv/obj/dat/dh/util/dh_put_value.html">dh_put_value.pro</a>', "dh_put_value.pro", "", "dhpv_put", "", "commentarrayformatdhlinekeywordvalueelemobjhist", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dh/util/dh_put_value.html#dh_put_value", "dh_put_value", 'routine in <a href="nv/obj/dat/dh/util/dh_put_value.html">dh_put_value.pro</a>', "dh_put_value.pro", "", "dh_put_value", "", "object_indexcommentsectiondhkeywordvalue", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dh/util/dh_read.html", "dh_read.pro", '.pro file in <a href="nv/obj/dat/dh/util/dir-overview.html">nv/obj/dat/dh/util/ directory</a>', "dh_read.pro", "", "", " NAME: 	dh_read    PURPOSE: 	Reads a detached header file.    CATEGORY: 	UTIL/DH    CALLING SEQUENCE: 	result = dh_read(filename)    ARGUMENTS:   INPUT: 	filename:	Name of file to be read.    OUTPUT: NONE    KEYWORDS:   INPUT: 	buflen:		Number of lines to allocate at a time.  Default is 1000. 			The routine is faster with larger values of buflen, but 			less memory efficient.    OUTPUT: NONE    RETURN: 	String array in which each line is a line of the detached header. 	a blank detached header is created and returned if the file is 	not found.    STATUS: 	Complete    SEE ALSO: 	dh_write    MODIFICATION HISTORY:  	Written by:	Spitale, 7/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dh/util/dh_read.html#dh_read", "dh_read", 'routine in <a href="nv/obj/dat/dh/util/dh_read.html">dh_read.pro</a>', "dh_read.pro", "", "dh_read", "", "buflenfilename", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/ext/dh_read_ext.html", "dh_read_ext.pro", '.pro file in <a href="config/ext/dir-overview.html">config/ext/ directory</a>', "dh_read_ext.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/ext/dh_read_ext.html#dh_read_ext", "dh_read_ext", 'routine in <a href="config/ext/dh_read_ext.html">dh_read_ext.pro</a>', "dh_read_ext.pro", "", "dh_read_ext", "", "abscissanodatagffsamplereturned_samplesddlabeldimtypeminmax", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/fits/dh_read_fits.html", "dh_read_fits.pro", '.pro file in <a href="config/fits/dir-overview.html">config/fits/ directory</a>', "dh_read_fits.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/fits/dh_read_fits.html#dh_read_fits", "dh_read_fits", 'routine in <a href="config/fits/dh_read_fits.html">dh_read_fits.pro</a>', "dh_read_fits.pro", "", "dh_read_fits", "", "abscissanodatagffsamplereturned_samplesddlabeldimtypeminmax", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/isis/dh_read_isis.html", "dh_read_isis.pro", '.pro file in <a href="config/isis/dir-overview.html">config/isis/ directory</a>', "dh_read_isis.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/isis/dh_read_isis.html#dh_read_isis", "dh_read_isis", 'routine in <a href="config/isis/dh_read_isis.html">dh_read_isis.pro</a>', "dh_read_isis.pro", "", "dh_read_isis", "", "abscissanodatagffsamplereturned_samplesddlabeldimtypeminmax", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/mask/dh_read_mask.html", "dh_read_mask.pro", '.pro file in <a href="config/mask/dir-overview.html">config/mask/ directory</a>', "dh_read_mask.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/mask/dh_read_mask.html#dh_read_mask", "dh_read_mask", 'routine in <a href="config/mask/dh_read_mask.html">dh_read_mask.pro</a>', "dh_read_mask.pro", "", "dh_read_mask", "", "abscissanodatagffsamplereturned_samplesddheaderdimtypeminmax", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/multi/dh_read_multi.html", "dh_read_multi.pro", '.pro file in <a href="config/multi/dir-overview.html">config/multi/ directory</a>', "dh_read_multi.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/multi/dh_read_multi.html#dh_read_multi", "dh_read_multi", 'routine in <a href="config/multi/dh_read_multi.html">dh_read_multi.pro</a>', "dh_read_multi.pro", "", "dh_read_multi", "", "abscissanodatagffsamplereturned_samplesddlabeldimtypeminmax", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/occ/dh_read_occ.html", "dh_read_occ.pro", '.pro file in <a href="config/occ/dir-overview.html">config/occ/ directory</a>', "dh_read_occ.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/occ/dh_read_occ.html#dh_read_occ", "dh_read_occ", 'routine in <a href="config/occ/dh_read_occ.html">dh_read_occ.pro</a>', "dh_read_occ.pro", "", "dh_read_occ", "", "abscissanodatagffsamplereturned_samplesddlabeldimtypeminmax", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/pds/dh_read_pds.html", "dh_read_pds.pro", '.pro file in <a href="config/pds/dir-overview.html">config/pds/ directory</a>', "dh_read_pds.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/pds/dh_read_pds.html#dh_read_pds", "dh_read_pds", 'routine in <a href="config/pds/dh_read_pds.html">dh_read_pds.pro</a>', "dh_read_pds.pro", "", "dh_read_pds", "", "abscissanodatagffsamplereturned_samplesddlabeldimtypeminmax", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/tdl/dh_read_tdl.html", "dh_read_tdl.pro", '.pro file in <a href="config/tdl/dir-overview.html">config/tdl/ directory</a>', "dh_read_tdl.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/tdl/dh_read_tdl.html#dh_read_tdl", "dh_read_tdl", 'routine in <a href="config/tdl/dh_read_tdl.html">dh_read_tdl.pro</a>', "dh_read_tdl.pro", "", "dh_read_tdl", "", "abscissanodatagffsamplereturned_samplesddlabeldimtypeminmax", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/vgr_cd/dh_read_vgr_cd.html", "dh_read_vgr_cd.pro", '.pro file in <a href="config/vgr_cd/dir-overview.html">config/vgr_cd/ directory</a>', "dh_read_vgr_cd.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/vgr_cd/dh_read_vgr_cd.html#dh_read_vgr_cd", "dh_read_vgr_cd", 'routine in <a href="config/vgr_cd/dh_read_vgr_cd.html">dh_read_vgr_cd.pro</a>', "dh_read_vgr_cd.pro", "", "dh_read_vgr_cd", "", "abscissanodatagffsamplereturned_samplesddlabeldimtypeminmax", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/vicar/dh_read_vicar.html", "dh_read_vicar.pro", '.pro file in <a href="config/vicar/dir-overview.html">config/vicar/ directory</a>', "dh_read_vicar.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/vicar/dh_read_vicar.html#dh_read_vicar", "dh_read_vicar", 'routine in <a href="config/vicar/dh_read_vicar.html">dh_read_vicar.pro</a>', "dh_read_vicar.pro", "", "dh_read_vicar", "", "abscissanodatagffsamplereturned_samplesddlabeldimtypeminmax", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dh/util/dh_rm_value.html", "dh_rm_value.pro", '.pro file in <a href="nv/obj/dat/dh/util/dir-overview.html">nv/obj/dat/dh/util/ directory</a>', "dh_rm_value.pro", "", "", " NAME: 	dh_rm_value    PURPOSE: 	Deletes a specified keyword/value pair.    CATEGORY: 	UTIL/DH    CALLING SEQUENCE: 	dh_rm_value, dh, keyword    ARGUMENTS:   INPUT: 	dh:		String giving the detached header.  	keyword:	String giving the keyword to be deleted.    OUTPUT: 	dh:		dh is modified on return.     KEYWORDS:   INPUT: 	n_match:	Maximum number of matches to return.  If not given, 			all matches are returned.  	all_match:	If set, match all occurrences.  	all_object:	If set, match all object indices.  If not set, then 			match only object index 0.  	all_history:	If set, match all history indices.  If not set, 			then only the highest history index is matched.  	object_index:	If given, then match only this object index.  	history_index:	If given, then match only this history index.  	prefix:		If set, then match any keyword which begins with the 			given keyword string instead of requiring an exact 			match.    OUTPUT: 	count:		Integer giving the numebr of keywords matched.    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	dh_get_value, dh_put_value    MODIFICATION HISTORY:  	Written by:	Spitale, 7/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dh/util/dh_rm_value.html#dh_rm_value", "dh_rm_value", 'routine in <a href="nv/obj/dat/dh/util/dh_rm_value.html">dh_rm_value.pro</a>', "dh_rm_value.pro", "", "dh_rm_value", "", "n_matchall_matchall_objectall_historycountobject_indexhistory_indexprefixdhkeyword", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dh/util/dh_set.html", "dh_set.pro", '.pro file in <a href="nv/obj/dat/dh/util/dir-overview.html">nv/obj/dat/dh/util/ directory</a>', "dh_set.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dh/util/dh_set.html#dh_set", "dh_set", 'routine in <a href="nv/obj/dat/dh/util/dh_set.html">dh_set.pro</a>', "dh_set.pro", "", "dh_set", "", "dddh", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dh/dh_std_input.html", "dh_std_input.pro", '.pro file in <a href="nv/obj/dat/dh/dir-overview.html">nv/obj/dat/dh/ directory</a>', "dh_std_input.pro", "", "", " NAME: 	dh_std_input    PURPOSE: 	Input translator for detached header    CATEGORY: 	NV/CONFIG    CALLING SEQUENCE(only to be called by dat_get_value): 	result = dh_std_input(dd, keyword)    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	keyword:	String giving the name of the translator quantity to 			read.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	NONE    OUTPUT: 	status:		Zero if valid data is returned     TRANSLATOR KEYWORDS: 	history:	History index to use in matching the keyword.  If not 			specified, the keyowrd with the highest history index 			is matched.    RETURN: 	Data associated with the requested keyword.    STATUS: 	Complete    SEE ALSO: 	dh_std_output    MODIFICATION HISTORY:  	Written by:	Spitale, 1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dh/dh_std_input.html#dhsi_associate_object", "dhsi_associate_object", 'routine in <a href="nv/obj/dat/dh/dh_std_input.html">dh_std_input.pro</a>', "dh_std_input.pro", "", "dhsi_associate_object", "", "nameddall_xds", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dh/dh_std_input.html#dhsi_get", "dhsi_get", 'routine in <a href="nv/obj/dat/dh/dh_std_input.html">dh_std_input.pro</a>', "dh_std_input.pro", "", "dhsi_get", "", "objhidhprefixddall_xds", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dh/dh_std_input.html#dh_std_input", "dh_std_input", 'routine in <a href="nv/obj/dat/dh/dh_std_input.html">dh_std_input.pro</a>', "dh_std_input.pro", "", "dh_std_input", "", "valuesstatusddkeyword@nv_trs_keywords_include.pro", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dh/dh_std_output.html", "dh_std_output.pro", '.pro file in <a href="nv/obj/dat/dh/dir-overview.html">nv/obj/dat/dh/ directory</a>', "dh_std_output.pro", "", "", " NAME: 	dh_std_output    PURPOSE: 	Output translator for detached headers.    CATEGORY: 	NV/CONFIG    CALLING SEQUENCE(only to be called by dat_put_value): 	dh_std_output, dd, keyword, value    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	keyword:	String giving the name of the translator quantity to 			write.  	value:		The data to write.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	NONE    OUTPUT: 	status:		Zero unless a problem occurs.     TRANSLATOR KEYWORDS: 	format:		String giving the name of the output representation. 			Default is OMINAS internal representation.  The null 			string, '', indicates the default.    SIDE EFFECTS: 	The detached header in the data descriptor is modified.    STATUS: 	Complete    SEE ALSO: 	dh_std_input    MODIFICATION HISTORY:  	Written by:	Spitale, 1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dh/dh_std_output.html#dhso_put", "dhso_put", 'routine in <a href="nv/obj/dat/dh/dh_std_output.html">dh_std_output.pro</a>', "dh_std_output.pro", "", "dhso_put", "", "objdddh_odprefix", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dh/dh_std_output.html#dh_std_output", "dh_std_output", 'routine in <a href="nv/obj/dat/dh/dh_std_output.html">dh_std_output.pro</a>', "dh_std_output.pro", "", "dh_std_output", "", "statusddkeywordvalue@nv_trs_keywords_include.pro", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/fits/dh_sxpar.html", "dh_sxpar.pro", '.pro file in <a href="config/fits/dir-overview.html">config/fits/ directory</a>', "dh_sxpar.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/fits/dh_sxpar.html#dh_sxpar", "dh_sxpar", 'routine in <a href="config/fits/dh_sxpar.html">dh_sxpar.pro</a>', "dh_sxpar.pro", "", "dh_sxpar", "", "getsetheaderkeyword", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dh/dh_to_ominas.html", "dh_to_ominas.pro", '.pro file in <a href="nv/obj/dat/dh/dir-overview.html">nv/obj/dat/dh/ directory</a>', "dh_to_ominas.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dh/dh_to_ominas.html#dh_to_ominas", "dh_to_ominas", 'routine in <a href="nv/obj/dat/dh/dh_to_ominas.html">dh_to_ominas.pro</a>', "dh_to_ominas.pro", "", "dh_to_ominas", "", "formatvalue", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/vicar/dh_vicpar.html", "dh_vicpar.pro", '.pro file in <a href="config/vicar/dir-overview.html">config/vicar/ directory</a>', "dh_vicpar.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/vicar/dh_vicpar.html#dh_vicpar", "dh_vicpar", 'routine in <a href="config/vicar/dh_vicpar.html">dh_vicpar.pro</a>', "dh_vicpar.pro", "", "dh_vicpar", "", "getsetlabelkeyword", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dh/util/dh_write.html", "dh_write.pro", '.pro file in <a href="nv/obj/dat/dh/util/dir-overview.html">nv/obj/dat/dh/util/ directory</a>', "dh_write.pro", "", "", " NAME: 	dh_write    PURPOSE: 	Writes a detached header file.    CATEGORY: 	UTIL/DH    CALLING SEQUENCE: 	dh_write, filename, dh    ARGUMENTS:   INPUT: 	filename:	Name of file to be written.  	dh:		String array giving the detached header to write.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	dh_read    MODIFICATION HISTORY:  	Written by:	Spitale, 7/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dh/util/dh_write.html#dh_write", "dh_write", 'routine in <a href="nv/obj/dat/dh/util/dh_write.html">dh_write.pro</a>', "dh_write.pro", "", "dh_write", "", "filenamedh", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/fits/dh_write_fits.html", "dh_write_fits.pro", '.pro file in <a href="config/fits/dir-overview.html">config/fits/ directory</a>', "dh_write_fits.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/fits/dh_write_fits.html#dh_write_fits", "dh_write_fits", 'routine in <a href="config/fits/dh_write_fits.html">dh_write_fits.pro</a>', "dh_write_fits.pro", "", "dh_write_fits", "", "abscissanodataddfilenamedataheader", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/mask/dh_write_mask.html", "dh_write_mask.pro", '.pro file in <a href="config/mask/dir-overview.html">config/mask/ directory</a>', "dh_write_mask.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/mask/dh_write_mask.html#dh_write_mask", "dh_write_mask", 'routine in <a href="config/mask/dh_write_mask.html">dh_write_mask.pro</a>', "dh_write_mask.pro", "", "dh_write_mask", "", "abscissanodataddfilenamedataheader", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/multi/dh_write_multi.html", "dh_write_multi.pro", '.pro file in <a href="config/multi/dir-overview.html">config/multi/ directory</a>', "dh_write_multi.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/multi/dh_write_multi.html#dh_write_multi", "dh_write_multi", 'routine in <a href="config/multi/dh_write_multi.html">dh_write_multi.pro</a>', "dh_write_multi.pro", "", "dh_write_multi", "", "abscissanodataddfilenamedataheader", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/occ/dh_write_occ.html", "dh_write_occ.pro", '.pro file in <a href="config/occ/dir-overview.html">config/occ/ directory</a>', "dh_write_occ.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/occ/dh_write_occ.html#dh_write_occ", "dh_write_occ", 'routine in <a href="config/occ/dh_write_occ.html">dh_write_occ.pro</a>', "dh_write_occ.pro", "", "dh_write_occ", "", "abscissanodataddfilenamedataheader", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/tdl/dh_write_tdl.html", "dh_write_tdl.pro", '.pro file in <a href="config/tdl/dir-overview.html">config/tdl/ directory</a>', "dh_write_tdl.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/tdl/dh_write_tdl.html#dh_write_tdl", "dh_write_tdl", 'routine in <a href="config/tdl/dh_write_tdl.html">dh_write_tdl.pro</a>', "dh_write_tdl.pro", "", "dh_write_tdl", "", "abscissanodataddfilenamedataheader", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/vicar/dh_write_vicar.html", "dh_write_vicar.pro", '.pro file in <a href="config/vicar/dir-overview.html">config/vicar/ directory</a>', "dh_write_vicar.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/vicar/dh_write_vicar.html#dh_write_vicar", "dh_write_vicar", 'routine in <a href="config/vicar/dh_write_vicar.html">dh_write_vicar.pro</a>', "dh_write_vicar.pro", "", "dh_write_vicar", "", "abscissanodataddfilenamedataheader", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dh/util/dhh_extract.html", "dhh_extract.pro", '.pro file in <a href="nv/obj/dat/dh/util/dir-overview.html">nv/obj/dat/dh/util/ directory</a>', "dhh_extract.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dh/util/dhh_extract.html#dhh_extract", "dhh_extract", 'routine in <a href="nv/obj/dat/dh/util/dhh_extract.html">dhh_extract.pro</a>', "dhh_extract.pro", "", "dhh_extract", "", "dh_historydhsection", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dh/util/dhh_insert.html", "dhh_insert.pro", '.pro file in <a href="nv/obj/dat/dh/util/dir-overview.html">nv/obj/dat/dh/util/ directory</a>', "dhh_insert.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dh/util/dhh_insert.html#dhh_insert", "dhh_insert", 'routine in <a href="nv/obj/dat/dh/util/dhh_insert.html">dhh_insert.pro</a>', "dhh_insert.pro", "", "dhh_insert", "", "dh_historydhdh_section", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dh/util/dhh_parse_keyword.html", "dhh_parse_keyword.pro", '.pro file in <a href="nv/obj/dat/dh/util/dir-overview.html">nv/obj/dat/dh/util/ directory</a>', "dhh_parse_keyword.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dh/util/dhh_parse_keyword.html#dhh_parse_keyword", "dhh_parse_keyword", 'routine in <a href="nv/obj/dat/dh/util/dhh_parse_keyword.html">dhh_parse_keyword.pro</a>', "dhh_parse_keyword.pro", "", "dhh_parse_keyword", "", "rkwkwelm_indexobj_indexhist_index", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dh/util/dhh_parse_line.html", "dhh_parse_line.pro", '.pro file in <a href="nv/obj/dat/dh/util/dir-overview.html">nv/obj/dat/dh/util/ directory</a>', "dhh_parse_line.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dh/util/dhh_parse_line.html#dhh_parse_line", "dhh_parse_line", 'routine in <a href="nv/obj/dat/dh/util/dhh_parse_line.html">dhh_parse_line.pro</a>', "dhh_parse_line.pro", "", "dhh_parse_line", "", "linerkwval", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dh/util/dhh_search.html", "dhh_search.pro", '.pro file in <a href="nv/obj/dat/dh/util/dir-overview.html">nv/obj/dat/dh/util/ directory</a>', "dhh_search.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dh/util/dhh_search.html#dhh_search", "dhh_search", 'routine in <a href="nv/obj/dat/dh/util/dhh_search.html">dhh_search.pro</a>', "dhh_search.pro", "", "dhh_search", "", "linesdhkeyword", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/dh/util/dhh_separate.html", "dhh_separate.pro", '.pro file in <a href="nv/obj/dat/dh/util/dir-overview.html">nv/obj/dat/dh/util/ directory</a>', "dhh_separate.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/dh/util/dhh_separate.html#dhh_separate", "dhh_separate", 'routine in <a href="nv/obj/dat/dh/util/dhh_separate.html">dhh_separate.pro</a>', "dhh_separate.pro", "", "dhh_separate", "", "dh_sectionsdhdh_history", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/gen/diaggen.html", "diaggen.pro", '.pro file in <a href="util/gen/dir-overview.html">util/gen/ directory</a>', "diaggen.pro", "", "", " NAME: 	diaggen    PURPOSE: 	Constructs 1d subscripts of diagonal elements of an array of nn nxn 	matrices such that subscripting the array of matrices will produce 	an array of column vectors with each column containing the diagonal 	elements of the corresponding matrix.    CATEGORY: 	UTIL/GEN    CALLING SEQUENCE: 	sub = diaggen(n, nn)    ARGUMENTS:   INPUT: 	n:	 Degree of matrix, i.e., number of rows / columns.  	nn:	 Number of matrices.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Array (n x n x nn) of subscripts.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/gen/diaggen.html#diaggen", "diaggen", 'routine in <a href="util/gen/diaggen.html">diaggen.pro</a>', "diaggen.pro", "", "diaggen", "", "nnn", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/dialog_input.html", "dialog_input.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "dialog_input.pro", "", "", " dialog_input   PURPOSE    Pops up a widget displaying the string msg, with a text widget   for keyboard entry of data.  The input box is always modal.    CALLING SEQUENCE :         result = dialog_input(msg, [title, no_beep])    ARGUMENTS   INPUT : msg - String array containing the message to be displayed.                  Each element of the array will be separated by a                  carriage return.    OUTPUT : NONE     KEYWORDS   INPUT : fname - Name of file to read message from instead of using                   'msg' argument.            max_ysize - Maximum size for message window before adding                       a scroll bar.            title - The title for the widget, default is 'Question'            beep -    If set, the appearance of the widget                     will be accompanied by a beep.            init_text - initial text for the input text widget,                       default is ''.            xoffset, yoffset - Coordinates of the upper left corner of the                              box relative to the root window..            no_cancel - do not include the cancel button.  Since the                       cancel button causes '' to be returned, it is                       equivalent to hitting enter with nothing in the                       input text widget.  Thus is many cases, the cancel                       button is redundant.  It would not be redundant,                       however, when you use inital input text and                       you do not want the user to have to destroy                       it to cancel the action.    OUTPUT : cancelled - 1 for cancel pressed, 0 for cancel not pressed.     RETURN : The string in the input text widget when the user presses           return.  If Cancel is pressed, then the null string '' is           returned.     EXAMPLE :    ans = dialog_input( ['Please enter your hat size : '])    KNOWN BUGS : NONE     MODIFICATION HISTORY : 	J. Spitale ; 6/94	(drm_input_box) 	Spitale 5/2005; renamed dialog_input, 	                added 'Ok' button 			removed drm calls    ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/dialog_input.html#dialog_input_event", "dialog_input_event", 'routine in <a href="util/dialog_input.html">dialog_input.pro</a>', "dialog_input.pro", "", "dialog_input_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/dialog_input.html#dialog_input", "dialog_input", 'routine in <a href="util/dialog_input.html">dialog_input.pro</a>', "dialog_input.pro", "", "dialog_input", "", "titlebeepgroup_leaderinit_textno_cancelcancelledfnamemax_ysizemac_overwritemac_appendxoffsetyoffsetmsg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/dialog_interrupt.html", "dialog_interrupt.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "dialog_interrupt.pro", "", "", " dialog_interrupt   PURPOSE    Pops up a widget with one button whose purpose is to immediately    call a given procedure when pressed, interrupting any current    processing.  After the callback procedure returns, a 'retall'    is performed.    CALLING SEQUENCE :         base = dialog_interrupt(callback=callback)    ARGUMENTS   INPUT : NONE    OUTPUT : NONE     KEYWORDS   INPUT : callback	Name of a procedure to be called when the 			interrupt button is pressed,  	   data		data to be passed as the argument to the callback 			procedure.  	   text		Text displayed above the button.  Default is 			'Processing'.  	   label	Label for the interrupt button.  Default is 			'Interrupt'.    OUTPUT : NONE     RETURN : Widget id of the dialog base, so that it may be destroyed 	   when the task is complete.  If a dialog is already open, 	   then -1 is returned.    RESTRICTIONS : 	Only one dialog_interrupt widget will run at any given time.    MODIFICATION HISTORY : 	Spitale; 7/2005    ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/dialog_interrupt.html#dialog_interrupt_event", "dialog_interrupt_event", 'routine in <a href="util/dialog_interrupt.html">dialog_interrupt.pro</a>', "dialog_interrupt.pro", "", "dialog_interrupt_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/dialog_interrupt.html#dialog_interrupt", "dialog_interrupt", 'routine in <a href="util/dialog_interrupt.html">dialog_interrupt.pro</a>', "dialog_interrupt.pro", "", "dialog_interrupt", "", "callbackdatalabelgroup_leadertextinterval", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/dir_rep.html", "dir_rep.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "dir_rep.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/dir_rep.html#dir_rep", "dir_rep", 'routine in <a href="util/dir_rep.html">dir_rep.pro</a>', "dir_rep.pro", "", "dir_rep", "", "filenamenew_dir", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/disk_to_corot.html", "disk_to_corot.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "disk_to_corot.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/disk_to_corot.html#disk_to_corot", "disk_to_corot", 'routine in <a href="nv/obj/tools/disk_to_corot.html">disk_to_corot.pro</a>', "disk_to_corot.pro", "", "disk_to_corot", "", "cddkxgbxt0dmldttimesdisk_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/disk_to_corot_lon.html", "disk_to_corot_lon.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "disk_to_corot_lon.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/disk_to_corot_lon.html#disk_to_corot_lon", "disk_to_corot_lon", 'routine in <a href="nv/obj/tools/disk_to_corot_lon.html">disk_to_corot_lon.pro</a>', "disk_to_corot_lon.pro", "", "disk_to_corot_lon", "", "cddkxgbxt0dmldttimesdisk_lons", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/composite/disk_to_image.html", "disk_to_image.pro", '.pro file in <a href="nv/obj/tools/composite/dir-overview.html">nv/obj/tools/composite/ directory</a>', "disk_to_image.pro", "", "", " NAME:        disk_to_image    PURPOSE:        Transforms points in disk coordinates to image coordinates    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = disk_to_image(cd, dkx, p)    ARGUMENTS:   INPUT: 	cd:       Array of nt camera or map descriptors.  	dkx:      Array of nt object descriptors (subclass of DISK).  	p:       Array (nv x 3 x nt) of image points.    OUTPUT:        NONE   KEYWORDS:    INPUT: 	sund:	If given, longitudes are assumed to be referenced to the 		sun direction.     OUTPUT: 	valid:	Indices of valid output points.  	body_pts:	Body coordinates of output points.    RETURN:        Array (nv x 3 x nt) of image coordinates.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale, 9/2002  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/composite/disk_to_image.html#disk_to_image", "disk_to_image", 'routine in <a href="nv/obj/tools/composite/disk_to_image.html">disk_to_image.pro</a>', "disk_to_image.pro", "", "disk_to_image", "", "body_ptsvalidcddkxp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/composite/disk_to_inertial_pos.html", "disk_to_inertial_pos.pro", '.pro file in <a href="nv/obj/tools/composite/dir-overview.html">nv/obj/tools/composite/ directory</a>', "disk_to_inertial_pos.pro", "", "", " NAME:        disk_to_inertial_pos    PURPOSE:        Transforms position vectors in disk coordinates to inertial 	coordinates.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = disk_to_inertial_pos(dkx, v)    ARGUMENTS:   INPUT: 	dkx:	Array of nt descriptors, subclass of DISK.  	v:	Array (nv x 3 x nt) of disk points.    OUTPUT:        NONE   KEYWORDS:    INPUT: NONE     OUTPUT: NONE    RETURN:        Array (nv x 3 x nt) of inertial points.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/composite/disk_to_inertial_pos.html#disk_to_inertial_pos", "disk_to_inertial_pos", 'routine in <a href="nv/obj/tools/composite/disk_to_inertial_pos.html">disk_to_inertial_pos.pro</a>', "disk_to_inertial_pos.pro", "", "disk_to_inertial_pos", "", "rdp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/composite/disk_to_map.html", "disk_to_map.pro", '.pro file in <a href="nv/obj/tools/composite/dir-overview.html">nv/obj/tools/composite/ directory</a>', "disk_to_map.pro", "", "", " NAME:        disk_to_map    PURPOSE:        Transforms points in disk coordinates to map coordinates.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = disk_to_map(md, dkx, disk_pts)    ARGUMENTS:   INPUT: 	md:      Array of nt map descriptors.  	dkx:     Array of nt disk descriptors.  	disk_pts:       Array (nv x 3 x nt) of disk points.    OUTPUT:        NONE   KEYWORDS:    INPUT: NONE     OUTPUT: NONE    RETURN:        Array (2 x nv x nt) of map coordinates.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/composite/disk_to_map.html#disk_to_map", "disk_to_map", 'routine in <a href="nv/obj/tools/composite/disk_to_map.html">disk_to_map.pro</a>', "disk_to_map.pro", "", "disk_to_map", "", "mddkddisk_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/divisors.html", "divisors.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "divisors.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/divisors.html#divisors", "divisors", 'routine in <a href="util/divisors.html">divisors.pro</a>', "divisors.pro", "", "divisors", "", "tolxmax_denom", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/doc_util.html", "doc_util.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "doc_util.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("util/dd/doubledouble__define.html", "doubledouble__define.pro", '.pro file in <a href="util/dd/dir-overview.html">util/dd/ directory</a>', "doubledouble__define.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/dd/doubledouble__define.html#doubledouble__define", "doubledouble__define", 'routine in <a href="util/dd/doubledouble__define.html">doubledouble__define.pro</a>', "doubledouble__define.pro", "", "doubledouble__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/doythhmmss_to_sec.html", "doythhmmss_to_sec.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "doythhmmss_to_sec.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/doythhmmss_to_sec.html#doythhmmss_to_sec", "doythhmmss_to_sec", 'routine in <a href="util/doythhmmss_to_sec.html">doythhmmss_to_sec.pro</a>', "doythhmmss_to_sec.pro", "", "doythhmmss_to_sec", "", "doythhmmss", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/grim/dred/dred.html", "dred.pro", '.pro file in <a href="nv/grim/dred/dir-overview.html">nv/grim/dred/ directory</a>', "dred.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/grim/dred/dred.html#dred_update_form", "dred_update_form", 'routine in <a href="nv/grim/dred/dred.html">dred.pro</a>', "dred.pro", "", "dred_update_form", "", "dataclass", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/dred/dred.html#dred_update_form", "dred_update_form", 'routine in <a href="nv/grim/dred/dred.html">dred.pro</a>', "dred.pro", "", "dred_update_form", "", "data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/dred/dred.html#dred_configure_xd", "dred_configure_xd", 'routine in <a href="nv/grim/dred/dred.html">dred.pro</a>', "dred.pro", "", "dred_configure_xd", "", "basexd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/dred/dred.html#dred_switch_class", "dred_switch_class", 'routine in <a href="nv/grim/dred/dred.html">dred.pro</a>', "dred.pro", "", "dred_switch_class", "", "dataclass", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/dred/dred.html#dred_switch_xd", "dred_switch_xd", 'routine in <a href="nv/grim/dred/dred.html">dred.pro</a>', "dred.pro", "", "dred_switch_xd", "", "datasii", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/dred/dred.html#dred_resize", "dred_resize", 'routine in <a href="nv/grim/dred/dred.html">dred.pro</a>', "dred.pro", "", "dred_resize", "", "datas", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/dred/dred.html#dred_event", "dred_event", 'routine in <a href="nv/grim/dred/dred.html">dred.pro</a>', "dred.pro", "", "dred_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/dred/dred.html#dred_cleanup", "dred_cleanup", 'routine in <a href="nv/grim/dred/dred.html">dred.pro</a>', "dred.pro", "", "dred_cleanup", "", "base", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/dred/dred.html#dred", "dred", 'routine in <a href="nv/grim/dred/dred.html">dred.pro</a>', "dred.pro", "", "dred", "", "xd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/dropouts.html", "dropouts.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "dropouts.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/dropouts.html#dropouts", "dropouts", 'routine in <a href="util/dropouts.html">dropouts.pro</a>', "dropouts.pro", "", "dropouts", "", "nmaxminimage", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_apply_scale.html", "dsk_apply_scale.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_apply_scale.pro", "", "", " NAME: 	dsk_apply_scale    PURPOSE: 	Computes scaled radii.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	scaled_radii = dsk_apply_scale(dkd, radii)    ARGUMENTS:   INPUT: 	dkd:	 A single disk descriptors.  	radii:	 Array of radii to convert.    OUTPUT: NONE    KEYWORDS:   INPUT: 	inverse:	If set, the operation is performed in reverse.    OUTPUT: NONE    RETURN: 	Scaled radii based onthe scale parameters in the disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_apply_scale.html#dsk_apply_scale", "dsk_apply_scale", 'routine in <a href="nv/obj/dsk/dsk_apply_scale.html">dsk_apply_scale.pro</a>', "dsk_apply_scale.pro", "", "dsk_apply_scale", "", "inversenoeventdkdradii", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_assign.html", "dsk_assign.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_assign.pro", "", "", " NAME: 	dsk_assign    PURPOSE: 	Replaces fields in a DISK object.  This is a convenient way of 	setting multiple fields in one call, and only a single event is 	generated.    CATEGORY: 	NV/OBJ/DSK    CALLING SEQUENCE: 	dsk_assign, dkd, <keywords>=<values>    ARGUMENTS:   INPUT: 	dkd:		DISK object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	DISK fields to set.  	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	dsk_assign_*     MODIFICATION HISTORY:  	Written by:	Spitale		2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_assign.html#dsk_assign", "dsk_assign", 'routine in <a href="nv/obj/dsk/dsk_assign.html">dsk_assign.pro</a>', "dsk_assign.pro", "", "dsk_assign", "", "noeventxd@dsk__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_body_to_disk.html", "dsk_body_to_disk.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_body_to_disk.pro", "", "", " NAME: 	dsk_body_to_disk    PURPOSE: 	Transforms vectors from the body coordinate system to the disk 	coordinate system.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	v_disk = dsk_body_to_disk(dkd, v_body)    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	v_body:	 Array (nv x 3 x nt) of column vectors in the body 		 coordinate system.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (nv x 3 x nt) of column vectors in the disk coordinate system.    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_body_to_disk.html#dsk_body_to_disk", "dsk_body_to_disk", 'routine in <a href="nv/obj/dsk/dsk_body_to_disk.html">dsk_body_to_disk.pro</a>', "dsk_body_to_disk.pro", "", "dsk_body_to_disk", "", "dkdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/dsk_cat.html", "dsk_cat.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "dsk_cat.pro", "", "", " NAME:        dsk_cat    PURPOSE: 	Concatenates the given disk descriptors into one descriptor encompassing 	the entire system.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        dkx_cat = dsk_cat(dkx)    ARGUMENTS:   INPUT: 	dkx:	Array (nt) of any subclass of DISK.    OUTPUT:        NONE    KEYOWRDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	A descriptor of the same class as dkx whose semimajor axes 	encompass the all of the input disks.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/dsk_cat.html#dsk_cat", "dsk_cat", 'routine in <a href="nv/obj/tools/dsk_cat.html">dsk_cat.pro</a>', "dsk_cat.pro", "", "dsk_cat", "", "dkxs", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/dsk_cat_by_name.html", "dsk_cat_by_name.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "dsk_cat_by_name.pro", "", "", " NAME:        dsk_cat_by_name    PURPOSE: 	Concatenates the given disk descriptors into one descriptor 	encompassing all of the named descriptors.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        dkx_cat = dsk_cat_by_name(dkx, names)    ARGUMENTS:   INPUT: 	dkx:	Array (nt) of any subclass of DISK.  	names:	Array of names of disks to concatenate.    OUTPUT:        NONE    KEYOWRDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	A descriptor of the same class as dkx whose semimajor axes 	encompass the all of the named input disks.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/dsk_cat_by_name.html#dsk_cat_by_name", "dsk_cat_by_name", 'routine in <a href="nv/obj/tools/dsk_cat_by_name.html">dsk_cat_by_name.pro</a>', "dsk_cat_by_name.pro", "", "dsk_cat_by_name", "", "dkxsnames", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_create_descriptors.html", "dsk_create_descriptors.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_create_descriptors.pro", "", "", " NAME: 	dsk_create_descriptors    PURPOSE: 	Init method for the DISK class.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dkd = dsk_create_descriptors(n)    ARGUMENTS:   INPUT: 	n:	Number of descriptors to create.    OUTPUT: NONE    KEYWORDS (in addition to those accepted by all superclasses):   INPUT: 	dkd:	Disk descriptor(s) to initialize, instead of creating a new one.  	sld:	Solid descriptor(s) instead of using sld_create_descriptors.  	bd:	Body descriptor(s) to pass to bod_create_descriptors.  	crd:	Core descriptor(s) to pass to cor_create_descriptors.  	sma:	Array (ndv+1 x 2 x n) giving the semimajor axes and derivatives 		for each edge.  	ecc:	Array (ndv+1 x 2 x n) giving the eccentricities and derivatives 		for each edge.  	scale:	Array (2 x n) giving radial scale coefficients.  	nm:	Integer giving the number of radial harmonics in the ring 		shape.  	m:	Array (nm x 2 x n) giving the m value for each harmonic, for 		each edge.  	em:	Array (nm x 2 x n) giving the eccentricity for each harmonic, for 		each edge.  	tapm:	Array (nm x 2 x n) giving the true anomaly of periapse for each 		harmonic, for each edge.  	dtapmdt:Array (nm x 2 x n) giving the tapm rate for each 		harmonic, for each edge.  	libam:	Array (nm x 2 x n) giving the libration amplitude for each 		harmonic, for each edge.  	libm:	Array (nm x 2 x n) giving the libration phase for each 		harmonic, for each edge.  	dlibmdt:	Array (nm x 2 x n) giving the libration frequency for each 			harmonic, for each edge.  	nl:	Integer giving the number of radial harmonics in the ring 		shape.  	_l:	Array (nl x 2 x n) giving the l value for each harmonic, for 		each edge.  The leading underscore is needed to avoid 		conflict with other keywords.  	il:	Array (l x 2 x n) giving the inclination for each harmonic, for 		each edge.  	taanl:	Array (nl x 2 x n) giving the true anomaly of periapse for each 		harmonic, for each edge.  	dtaanldt:	Array (nl x 2 x n) giving the taanl rate for each 			harmonic, for each edge.  	libal:	Array (nl x 2 x n) giving the libration amplitude for each 		harmonic, for each edge.  	libl:	Array (nl x 2 x n) giving the libration phase for each 		harmonic, for each edge.  	dlibldt:	Array (nl x 2 x n) giving the libration frequency for each 			harmonic, for each edge.    OUTPUT: NONE    RETURN: 	Newly created or or freshly initialized disk descriptors, depending 	on the presence of the dkd keyword.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_create_descriptors.html#dsk_create_descriptors", "dsk_create_descriptors", 'routine in <a href="nv/obj/dsk/dsk_create_descriptors.html">dsk_create_descriptors.pro</a>', "dsk_create_descriptors.pro", "", "dsk_create_descriptors", "", "crdbdslddkdn@dsk__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_dap.html", "dsk_dap.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_dap.pro", "", "", " NAME: 	dsk_dap    PURPOSE: 	Returns dap for each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dap = dsk_dap(dkd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Any subclass of DISK.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	dap value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_dap.html#dsk_dap", "dsk_dap", 'routine in <a href="nv/obj/dsk/dsk_dap.html">dsk_dap.pro</a>', "dsk_dap.pro", "", "dsk_dap", "", "noeventdkd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_disk_to_body.html", "dsk_disk_to_body.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_disk_to_body.pro", "", "", " NAME: 	dsk_disk_to_body    PURPOSE: 	Transforms vectors from the disk coordinate system to the body 	coordinate system.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	v_body = dsk_disk_to_body(dkd, v_dsk)    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	v_disk:	 Array (nv x 3 x nt) of column vectors in the disk 		 coordinate system.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (nv x 3 x nt) of column vectors in the body coordinate system.    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_disk_to_body.html#dsk_disk_to_body", "dsk_disk_to_body", 'routine in <a href="nv/obj/dsk/dsk_disk_to_body.html">dsk_disk_to_body.pro</a>', "dsk_disk_to_body.pro", "", "dsk_disk_to_body", "", "dkdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_dlibldt.html", "dsk_dlibldt.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_dlibldt.pro", "", "", " NAME: 	dsk_dlibldt    PURPOSE: 	Returns dlibldt for each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dlibldt = dsk_dlibldt(dkd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Any subclass of DISK.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	dlibldt value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_dlibldt.html#dsk_dlibldt", "dsk_dlibldt", 'routine in <a href="nv/obj/dsk/dsk_dlibldt.html">dsk_dlibldt.pro</a>', "dsk_dlibldt.pro", "", "dsk_dlibldt", "", "noeventdkd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_dlibmdt.html", "dsk_dlibmdt.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_dlibmdt.pro", "", "", " NAME: 	dsk_dlibmdt    PURPOSE: 	Returns dlibmdt for each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dlibmdt = dsk_dlibmdt(dkd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Any subclass of DISK.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	dlibmdt value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_dlibmdt.html#dsk_dlibmdt", "dsk_dlibmdt", 'routine in <a href="nv/obj/dsk/dsk_dlibmdt.html">dsk_dlibmdt.pro</a>', "dsk_dlibmdt.pro", "", "dsk_dlibmdt", "", "noeventdkd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_dtaanldt.html", "dsk_dtaanldt.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_dtaanldt.pro", "", "", " NAME: 	dsk_dtaanldt    PURPOSE: 	Returns dtaanldt for each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dtaanldt = dsk_dtaanldt(dkd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Any subclass of DISK.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	dtaanldt value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_dtaanldt.html#dsk_dtaanldt", "dsk_dtaanldt", 'routine in <a href="nv/obj/dsk/dsk_dtaanldt.html">dsk_dtaanldt.pro</a>', "dsk_dtaanldt.pro", "", "dsk_dtaanldt", "", "noeventdkd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_dtapmdt.html", "dsk_dtapmdt.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_dtapmdt.pro", "", "", " NAME: 	dsk_dtapmdt    PURPOSE: 	Returns dtapmdt for each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dtapmdt = dsk_dtapmdt(dkd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Any subclass of DISK.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	dtapmdt value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_dtapmdt.html#dsk_dtapmdt", "dsk_dtapmdt", 'routine in <a href="nv/obj/dsk/dsk_dtapmdt.html">dsk_dtapmdt.pro</a>', "dsk_dtapmdt.pro", "", "dsk_dtapmdt", "", "noeventdkd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_ecc.html", "dsk_ecc.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_ecc.pro", "", "", " NAME: 	dsk_ecc    PURPOSE: 	Returns ecc for each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	ecc = dsk_ecc(dkd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Any subclass of DISK.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	ecc value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_ecc.html#dsk_ecc", "dsk_ecc", 'routine in <a href="nv/obj/dsk/dsk_ecc.html">dsk_ecc.pro</a>', "dsk_ecc.pro", "", "dsk_ecc", "", "noeventdkd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_em.html", "dsk_em.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_em.pro", "", "", " NAME: 	dsk_em    PURPOSE: 	Returns em for each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	em = dsk_em(dkd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Any subclass of DISK.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	em value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_em.html#dsk_em", "dsk_em", 'routine in <a href="nv/obj/dsk/dsk_em.html">dsk_em.pro</a>', "dsk_em.pro", "", "dsk_em", "", "noeventdkd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_evolve.html", "dsk_evolve.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_evolve.pro", "", "", " NAME: 	dsk_evolve    PURPOSE: 	Computes new disk descriptors at the given time offsets from the 	given disk descriptors using the taylor series expansion 	corresponding to the derivatives contained in the given disk 	descriptor.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	dkdt = dsk_evolve(dkd, dt)    ARGUMENTS:   INPUT: 	dkd:	 Any subclass of DISK.  	dt:	 Time offset.    OUTPUT: NONE    KEYWORDS:   INPUT: 	nodv:	 If set, derivatives will not be evolved.  	copy:	If set, the evolved descriptor is copied into the input 		descriptor and it is freed.  The input descriptor is returned.     OUTPUT: NONE    RETURN: 	Array (ndkd,ndt) of newly allocated descriptors, of class DISK, 	evolved by time dt, where ndkd is the number of dkd, and ndt 	is the number of dt.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_evolve.html#dsk_evolve", "dsk_evolve", 'routine in <a href="nv/obj/dsk/dsk_evolve.html">dsk_evolve.pro</a>', "dsk_evolve.pro", "", "dsk_evolve", "", "nodvcopydkddt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_get_ansa.html", "dsk_get_ansa.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_get_ansa.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_get_ansa.html#dsk_get_ansa", "dsk_get_ansa", 'routine in <a href="nv/obj/dsk/dsk_get_ansa.html">dsk_get_ansa.pro</a>', "dsk_get_ansa.pro", "", "dsk_get_ansa", "", "ndkdr", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_get_ap.html", "dsk_get_ap.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_get_ap.pro", "", "", " NAME: 	dsk_get_ap    PURPOSE: 	Determines ap for each given disk descriptor, based on the 	orientation of its BODY axes.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	ap = dsk_ap(dkd, frame_bd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Array (nt) of any subclass of DISK.  	frame_bd:	Subclass of BODY giving the frame against which to 			measure inclinations and nodes, e.g., a planet 			descriptor.  One for each dkd.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	ap value associated with each given disk descriptor.  One for each dkd.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_get_ap.html#dsk_get_ap", "dsk_get_ap", 'routine in <a href="nv/obj/dsk/dsk_get_ap.html">dsk_get_ap.pro</a>', "dsk_get_ap.pro", "", "dsk_get_ap", "", "dkdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_get_dapdt.html", "dsk_get_dapdt.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_get_dapdt.pro", "", "", " NAME: 	dsk_get_dapdt    PURPOSE: 	Determines dapdt for each given disk descriptor, based on the 	orientation of its BODY axes.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dapdt = dsk_dapdt(dkd, frame_bd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Array (nt) of any subclass of DISK.  	frame_bd:	Subclass of BODY giving the frame against which to 			measure inclinations and nodes, e.g., a planet 			descriptor.  One for each dkd.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	dapdt value associated with each given disk descriptor.  One for each dkd.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_get_dapdt.html#dsk_get_dapdt", "dsk_get_dapdt", 'routine in <a href="nv/obj/dsk/dsk_get_dapdt.html">dsk_get_dapdt.pro</a>', "dsk_get_dapdt.pro", "", "dsk_get_dapdt", "", "dkdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_get_disk_points.html", "dsk_get_disk_points.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_get_disk_points.pro", "", "", " NAME: 	dsk_get_disk_points    PURPOSE: 	Computes points on the inner and outer edges of a disk.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	disk_pts = dsk_get_disk_points(dkd, np)    ARGUMENTS:   INPUT: 	dkd:	 Any single subclass of DISK.  	np:	 Number of points on each edge.    OUTPUT: NONE    KEYWORDS:   INPUT: 	dta:		Azimuthal spacing for the points, instead of specifying 			the np argument.    OUTPUT: NONE    RETURN: 	Array (np x 3 x 2) of points on the inner and outer edges of the 	disk, in disk body coordinates.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_get_disk_points.html#_dsk_get_disk_points", "_dsk_get_disk_points", 'routine in <a href="nv/obj/dsk/dsk_get_disk_points.html">dsk_get_disk_points.pro</a>', "dsk_get_disk_points.pro", "", "_dsk_get_disk_points", "", "dkdn_points", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_get_disk_points.html#dsk_get_disk_points", "dsk_get_disk_points", 'routine in <a href="nv/obj/dsk/dsk_get_disk_points.html">dsk_get_disk_points.pro</a>', "dsk_get_disk_points.pro", "", "dsk_get_disk_points", "", "dtadkdn_points", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_get_dlandt.html", "dsk_get_dlandt.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_get_dlandt.pro", "", "", " NAME: 	dsk_get_dlandt    PURPOSE: 	Determines dlandt for each given disk descriptor, based on the 	orientation of its BODY axes.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dlandt = dsk_dlandt(dkd, frame_bd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Array (nt) of any subclass of DISK.  	frame_bd:	Subclass of BODY giving the frame against which to 			measure inclinations and nodes, e.g., a planet 			descriptor.  One for each dkd.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	dlandt value associated with each given disk descriptor.  One for each dkd.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_get_dlandt.html#dsk_get_dlandt", "dsk_get_dlandt", 'routine in <a href="nv/obj/dsk/dsk_get_dlandt.html">dsk_get_dlandt.pro</a>', "dsk_get_dlandt.pro", "", "dsk_get_dlandt", "", "dkdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_get_dlibdt_ap.html", "dsk_get_dlibdt_ap.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_get_dlibdt_ap.pro", "", "", " NAME: 	dsk_get_dlibdt_ap    PURPOSE: 	Determines dlibdt_ap for each given disk descriptor, based on the 	orientation of its BODY axes.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dlibdt_ap = dsk_dlibdt_ap(dkd, frame_bd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Array (nt) of any subclass of DISK.  	frame_bd:	Subclass of BODY giving the frame against which to 			measure inclinations and nodes, e.g., a planet 			descriptor.  One for each dkd.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	dlibdt_ap value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_get_dlibdt_ap.html#dsk_get_dlibdt_ap", "dsk_get_dlibdt_ap", 'routine in <a href="nv/obj/dsk/dsk_get_dlibdt_ap.html">dsk_get_dlibdt_ap.pro</a>', "dsk_get_dlibdt_ap.pro", "", "dsk_get_dlibdt_ap", "", "dkdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_get_dlibdt_lan.html", "dsk_get_dlibdt_lan.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_get_dlibdt_lan.pro", "", "", " NAME: 	dsk_get_dlibdt_lan    PURPOSE: 	Determines dlibdt_lan for each given disk descriptor, based on the 	orientation of its BODY axes.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dlibdt_lan = dsk_dlibdt_lan(dkd, frame_bd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Array (nt) of any subclass of DISK.  	frame_bd:	Subclass of BODY giving the frame against which to 			measure inclinations and nodes, e.g., a planet 			descriptor.  One for each dkd.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	dlibdt_lan value associated with each given disk descriptor.  One for each dkd.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_get_dlibdt_lan.html#dsk_get_dlibdt_lan", "dsk_get_dlibdt_lan", 'routine in <a href="nv/obj/dsk/dsk_get_dlibdt_lan.html">dsk_get_dlibdt_lan.pro</a>', "dsk_get_dlibdt_lan.pro", "", "dsk_get_dlibdt_lan", "", "dkdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_get_edge_elevation.html", "dsk_get_edge_elevation.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_get_edge_elevation.pro", "", "", " NAME: 	dsk_get_edge_elevation    PURPOSE: 	Computes elevations along the edge of a disk.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	z = dsk_get_edge_elevation(dkd, ta)    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	ta:	 Array (nta) of true anomalies at which to compute elevations.     OUTPUT: NONE    KEYWORDS:   INPUT: 	inner:	If set, the inner edge is used.  	outer:	If set, the outer edge is used.    OUTPUT: NONE    RETURN: 	Array (nt x nta) of elevations computed at each true anomaly on each 	disk.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_get_edge_elevation.html#dsk_get_edge_elevation", "dsk_get_edge_elevation", 'routine in <a href="nv/obj/dsk/dsk_get_edge_elevation.html">dsk_get_edge_elevation.pro</a>', "dsk_get_edge_elevation.pro", "", "dsk_get_edge_elevation", "", "innerouterone_to_onenoeventdkdta", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_get_edge_radius.html", "dsk_get_edge_radius.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_get_edge_radius.pro", "", "", " NAME: 	dsk_get_edge_radius    PURPOSE: 	Computes radii along the edge of a disk.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	r = dsk_get_edge_radius(dkd, ta, frame_bd)    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	ta:	 Array (nv x nt) of true anomalies at which to compute radii.  	time:	 Array (nt) of epochs to use instead of that of dkd.     OUTPUT: NONE    KEYWORDS:   INPUT: 	inner:	If set, the inner edge is used.  	outer:	If set, the outer edge is used.    OUTPUT: NONE    RETURN: 	Array (nv x nt) of radii computed at each true anomaly on each 	disk.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_get_edge_radius.html#dsk_get_edge_radius", "dsk_get_edge_radius", 'routine in <a href="nv/obj/dsk/dsk_get_edge_radius.html">dsk_get_edge_radius.pro</a>', "dsk_get_edge_radius.pro", "", "dsk_get_edge_radius", "", "inneroutertimenoeventdkdta", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_get_inc.html", "dsk_get_inc.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_get_inc.pro", "", "", " NAME: 	dsk_get_inc    PURPOSE: 	Determines inc for each given disk descriptor, based on the 	orientation of its BODY axes.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	inc = dsk_inc(dkd, frame_bd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Array (nt) of any subclass of DISK.  	frame_bd:	Subclass of BODY giving the frame against which to 			measure inclinations and nodes, e.g., a planet 			descriptor.  One for each dkd.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	inc value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_get_inc.html#dsk_get_inc", "dsk_get_inc", 'routine in <a href="nv/obj/dsk/dsk_get_inc.html">dsk_get_inc.pro</a>', "dsk_get_inc.pro", "", "dsk_get_inc", "", "dkdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_get_inner_disk_points.html", "dsk_get_inner_disk_points.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_get_inner_disk_points.pro", "", "", " NAME: 	dsk_get_inner_disk_points    PURPOSE: 	Computes points on the inner edge of a disk.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	disk_pts = dsk_get_inner_disk_points(dkd, np)    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	np:	 Number of points on the edge.    OUTPUT: NONE    KEYWORDS:   INPUT: 	ta:	True anomalies for the points.  Default is the full circle.    OUTPUT: NONE    RETURN: 	Array (np x 3 x nt) of points on the outer edge of each disk, 	in disk body coordinates.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_get_inner_disk_points.html#dsk_get_inner_disk_points", "dsk_get_inner_disk_points", 'routine in <a href="nv/obj/dsk/dsk_get_inner_disk_points.html">dsk_get_inner_disk_points.pro</a>', "dsk_get_inner_disk_points.pro", "", "dsk_get_inner_disk_points", "", "tadisk_ptsdkdn_points", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_get_lan.html", "dsk_get_lan.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_get_lan.pro", "", "", " NAME: 	dsk_get_lan    PURPOSE: 	Determines lan for each given disk descriptor, based on the 	orientation of its BODY axes.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	lan = dsk_lan(dkd, frame_bd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Array (nt) of any subclass of DISK.  	frame_bd:	Subclass of BODY giving the frame against which to 			measure inclinations and nodes, e.g., a planet 			descriptor.  One for each dkd.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	lan value associated with each given disk descriptor.  One for each dkd.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_get_lan.html#dsk_get_lan", "dsk_get_lan", 'routine in <a href="nv/obj/dsk/dsk_get_lan.html">dsk_get_lan.pro</a>', "dsk_get_lan.pro", "", "dsk_get_lan", "", "dkdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_get_lib_ap.html", "dsk_get_lib_ap.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_get_lib_ap.pro", "", "", " NAME: 	dsk_get_lib_ap    PURPOSE: 	Determines lib_ap for each given disk descriptor, based on the 	orientation of its BODY axes.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	lib_ap = dsk_lib_ap(dkd, frame_bd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Array (nt) of any subclass of DISK.  	frame_bd:	Subclass of BODY giving the frame against which to 			measure inclinations and nodes, e.g., a planet 			descriptor.  One for each dkd.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	lib_ap value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_get_lib_ap.html#dsk_get_lib_ap", "dsk_get_lib_ap", 'routine in <a href="nv/obj/dsk/dsk_get_lib_ap.html">dsk_get_lib_ap.pro</a>', "dsk_get_lib_ap.pro", "", "dsk_get_lib_ap", "", "dkdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_get_lib_lan.html", "dsk_get_lib_lan.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_get_lib_lan.pro", "", "", " NAME: 	dsk_get_lib_lan    PURPOSE: 	Determines lib_lan for each given disk descriptor, based on the 	orientation of its BODY axes.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	lib_lan = dsk_lib_lan(dkd, frame_bd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Array (nt) of any subclass of DISK.  	frame_bd:	Subclass of BODY giving the frame against which to 			measure inclinations and nodes, e.g., a planet 			descriptor.  One for each dkd.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	lib_lan value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_get_lib_lan.html#dsk_get_lib_lan", "dsk_get_lib_lan", 'routine in <a href="nv/obj/dsk/dsk_get_lib_lan.html">dsk_get_lib_lan.pro</a>', "dsk_get_lib_lan.pro", "", "dsk_get_lib_lan", "", "dkdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_get_liba_ap.html", "dsk_get_liba_ap.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_get_liba_ap.pro", "", "", " NAME: 	dsk_get_liba_ap    PURPOSE: 	Determines liba_ap for each given disk descriptor, based on the 	orientation of its BODY axes.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	liba_ap = dsk_liba_ap(dkd, frame_bd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Array (nt) of any subclass of DISK.  	frame_bd:	Subclass of BODY giving the frame against which to 			measure inclinations and nodes, e.g., a planet 			descriptor.  One for each dkd.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	liba_ap value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_get_liba_ap.html#dsk_get_liba_ap", "dsk_get_liba_ap", 'routine in <a href="nv/obj/dsk/dsk_get_liba_ap.html">dsk_get_liba_ap.pro</a>', "dsk_get_liba_ap.pro", "", "dsk_get_liba_ap", "", "dkdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_get_liba_lan.html", "dsk_get_liba_lan.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_get_liba_lan.pro", "", "", " NAME: 	dsk_get_liba_lan    PURPOSE: 	Determines liba_lan for each given disk descriptor, based on the 	orientation of its BODY axes.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	liba_lan = dsk_liba_lan(dkd, frame_bd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Array (nt) of any subclass of DISK.  	frame_bd:	Subclass of BODY giving the frame against which to 			measure inclinations and nodes, e.g., a planet 			descriptor.  One for each dkd.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	liba_lan value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_get_liba_lan.html#dsk_get_liba_lan", "dsk_get_liba_lan", 'routine in <a href="nv/obj/dsk/dsk_get_liba_lan.html">dsk_get_liba_lan.pro</a>', "dsk_get_liba_lan.pro", "", "dsk_get_liba_lan", "", "dkdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_get_nl.html", "dsk_get_nl.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_get_nl.pro", "", "", " NAME: 	dsk_get_nl    PURPOSE: 	Obtains the nl (number of vertical harmonics) value from the enironment.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	nm = dsk_get_nm()    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    ENVIRONMENT VARIABLES: 	DSK_NL:		Sets the nl value.    RETURN: 	Value for nl obtained from the DSK_NL environmet variable.  Default 	is 4.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_get_nl.html#dsk_get_nl", "dsk_get_nl", 'routine in <a href="nv/obj/dsk/dsk_get_nl.html">dsk_get_nl.pro</a>', "dsk_get_nl.pro", "", "dsk_get_nl", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_get_nm.html", "dsk_get_nm.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_get_nm.pro", "", "", " NAME: 	dsk_get_nm    PURPOSE: 	Obtains the nm (number of radial harmonics) value from the enironment.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	nm = dsk_get_nm()    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    ENVIRONMENT VARIABLES: 	DSK_NM:		Sets the nm value.    RETURN: 	Value for nm obtained from the DSK_NM environmet variable.  Default 	is 4.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_get_nm.html#dsk_get_nm", "dsk_get_nm", 'routine in <a href="nv/obj/dsk/dsk_get_nm.html">dsk_get_nm.pro</a>', "dsk_get_nm.pro", "", "dsk_get_nm", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_get_node.html", "dsk_get_node.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_get_node.pro", "", "", " NAME: 	dsk_get_node    PURPOSE: 	Computes the ascending node of the given disk wrt the given frame 	body descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	node = dsk_get_node(dkd, frame_bd)    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	frame_bd:	Subclass of BODY giving the frame against which to 			measure inclinations and nodes, e.g., a planet 			descriptor.  One for each dkd.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	One unit vector for each input descriptor pointng along the 	ascending node of each given disk on each given frame 	body descriptor.    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_get_node.html#dsk_get_node", "dsk_get_node", 'routine in <a href="nv/obj/dsk/dsk_get_node.html">dsk_get_node.pro</a>', "dsk_get_node.pro", "", "dsk_get_node", "", "dkdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_get_outer_disk_points.html", "dsk_get_outer_disk_points.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_get_outer_disk_points.pro", "", "", " NAME: 	dsk_get_outer_disk_points    PURPOSE: 	Computes points on the outer edge of a disk.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	disk_pts = dsk_get_outer_disk_points(dkd, np)    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	np:	 Number of points on the edge.    OUTPUT: NONE    KEYWORDS:   INPUT: 	ta:	True anomalies for the points.  Default is the full circle.    OUTPUT: NONE    RETURN: 	Array (np x 3 x nt) of points on the outer edge of each disk, 	in disk body coordinates.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_get_outer_disk_points.html#dsk_get_outer_disk_points", "dsk_get_outer_disk_points", 'routine in <a href="nv/obj/dsk/dsk_get_outer_disk_points.html">dsk_get_outer_disk_points.pro</a>', "dsk_get_outer_disk_points.pro", "", "dsk_get_outer_disk_points", "", "tadisk_ptsdkdn_points", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/dsk_get_perp.html", "dsk_get_perp.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "dsk_get_perp.pro", "", "", " NAME:        dsk_get_perp    PURPOSE: 	Computes vectors in the direction perpendicular to the azimuthal 	direction at a point on a disk.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        dir = dsk_get_perp(cd, dkx, p)    ARGUMENTS:   INPUT: 	cd:	Camera descriptor.  	dkx:	Any subclass of DISK.  	p:	Point on the disk n inertial coordinates.    OUTPUT:  NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (nv,3) of inertial direction vectors.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/dsk_get_perp.html#dsk_get_perp", "dsk_get_perp", 'routine in <a href="nv/obj/tools/dsk_get_perp.html">dsk_get_perp.pro</a>', "dsk_get_perp.pro", "", "dsk_get_perp", "", "uucddkdp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_get_radius.html", "dsk_get_radius.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_get_radius.pro", "", "", " NAME: 	dsk_get_radius    PURPOSE: 	Computes radii along the inner and outer edges of a disk.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	r = dsk_get_radius(dkd, ta, frame_bd)    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	ta:	 Array (nv x nt) of true anomalies at which to compute radii.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (nv x 2 x nt) of radii computed at each true anomaly on each 	disk.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_get_radius.html#dsk_get_radius", "dsk_get_radius", 'routine in <a href="nv/obj/dsk/dsk_get_radius.html">dsk_get_radius.pro</a>', "dsk_get_radius.pro", "", "dsk_get_radius", "", "one_to_onedkdta", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_get_ranges.html", "dsk_get_ranges.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_get_ranges.pro", "", "", " NAME: 	dsk_get_ranges    PURPOSE: 	Returns ranges of valid coordinates for the given DISK object.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	ranges = dsk_get_ranges(dkd)    ARGUMENTS:   INPUT: 	dkd:	 Any subclass of DISK.  One descriptor only.     OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Array (2 x 3) giving the ranges in radius, true anomaly and altitude.    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_get_ranges.html#dsk_get_ranges", "dsk_get_ranges", 'routine in <a href="nv/obj/dsk/dsk_get_ranges.html">dsk_get_ranges.pro</a>', "dsk_get_ranges.pro", "", "dsk_get_ranges", "", "dkd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_hide_points.html", "dsk_hide_points.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_hide_points.pro", "", "", " NAME: 	dsk_hide_points    PURPOSE: 	Hides points wrt a DISK object.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	sub = dsk_hide_points(dkd, r, points)    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	r:	 Column vector giving the position of the viewer in the disk 		 body frame.  	points:	 Array (nv x 3 x nt) of points to test, given in the disk 		 body frame    OUTPUT: NONE    KEYWORDS:   INPUT: 	rm:	If set, points are flagged for being in front of or behind 		the disk, rather then just behind it.  	epsilon: 		Distance in front of the disk for a point to be 		considered  in front of  the disk.  Default is 1.     OUTPUT: NONE    RETURN: 	Array Subscripts of all input vectors (points argument) that are hidden 	from the viewer at r by the given disk.    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_hide_points.html#dsk_hide_points", "dsk_hide_points", 'routine in <a href="nv/obj/dsk/dsk_hide_points.html">dsk_hide_points.pro</a>', "dsk_hide_points.pro", "", "dsk_hide_points", "", "rmepsilondkdrpoints", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_hide_points.html#_dsk_hide_points", "_dsk_hide_points", 'routine in <a href="nv/obj/dsk/dsk_hide_points.html">dsk_hide_points.pro</a>', "dsk_hide_points.pro", "", "_dsk_hide_points", "", "epsiloninvertdkdrpoints", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_il.html", "dsk_il.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_il.pro", "", "", " NAME: 	dsk_il    PURPOSE: 	Returns il for each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	il = dsk_il(dkd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Any subclass of DISK.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	il value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_il.html#dsk_il", "dsk_il", 'routine in <a href="nv/obj/dsk/dsk_il.html">dsk_il.pro</a>', "dsk_il.pro", "", "dsk_il", "", "noeventdkd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/dsk_image_bounds.html", "dsk_image_bounds.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "dsk_image_bounds.pro", "", "", " NAME:        dsk_image_bounds    PURPOSE: 	Determines disk coordinate ranges visible in an image described 	by a given camera descriptor.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        dsk_image_bounds, cd, dkx, $ 	        radmin=radmin, radmax=radmax, lonmin=lonmin, lonmax=lonmax    ARGUMENTS:   INPUT: 	cd:	Camera descripor.  	dkx:	Any subclass of DISK.    OUTPUT:  NONE    KEYOWRDS:   INPUT: 	np:	Number of border points to compute.  	slop:	Number of pixels by which to expand the image in each 		direction.  	plane:	If set, the sma field in dkx is ignored, so an infinite 		disk is considered.     OUTPUT: 	radmin:	Minimum disk radius in image.  	radmax:	Maximum disk radius in image.  	lonmin:	Minimum disk longitude in image.  	lonmax:	Maximum disk longitude in image.  	border_pts_im:	Array (2,np) of points along the edge of the image.  	status:	-1 if no disk in the image, 0 otherwise.    RETURN: NONE    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/dsk_image_bounds.html#dsk_image_bounds", "dsk_image_bounds", 'routine in <a href="nv/obj/tools/dsk_image_bounds.html">dsk_image_bounds.pro</a>', "dsk_image_bounds.pro", "", "dsk_image_bounds", "", "slopborder_pts_imradminradmaxlonminlonmaxnpplanestatuscropcddkx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_intersect.html", "dsk_intersect.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_intersect.pro", "", "", " NAME: 	dsk_intersect    PURPOSE: 	Computes ray intersections with a DISK object.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	v_int = dsk_intersect(dkd, v, r)    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	v:	 Array (nv x 3 x nt) of column vectors giving the origins 		 of the rays in the body frame.  	r:	 Array (nv x 3 x nt) of column vectors giving the directions 		 of the rays in the body frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	t:	Array(nv x 3 x nt) giving the distances to each intersection. 		Values down each column are identical, i.e., this array 		is a stack of three identical (nv x 1 x nt) arrays.  	hit: 	Array giving the subscripts of the input rays that actually 	 	intersect the disk.    RETURN: 	Array (nv x 3 x nt) of column vectors giving the ray/disk 	intersections in the body frame.    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_intersect.html#dsk_intersect", "dsk_intersect", 'routine in <a href="nv/obj/dsk/dsk_intersect.html">dsk_intersect.pro</a>', "dsk_intersect.pro", "", "dsk_intersect", "", "thitnearfaralldkdvr", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_intersect.html#_dsk_intersect", "_dsk_intersect", 'routine in <a href="nv/obj/dsk/dsk_intersect.html">dsk_intersect.pro</a>', "dsk_intersect.pro", "", "_dsk_intersect", "", "thitdkdvr", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_intersect_inertial.html", "dsk_intersect_inertial.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_intersect_inertial.pro", "", "", " NAME: 	dsk_intersect_inertial    PURPOSE: 	Computes ray intersections with a DISK object, in inertial coordinates.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	v_int = dsk_intersect_inertial(dkd, v, r)    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	v:	 Array (nv x 3 x nt) of column vectors giving the origins 		 of the rays in the inertial frame.  	r:	 Array (nv x 3 x nt) of column vectors giving the directions 		 of the rays in the inertial frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	t:	Array(nv x 3 x nt) giving the distances to each intersection. 		Values down each column are identical, i.e., this array 		is a stack of three identical (nv x 1 x nt) arrays.  	hit: 	Array giving the subscripts of the input rays that actually 	 	intersect the disk.    RETURN: 	Array (nv x 3 x nt) of column vectors giving the ray/disk 	intersections in the inertial frame.  Note this if inertial 	results are needed, this routine is slightly faster than 	dsk_intersect.    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_intersect_inertial.html#dsk_intersect_inertial", "dsk_intersect_inertial", 'routine in <a href="nv/obj/dsk/dsk_intersect_inertial.html">dsk_intersect_inertial.pro</a>', "dsk_intersect_inertial.pro", "", "dsk_intersect_inertial", "", "thitnoeventdkdvr", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_l.html", "dsk_l.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_l.pro", "", "", " NAME: 	dsk_l    PURPOSE: 	Returns l for each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	l = dsk_l(dkd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Any subclass of DISK.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	l value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_l.html#dsk_l", "dsk_l", 'routine in <a href="nv/obj/dsk/dsk_l.html">dsk_l.pro</a>', "dsk_l.pro", "", "dsk_l", "", "noeventdkd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_libal.html", "dsk_libal.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_libal.pro", "", "", " NAME: 	dsk_libal    PURPOSE: 	Returns libal for each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	libal = dsk_libal(dkd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Any subclass of DISK.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	libal value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_libal.html#dsk_libal", "dsk_libal", 'routine in <a href="nv/obj/dsk/dsk_libal.html">dsk_libal.pro</a>', "dsk_libal.pro", "", "dsk_libal", "", "noeventdkd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_libam.html", "dsk_libam.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_libam.pro", "", "", " NAME: 	dsk_libam    PURPOSE: 	Returns libam for each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	libam = dsk_libam(dkd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Any subclass of DISK.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	libam value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_libam.html#dsk_libam", "dsk_libam", 'routine in <a href="nv/obj/dsk/dsk_libam.html">dsk_libam.pro</a>', "dsk_libam.pro", "", "dsk_libam", "", "noeventdkd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_libl.html", "dsk_libl.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_libl.pro", "", "", " NAME: 	dsk_libl    PURPOSE: 	Returns libl for each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	libl = dsk_libl(dkd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Any subclass of DISK.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	libl value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_libl.html#dsk_libl", "dsk_libl", 'routine in <a href="nv/obj/dsk/dsk_libl.html">dsk_libl.pro</a>', "dsk_libl.pro", "", "dsk_libl", "", "noeventdkd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_libm.html", "dsk_libm.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_libm.pro", "", "", " NAME: 	dsk_libm    PURPOSE: 	Returns libm for each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	libm = dsk_libm(dkd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Any subclass of DISK.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	libm value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_libm.html#dsk_libm", "dsk_libm", 'routine in <a href="nv/obj/dsk/dsk_libm.html">dsk_libm.pro</a>', "dsk_libm.pro", "", "dsk_libm", "", "noeventdkd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_m.html", "dsk_m.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_m.pro", "", "", " NAME: 	dsk_m    PURPOSE: 	Returns m for each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	m = dsk_m(dkd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Any subclass of DISK.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	m value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_m.html#dsk_m", "dsk_m", 'routine in <a href="nv/obj/dsk/dsk_m.html">dsk_m.pro</a>', "dsk_m.pro", "", "dsk_m", "", "noeventdkd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_nl.html", "dsk_nl.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_nl.pro", "", "", " NAME: 	dsk_nl    PURPOSE: 	Returns nl for each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	nl = dsk_nl(dkd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Any subclass of DISK.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	nl value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_nl.html#dsk_nl", "dsk_nl", 'routine in <a href="nv/obj/dsk/dsk_nl.html">dsk_nl.pro</a>', "dsk_nl.pro", "", "dsk_nl", "", "noeventdkd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_nm.html", "dsk_nm.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_nm.pro", "", "", " NAME: 	dsk_nm    PURPOSE: 	Returns nm for each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	nm = dsk_nm(dkd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Any subclass of DISK.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	nm value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_nm.html#dsk_nm", "dsk_nm", 'routine in <a href="nv/obj/dsk/dsk_nm.html">dsk_nm.pro</a>', "dsk_nm.pro", "", "dsk_nm", "", "noeventdkd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/dsk_projected_resolution.html", "dsk_projected_resolution.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "dsk_projected_resolution.pro", "", "", " NAME:        dsk_projected_resolution    PURPOSE: 	Computes the resolution (actually scale) components at a point on a 	disk in a given camera.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        res = dsk_projected_resolution(dkx, cd, p, scale)    ARGUMENTS:   INPUT: 	dkx:	Any subclass of DISK.  	cd:	Camera descriptor.  	p:	Point on the dkx in inertial coordinates.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	rad:	Pixel scale in the radial direction.  	lon:	Pixel scale in the longitude direction.  	perp:	Pixel scale in the direction perpendicular to the 		projected longitude direction.  	rr:	Intercept radius.    RETURN: 	Radial resolution on dkx at r, computed as the length of a 	segment bisecting the intersection ellipse in the radial direction.    MODIFICATION HISTORY:        Written by:     Spitale, usning an approach suggested by M. Tiscareno   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/dsk_projected_resolution.html#dsk_projected_resolution", "dsk_projected_resolution", 'routine in <a href="nv/obj/tools/dsk_projected_resolution.html">dsk_projected_resolution.pro</a>', "dsk_projected_resolution.pro", "", "dsk_projected_resolution", "", "radlonperprrdkdcdpscale", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_query.html", "dsk_query.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_query.pro", "", "", " NAME: 	dsk_query    PURPOSE: 	Returns the fields associated with a DISK object.  This is a 	convenient way of getting multiple fields in one call, and only a 	single event is generated.    CATEGORY: 	NV/OBJ/DSK    CALLING SEQUENCE: 	dsk_query, dkd, <keywords>=<values>    ARGUMENTS:   INPUT: 	dkd:	DISK object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	DISK object fields to set.  	condition:	Structure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT object, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.  	cat:		If set, arrays from mulitple input objets are 			concatenated.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.  	noevent:	If set, no event is generated.    OUTPUT: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_query.html#dsk_query", "dsk_query", 'routine in <a href="nv/obj/dsk/dsk_query.html">dsk_query.pro</a>', "dsk_query.pro", "", "dsk_query", "", "conditioncatnoeventxd@dsk__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/dsk_radial_resolution.html", "dsk_radial_resolution.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "dsk_radial_resolution.pro", "", "", " NAME:        dsk_radial_resolution    PURPOSE: 	Computes the radial resolution at a point on a disk in a 	given camera.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        res = dsk_radial_resolution(dkx, cd, r, scale)    ARGUMENTS:   INPUT: 	dkx:	Any subclass of DISK.  	cd:	Camera descriptor.  	r:	Point on the dkx in inertial coordinates.    OUTPUT:  NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Radial resolution on dkx at r, computed as the length of a 	segment bisecting the intersection ellipse in the radial direction.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/dsk_radial_resolution.html#dsk_radial_resolution", "dsk_radial_resolution", 'routine in <a href="nv/obj/tools/dsk_radial_resolution.html">dsk_radial_resolution.pro</a>', "dsk_radial_resolution.pro", "", "dsk_radial_resolution", "", "dkdcdrscale", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_reflect.html", "dsk_reflect.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_reflect.pro", "", "", " NAME: 	dsk_reflect    PURPOSE: 	Computes ray reflections with a DISK object.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	v_int = dsk_reflect(dkd, v, r)    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	v:	 Array (nv x 3 x nt) of column vectors giving the observer 		 position in the body frame.  	r:	 Array (nv x 3 x nt) of column vectors giving the source 		 position in the body frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	hit: 	Array giving the subscripts of the input rays that actually 	 	reflect on the disk.    RETURN: 	Array (nv x 3 x nt) of column vectors giving the ray/disk 	reflections in the body frame.    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_reflect.html#dsk_reflect", "dsk_reflect", 'routine in <a href="nv/obj/dsk/dsk_reflect.html">dsk_reflect.pro</a>', "dsk_reflect.pro", "", "dsk_reflect", "", "hitdkdvr", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_replicate.html", "dsk_replicate.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_replicate.pro", "", "", " NAME: 	dsk_replicate    PURPOSE: 	Replicates the given descriptor, producing an array of the given 	dimensions containing cloned versions of the input descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	xd = dsk_replicate(dkd, dim)    ARGUMENTS:   INPUT: 	dkd:	 Any superclass of DISK.  	dim:	 Dimensions of the result.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Array of the given dimensions containing cloned versions of the input 	descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_replicate.html#dsk_replicate", "dsk_replicate", 'routine in <a href="nv/obj/dsk/dsk_replicate.html">dsk_replicate.pro</a>', "dsk_replicate.pro", "", "dsk_replicate", "", "dkddim", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_scale.html", "dsk_scale.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_scale.pro", "", "", " NAME: 	dsk_scale    PURPOSE: 	Returns scale for each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	scale = dsk_scale(dkd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Any subclass of DISK.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	scale value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_scale.html#dsk_scale", "dsk_scale", 'routine in <a href="nv/obj/dsk/dsk_scale.html">dsk_scale.pro</a>', "dsk_scale.pro", "", "dsk_scale", "", "noeventdkd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_ap.html", "dsk_set_ap.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_set_ap.pro", "", "", " NAME: 	dsk_set_ap    PURPOSE: 	Replaces ap in each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_ap, bx, ap    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	ap:	 New ap value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_ap.html#dsk_set_ap", "dsk_set_ap", 'routine in <a href="nv/obj/dsk/dsk_set_ap.html">dsk_set_ap.pro</a>', "dsk_set_ap.pro", "", "dsk_set_ap", "", "dkdapframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_dap.html", "dsk_set_dap.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_set_dap.pro", "", "", " NAME: 	dsk_set_dap    PURPOSE: 	Replaces the apsidal shift in each given disk descriptor.  Half of the 	shift is applied to each edge, so as to not affect the mean periapse 	direction.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_dap, bx, dap    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	dap:	 New dap value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_dap.html#dsk_set_dap", "dsk_set_dap", 'routine in <a href="nv/obj/dsk/dsk_set_dap.html">dsk_set_dap.pro</a>', "dsk_set_dap.pro", "", "dsk_set_dap", "", "noeventdkddap", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_dapdt.html", "dsk_set_dapdt.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_set_dapdt.pro", "", "", " NAME: 	dsk_set_dapdt    PURPOSE: 	Replaces dapdt in each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_dapdt, bx, dapdt    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	dapdt:	 New dapdt value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_dapdt.html#dsk_set_dapdt", "dsk_set_dapdt", 'routine in <a href="nv/obj/dsk/dsk_set_dapdt.html">dsk_set_dapdt.pro</a>', "dsk_set_dapdt.pro", "", "dsk_set_dapdt", "", "dkddapdtframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_dlandt.html", "dsk_set_dlandt.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_set_dlandt.pro", "", "", " NAME: 	dsk_set_dlandt    PURPOSE: 	Replaces dlandt in each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_dlandt, bx, dlandt    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	dlandt:	 New dlandt value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_dlandt.html#dsk_set_dlandt", "dsk_set_dlandt", 'routine in <a href="nv/obj/dsk/dsk_set_dlandt.html">dsk_set_dlandt.pro</a>', "dsk_set_dlandt.pro", "", "dsk_set_dlandt", "", "dkddlandtframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_dlibdt_ap.html", "dsk_set_dlibdt_ap.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_set_dlibdt_ap.pro", "", "", " NAME: 	dsk_set_dlibdt_ap    PURPOSE: 	Sets dlibdt_ap in each given disk descriptor.  This value is determined 	by the orientation of the BODY axes.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_dlibdt_ap, bx, dlibdt_ap, frame_bd    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	dlibdt_ap:	 New dlibdt_ap value.  	frame_bd:	Subclass of BODY giving the frame against which to 			measure inclinations and nodes, e.g., a planet 			descriptor.  One for each dkd.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_dlibdt_ap.html#dsk_set_dlibdt_ap", "dsk_set_dlibdt_ap", 'routine in <a href="nv/obj/dsk/dsk_set_dlibdt_ap.html">dsk_set_dlibdt_ap.pro</a>', "dsk_set_dlibdt_ap.pro", "", "dsk_set_dlibdt_ap", "", "dkddlibdt_apframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_dlibdt_lan.html", "dsk_set_dlibdt_lan.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_set_dlibdt_lan.pro", "", "", " NAME: 	dsk_set_dlibdt_lan    PURPOSE: 	Sets dlibdt_lan in each given disk descriptor.  This value is determined 	by the orientation of the BODY axes.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_dlibdt_lan, bx, dlibdt_lan, frame_bd    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	dlibdt_lan:	 New dlibdt_lan value.  	frame_bd:	Subclass of BODY giving the frame against which to 			measure inclinations and nodes, e.g., a planet 			descriptor.  One for each dkd.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_dlibdt_lan.html#dsk_set_dlibdt_lan", "dsk_set_dlibdt_lan", 'routine in <a href="nv/obj/dsk/dsk_set_dlibdt_lan.html">dsk_set_dlibdt_lan.pro</a>', "dsk_set_dlibdt_lan.pro", "", "dsk_set_dlibdt_lan", "", "dkddlibdt_lanframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_dlibldt.html", "dsk_set_dlibldt.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_set_dlibldt.pro", "", "", " NAME: 	dsk_set_dlibldt    PURPOSE: 	Replaces dlibldt in each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_dlibldt, bx, dlibldt    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	dlibldt:	 New dlibldt value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_dlibldt.html#dsk_set_dlibldt", "dsk_set_dlibldt", 'routine in <a href="nv/obj/dsk/dsk_set_dlibldt.html">dsk_set_dlibldt.pro</a>', "dsk_set_dlibldt.pro", "", "dsk_set_dlibldt", "", "noeventdkddlibldt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_dlibmdt.html", "dsk_set_dlibmdt.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_set_dlibmdt.pro", "", "", " NAME: 	dsk_set_dlibmdt    PURPOSE: 	Replaces dlibmdt in each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_dlibmdt, bx, dlibmdt    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	dlibmdt:	 New dlibmdt value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_dlibmdt.html#dsk_set_dlibmdt", "dsk_set_dlibmdt", 'routine in <a href="nv/obj/dsk/dsk_set_dlibmdt.html">dsk_set_dlibmdt.pro</a>', "dsk_set_dlibmdt.pro", "", "dsk_set_dlibmdt", "", "noeventdkddlibmdt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_dlpmdt.html", "dsk_set_dlpmdt.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_set_dlpmdt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_dlpmdt.html#dsk_set_dlpmdt", "dsk_set_dlpmdt", 'routine in <a href="nv/obj/dsk/dsk_set_dlpmdt.html">dsk_set_dlpmdt.pro</a>', "dsk_set_dlpmdt.pro", "", "dsk_set_dlpmdt", "", "bxdlpmdt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_dtaanldt.html", "dsk_set_dtaanldt.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_set_dtaanldt.pro", "", "", " NAME: 	dsk_set_dtaanldt    PURPOSE: 	Replaces dtaanldt in each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_dtaanldt, bx, dtaanldt    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	dtaanldt:	 New dtaanldt value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_dtaanldt.html#dsk_set_dtaanldt", "dsk_set_dtaanldt", 'routine in <a href="nv/obj/dsk/dsk_set_dtaanldt.html">dsk_set_dtaanldt.pro</a>', "dsk_set_dtaanldt.pro", "", "dsk_set_dtaanldt", "", "noeventdkddtaanldt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_dtapmdt.html", "dsk_set_dtapmdt.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_set_dtapmdt.pro", "", "", " NAME: 	dsk_set_dtapmdt    PURPOSE: 	Replaces dtapmdt in each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_dtapmdt, bx, dtapmdt    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	dtapmdt:	 New dtapmdt value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_dtapmdt.html#dsk_set_dtapmdt", "dsk_set_dtapmdt", 'routine in <a href="nv/obj/dsk/dsk_set_dtapmdt.html">dsk_set_dtapmdt.pro</a>', "dsk_set_dtapmdt.pro", "", "dsk_set_dtapmdt", "", "noeventdkddtapmdt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_ecc.html", "dsk_set_ecc.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_set_ecc.pro", "", "", " NAME: 	dsk_set_ecc    PURPOSE: 	Replaces ecc in each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_ecc, bx, ecc    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	ecc:	 New ecc value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_ecc.html#dsk_set_ecc", "dsk_set_ecc", 'routine in <a href="nv/obj/dsk/dsk_set_ecc.html">dsk_set_ecc.pro</a>', "dsk_set_ecc.pro", "", "dsk_set_ecc", "", "noeventdkdecc", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_em.html", "dsk_set_em.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_set_em.pro", "", "", " NAME: 	dsk_set_em    PURPOSE: 	Replaces em in each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_em, bx, em    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	em:	 New em value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_em.html#dsk_set_em", "dsk_set_em", 'routine in <a href="nv/obj/dsk/dsk_set_em.html">dsk_set_em.pro</a>', "dsk_set_em.pro", "", "dsk_set_em", "", "noeventdkdem", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_il.html", "dsk_set_il.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_set_il.pro", "", "", " NAME: 	dsk_set_il    PURPOSE: 	Replaces il in each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_il, bx, il    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	il:	 New il value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_il.html#dsk_set_il", "dsk_set_il", 'routine in <a href="nv/obj/dsk/dsk_set_il.html">dsk_set_il.pro</a>', "dsk_set_il.pro", "", "dsk_set_il", "", "noeventdkdil", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_inc.html", "dsk_set_inc.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_set_inc.pro", "", "", " NAME: 	dsk_set_inc    PURPOSE: 	Sets inc in each given disk descriptor.  This value is determined 	by the orientation of the BODY axes.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_inc, bx, inc, frame_bd    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	inc:	 New inc value.  	frame_bd:	Subclass of BODY giving the frame against which to 			measure inclinations and nodes, e.g., a planet 			descriptor.  One for each dkd.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_inc.html#dsk_set_inc", "dsk_set_inc", 'routine in <a href="nv/obj/dsk/dsk_set_inc.html">dsk_set_inc.pro</a>', "dsk_set_inc.pro", "", "dsk_set_inc", "", "dkdincframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_l.html", "dsk_set_l.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_set_l.pro", "", "", " NAME: 	dsk_set_l    PURPOSE: 	Replaces l in each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_l, bx, l    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	l:	 New l value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_l.html#dsk_set_l", "dsk_set_l", 'routine in <a href="nv/obj/dsk/dsk_set_l.html">dsk_set_l.pro</a>', "dsk_set_l.pro", "", "dsk_set_l", "", "noeventdkdl", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_lan.html", "dsk_set_lan.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_set_lan.pro", "", "", " NAME: 	dsk_set_lan    PURPOSE: 	Sets lan in each given disk descriptor.  This value is determined 	by the orientation of the BODY axes.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_lan, bx, lan, frame_bd    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	lan:	 New lan value.  	frame_bd:	Subclass of BODY giving the frame against which to 			measure inclinations and nodes, e.g., a planet 			descriptor.  One for each dkd.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_lan.html#dsk_set_lan", "dsk_set_lan", 'routine in <a href="nv/obj/dsk/dsk_set_lan.html">dsk_set_lan.pro</a>', "dsk_set_lan.pro", "", "dsk_set_lan", "", "dkdlanframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_lib_ap.html", "dsk_set_lib_ap.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_set_lib_ap.pro", "", "", " NAME: 	dsk_set_lib_ap    PURPOSE: 	Sets lib_ap in each given disk descriptor.  This value is determined 	by the orientation of the BODY axes.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_lib_ap, bx, lib_ap, frame_bd    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	lib_ap:	 New lib_ap value.  	frame_bd:	Subclass of BODY giving the frame against which to 			measure inclinations and nodes, e.g., a planet 			descriptor.  One for each dkd.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_lib_ap.html#dsk_set_lib_ap", "dsk_set_lib_ap", 'routine in <a href="nv/obj/dsk/dsk_set_lib_ap.html">dsk_set_lib_ap.pro</a>', "dsk_set_lib_ap.pro", "", "dsk_set_lib_ap", "", "dkdlib_apframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_lib_lan.html", "dsk_set_lib_lan.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_set_lib_lan.pro", "", "", " NAME: 	dsk_set_lib_lan    PURPOSE: 	Sets lib_lan in each given disk descriptor.  This value is determined 	by the orientation of the BODY axes.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_lib_lan, bx, lib_lan, frame_bd    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	lib_lan:	 New lib_lan value.  	frame_bd:	Subclass of BODY giving the frame against which to 			measure inclinations and nodes, e.g., a planet 			descriptor.  One for each dkd.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_lib_lan.html#dsk_set_lib_lan", "dsk_set_lib_lan", 'routine in <a href="nv/obj/dsk/dsk_set_lib_lan.html">dsk_set_lib_lan.pro</a>', "dsk_set_lib_lan.pro", "", "dsk_set_lib_lan", "", "dkdlib_lanframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_liba_ap.html", "dsk_set_liba_ap.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_set_liba_ap.pro", "", "", " NAME: 	dsk_set_liba_ap    PURPOSE: 	Sets liba_ap in each given disk descriptor.  This value is determined 	by the orientation of the BODY axes.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_liba_ap, bx, liba_ap, frame_bd    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	liba_ap:	 New liba_ap value.  	frame_bd:	Subclass of BODY giving the frame against which to 			measure inclinations and nodes, e.g., a planet 			descriptor.  One for each dkd.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_liba_ap.html#dsk_set_liba_ap", "dsk_set_liba_ap", 'routine in <a href="nv/obj/dsk/dsk_set_liba_ap.html">dsk_set_liba_ap.pro</a>', "dsk_set_liba_ap.pro", "", "dsk_set_liba_ap", "", "dkdliba_apframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_liba_lan.html", "dsk_set_liba_lan.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_set_liba_lan.pro", "", "", " NAME: 	dsk_set_liba_lan    PURPOSE: 	Sets liba_lan in each given disk descriptor.  This value is determined 	by the orientation of the BODY axes.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_liba_lan, bx, liba_lan, frame_bd    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	liba_lan:	 New liba_lan value.  	frame_bd:	Subclass of BODY giving the frame against which to 			measure inclinations and nodes, e.g., a planet 			descriptor.  One for each dkd.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_liba_lan.html#dsk_set_liba_lan", "dsk_set_liba_lan", 'routine in <a href="nv/obj/dsk/dsk_set_liba_lan.html">dsk_set_liba_lan.pro</a>', "dsk_set_liba_lan.pro", "", "dsk_set_liba_lan", "", "dkdliba_lanframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_libal.html", "dsk_set_libal.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_set_libal.pro", "", "", " NAME: 	dsk_set_libal    PURPOSE: 	Replaces libal in each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_libal, bx, libal    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	libal:	 New libal value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_libal.html#dsk_set_libal", "dsk_set_libal", 'routine in <a href="nv/obj/dsk/dsk_set_libal.html">dsk_set_libal.pro</a>', "dsk_set_libal.pro", "", "dsk_set_libal", "", "noeventdkdlibal", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_libam.html", "dsk_set_libam.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_set_libam.pro", "", "", " NAME: 	dsk_set_libam    PURPOSE: 	Replaces libam in each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_libam, bx, libam    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	libam:	 New libam value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_libam.html#dsk_set_libam", "dsk_set_libam", 'routine in <a href="nv/obj/dsk/dsk_set_libam.html">dsk_set_libam.pro</a>', "dsk_set_libam.pro", "", "dsk_set_libam", "", "noeventdkdlibam", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_libl.html", "dsk_set_libl.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_set_libl.pro", "", "", " NAME: 	dsk_set_libl    PURPOSE: 	Replaces libl in each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_libl, bx, libl    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	libl:	 New libl value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_libl.html#dsk_set_libl", "dsk_set_libl", 'routine in <a href="nv/obj/dsk/dsk_set_libl.html">dsk_set_libl.pro</a>', "dsk_set_libl.pro", "", "dsk_set_libl", "", "noeventdkdlibl", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_libm.html", "dsk_set_libm.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_set_libm.pro", "", "", " NAME: 	dsk_set_libm    PURPOSE: 	Replaces libm in each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_libm, bx, libm    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	libm:	 New libm value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_libm.html#dsk_set_libm", "dsk_set_libm", 'routine in <a href="nv/obj/dsk/dsk_set_libm.html">dsk_set_libm.pro</a>', "dsk_set_libm.pro", "", "dsk_set_libm", "", "noeventdkdlibm", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_lpm.html", "dsk_set_lpm.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_set_lpm.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_lpm.html#dsk_set_lpm", "dsk_set_lpm", 'routine in <a href="nv/obj/dsk/dsk_set_lpm.html">dsk_set_lpm.pro</a>', "dsk_set_lpm.pro", "", "dsk_set_lpm", "", "bxlpm", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_m.html", "dsk_set_m.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_set_m.pro", "", "", " NAME: 	dsk_set_m    PURPOSE: 	Replaces m in each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_m, bx, m    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	m:	 New m value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_m.html#dsk_set_m", "dsk_set_m", 'routine in <a href="nv/obj/dsk/dsk_set_m.html">dsk_set_m.pro</a>', "dsk_set_m.pro", "", "dsk_set_m", "", "noeventdkdm", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_nl.html", "dsk_set_nl.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_set_nl.pro", "", "", " NAME: 	dsk_set_nl    PURPOSE: 	Replaces nl in each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_nl, bx, nl    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	nl:	 New nl value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_nl.html#dsk_set_nl", "dsk_set_nl", 'routine in <a href="nv/obj/dsk/dsk_set_nl.html">dsk_set_nl.pro</a>', "dsk_set_nl.pro", "", "dsk_set_nl", "", "noeventdkdnl", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_nm.html", "dsk_set_nm.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_set_nm.pro", "", "", " NAME: 	dsk_set_nm    PURPOSE: 	Replaces nm in each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_nm, bx, nm    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	nm:	 New nm value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_nm.html#dsk_set_nm", "dsk_set_nm", 'routine in <a href="nv/obj/dsk/dsk_set_nm.html">dsk_set_nm.pro</a>', "dsk_set_nm.pro", "", "dsk_set_nm", "", "noeventdkdnm", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_phase_fn.html", "dsk_set_phase_fn.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_set_phase_fn.pro", "", "", " NAME: 	dsk_set_phase_fn    PURPOSE:        Replaces the phase function for each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_phase_fn, dkd, phase_fn    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK descriptors.  	phase_fn: Array (nt) of new phase functions.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_phase_fn.html#dsk_set_phase_fn", "dsk_set_phase_fn", 'routine in <a href="nv/obj/dsk/dsk_set_phase_fn.html">dsk_set_phase_fn.pro</a>', "dsk_set_phase_fn.pro", "", "dsk_set_phase_fn", "", "noeventdkdphase_fn", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_refl_fn.html", "dsk_set_refl_fn.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_set_refl_fn.pro", "", "", " NAME: 	dsk_set_refl_fn    PURPOSE:        Replaces the reflection function for each given disk descriptor.    CATEGORY: 	NV/LIB/dsk    CALLING SEQUENCE: 	dsk_set_refl_fn, dkd, refl_fn    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK descriptors.  	refl_fn: Array (nt) of new reflection functions.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_refl_fn.html#dsk_set_refl_fn", "dsk_set_refl_fn", 'routine in <a href="nv/obj/dsk/dsk_set_refl_fn.html">dsk_set_refl_fn.pro</a>', "dsk_set_refl_fn.pro", "", "dsk_set_refl_fn", "", "noeventdkdrefl_fn", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_scale.html", "dsk_set_scale.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_set_scale.pro", "", "", " NAME: 	dsk_set_scale    PURPOSE: 	Replaces the scale in each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_scale, bx, scale    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	scale:	 New scale value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_scale.html#dsk_set_scale", "dsk_set_scale", 'routine in <a href="nv/obj/dsk/dsk_set_scale.html">dsk_set_scale.pro</a>', "dsk_set_scale.pro", "", "dsk_set_scale", "", "noeventdkdscale", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_sma.html", "dsk_set_sma.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_set_sma.pro", "", "", " NAME: 	dsk_set_sma    PURPOSE: 	Replaces the sma in each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_sma, bx, sma    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	sma:	 New sma value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_sma.html#dsk_set_sma", "dsk_set_sma", 'routine in <a href="nv/obj/dsk/dsk_set_sma.html">dsk_set_sma.pro</a>', "dsk_set_sma.pro", "", "dsk_set_sma", "", "noeventdkdsma", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_taanl.html", "dsk_set_taanl.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_set_taanl.pro", "", "", " NAME: 	dsk_set_taanl    PURPOSE: 	Replaces taanl in each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_taanl, bx, taanl    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	taanl:	 New taanl value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_taanl.html#dsk_set_taanl", "dsk_set_taanl", 'routine in <a href="nv/obj/dsk/dsk_set_taanl.html">dsk_set_taanl.pro</a>', "dsk_set_taanl.pro", "", "dsk_set_taanl", "", "noeventdkdtaanl", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_tanl.html", "dsk_set_tanl.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_set_tanl.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_tanl.html#dsk_set_tanl", "dsk_set_tanl", 'routine in <a href="nv/obj/dsk/dsk_set_tanl.html">dsk_set_tanl.pro</a>', "dsk_set_tanl.pro", "", "dsk_set_tanl", "", "bxtanl", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_tapm.html", "dsk_set_tapm.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_set_tapm.pro", "", "", " NAME: 	dsk_set_tapm    PURPOSE: 	Replaces tapm in each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	dsk_set_tapm, bx, tapm    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	tapm:	 New tapm value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_set_tapm.html#dsk_set_tapm", "dsk_set_tapm", 'routine in <a href="nv/obj/dsk/dsk_set_tapm.html">dsk_set_tapm.pro</a>', "dsk_set_tapm.pro", "", "dsk_set_tapm", "", "noeventdkdtapm", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_shape_radial.html", "dsk_shape_radial.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_shape_radial.pro", "", "", " NAME: 	dsk_shape_radial    PURPOSE: 	Computes radii along the edge of a disk using disk elements.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	z = dsk_shape_radial(a, e, dap, ta, m, em, tapm)    ARGUMENTS:   INPUT: 	a:	 Array (nt) of semimajor axis values.  	e:	 Array (nt) of eccentricity values.  	dap:	 Array (nt) of apsidal shift values.  	ta:	 Array (nv x nt) of true anomalies at which to compute radii.  	m:	 Array (nt x nm) of radial wavenumbers.  	em:	 Array (nt x nm) of eccentricities for each m.  	tapm:	 Array (nt x nm) of true anomalies of periapse for each m.     OUTPUT: NONE    KEYWORDS:   INPUT: 	mm:	If set, only the radius component for this wavenumber 		is returned.  	mii:	If set, only the radius component with this index 		is returned.    OUTPUT: NONE    RETURN: 	Array (nv x nt) of radii computed at each true anomaly on each 	disk.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_shape_radial.html#dsk_shape_radial", "dsk_shape_radial", 'routine in <a href="nv/obj/dsk/dsk_shape_radial.html">dsk_shape_radial.pro</a>', "dsk_shape_radial.pro", "", "dsk_shape_radial", "", "mmmii_a_e_dapta_m_em_tapm", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_shape_vertical.html", "dsk_shape_vertical.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_shape_vertical.pro", "", "", " NAME: 	dsk_shape_vertical    PURPOSE: 	Computes elevations along the edge of a disk using disk elements.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	z = dsk_shape_vertical(dkd, a, ta, l, il, taanl)    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.  	a:	 Array (nt) of semimajor axis values.  	ta:	 Array (nta) of true anomalies at which to compute elevations.  	l:	 Array (nt) of vertical wavenumbers.  	il:	 Array (nt) of inclinations for each l.  	taanl:	 Array (nt) of true anomalies of ascending node for each l.     OUTPUT: NONE    KEYWORDS:   INPUT: 	ll:	If set, only the elevation component for this wavenumber 		is returned.  	lii:	If set, only the elevation component with this index 		is returned.    OUTPUT: NONE    RETURN: 	Array (nt x nta) of elevations computed at each true anomaly on each 	disk.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_shape_vertical.html#dsk_shape_vertical", "dsk_shape_vertical", 'routine in <a href="nv/obj/dsk/dsk_shape_vertical.html">dsk_shape_vertical.pro</a>', "dsk_shape_vertical.pro", "", "dsk_shape_vertical", "", "dkdllliiataliltaanl", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_sma.html", "dsk_sma.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_sma.pro", "", "", " NAME: 	dsk_sma    PURPOSE: 	Returns sma for each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	sma = dsk_sma(dkd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Any subclass of DISK.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	sma value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_sma.html#dsk_sma", "dsk_sma", 'routine in <a href="nv/obj/dsk/dsk_sma.html">dsk_sma.pro</a>', "dsk_sma.pro", "", "dsk_sma", "", "noeventdkd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_surface_normal.html", "dsk_surface_normal.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_surface_normal.pro", "", "", " NAME: 	dsk_surface_normal    PURPOSE: 	Computes the surface normal for a DISK object at the given 	body-frame positions.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	n = dsk_surface_normal(dkd, r)    ARGUMENTS:   INPUT: 	dkd:	Array (nt) of any subclass of DISK descriptors.  	v:	Array (nv,3) of observer positions in the BODY frame.  	r:	Array (nv,3) of surface positions in the BODY frame.     OUTPUT: NONE    KEYWORDS:   INPUT: 	north:     If set, the retruned normals will be pointed north. 	           Otherwise, they point toward the observer's hemisphere.     OUTPUT: NONE    RETURN: 	Array (nv, 3, nt) of surface unit normals in the BODY frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_surface_normal.html#dsk_surface_normal", "dsk_surface_normal", 'routine in <a href="nv/obj/dsk/dsk_surface_normal.html">dsk_surface_normal.pro</a>', "dsk_surface_normal.pro", "", "dsk_surface_normal", "", "noeventnorthdkdvr", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_swap.html", "dsk_swap.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_swap.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_swap.html#dsk_swap", "dsk_swap", 'routine in <a href="nv/obj/dsk/dsk_swap.html">dsk_swap.pro</a>', "dsk_swap.pro", "", "dsk_swap", "", "noeventdkd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_taanl.html", "dsk_taanl.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_taanl.pro", "", "", " NAME: 	dsk_taanl    PURPOSE: 	Returns taanl for each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	taanl = dsk_taanl(dkd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Any subclass of DISK.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	taanl value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_taanl.html#dsk_taanl", "dsk_taanl", 'routine in <a href="nv/obj/dsk/dsk_taanl.html">dsk_taanl.pro</a>', "dsk_taanl.pro", "", "dsk_taanl", "", "noeventdkd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_tapm.html", "dsk_tapm.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_tapm.pro", "", "", " NAME: 	dsk_tapm    PURPOSE: 	Returns tapm for each given disk descriptor.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	tapm = dsk_tapm(dkd)    ARGUMENTS:   INPUT: NONE 	dkd:	 Any subclass of DISK.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	tapm value associated with each given disk descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_tapm.html#dsk_tapm", "dsk_tapm", 'routine in <a href="nv/obj/dsk/dsk_tapm.html">dsk_tapm.pro</a>', "dsk_tapm.pro", "", "dsk_tapm", "", "noeventdkd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_valid_edges.html", "dsk_valid_edges.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_valid_edges.pro", "", "", " NAME: 	dsk_valid_edges    PURPOSE: 	Determines which edges (i.e., inner/outer) in the input DISK objects 	are valid.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	sub = dsk_valid_edges(dkd, </inner|/outer|/all>)    ARGUMENTS:   INPUT: 	dkd:	 Array (nt) of any subclass of DISK.    OUTPUT: NONE    KEYWORDS:   INPUT: 	inner:	If set, only the inner edges are tested.  	outer:	If set, only the outer edges are tested.  	all:	If set, the inner and outer edges are tested, and must 		both be valid to be selected.    OUTPUT: NONE    RETURN: 	Array of subscripts of the descriptors whose edges meet the criteria 	defined by the input keyowrds.    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_valid_edges.html#dsk_valid_edges", "dsk_valid_edges", 'routine in <a href="nv/obj/dsk/dsk_valid_edges.html">dsk_valid_edges.pro</a>', "dsk_valid_edges.pro", "", "dsk_valid_edges", "", "innerouterallnoeventdkd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_widen.html", "dsk_widen.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "dsk_widen.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/dsk_widen.html#dsk_widen", "dsk_widen", 'routine in <a href="nv/obj/dsk/dsk_widen.html">dsk_widen.pro</a>', "dsk_widen.pro", "", "dsk_widen", "", "noeventdkdwidth", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/east_to_west_longitude.html", "east_to_west_longitude.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "east_to_west_longitude.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/east_to_west_longitude.html#east_to_west_longitude", "east_to_west_longitude", 'routine in <a href="util/east_to_west_longitude.html">east_to_west_longitude.pro</a>', "east_to_west_longitude.pro", "", "east_to_west_longitude", "", "lon", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/icv/edge_model_atan.html", "edge_model_atan.pro", '.pro file in <a href="nv/obj/tools/icv/dir-overview.html">nv/obj/tools/icv/ directory</a>', "edge_model_atan.pro", "", "", " NAME:        edge_model_atan    PURPOSE: 	Calculates an arctan edge model for use in curve fitting.   CATEGORY:        NV/LIB/TOOLS/ICV    CALLING SEQUENCE:        result = edge_model_atan(n, w)    ARGUMENTS:   INPUT: 	    n:	Size of the model in samples  	    a:	Scaling factor: larger values give a sharper edge.    OUTPUT: 	 zero:  The array element corresponding to the physical edge.  	delta:	The number of pixels represented by each element 		Currently = 1.0  	cd:	Not used.    RETURN: 	An array containing the model.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale, 6/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/icv/edge_model_atan.html#edge_model_atan", "edge_model_atan", 'routine in <a href="nv/obj/tools/icv/edge_model_atan.html">edge_model_atan.pro</a>', "edge_model_atan.pro", "", "edge_model_atan", "", "zerodeltacdna", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/icv/edge_model_gauss.html", "edge_model_gauss.pro", '.pro file in <a href="nv/obj/tools/icv/dir-overview.html">nv/obj/tools/icv/ directory</a>', "edge_model_gauss.pro", "", "", " NAME:        edge_model_gauss    PURPOSE: 	Calculates a gaussian edge model for use in curve fitting.   CATEGORY:        NV/LIB/TOOLS/ICV    CALLING SEQUENCE:        result = edge_model_gauss(n, w)    ARGUMENTS:   INPUT: 	    n:	Size of the model in samples  	    w:	Width of the gaussian (sigma)    OUTPUT: 	 zero:  The array element corresponding to the phyiscal edge.  	delta:	The number of pixels represented by each element 		Currently = 1.0  	cd:	Not used.    RETURN: 	An array containing the model.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Haemmerle, 6/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/icv/edge_model_gauss.html#edge_model_gauss", "edge_model_gauss", 'routine in <a href="nv/obj/tools/icv/edge_model_gauss.html">edge_model_gauss.pro</a>', "edge_model_gauss.pro", "", "edge_model_gauss", "", "zerodeltacdnw", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/icv/edge_model_nav_limb.html", "edge_model_nav_limb.pro", '.pro file in <a href="nv/obj/tools/icv/dir-overview.html">nv/obj/tools/icv/ directory</a>', "edge_model_nav_limb.pro", "", "", " NAME:        edge_model_nav_limb    PURPOSE: 	Returns the edge model used by the VICAR program NAV for limb fits.   CATEGORY:        NV/LIB/TOOLS/ICV    CALLING SEQUENCE:        result = edge_model_nav_limb()    ARGUMENTS:   INPUT: 	    NONE    OUTPUT: 	 zero:  The array element corresponding to the phyiscal edge.  	delta:	The number of pixels represented by each element 		Currently = 1.0  	cd:	Not used.    RETURN: 	An array containing the model.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale, 6/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/icv/edge_model_nav_limb.html#edge_model_nav_limb", "edge_model_nav_limb", 'routine in <a href="nv/obj/tools/icv/edge_model_nav_limb.html">edge_model_nav_limb.pro</a>', "edge_model_nav_limb.pro", "", "edge_model_nav_limb", "", "zerodeltacd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/icv/edge_model_nav_ring.html", "edge_model_nav_ring.pro", '.pro file in <a href="nv/obj/tools/icv/dir-overview.html">nv/obj/tools/icv/ directory</a>', "edge_model_nav_ring.pro", "", "", " NAME:        edge_model_nav_ring    PURPOSE: 	Returns the edge model used by the VICAR program NAV for ring fits.   CATEGORY:        NV/LIB/TOOLS/ICV    CALLING SEQUENCE:        result = edge_model_nav_ring()    KEYWORDS:   INPUT: NONE    OUTPUT: 	 zero:  The array element corresponding to the phyiscal edge.  	delta:	The number of pixels represented by each element 		Currently = 1.0  	cd:	Not used.    RETURN: 	An array containing the model.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale, 6/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/icv/edge_model_nav_ring.html#edge_model_nav_ring", "edge_model_nav_ring", 'routine in <a href="nv/obj/tools/icv/edge_model_nav_ring.html">edge_model_nav_ring.pro</a>', "edge_model_nav_ring.pro", "", "edge_model_nav_ring", "", "zerodeltacd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/icv/edge_model_psf_ring.html", "edge_model_psf_ring.pro", '.pro file in <a href="nv/obj/tools/icv/dir-overview.html">nv/obj/tools/icv/ directory</a>', "edge_model_psf_ring.pro", "", "", " NAME:        edge_model_psf_ring    PURPOSE: 	Returns an edge model produced by convolving a sharp edge with 	a point-spread function.   CATEGORY:        NV/LIB/TOOLS/ICV    CALLING SEQUENCE:        result = edge_model_psf_ring()    KEYWORDS:   INPUT: NONE    OUTPUT: 	 zero:  The array element corresponding to the phyiscal edge.  	delta:	The number of pixels represented by each element 		Currently = 1.0  	cd:	Camera descriptor fromwhich to obtain the PSF.    RETURN: 	An array containing the model.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale, 6/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/icv/edge_model_psf_ring.html#edge_model_psf_ring", "edge_model_psf_ring", 'routine in <a href="nv/obj/tools/icv/edge_model_psf_ring.html">edge_model_psf_ring.pro</a>', "edge_model_psf_ring.pro", "", "edge_model_psf_ring", "", "cdzerodelta", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/elem_struct.html", "elem_struct.pro", '.pro file in <a href="config/pds/Readpds_4.4/dir-overview.html">config/pds/Readpds_4.4/ directory</a>', "elem_struct.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/elem_struct.html#extract_name", "extract_name", 'routine in <a href="config/pds/Readpds_4.4/elem_struct.html">elem_struct.pro</a>', "elem_struct.pro", "", "extract_name", "", "labelobjindexend_index", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/elem_struct.html#extract_data_type", "extract_data_type", 'routine in <a href="config/pds/Readpds_4.4/elem_struct.html">elem_struct.pro</a>', "elem_struct.pro", "", "extract_data_type", "", "labelcur_indend_index", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/elem_struct.html#determine_element_type", "determine_element_type", 'routine in <a href="config/pds/Readpds_4.4/elem_struct.html">elem_struct.pro</a>', "elem_struct.pro", "", "determine_element_type", "", "data_typebytes", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/elem_struct.html#elem_struct", "elem_struct", 'routine in <a href="config/pds/Readpds_4.4/elem_struct.html">elem_struct.pro</a>', "elem_struct.pro", "", "elem_struct", "", "labelindex", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/ellipse.html", "ellipse.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "ellipse.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/ellipse.html#ellipse", "ellipse", 'routine in <a href="util/ellipse.html">ellipse.pro</a>', "ellipse.pro", "", "ellipse", "", "npcenterabalpha", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/enigma.html", "enigma.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "enigma.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/enigma.html#enig_advance", "enig_advance", 'routine in <a href="util/enigma.html">enigma.pro</a>', "enigma.pro", "", "enig_advance", "", "settings", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/enigma.html#enig_rotor", "enig_rotor", 'routine in <a href="util/enigma.html">enigma.pro</a>', "enigma.pro", "", "enig_rotor", "", "settinginput_rotor_num", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/enigma.html#enig_encode", "enig_encode", 'routine in <a href="util/enigma.html">enigma.pro</a>', "enigma.pro", "", "enig_encode", "", "settingsinput", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/enigma.html#enigma", "enigma", 'routine in <a href="util/enigma.html">enigma.pro</a>', "enigma.pro", "", "enigma", "", "_settingsmessage", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/eph/eph_db_cache_struct__define.html", "eph_db_cache_struct__define.pro", '.pro file in <a href="config/spice/eph/dir-overview.html">config/spice/eph/ directory</a>', "eph_db_cache_struct__define.pro", "", "", " NAME: 	eph_db_cache_struct__define    PURPOSE: 	Structure defining a cached kernel database.    CATEGORY: 	CONFIG/SPICE/EPH    CALLING SEQUENCE: 	N/A    FIELDS:       STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale		2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/eph/eph_db_cache_struct__define.html#eph_db_cache_struct__define", "eph_db_cache_struct__define", 'routine in <a href="config/spice/eph/eph_db_cache_struct__define.html">eph_db_cache_struct__define.pro</a>', "eph_db_cache_struct__define.pro", "", "eph_db_cache_struct__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/eph/eph_db_struct__define.html", "eph_db_struct__define.pro", '.pro file in <a href="config/spice/eph/dir-overview.html">config/spice/eph/ directory</a>', "eph_db_struct__define.pro", "", "", " NAME: 	eph_db_struct__define    PURPOSE: 	Structure defining a record in the kernel database.    CATEGORY: 	CONFIG/SPICE/EPH    CALLING SEQUENCE: 	N/A    FIELDS:       STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale		2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/eph/eph_db_struct__define.html#eph_db_struct__define", "eph_db_struct__define", 'routine in <a href="config/spice/eph/eph_db_struct__define.html">eph_db_struct__define.pro</a>', "eph_db_struct__define.pro", "", "eph_db_struct__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/eph/eph_spice_build_db.html", "eph_spice_build_db.pro", '.pro file in <a href="config/spice/eph/dir-overview.html">config/spice/eph/ directory</a>', "eph_spice_build_db.pro", "", "", " NAME:        eph_spice_build_db    PURPOSE:        Read/Build the SPICE kernel database    CATEGORY:        UTIL/SPICE    CALLING SEQUENCE:        eph_spice_build_db, kpath, data    ARGUMENTS:   INPUT:        kpath:          Path of the kernel files  	type:		Type of kernel: 'c' or 'sp'.     OUTPUT: NONE    KEYWORDS:   INPUT: 	nocheck:	If set, no checking is performed to determine whether 			the database file needs to be updated.    OUTPUT: NONE     RETURN:              Structure that contains:                        filename:	Kernel filename                        first:		Range start (ET seconds)                        last:		Range end (ET seconds)                        mtime:		File system date (seconds, OS dependent)                        lbltime:	LBL file creation date (seconds ET)                        installtime:	OMINAS install timestamp (Julian date) 			stillThere:	File in database still exists in kpath    PROCEDURE:		File unit is allocated for internal use, then released when finished                        Checks for existence of database, reads if so                        Location of database is in ~/.ominas                        Filename is spice_<type>k_database.<kpath with / replaced by _ >                        (for a kpath with a wildcard, *, it is replaced by x)                        Compares/generates list of filename in kpath                        If file system time matches current database, uses that information                        Uses spice to calculate the range if so                        Calls eph_spice_read_label to read from LBL file for PRODUCT_CREATION_TIME                        Calls eph_spice_read_timestamp to read OMINAS timestamp file in ~/.ominas/timestamps                        Generates structure of information to return in data (optional if supplied)                        Writes database if it did not exist.    RESTRICTIONS:    STATUS:        Complete.    MODIFICATION HISTORY:        Written by:     V. Haemmerle,  Feb. 2017 	Addapted by:	J.Spitale      Feb. 2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/eph/eph_spice_build_db.html#esbd_kcov", "esbd_kcov", 'routine in <a href="config/spice/eph/eph_spice_build_db.html">eph_spice_build_db.pro</a>', "eph_spice_build_db.pro", "", "esbd_kcov", "", "statustypefileidneedav", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/spice/eph/eph_spice_build_db.html#esbd_kobj", "esbd_kobj", 'routine in <a href="config/spice/eph/eph_spice_build_db.html">eph_spice_build_db.pro</a>', "eph_spice_build_db.pro", "", "esbd_kobj", "", "statustypefile", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/spice/eph/eph_spice_build_db.html#eph_spice_build_db", "eph_spice_build_db", 'routine in <a href="config/spice/eph/eph_spice_build_db.html">eph_spice_build_db.pro</a>', "eph_spice_build_db.pro", "", "eph_spice_build_db", "", "nocheck_kpathtype", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/eph/eph_spice_cache_db.html", "eph_spice_cache_db.pro", '.pro file in <a href="config/spice/eph/dir-overview.html">config/spice/eph/ directory</a>', "eph_spice_cache_db.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/eph/eph_spice_cache_db.html#eph_spice_cache_db", "eph_spice_cache_db", 'routine in <a href="config/spice/eph/eph_spice_cache_db.html">eph_spice_cache_db.pro</a>', "eph_spice_cache_db.pro", "", "eph_spice_cache_db", "", "getdbfiledb", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/eph/eph_spice_cameras.html", "eph_spice_cameras.pro", '.pro file in <a href="config/spice/eph/dir-overview.html">config/spice/eph/ directory</a>', "eph_spice_cameras.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/eph/eph_spice_cameras.html#eph_spice_cameras", "eph_spice_cameras", 'routine in <a href="config/spice/eph/eph_spice_cameras.html">eph_spice_cameras.pro</a>', "eph_spice_cameras.pro", "", "eph_spice_cameras", "", "posn_objdimstatustimeobsddref", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/eph/eph_spice_ck_detect.html", "eph_spice_ck_detect.pro", '.pro file in <a href="config/spice/eph/dir-overview.html">config/spice/eph/ directory</a>', "eph_spice_ck_detect.pro", "", "", " NAME:        eph_spice_ck_detect    PURPOSE:        Return filenames of CKs approprate to given time, in correct order    CATEGORY:        UTIL/SPICE    CALLING SEQUENCE:        files = eph_spice_ck_detect( ckpath, sc=sc, time=time )    ARGUMENTS:   INPUT: 	dd:		Data descriptor.         ckpath:         Path of the CK files    OUTPUT: 	files:		Array of CK filenames for use with cspice_furnsh    KEYWORDS:   INPUT: 	sc:		NAIF spacecraft ID         time:           Time for CK coverage (optional if using /all)  	djd:		Window around time to include coverage for (days, default=1)  	all:		Return all CKs (time not needed in this case)  	strict:		No function.  Included for consistent interface.    OUTPUT: NONE    PROCEDURE:		Read CK database                        Deterimine CKs which have coverage for given time (or all) 			Determine which time base to use for ordering: file system, PDS LBL time, or OMINAS timestamp                        Return ordered file list   RESTRICTIONS: 			SCLK file and Leapseconds kernel need to be loaded    STATUS:        Complete.    MODIFICATION HISTORY:        Written by:     V. Haemmerle,  Feb. 2017 	Addapted by:	J.Spitale      Feb. 2017  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/eph/eph_spice_ck_detect.html#eph_spice_ck_detect", "eph_spice_ck_detect", 'routine in <a href="config/spice/eph/eph_spice_ck_detect.html">eph_spice_ck_detect.pro</a>', "eph_spice_ck_detect.pro", "", "eph_spice_ck_detect", "", "djdsctimeallstrictddckpath", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/eph/eph_spice_input.html", "eph_spice_input.pro", '.pro file in <a href="config/spice/eph/dir-overview.html">config/spice/eph/ directory</a>', "eph_spice_input.pro", "", "", " NAME: 	eph_spice_input    PURPOSE: 	NAIF/SPICE input translator for Cassini.    CATEGORY: 	NV/CONFIG    CALLING SEQUENCE: 	result = eph_spice_input(dd, keyword)    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	keyword:	String giving the name of the translator quantity.     OUTPUT: 	NONE    KEYWORDS:   INPUT: 	key1:		Camera descriptor.    OUTPUT: 	status:		Zero if valid data is returned.     TRANSLATOR KEYWORDS: 	ref:		Name of the reference frame for the output quantities. 			Default is 'j2000'.  	j2000:		/j2000 is equivalent to specifying ref=j2000.  	b1950:		/b1950 is equivalent to specifying ref=b1950.  	klist:		Name of a file giving a list of SPICE kernels to use. 			If no path is included, the path is taken from the 			NV_SPICE_KER environment variable.  	planets:	List of planets to for which to request ephemeris. 			Must be delineated by semicolons with no space.  	reload:		If set, new kernels are loaded, as specified by the 			klist and ck_in keywords.    RETURN: 	Data associated with the requested keyword.    STATUS: 	Complete    SEE ALSO: 	eph_spice_output    MODIFICATION HISTORY:  	Written by:	Spitale, 10/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/eph/eph_spice_input.html#eph_spice_input", "eph_spice_input", 'routine in <a href="config/spice/eph/eph_spice_input.html">eph_spice_input.pro</a>', "eph_spice_input.pro", "", "eph_spice_input", "", "valuesstatusddkeyword@nv_trs_keywords_include.pro", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/eph/eph_spice_kernel_detect.html", "eph_spice_kernel_detect.pro", '.pro file in <a href="config/spice/eph/dir-overview.html">config/spice/eph/ directory</a>', "eph_spice_kernel_detect.pro", "", "", " NAME:        eph_spice_kernel_detect    PURPOSE:        Return filenames of kernels approprate to given time, in correct order    CATEGORY:        UTIL/SPICE    CALLING SEQUENCE:        files = eph_spice_kernel_detect(dd, kpath, type, sc=sc, time=time )    ARGUMENTS:   INPUT: 	dd:		Data descriptor.         kpath:         Path of the CK files  	type:		Type of kernel: 'c' or 'sp'.  	sc:		NAIF spacecraft ID         time:           Time for CK coverage (optional if using /all)  	djd:		Window around time to include coverage for (days, default=1)    OUTPUT: 	files:		Array of CK filenames for use with cspice_furnsh    KEYWORDS:   INPUT: 	sc:		NAIF spacecraft ID         time:           Time for CK coverage (optional if using /all)  	djd:		Window around time to include coverage for (days, default=1)  	all:		Return all kernels (time not needed in this case)  	strict:		No function.  Included for consistent interface.    OUTPUT: NONE    PROCEDURE:		Read kernel database                        Deterimine kernels that have coverage for given time (or all) 			Determine which time base to use for ordering: file system, PDS LBL time, or OMINAS timestamp                        Return ordered file list   RESTRICTIONS: 			Leapseconds kernels need to be loaded, SCLK kernels 			also need to be loaded if type=='c'.    STATUS:        Complete.    MODIFICATION HISTORY:        Written by:     V. Haemmerle,  Feb. 2017 	Addapted by:	J.Spitale      Feb. 2017  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/eph/eph_spice_kernel_detect.html#eph_spice_kernel_detect", "eph_spice_kernel_detect", 'routine in <a href="config/spice/eph/eph_spice_kernel_detect.html">eph_spice_kernel_detect.pro</a>', "eph_spice_kernel_detect.pro", "", "eph_spice_kernel_detect", "", "djdsctimeallstrictddkpathtype", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/eph/eph_spice_lsk_detect.html", "eph_spice_lsk_detect.pro", '.pro file in <a href="config/spice/eph/dir-overview.html">config/spice/eph/ directory</a>', "eph_spice_lsk_detect.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/eph/eph_spice_lsk_detect.html#eph_spice_lsk_detect", "eph_spice_lsk_detect", 'routine in <a href="config/spice/eph/eph_spice_lsk_detect.html">eph_spice_lsk_detect.pro</a>', "eph_spice_lsk_detect.pro", "", "eph_spice_lsk_detect", "", "sctimestrictallddkpath", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/eph/eph_spice_pck_detect.html", "eph_spice_pck_detect.pro", '.pro file in <a href="config/spice/eph/dir-overview.html">config/spice/eph/ directory</a>', "eph_spice_pck_detect.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/eph/eph_spice_pck_detect.html#eph_spice_pck_detect", "eph_spice_pck_detect", 'routine in <a href="config/spice/eph/eph_spice_pck_detect.html">eph_spice_pck_detect.pro</a>', "eph_spice_pck_detect.pro", "", "eph_spice_pck_detect", "", "sctimestrictallddkpath", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/eph/eph_spice_planets.html", "eph_spice_planets.pro", '.pro file in <a href="config/spice/eph/dir-overview.html">config/spice/eph/ directory</a>', "eph_spice_planets.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/eph/eph_spice_planets.html#eph_spice_planets", "eph_spice_planets", 'routine in <a href="config/spice/eph/eph_spice_planets.html">eph_spice_planets.pro</a>', "eph_spice_planets.pro", "", "eph_spice_planets", "", "targettimeplanetsn_objdimstatustarg_listconstantsobsddref", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/eph/eph_spice_read_db.html", "eph_spice_read_db.pro", '.pro file in <a href="config/spice/eph/dir-overview.html">config/spice/eph/ directory</a>', "eph_spice_read_db.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/eph/eph_spice_read_db.html#eph_spice_read_db", "eph_spice_read_db", 'routine in <a href="config/spice/eph/eph_spice_read_db.html">eph_spice_read_db.pro</a>', "eph_spice_read_db.pro", "", "eph_spice_read_db", "", "dbfile", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/spice/eph/eph_spice_read_db.html#___eph_spice_read_db", "___eph_spice_read_db", 'routine in <a href="config/spice/eph/eph_spice_read_db.html">eph_spice_read_db.pro</a>', "eph_spice_read_db.pro", "", "___eph_spice_read_db", "", "dbfile", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/eph/eph_spice_read_label.html", "eph_spice_read_label.pro", '.pro file in <a href="config/spice/eph/dir-overview.html">config/spice/eph/ directory</a>', "eph_spice_read_label.pro", "", "", " NAME:        eph_spice_read_label    PURPOSE:        Reads a PDS LBL file for a SPICE kernel file    CATEGORY:        UTIL/SPICE    CALLING SEQUENCE:        eph_spice_read_label, filename, unit, creation    ARGUMENTS:   INPUT:        filename:	Path of the SPK files    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:		File creation date (string)    PROCEDURE:		Adds '.lbl' to input filename                        Checks for label file, reads if so                        Extracts value of PRODUCT_CREATION_TIME    RESTRICTIONS:    STATUS:        Complete.    MODIFICATION HISTORY:        Written by:     V. Haemmerle,  Feb. 2017 	Adapted by:	J. Spitale     Feb. 2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/eph/eph_spice_read_label.html#eph_spice_read_label", "eph_spice_read_label", 'routine in <a href="config/spice/eph/eph_spice_read_label.html">eph_spice_read_label.pro</a>', "eph_spice_read_label.pro", "", "eph_spice_read_label", "", "filenameunitcreation", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/eph/eph_spice_read_timestamps.html", "eph_spice_read_timestamps.pro", '.pro file in <a href="config/spice/eph/dir-overview.html">config/spice/eph/ directory</a>', "eph_spice_read_timestamps.pro", "", "", " NAME:        eph_spice_read_timestamps    PURPOSE:        Reads an OMINAS install file for kernels for a particular path    CATEGORY:        UTIL/SPICE    CALLING SEQUENCE:        timetamps = eph_spice_read_timestamps(path, filenames)    ARGUMENTS:   INPUT:        path:		Path of the kernel files    OUTPUT: 	filenames:	String array of filenames in path    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:		Timestamps for files in path (JD)    PROCEDURE:		Converts path into OMINAS timestamp filename 			If path contains wildcard, checks for all timestamp files which apply                        Reads json files to get filename and timestamp                        Returns as two string arrays    RESTRICTIONS:    STATUS:        Complete.    MODIFICATION HISTORY:        Written by:     V. Haemmerle,  Feb. 2017 	Adapted by:	Spitale        Feb. 2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/eph/eph_spice_read_timestamps.html#eph_spice_read_timestamps", "eph_spice_read_timestamps", 'routine in <a href="config/spice/eph/eph_spice_read_timestamps.html">eph_spice_read_timestamps.pro</a>', "eph_spice_read_timestamps.pro", "", "eph_spice_read_timestamps", "", "pathfilenames", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/eph/eph_spice_spk_detect.html", "eph_spice_spk_detect.pro", '.pro file in <a href="config/spice/eph/dir-overview.html">config/spice/eph/ directory</a>', "eph_spice_spk_detect.pro", "", "", " NAME:        eph_spice_spk_detect    PURPOSE:        Return filenames of SPKs approprate to given time, in correct order    CATEGORY:        UTIL/SPICE    CALLING SEQUENCE:        files = eph_spice_spk_detect(dd, kpath, time=time)    ARGUMENTS:   INPUT: 	dd:		Data descriptor.         kpath:          Path of the SPK files    OUTPUT: 	files:		Array of SPK filenames for use with cspice_furnsh    KEYWORDS:   INPUT: 	sc:		NAIF spacecraft ID         time:           Time for SPK coverage (optional if using /all)  	all:		Return all SPKs  	strict:		No function.  Included for consistent interface.    OUTPUT: NONE    PROCEDURE:		Read SPK database                        Deterimine SPKs which have coverage for given time (or all) 			Determine which time base to use for ordering: file system, PDS LBL time, or OMINAS timestamp                        Return ordered file list   RESTRICTIONS:    STATUS:        Complete.    MODIFICATION HISTORY:        Written by:     V. Haemmerle,  Feb. 2017 	Addapted by:	J.Spitale      Feb. 2017  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/eph/eph_spice_spk_detect.html#eph_spice_spk_detect", "eph_spice_spk_detect", 'routine in <a href="config/spice/eph/eph_spice_spk_detect.html">eph_spice_spk_detect.pro</a>', "eph_spice_spk_detect.pro", "", "eph_spice_spk_detect", "", "scalltimestrictddkpath", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/eph/eph_spice_sun.html", "eph_spice_sun.pro", '.pro file in <a href="config/spice/eph/dir-overview.html">config/spice/eph/ directory</a>', "eph_spice_sun.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/eph/eph_spice_sun.html#eph_spice_sun", "eph_spice_sun", 'routine in <a href="config/spice/eph/eph_spice_sun.html">eph_spice_sun.pro</a>', "eph_spice_sun.pro", "", "eph_spice_sun", "", "n_objdimstatustimeconstantsobsddref", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/eph/eph_spice_write_db.html", "eph_spice_write_db.pro", '.pro file in <a href="config/spice/eph/dir-overview.html">config/spice/eph/ directory</a>', "eph_spice_write_db.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/eph/eph_spice_write_db.html#eph_spice_write_db", "eph_spice_write_db", 'routine in <a href="config/spice/eph/eph_spice_write_db.html">eph_spice_write_db.pro</a>', "eph_spice_write_db.pro", "", "eph_spice_write_db", "", "nosortdbfiledb", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/spice/eph/eph_spice_write_db.html#___eph_spice_write_db", "___eph_spice_write_db", 'routine in <a href="config/spice/eph/eph_spice_write_db.html">eph_spice_write_db.pro</a>', "eph_spice_write_db.pro", "", "___eph_spice_write_db", "", "dbfiledb", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/eph/eph_to_ominas.html", "eph_to_ominas.pro", '.pro file in <a href="config/spice/eph/dir-overview.html">config/spice/eph/ directory</a>', "eph_to_ominas.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/eph/eph_to_ominas.html#eph_to_ominas", "eph_to_ominas", 'routine in <a href="config/spice/eph/eph_to_ominas.html">eph_to_ominas.pro</a>', "eph_to_ominas.pro", "", "eph_to_ominas", "", "od", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/epoch_dt.html", "epoch_dt.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "epoch_dt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/epoch_dt.html#epoch_dt", "epoch_dt", 'routine in <a href="util/epoch_dt.html">epoch_dt.pro</a>', "epoch_dt.pro", "", "epoch_dt", "", "bxepoch_jd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/epoch_radec.html", "epoch_radec.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "epoch_radec.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/epoch_radec.html#epoch_radec", "epoch_radec", 'routine in <a href="nv/obj/tools/epoch_radec.html">epoch_radec.pro</a>', "epoch_radec.pro", "", "epoch_radec", "", "odbxepoch", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/errfill.html", "errfill.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "errfill.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/errfill.html#errfill", "errfill", 'routine in <a href="util/errfill.html">errfill.pro</a>', "errfill.pro", "", "errfill", "", "colorxysig", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/error_ellipse.html", "error_ellipse.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "error_ellipse.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/error_ellipse.html#error_ellipse", "error_ellipse", 'routine in <a href="util/error_ellipse.html">error_ellipse.pro</a>', "error_ellipse.pro", "", "error_ellipse", "", "psigp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/errrplot.html", "errrplot.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "errrplot.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/errrplot.html#errrplot", "errrplot", 'routine in <a href="util/errrplot.html">errrplot.pro</a>', "errrplot.pro", "", "errrplot", "", "sigxsigycolorxy", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/errrplot_polar.html", "errrplot_polar.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "errrplot_polar.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/errrplot_polar.html#errrplot_polar", "errrplot_polar", 'routine in <a href="util/errrplot_polar.html">errrplot_polar.pro</a>', "errrplot_polar.pro", "", "errrplot_polar", "", "sigrsigqcolorrq", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/estimate_max.html", "estimate_max.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "estimate_max.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/estimate_max.html#estimate_max", "estimate_max", 'routine in <a href="util/estimate_max.html">estimate_max.pro</a>', "estimate_max.pro", "", "estimate_max", "", "thresholdpadbytypex", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/et2jd.html", "et2jd.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "et2jd.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/et2jd.html#et2jd", "et2jd", 'routine in <a href="util/et2jd.html">et2jd.pro</a>', "et2jd.pro", "", "et2jd", "", "et", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/expfit.html", "expfit.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "expfit.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/expfit.html#expf_exponential", "expf_exponential", 'routine in <a href="util/expfit.html">expfit.pro</a>', "expfit.pro", "", "expf_exponential", "", "xcoeff", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/expfit.html#expf_eval", "expf_eval", 'routine in <a href="util/expfit.html">expfit.pro</a>', "expfit.pro", "", "expf_eval", "", "xcoeffresultpder", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/expfit.html#expfit", "expfit", 'routine in <a href="util/expfit.html">expfit.pro</a>', "expfit.pro", "", "expfit", "", "chisqitmaxxycoeff", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/ext/ext_get_name.html", "ext_get_name.pro", '.pro file in <a href="config/ext/dir-overview.html">config/ext/ directory</a>', "ext_get_name.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/ext/ext_get_name.html#ext_get_name", "ext_get_name", 'routine in <a href="config/ext/ext_get_name.html">ext_get_name.pro</a>', "ext_get_name.pro", "", "ext_get_name", "", "filename", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/ext/ext_read_bmp.html", "ext_read_bmp.pro", '.pro file in <a href="config/ext/dir-overview.html">config/ext/ directory</a>', "ext_read_bmp.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/ext/ext_read_bmp.html#ext_read_bmp", "ext_read_bmp", 'routine in <a href="config/ext/ext_read_bmp.html">ext_read_bmp.pro</a>', "ext_read_bmp.pro", "", "ext_read_bmp", "", "dimfilename", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/ext/ext_read_jpeg.html", "ext_read_jpeg.pro", '.pro file in <a href="config/ext/dir-overview.html">config/ext/ directory</a>', "ext_read_jpeg.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/ext/ext_read_jpeg.html#ext_read_jpeg", "ext_read_jpeg", 'routine in <a href="config/ext/ext_read_jpeg.html">ext_read_jpeg.pro</a>', "ext_read_jpeg.pro", "", "ext_read_jpeg", "", "dimtypefilename", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/ext/ext_read_jpg.html", "ext_read_jpg.pro", '.pro file in <a href="config/ext/dir-overview.html">config/ext/ directory</a>', "ext_read_jpg.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/ext/ext_read_jpg.html#ext_read_jpg", "ext_read_jpg", 'routine in <a href="config/ext/ext_read_jpg.html">ext_read_jpg.pro</a>', "ext_read_jpg.pro", "", "ext_read_jpg", "", "dimtypefilename", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/ext/ext_read_pict.html", "ext_read_pict.pro", '.pro file in <a href="config/ext/dir-overview.html">config/ext/ directory</a>', "ext_read_pict.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/ext/ext_read_pict.html#ext_read_pict", "ext_read_pict", 'routine in <a href="config/ext/ext_read_pict.html">ext_read_pict.pro</a>', "ext_read_pict.pro", "", "ext_read_pict", "", "dimfilename", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/ext/ext_read_png.html", "ext_read_png.pro", '.pro file in <a href="config/ext/dir-overview.html">config/ext/ directory</a>', "ext_read_png.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/ext/ext_read_png.html#ext_read_png", "ext_read_png", 'routine in <a href="config/ext/ext_read_png.html">ext_read_png.pro</a>', "ext_read_png.pro", "", "ext_read_png", "", "dimtypefilename", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/ext/ext_read_tif.html", "ext_read_tif.pro", '.pro file in <a href="config/ext/dir-overview.html">config/ext/ directory</a>', "ext_read_tif.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/ext/ext_read_tif.html#ext_read_tif", "ext_read_tif", 'routine in <a href="config/ext/ext_read_tif.html">ext_read_tif.pro</a>', "ext_read_tif.pro", "", "ext_read_tif", "", "dimfilename", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/ext/ext_read_tiff.html", "ext_read_tiff.pro", '.pro file in <a href="config/ext/dir-overview.html">config/ext/ directory</a>', "ext_read_tiff.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/ext/ext_read_tiff.html#ext_read_tiff", "ext_read_tiff", 'routine in <a href="config/ext/ext_read_tiff.html">ext_read_tiff.pro</a>', "ext_read_tiff.pro", "", "ext_read_tiff", "", "dimfilename", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/ext/ext_read_x11.html", "ext_read_x11.pro", '.pro file in <a href="config/ext/dir-overview.html">config/ext/ directory</a>', "ext_read_x11.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/ext/ext_read_x11.html#ext_read_x11", "ext_read_x11", 'routine in <a href="config/ext/ext_read_x11.html">ext_read_x11.pro</a>', "ext_read_x11.pro", "", "ext_read_x11", "", "dimfilename", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/ext/ext_read_xwd.html", "ext_read_xwd.pro", '.pro file in <a href="config/ext/dir-overview.html">config/ext/ directory</a>', "ext_read_xwd.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/ext/ext_read_xwd.html#ext_read_xwd", "ext_read_xwd", 'routine in <a href="config/ext/ext_read_xwd.html">ext_read_xwd.pro</a>', "ext_read_xwd.pro", "", "ext_read_xwd", "", "dimfilename", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/ext_rep.html", "ext_rep.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "ext_rep.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/ext_rep.html#ext_rep", "ext_rep", 'routine in <a href="util/ext_rep.html">ext_rep.pro</a>', "ext_rep.pro", "", "ext_rep", "", "allfilenamenew_ext", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/extend_mask.html", "extend_mask.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "extend_mask.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/extend_mask.html#extend_mask", "extend_mask", 'routine in <a href="util/extend_mask.html">extend_mask.pro</a>', "extend_mask.pro", "", "extend_mask", "", "_maskdist", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/external_points.html", "external_points.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "external_points.pro", "", "", " NAME:        external_points    PURPOSE:        Output subscripts of points outside the given bounds.    CATEGORY:        UTIL    CALLING SEQUENCE:        result = external_points(points, x0, x1, y0, y1)    ARGUMENTS:   INPUT:        points:         An array of image point.             x0:         Lower x bound.             x1:         Upper x bound.             y0:         Lower y bound.             y1:         Upper y bound.    OUTPUT:        NONE   RETURN:        Subscripts of points in array that fall outside the rectangle        whose corners are (x0,y0) and (x1,y1).    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/external_points.html#external_points", "external_points", 'routine in <a href="util/external_points.html">external_points.pro</a>', "external_points.pro", "", "external_points", "", "pointsx0x1y0y1", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/fft_wl.html", "fft_wl.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "fft_wl.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/fft_wl.html#fft_wl", "fft_wl", 'routine in <a href="util/fft_wl.html">fft_wl.pro</a>', "fft_wl.pro", "", "fft_wl", "", "infwlfry", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/file_manage.html", "file_manage.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "file_manage.pro", "", "", " NAME: 	file_manage    PURPOSE: 	Manages searching and caching of data files.  Files are searched for 	in the given directories, and once loaded, are cached in memory.    CATEGORY: 	UTIL/EXD    CALLING SEQUENCE: 	data = file_manage(fn, path, filename)    ARGUMENTS:   INPUT: 	fn:	Name of function to read the file.  The only argument to 		this function is the file name, ad it returns a data array.  	path:	Path specifications to use for searching for the file.  All 		matching files are read and the data arrays are concatenated.  	filename: 		Name of the file to search for.    OUTPUT: NONE    KEYWORDS:   INPUT: 	reload:	If set, the file is loaded from disk, even if it is already 		cached.     OUTPUT: NONE    RETURN: 	Data obtained from the given reader function.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/file_manage.html#cl_cache_put", "cl_cache_put", 'routine in <a href="util/file_manage.html">file_manage.pro</a>', "file_manage.pro", "", "cl_cache_put", "", "filedat", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/file_manage.html#cl_cache_get", "cl_cache_get", 'routine in <a href="util/file_manage.html">file_manage.pro</a>', "file_manage.pro", "", "cl_cache_get", "", "reloadfoundfile", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/file_manage.html#file_manage", "file_manage", 'routine in <a href="util/file_manage.html">file_manage.pro</a>', "file_manage.pro", "", "file_manage", "", "reloadfncatpathcatfile", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/fill_array.html", "fill_array.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "fill_array.pro", "", "", " NAME:        fill_array    PURPOSE:        Like the idl function make_array, but more flexible.    CATEGORY:        UTIL    CALLING SEQUENCE:        result = fill_array(n_elem, values=values, default=default)    ARGUMENTS:   INPUT:        n_elem:     Number of elements in resultant array.    OUTPUT:        NONE    KEYWORDS:   INPUT:            values:     Values to fill array.            default:     Default value for array.             string:     If set, array is a string array.    OUTPUT:        NONE   RETURN:        Array (n_elem) filled with values and/or default value.    PROCEDURE:        An array of n_elem is created.  If values is not given, array is        filled with default value.  If values is given and the number of        values is less than n_elem, then the rest of array is filled        with the default value.  If the default value is not given, the        default is taken as the last element in the values array.    SEE ALSO: 	make_array   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/fill_array.html#fill_array", "fill_array", 'routine in <a href="util/fill_array.html">fill_array.pro</a>', "fill_array.pro", "", "fill_array", "", "valuesdefaultstringn_elem", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/fill_ring.html", "fill_ring.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "fill_ring.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/fill_ring.html#fill_ring", "fill_ring", 'routine in <a href="nv/obj/tools/fill_ring.html">fill_ring.pro</a>', "fill_ring.pro", "", "fill_ring", "", "cdrdimagesub", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/findfile0.html", "findfile0.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "findfile0.pro", "", "", " NAME:        findfile0    PURPOSE:        Same as findfile, but expands the '~' symbol..    CATEGORY:        UTIL    CALLING SEQUENCE:        result = findfile0(filespec)    ARGUMENTS:   INPUT:        filespec:       A filename that may contain the ~ symbol.    OUTPUT:        NONE   RETURN:        Array of found filenames.   PROCEDURE:        Every occurrence of '~' is replaced by '$HOME' before calling findfile.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  8/2012   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/findfile0.html#findfile0", "findfile0", 'routine in <a href="util/findfile0.html">findfile0.pro</a>', "findfile0.pro", "", "findfile0", "", "_filespec", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/findfiles.html", "findfiles.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "findfiles.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/findfiles.html#findfiles", "findfiles", 'routine in <a href="util/findfiles.html">findfiles.pro</a>', "findfiles.pro", "", "findfiles", "", "compressuniqfilespec", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/fixed_array.html", "fixed_array.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "fixed_array.pro", "", "", " NAME: 	fixed_array    PURPOSE: 	Creates and array of fixed length by either truncating the given array 	or padding it with zeroes or null characters.    CATEGORY: 	UTIL    CALLING SEQUENCE: 	result = fixed_array(array, len)    ARGUMENTS:   INPUT: 	array:	Array to fix.  	len:	Length of output array.    OUTPUT: 	NONE    KEYWORDS: NONE    RETURN: 	Array with len elements.  If input array contains more than len 	elements, it is truncated, if it contains fewer, then int is padded 	with zeroes or null characters.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/fixed_array.html#fixed_array", "fixed_array", 'routine in <a href="util/fixed_array.html">fixed_array.pro</a>', "fixed_array.pro", "", "fixed_array", "", "arraylen", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/flatten_bg.html", "flatten_bg.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "flatten_bg.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/flatten_bg.html#flatten_bg", "flatten_bg", 'routine in <a href="util/flatten_bg.html">flatten_bg.pro</a>', "flatten_bg.pro", "", "flatten_bg", "", "data", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/float_bin.html", "float_bin.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "float_bin.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/float_bin.html#float_bin", "float_bin", 'routine in <a href="util/float_bin.html">float_bin.pro</a>', "float_bin.pro", "", "float_bin", "", "binxarryarr", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/footprint.html", "footprint.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "footprint.pro", "", "", " NAME:        footprint    PURPOSE: 	Computes the footprint of a camera on a given body.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        surface_pts = footprint(cd, bx)    ARGUMENTS:   INPUT: 	cd:		Camera descripor.  Only one allowed.  	bx:		Body descriptors.    OUTPUT:  NONE    KEYWORDS:   INPUT: 	corners:	Array(2,2) giving corers of image region to consider.  	slop:		Number of pixels by which to expand the image in each 			direction.  	image_pts:	Array (2,np) of points along the edge of the image.  	sample:		Sampling rate; default is 1 pixel.     OUTPUT: 	image_pts:	Footprint points in the image frame.  	body_p:		Array (nhit) of pointers to body footprint points for 			each body hit.  	hit_indices:	Array (nhit) of bx indices.   RETURN: 	Array (nhit) of pointers to inertial footprint points for each body hit. 	Zero is returned if no bodies are hit.    MODIFICATION HISTORY:        Written by:     Spitale		5/2014   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/footprint.html#footprint", "footprint", 'routine in <a href="nv/obj/tools/footprint.html">footprint.pro</a>', "footprint.pro", "", "footprint", "", "slopcornershit_indicesimage_ptsbody_psamplecdbx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/gauss1d.html", "gauss1d.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "gauss1d.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/gauss1d.html#gauss1d", "gauss1d", 'routine in <a href="util/gauss1d.html">gauss1d.pro</a>', "gauss1d.pro", "", "gauss1d", "", "xsig", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/gauss2d.html", "gauss2d.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "gauss2d.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/gauss2d.html#gauss2d", "gauss2d", 'routine in <a href="util/gauss2d.html">gauss2d.pro</a>', "gauss2d.pro", "", "gauss2d", "", "normxysig_asig_btheta", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/gauss_2d.html", "gauss_2d.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "gauss_2d.pro", "", "", " NAME:        gauss_2d    PURPOSE:        Generates an array containing a 2-dimensional gaussian    CATEGORY:        UTIL    CALLING SEQUENCE:        result = gauss_2d(x0, y0, w, xsize, ysize)    ARGUMENTS:   INPUT:           x0:  x position of center of gaussian            y0:  y position of center of gaussian             w:  half-width of gaussian; i.e., the distance at which the value 		is 1/e times that at the peak.         xsize:  size of output array in x         ysize:  size of output array in y    OUTPUT:        NONE    RETURN:        An array (xsize,ysize) containing a gaussian of width w centered        centered at position (x0,y0)    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/gauss_2d.html#gauss_2d", "gauss_2d", 'routine in <a href="util/gauss_2d.html">gauss_2d.pro</a>', "gauss_2d.pro", "", "gauss_2d", "", "x0y0wxsizeysize", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/gaussfit2d_linear.html", "gaussfit2d_linear.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "gaussfit2d_linear.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/gaussfit2d_linear.html#gaussfit2d_linear", "gaussfit2d_linear", 'routine in <a href="util/gaussfit2d_linear.html">gaussfit2d_linear.pro</a>', "gaussfit2d_linear.pro", "", "gaussfit2d_linear", "", "status_data", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/gaussfit_linear.html", "gaussfit_linear.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "gaussfit_linear.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/gaussfit_linear.html#gaussfit_linear", "gaussfit_linear", 'routine in <a href="util/gaussfit_linear.html">gaussfit_linear.pro</a>', "gaussfit_linear.pro", "", "gaussfit_linear", "", "x_y", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/gen/gen3x.html", "gen3x.pro", '.pro file in <a href="util/gen/dir-overview.html">util/gen/ directory</a>', "gen3x.pro", "", "", " NAME: 	gen3x    PURPOSE: 	Constructs nx x ny x nz array of subscripts with values incrementing 	in the x direction.    CATEGORY: 	UTIL/GEN    CALLING SEQUENCE: 	sub = gen3x(nx, ny, nz)    ARGUMENTS:   INPUT: 	nx:	 Number of elements in the x direction.  	ny:	 Number of elements in the y direction.  	nz:	 Number of elements in the z direction.     OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Array (nx x ny x nz) of subscripts.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/gen/gen3x.html#gen3x", "gen3x", 'routine in <a href="util/gen/gen3x.html">gen3x.pro</a>', "gen3x.pro", "", "gen3x", "", "nxnynz", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/gen/gen3y.html", "gen3y.pro", '.pro file in <a href="util/gen/dir-overview.html">util/gen/ directory</a>', "gen3y.pro", "", "", " NAME: 	gen3y    PURPOSE: 	Constructs nx x ny x nz array of subscripts with values incrementing 	in the y direction.    CATEGORY: 	UTIL/GEN    CALLING SEQUENCE: 	sub = gen3x(nx, ny, nz)    ARGUMENTS:   INPUT: 	nx:	 Number of elements in the x direction.  	ny:	 Number of elements in the y direction.  	nz:	 Number of elements in the z direction.     OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Array (nx x ny x nz) of subscripts.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/gen/gen3y.html#gen3y", "gen3y", 'routine in <a href="util/gen/gen3y.html">gen3y.pro</a>', "gen3y.pro", "", "gen3y", "", "nxnynz", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/gen/gen3z.html", "gen3z.pro", '.pro file in <a href="util/gen/dir-overview.html">util/gen/ directory</a>', "gen3z.pro", "", "", " NAME: 	gen3z    PURPOSE: 	Constructs nx x ny x nz array of subscripts with values incrementing 	in the z direction.    CATEGORY: 	UTIL/GEN    CALLING SEQUENCE: 	sub = gen3x(nx, ny, nz)    ARGUMENTS:   INPUT: 	nx:	 Number of elements in the x direction.  	ny:	 Number of elements in the y direction.  	nz:	 Number of elements in the z direction.     OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Array (nx x ny x nz) of subscripts.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/gen/gen3z.html#gen3z", "gen3z", 'routine in <a href="util/gen/gen3z.html">gen3z.pro</a>', "gen3z.pro", "", "gen3z", "", "nxnynz", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/fits/get_date.html", "get_date.pro", '.pro file in <a href="config/fits/dir-overview.html">config/fits/ directory</a>', "get_date.pro", "", "", " NAME: 	get_date    PURPOSE: 	Return the current date in DD/MM/YY or MM/DD/YY format.    CATEGORY: 	UTIL/FITS    CALLING SEQUENCE: 	get_date, dte    ARGUMENTS:   INPUT: NONE    OUTPUT: 	dte:	An eight character scalar string specifying the current day 		(0-31), current month (1-12), and last two digits of the 		current year   KEYWORDS:   INPUT: 	mdy:	If set, output will be as MM/DD/YY instead of DD/MM/YY.    OUTPUT: NONE    RETURN: 	Date as either DD/MM/YY or MM/DD/YY.    EXAMPLE: 	Add the current date to the DATE keyword in a FITS header,h  	IDL> GET_DATE,dte 	IDL> sxaddpar, h, 'DATE', dte    STATUS: 	Complete    MODIFICATION HISTORY: 	Written      W. Landsman          March 1991 	Added option to output date as mm/dd/yy - Spitale; June 1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/fits/get_date.html#get_date", "get_date", 'routine in <a href="config/fits/get_date.html">get_date.pro</a>', "get_date.pro", "", "get_date", "", "mdydte", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/get_disk_ref.html", "get_disk_ref.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "get_disk_ref.pro", "", "", " NAME:        get_disk_ref    PURPOSE: 	Produces inertial unit vectors corresponding to the projection 	of the given body 2-axis direction into the given disk plane.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        dkx_cat = get_disk_ref(dkx, bx)    ARGUMENTS:   INPUT: 	dkx:	Array (nt) of any subclass of DISK.  	bx:	Array (nt) of any subclass of BODY.    OUTPUT:        NONE    KEYOWRDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (1,3,nt) of inertial unit vectors.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/get_disk_ref.html#get_disk_ref", "get_disk_ref", 'routine in <a href="nv/obj/tools/get_disk_ref.html">get_disk_ref.pro</a>', "get_disk_ref.pro", "", "get_disk_ref", "", "dkxbx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/get_doc_purpose.html", "get_doc_purpose.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "get_doc_purpose.pro", "", "", " NAME:        get_doc_purpose    PURPOSE:        To extract the purpose from header documentation    CATEGORY:        UTIL    CALLING SEQUENCE:        result = get_doc_purpose(filespec)    ARGUMENTS:   INPUT:        filespec:       Filespec to extract documentation from.    OUTPUT:        NONE   KEYWORDS:   INPUT:          nospec:       Only works under UNIX unless /nospec    OUTPUT:        NONE   RETURN:        String containing documentation text.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/get_doc_purpose.html#get_doc_purpose", "get_doc_purpose", 'routine in <a href="util/get_doc_purpose.html">get_doc_purpose.pro</a>', "get_doc_purpose.pro", "", "get_doc_purpose", "", "nospecfilespec", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/get_edge_points.html", "get_edge_points.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "get_edge_points.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/get_edge_points.html#get_edge_points", "get_edge_points", 'routine in <a href="nv/obj/tools/get_edge_points.html">get_edge_points.pro</a>', "get_edge_points.pro", "", "get_edge_points", "", "cdbxgbxdkx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/get_image_border_pts.html", "get_image_border_pts.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "get_image_border_pts.pro", "", "", " NAME:        get_image_border_pts    PURPOSE: 	Computes points around the edge of an image.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        border_pts_im = get_image_border_pts(cd)    ARGUMENTS:   INPUT: 	cd:	Camera descripor.    OUTPUT:  NONE    KEYOWRDS:   INPUT: 	corners:	Array(2,2) giving corners of image region to border  	center:		Array (2) giving the center of the image to use 			instead of the optic axis.  	crop:		Number of pixels by which to shrink the image border in 			each direction.  	sample:		Sampling rate; default is 1 pixel.  	aperture:	If set, a circular aperture with a diameter equal to the 			logest dimension of the image is used.  (not complete)     OUTPUT: NONE    RETURN: 	Array (2,np) of image points on the image border.  np is computed 	such that points are spaced by one pixel.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/get_image_border_pts.html#get_image_border_pts", "get_image_border_pts", 'routine in <a href="nv/obj/tools/get_image_border_pts.html">get_image_border_pts.pro</a>', "get_image_border_pts.pro", "", "get_image_border_pts", "", "cornerscentercropsampleaperturecd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/get_image_profile.html", "get_image_profile.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "get_image_profile.pro", "", "", " NAME:        get_image_profile    PURPOSE: 	Extracts a profile from a rectangular, but not necessarily axis-aligned, 	image region using interpolation.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        profile = get_image_profile(image, cd, p, nl, nw, sample)    ARGUMENTS:   INPUT: 	image:	Image array.  	cd:	Camera descriptor.  	p:	Array (2,2) of image points giving the start and end points 		for the scan.  	nl:	Number of samples along the scan.  	nw:	Number of samples across the scan.     OUTPUT:  NONE    KEYWORDS:   INPUT: 	interp:		Type of interpolation, see image_interp_cam.  	arg_interp:	Interpolation argument, see image_interp_cam.    OUTPUT: 	image_pts:	Array (2,nl) of image points along the center of 			the scan.  	distance:	Array (nl) giving the distance along the scan.  	sigma:		Standard deviation across the profile at each sample 			along the profile.    RETURN: 	Array (nl) containing the profile.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/get_image_profile.html#get_image_profile", "get_image_profile", 'routine in <a href="nv/obj/tools/get_image_profile.html">get_image_profile.pro</a>', "get_image_profile.pro", "", "get_image_profile", "", "distanceinterparg_interpsigmaimage_ptsimcdpnlnwsample", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/get_image_profile_outline.html", "get_image_profile_outline.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "get_image_profile_outline.pro", "", "", " NAME:        get_image_profile_outline    PURPOSE: 	Generates an outline of an oblique rectangular image region.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        profile = get_image_profile_outline(points, point, nw=nw, nl=nl)    ARGUMENTS:   INPUT: 	points:	Array (2,2) of image points defining corners at opposite ends 		on one side of the sector.  	point:	Image point defining and third corner.     OUTPUT:  NONE    KEYWORDS:   INPUT: 	nl:	Number of samples along the scan.  	nw:	Number of samples across the scan.    OUTPUT: NONE    RETURN:        Array of image points defining the outline of the sector.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/get_image_profile_outline.html#get_image_profile_outline", "get_image_profile_outline", 'routine in <a href="nv/obj/tools/get_image_profile_outline.html">get_image_profile_outline.pro</a>', "get_image_profile_outline.pro", "", "get_image_profile_outline", "", "nwnlsamplepointspoint", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/get_image_vector.html", "get_image_vector.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "get_image_vector.pro", "", "", " NAME:        get_image_vector    PURPOSE: 	Projects inertial vectors into an image.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        p = get_image_vector(cd, v)    ARGUMENTS:   INPUT: 	cd:	Array (nt) of camera descriptors.  	v:	Array (nv,3,nt) of vectors in the inertial frame.    OUTPUT:        NONE    KEYOWRDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (2,nv,nt) of image vectors.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/get_image_vector.html#get_image_vector", "get_image_vector", 'routine in <a href="nv/obj/tools/get_image_vector.html">get_image_vector.pro</a>', "get_image_vector.pro", "", "get_image_vector", "", "cdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/get_index.html", "get_index.pro", '.pro file in <a href="config/pds/Readpds_4.4/dir-overview.html">config/pds/Readpds_4.4/ directory</a>', "get_index.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/get_index.html#get_index", "get_index", 'routine in <a href="config/pds/Readpds_4.4/get_index.html">get_index.pro</a>', "get_index.pro", "", "get_index", "", "labelstartindex", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/get_juliandate.html", "get_juliandate.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "get_juliandate.pro", "", "", " NAME:        get_juliandate    PURPOSE:        To obtain the Julian Date    CATEGORY:        UTIL    CALLING SEQUENCE:        result = get_juliandate(stime=stime, string=string, format=format)    ARGUMENTS:   INPUT:        NONE    OUTPUT: 	NONE   KEYWORDS:   INPUT:          string:       If set, time is output as a string.           format:       Format to use if output is string.  Default is                        (d14.6)    OUTPUT:           stime:       System time   RETURN:        Julian date in floating point or a string if /string used.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/get_juliandate.html#get_juliandate", "get_juliandate", 'routine in <a href="util/get_juliandate.html">get_juliandate.pro</a>', "get_juliandate.pro", "", "get_juliandate", "", "stimestringformat", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/get_limb_profile_outline.html", "get_limb_profile_outline.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "get_limb_profile_outline.pro", "", "", " NAME:        get_limb_profile_outline    PURPOSE:        Generates an outline of a limb sector.   CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE: 	result = get_limb_profile_outline(cd, gbx, points)    ARGUMENTS:   INPUT: 	cd:	Camera descriptor.  	gbx:	Globe descriptor.  	points:	Array (2,2) of image points defining opposite corners 		of the sector.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	NONE    OUTPUT: 	inertial:	Inertial vectors corresponding to the limb sector 			outline points.  	dkd:	Disk descriptor corresponding to the skyplane.    RETURN:        Array of image points defining the outline of the sector.    MODIFICATION HISTORY:        Written by:     Spitale, 8/2006   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/get_limb_profile_outline.html#get_limb_profile_outline", "get_limb_profile_outline", 'routine in <a href="nv/obj/tools/get_limb_profile_outline.html">get_limb_profile_outline.pro</a>', "get_limb_profile_outline.pro", "", "get_limb_profile_outline", "", "altaznaltnazinertialdkdsave_azsscan_altscan_azlimb_pts_bodygraphiccdgbxpoints", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/get_limb_profile_outline_linear.html", "get_limb_profile_outline_linear.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "get_limb_profile_outline_linear.pro", "", "", " NAME:        get_limb_profile_outline_linear    PURPOSE:        Generates an outline of a rectangular limb sector.   CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE: 	result = get_limb_profile_outline_linear(cd, gbx, points)    ARGUMENTS:   INPUT: 	cd:	Camera descriptor.  	gbx:	Globe descriptor.  	points:	Array (2,2) of image points defining opposite corners 		of the sector.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	NONE    OUTPUT: 	inertial:	Inertial vectors corresponding to the limb sector 			outline points.    RETURN:        Array of image points defining the outline of the sector.    MODIFICATION HISTORY:        Written by:     Spitale, 1/2009   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/get_limb_profile_outline_linear.html#get_limb_profile_outline_linear", "get_limb_profile_outline_linear", 'routine in <a href="nv/obj/tools/get_limb_profile_outline_linear.html">get_limb_profile_outline_linear.pro</a>', "get_limb_profile_outline_linear.pro", "", "get_limb_profile_outline_linear", "", "altaz0rimpointsnaltnriminertialsave_rimsscan_altscan_rimlimb_pts_bodygraphiccdgbx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/get_limb_profile_outline_oblique.html", "get_limb_profile_outline_oblique.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "get_limb_profile_outline_oblique.pro", "", "", " NAME:        get_limb_profile_outline_oblique.  **incomplete**    PURPOSE:        Generates an outline of an oblique limb sector.   CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE: 	result = get_limb_profile_outline_oblique(cd, gbx, points)    ARGUMENTS:   INPUT: 	cd:	Camera descriptor.  	gbx:	Globe descriptor.  	points:	Array (2,2) of image points defining opposite corners 		of the sector.  	point:    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	NONE    OUTPUT: 	inertial:	Inertial vectors corresponding to the limb sector 			outline points.    RETURN:        Array of image points defining the outline of the sector.    MODIFICATION HISTORY:        Written by:     Spitale, 1/2009   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/get_limb_profile_outline_oblique.html#get_limb_profile_outline_oblique", "get_limb_profile_outline_oblique", 'routine in <a href="nv/obj/tools/get_limb_profile_outline_oblique.html">get_limb_profile_outline_oblique.pro</a>', "get_limb_profile_outline_oblique.pro", "", "get_limb_profile_outline_oblique", "", "naltnazdkdcdgbxpointspoint", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/get_lonperp.html", "get_lonperp.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "get_lonperp.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/get_lonperp.html#get_lonperp", "get_lonperp", 'routine in <a href="nv/obj/tools/get_lonperp.html">get_lonperp.pro</a>', "get_lonperp.pro", "", "get_lonperp", "", "cdrdp0p1", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/get_mem.html", "get_mem.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "get_mem.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/get_mem.html#get_mem", "get_mem", 'routine in <a href="util/get_mem.html">get_mem.pro</a>', "get_mem.pro", "", "get_mem", "", "change", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/get_object_by_name.html", "get_object_by_name.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "get_object_by_name.pro", "", "", " NAME:        get_object_by_name    PURPOSE: 	Selects from a list of descriptors based on their name.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        xd = get_object_by_name(xds, name)    ARGUMENTS:   INPUT: 	xds:	Array of any subclass of CORE.  	name:	Name to select.    OUTPUT:        NONE    KEYOWRDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array descriptors whose CORE name field matches the given name. 	If no matches are found, 0 is returned.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/get_object_by_name.html#get_object_by_name", "get_object_by_name", 'routine in <a href="nv/obj/tools/get_object_by_name.html">get_object_by_name.pro</a>', "get_object_by_name.pro", "", "get_object_by_name", "", "xdsname", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/get_path.html", "get_path.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "get_path.pro", "", "", " NAME: 	get_path    PURPOSE: 	Obtains a path list from a specified path variable using the 	same syntax used for IDL paths.    CATEGORY: 	UTIL    CALLING SEQUENCE: 	paths = get_path(path)    ARGUMENTS:   INPUT: 	path:	 Strings giving path specifications.    OUTPUT: NONE    KEYWORDS:   INPUT: 	extesion:	File extension to match.  If given, only directories 		 	containing files of this type are returned.  	file:		File name to match.  If given, only directories 			containing files with this name are returned.     OUTPUT: NONE    RETURN: 	An array of directories produced by expanding the value of the 	given path using the IDL path syntax.  See the IDL routine 	EXPAND_PATH.  The result is narrowed based on the EXTENSION and 	FILE keywords, if present.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2011   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/get_path.html#get_path", "get_path", 'routine in <a href="util/get_path.html">get_path.pro</a>', "get_path.pro", "", "get_path", "", "extesionfilepath", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/get_primary.html", "get_primary.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "get_primary.pro", "", "", " NAME:        get_primary    PURPOSE: 	Attempts to determine the primary planet from a list of descriptors 	based on their names and proximity to the observer.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        gbx0 = get_primary(bx, gbx)    ARGUMENTS:   INPUT: 	bx:	Array (nt) of any subclass of BODY, describing the observer.  	gbx:	Array (nd,nt) of any subclass of GLOBE, specifying a 		system of globe objects.    OUTPUT:        NONE    KEYOWRDS:   INPUT: 	rx:	Any subclass of RING.  	planets:	Array of names of objects to consider as planets. 			Default is the planets of the Solar System, or the 			primary planet of rx, if provided.    OUTPUT: NONE    RETURN: 	GLOBE descriptor for the selected primary.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/get_primary.html#get_primary", "get_primary", 'routine in <a href="nv/obj/tools/get_primary.html">get_primary.pro</a>', "get_primary.pro", "", "get_primary", "", "planetsrxodgbx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/get_pro_by_prefix.html", "get_pro_by_prefix.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "get_pro_by_prefix.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/get_pro_by_prefix.html#get_pro_by_prefix", "get_pro_by_prefix", 'routine in <a href="util/get_pro_by_prefix.html">get_pro_by_prefix.pro</a>', "get_pro_by_prefix.pro", "", "get_pro_by_prefix", "", "dirprefix", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/get_radperp.html", "get_radperp.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "get_radperp.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/get_radperp.html#get_radperp", "get_radperp", 'routine in <a href="nv/obj/tools/get_radperp.html">get_radperp.pro</a>', "get_radperp.pro", "", "get_radperp", "", "cddkxp0p1dsk_pt0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/get_ring_profile.html", "get_ring_profile.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "get_ring_profile.pro", "", "", " NAME:        get_ring_profile    PURPOSE:        Generates a ring profile in radius or longitude.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        result = get_ring_profile(image, cd, dkd, lon, rad)   ARGUMENTS:   INPUT:            image:      The image to scan                cd:      Camera descriptor               dkd:      Disk descriptor               lon:      Array of longitudes at which to sample image               rad:      Array of radii at which to sample image    OUTPUT:        NONE    KEYWORDS:   INPUT:        azimuthal:      If set, a longitudinal scan is done instead.    OUTPUT:        NONE    RETURN:        An array of averaged dn values that match the given rad or        match the given lon if /azimuthal selected.    PROCEDURE:        The profile is calculated by applying a grid of (radius, longitude)        given by rad and lon on a ring sector, interpolating the dn in        the image, and averaging along a direction to give a radius profile,        or a longitudinal profile.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Haemmerle, 6/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/get_ring_profile.html#get_ring_profile", "get_ring_profile", 'routine in <a href="nv/obj/tools/get_ring_profile.html">get_ring_profile.pro</a>', "get_ring_profile.pro", "", "get_ring_profile", "", "azimuthalinterpim_ptsdxdsk_ptssigmawidthnnarg_interpimagecddkdlon_ptsrad_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/get_ring_profile_bin.html", "get_ring_profile_bin.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "get_ring_profile_bin.pro", "", "", " NAME:        get_ring_profile_bin    PURPOSE:        Generates a ring profile in radius or longitude using binning.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        result = get_ring_profile_bin(image, cd, dkd, dlon, rad)   ARGUMENTS:   INPUT:            image:      The image to scan                cd:      Camera descriptor               dkd:      Disk descriptor              dlon:      Array of disk longitudes of which to sample image               rad:      Array of disk radii of which to sample image    OUTPUT:        NONE    KEYWORDS:   INPUT:        azimuthal:      If set, a longitudinal scan is done instead.    OUTPUT:        NONE    RETURN:        An array of averaged dn values that match the given rad or        match the given dlon if /azimuthal selected.    PROCEDURE:        A ring sector polygon is calculated from the given dlon and rad        arrays.  All the pixels of the image within this polygon are        binned in an equally-spaced histogram in radius or longitude.   RESTRICTIONS:        The dlon and rad arrays are treated as equally spaced, that is,        the binsize is calculated by dividing the spacing in radius by        number of points minus one.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Haemmerle, 6/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/get_ring_profile_bin.html#get_ring_profile_bin", "get_ring_profile_bin", 'routine in <a href="nv/obj/tools/get_ring_profile_bin.html">get_ring_profile_bin.pro</a>', "get_ring_profile_bin.pro", "", "get_ring_profile_bin", "", "slopeazimuthalimagecddkdlon_ptsrad_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/get_ring_profile_n.html", "get_ring_profile_n.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "get_ring_profile_n.pro", "", "", " NAME:        get_ring_profile_n    PURPOSE:        Calculate the number of points in radius and longitude for        a ring profile.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        result = get_ring_profile_n(outline_pts, cd, dkd, lon, rad)    ARGUMENTS:   INPUT:        outline_pts:    Outline sector image points which are the result                        of calling get_ring_profile_outline()                  cd:    Camera descriptor                 dkd:    Disk descriptor                lon:    Equally spaced longitude array                 rad:    Equally spaced radius array    OUTPUT:        NONE    KEYWORDS:   INPUT:           oversamp:    Oversample factor compared to regular calculation of                        radius and longitude spacing which would put maximum                        spacing at 1 pixel.    OUTPUT:        NONE    RETURN:        Array containg n_rad and n_lon to be used by get_ring_profile() or        get_ring_profile_bin().    PROCEDURE:        Routine goes along the radial and longitudinal edges of a ring        profile sector and calculates the minimum spacing between the        points in image space, then derives the n_rad and n_lon points        to make the minimum spacing 1 pixel.  If the oversamp parameter        is given, the numbers are multiplied by this factor.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Haemmerle, 6/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/get_ring_profile_n.html#get_ring_profile_n", "get_ring_profile_n", 'routine in <a href="nv/obj/tools/get_ring_profile_n.html">get_ring_profile_n.pro</a>', "get_ring_profile_n.pro", "", "get_ring_profile_n", "", "oversampoutline_ptscddkdlonrad", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/get_ring_profile_outline.html", "get_ring_profile_outline.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "get_ring_profile_outline.pro", "", "", " NAME:        get_profile_ring_outline    PURPOSE:        Generates an outline of a ring sector.   CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:     result = get_profile_ring_outline(cd, dkd, lon, rad, inertial=inertial)    ARGUMENTS:   INPUT: 	cd:	Camera descriptor.  	dkx:	Disk descriptor.  	points:	Array (2,2) of image points defining corners of the sector.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	lon:	Array of disk longitudes for sector  	rad:	Array of disk radii for sector  	nrad:	Number of points in the radial direction.  	nlon:	Number of points in the longitudinal direction.    OUTPUT: 	inertial:	Inertial vectors corresponding to the ring sector 			outline points.    RETURN:        Output is set of image points (x,y) defining the outline of the        ring sector.   MODIFICATION HISTORY:        Written by:     Vance Haemmerle & Joe Spitale, 6/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/get_ring_profile_outline.html#get_ring_profile_outline", "get_ring_profile_outline", 'routine in <a href="nv/obj/tools/get_ring_profile_outline.html">get_ring_profile_outline.pro</a>', "get_ring_profile_outline.pro", "", "get_ring_profile_outline", "", "radlonxlondirnradnlonslopeinertialcddkdpoints", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/get_ring_profile_outline_oblique.html", "get_ring_profile_outline_oblique.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "get_ring_profile_outline_oblique.pro", "", "", " NAME:        get_ring_profile_outline_oblique    PURPOSE:        Generates an outline of an oblique ring sector.   CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE: 	result = get_ring_profile_outline_oblique(cd, dkx, points, point)    ARGUMENTS:   INPUT: 	cd:	Camera descriptor.  	gbx:	Globe descriptor.  	points:	Array (2,2) of image points defining corners at opposite ends 		on one side of the sector.  	point:	Image point defining and third corner.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	nrad:	Number of points in the radial direction.  	nlon:	Number of points in the longitudinal direction.    OUTPUT: NONE    RETURN:        Array of image points defining the outline of the sector.    MODIFICATION HISTORY:        Written by:     Spitale, 8/2006   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/get_ring_profile_outline_oblique.html#get_ring_profile_outline_oblique", "get_ring_profile_outline_oblique", 'routine in <a href="nv/obj/tools/get_ring_profile_outline_oblique.html">get_ring_profile_outline_oblique.pro</a>', "get_ring_profile_outline_oblique.pro", "", "get_ring_profile_outline_oblique", "", "dirnradnloncddkxpointspoint", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/get_ring_profile_outline_perp.html", "get_ring_profile_outline_perp.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "get_ring_profile_outline_perp.pro", "", "", " NAME:        get_ring_profile_outline_perp    PURPOSE:        Generates an outline of a ring sector perpendicular to the 	image-projected radial direction.   CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE: 	result = get_ring_profile_outline_perp(cd, dkx, points)    ARGUMENTS:   INPUT: 	cd:	Camera descriptor.  	gbx:	Globe descriptor.  	points:	Array (2,2) of image points defining corners of the sector.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	nrad:	Number of points in the radial direction.  	nlon:	Number of points in the longitudinal direction.    OUTPUT: NONE    RETURN:        Array of image points defining the outline of the sector.    MODIFICATION HISTORY:        Written by:     Spitale, 8/2006   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/get_ring_profile_outline_perp.html#get_ring_profile_outline_perp", "get_ring_profile_outline_perp", 'routine in <a href="nv/obj/tools/get_ring_profile_outline_perp.html">get_ring_profile_outline_perp.pro</a>', "get_ring_profile_outline_perp.pro", "", "get_ring_profile_outline_perp", "", "dirnradnloncddkxpoints", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/get_solar_ref.html", "get_solar_ref.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "get_solar_ref.pro", "", "", " NAME:        get_solar_ref    PURPOSE: 	Produces inertial unit vectors corresponding to the projection 	of the sun direction into the given disk plane.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        v = get_solar_ref(dkx, sund)    ARGUMENTS:   INPUT: 	dkx:	Array (nt) of any subclass of DISK.  	sund:	Array (nt) of any subclass of STAR representing the sun.    OUTPUT:  NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (1,3,nt) of inertial vectors.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/get_solar_ref.html#get_solar_ref", "get_solar_ref", 'routine in <a href="nv/obj/tools/get_solar_ref.html">get_solar_ref.pro</a>', "get_solar_ref.pro", "", "get_solar_ref", "", "dkxsund", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/composite/get_surface_ranges.html", "get_surface_ranges.pro", '.pro file in <a href="nv/obj/tools/composite/dir-overview.html">nv/obj/tools/composite/ directory</a>', "get_surface_ranges.pro", "", "", " NAME:        get_surface_ranges    PURPOSE: 	Determines full ranges of valid surface coordinate system.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        points = get_surface_ranges(cd, bx)    ARGUMENTS:   INPUT: 	cd:      Camera or map descriptor  	bx:      Object descriptor (subclass of BODY)     OUTPUT: NONE    KEYWORDS:    INPUT: NONE     OUTPUT: NONE    RETURN: 	Array of 2 points representng the minimum and maximum values of the 	relevant coordinate system.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/composite/get_surface_ranges.html#get_surface_ranges", "get_surface_ranges", 'routine in <a href="nv/obj/tools/composite/get_surface_ranges.html">get_surface_ranges.pro</a>', "get_surface_ranges.pro", "", "get_surface_ranges", "", "odbx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/get_tags.html", "get_tags.pro", '.pro file in <a href="config/pds/Readpds_4.4/dir-overview.html">config/pds/Readpds_4.4/ directory</a>', "get_tags.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/get_tags.html#All_Tags", "All_Tags", 'routine in <a href="config/pds/Readpds_4.4/get_tags.html">get_tags.pro</a>', "get_tags.pro", "", "All_Tags", "", "structurerootname", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/get_tags.html#get_tags", "get_tags", 'routine in <a href="config/pds/Readpds_4.4/get_tags.html">get_tags.pro</a>', "get_tags.pro", "", "get_tags", "", "structurerootname", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/get_username.html", "get_username.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "get_username.pro", "", "", " NAME:        get_username    PURPOSE:        To obtain the username of the person running the function    CATEGORY:        UTIL    CALLING SEQUENCE:        result = get_username()    ARGUMENTS:        NONE   RETURN:        String variable containing the username.  This routine is operating        system dependent and only works for unix and VMS currently.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/get_username.html#get_username", "get_username", 'routine in <a href="util/get_username.html">get_username.pro</a>', "get_username.pro", "", "get_username", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/get_viewport_indices.html", "get_viewport_indices.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "get_viewport_indices.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/get_viewport_indices.html#get_viewport_indices", "get_viewport_indices", 'routine in <a href="util/get_viewport_indices.html">get_viewport_indices.pro</a>', "get_viewport_indices.pro", "", "get_viewport_indices", "", "pdevice_indicesdevice_sizexrangeyrangenoclipdim", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/gethost.html", "gethost.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "gethost.pro", "", "", " NAME: 	gethost    PURPOSE: 	Determines the host machine type.    CATEGORY: 	UTIL    CALLING SEQUENCE: 	result=gethost()    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	status:	If no errors occur, status will be zero, otherwise 		it will be a string giving an error message.    RETURN: 	String indicating the host machine type.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 5/1996   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/gethost.html#gethost", "gethost", 'routine in <a href="util/gethost.html">gethost.pro</a>', "gethost.pro", "", "gethost", "", "status", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/gff/gff_create.html", "gff_create.pro", '.pro file in <a href="config/gff/dir-overview.html">config/gff/ directory</a>', "gff_create.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/gff/gff_create.html#gff_create", "gff_create", 'routine in <a href="config/gff/gff_create.html">gff_create.pro</a>', "gff_create.pro", "", "gff_create", "", "interleavefile_offsetdata_offsetfilenamedimtype", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/gff/gff_read.html", "gff_read.pro", '.pro file in <a href="config/gff/dir-overview.html">config/gff/ directory</a>', "gff_read.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/gff/gff_read.html#gff_read", "gff_read", 'routine in <a href="config/gff/gff_read.html">gff_read.pro</a>', "gff_read.pro", "", "gff_read", "", "subscriptsgff", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/gff/gff_struct__define.html", "gff_struct__define.pro", '.pro file in <a href="config/gff/dir-overview.html">config/gff/ directory</a>', "gff_struct__define.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/gff/gff_struct__define.html#gff_struct__define", "gff_struct__define", 'routine in <a href="config/gff/gff_struct__define.html">gff_struct__define.pro</a>', "gff_struct__define.pro", "", "gff_struct__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/glb/glb_altaz_to_local.html", "glb_altaz_to_local.pro", '.pro file in <a href="nv/obj/glb/dir-overview.html">nv/obj/glb/ directory</a>', "glb_altaz_to_local.pro", "", "", " NAME: 	glb_altaz_to_local    PURPOSE:        Converts the given column vectors from the altaz coordinate        system to the local coordinate system.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	local_dir = glb_altaz_to_local(gbd, surf_pts, altaz_dir)    ARGUMENTS:   INPUT: 	gbd:	        Array (nt) of any subclass of GLOBE descriptors.  	surf_pts:	Array (nv,3,nt) of column vectors in the body                        frame (representing points on the surface of                        the globe).         altaz_dir:      Array (3,nt) of column vectors in the altaz                        system, giving the direction from each surface point.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (nv,3,nt) of column vectors in the local system.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/glb/glb_altaz_to_local.html#glb_altaz_to_local", "glb_altaz_to_local", 'routine in <a href="nv/obj/glb/glb_altaz_to_local.html">glb_altaz_to_local.pro</a>', "glb_altaz_to_local.pro", "", "glb_altaz_to_local", "", "gbdvr", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/glb/glb_assign.html", "glb_assign.pro", '.pro file in <a href="nv/obj/glb/dir-overview.html">nv/obj/glb/ directory</a>', "glb_assign.pro", "", "", " NAME: 	glb_assign    PURPOSE: 	Replaces fields in a GLOBE object.  This is a convenient way of 	setting multiple fields in one call, and only a single event is 	generated.    CATEGORY: 	NV/OBJ/GLB    CALLING SEQUENCE: 	glb_assign, gbd, <keywords>=<values>    ARGUMENTS:   INPUT: 	gbd:		GLOBE object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	GLOBE fields to set.  	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	glb_set_*     MODIFICATION HISTORY:  	Written by:	Spitale		2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/glb/glb_assign.html#glb_assign", "glb_assign", 'routine in <a href="nv/obj/glb/glb_assign.html">glb_assign.pro</a>', "glb_assign.pro", "", "glb_assign", "", "noeventxd@glb__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/glb/glb_body_to_globe.html", "glb_body_to_globe.pro", '.pro file in <a href="nv/obj/glb/dir-overview.html">nv/obj/glb/ directory</a>', "glb_body_to_globe.pro", "", "", " NAME: 	glb_body_to_globe    PURPOSE:        Transforms the given column vectors from the body coordinate        system to the globe coordinate system.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	globe_pts = glb_body_to_globe(gbd, body_pts)    ARGUMENTS:   INPUT: 	gbd:	        Array (nt) of any subclass of GLOBE descriptors.  	body_pts:	Array (nv,3,nt) of column vectors in the body frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (nv,3,nt) of column vectors in the globe frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/glb/glb_body_to_globe.html#glb_body_to_globe", "glb_body_to_globe", 'routine in <a href="nv/obj/glb/glb_body_to_globe.html">glb_body_to_globe.pro</a>', "glb_body_to_globe.pro", "", "glb_body_to_globe", "", "gbdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/glb/glb_body_to_local.html", "glb_body_to_local.pro", '.pro file in <a href="nv/obj/glb/dir-overview.html">nv/obj/glb/ directory</a>', "glb_body_to_local.pro", "", "", " NAME: 	glb_body_to_local    PURPOSE:        Converts the given column vectors from the body coordinate        system to the local coordinate system.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	local_dir = glb_body_to_local(gbd, body_pts, body_dir)    ARGUMENTS:   INPUT: 	gbd:	        Array (nt) of any subclass of GLOBE descriptors.  	body_pts:	Array (nv,3,nt) of column vectors in the body                        frame (representing points on the surface of                        the globe).         body_dir:       Array (3,nt) of column vectors in the body                        frame, giving the direction from each surface point.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (nv,3,nt) of column vectors in the local system.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/glb/glb_body_to_local.html#glb_body_to_local", "glb_body_to_local", 'routine in <a href="nv/obj/glb/glb_body_to_local.html">glb_body_to_local.pro</a>', "glb_body_to_local.pro", "", "glb_body_to_local", "", "gbdvr", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/glb/glb_create_descriptors.html", "glb_create_descriptors.pro", '.pro file in <a href="nv/obj/glb/dir-overview.html">nv/obj/glb/ directory</a>', "glb_create_descriptors.pro", "", "", " NAME: 	glb_create_descriptors    PURPOSE: 	Init method for the GLOBE class.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	gbd = glb_create_descriptors(n)    ARGUMENTS:   INPUT: 	n:	Number of descriptors to create.    OUTPUT: NONE    KEYWORDS (in addition to those accepted by all superclasses):   INPUT: 	gbd:	Globe descriptor(s) to initialize, instead of creating a new one.  	sld:	Solid descriptor(s) instead of using sld_create_descriptors.  	bd:	Body descriptor(s) instead of using bod_create_descriptors.  	crd:	Core descriptor(s) instead of using cor_create_descriptors.  	type:	Array (n) of type strings.  	lref:	Array (n) of longitude reference notes.  	radii:	Array (3,n) of ellipsoid radii.  	lora:	Array (n) giving longitudes  first ellipsoid radius.  	rref:	Array (n) of reference radii.  	J:	Array (n,nj) of zonal harmonics.  	GM:	Array (n) of masses x gravitiational constant.  	mass:	Array (n) of masses.  	phase_fn: Array (n) of phase function names.  	phase_parm:	Array (npht,n) of phase function parameters.  	refl_fn: Array (n) of reflection function names.  	refl_parm:	Array (npht,n) of reflection function parameters.  	albedo:	Array (n) of bond albedos.     OUTPUT: NONE    RETURN: 	Newly created or or freshly initialized globe descriptors, depending 	on the presence of the bd keyword.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/glb/glb_create_descriptors.html#glb_create_descriptors", "glb_create_descriptors", 'routine in <a href="nv/obj/glb/glb_create_descriptors.html">glb_create_descriptors.pro</a>', "glb_create_descriptors.pro", "", "glb_create_descriptors", "", "crdbdsldgbdn@glb__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/glb/glb_evolve.html", "glb_evolve.pro", '.pro file in <a href="nv/obj/glb/dir-overview.html">nv/obj/glb/ directory</a>', "glb_evolve.pro", "", "", " NAME: 	glb_evolve    PURPOSE:        Computes new globe descriptors at the given time offsets from        the given globe descriptors using the taylor series expansion        corresponding to the derivatives contained in the given globe        descriptor.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	gbdt = glb_evolve(gbd, dt)    ARGUMENTS:   INPUT: 	gbd:	 Array (ngd) of any subclass of GLOBE descriptors.  	dt:	 Array (ndt) of time offsets.    OUTPUT: NONE    KEYWORDS:   INPUT: 	nodv:	 If set, velocities will not be evolved.  	copy:	If set, the evolved descriptor is copied into the input 		descriptor and it is freed.  The input descriptor is returned.     OUTPUT: NONE    RETURN:        Array (ngd,ndt) of newly allocated globe descriptors evolved        by time dt, where ngd is the number of gbd, and ndt is the        number of dt.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/glb/glb_evolve.html#glb_evolve", "glb_evolve", 'routine in <a href="nv/obj/glb/glb_evolve.html">glb_evolve.pro</a>', "glb_evolve.pro", "", "glb_evolve", "", "nodvcopygbddt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/glb/glb_get_cusp_points.html", "glb_get_cusp_points.pro", '.pro file in <a href="nv/obj/glb/dir-overview.html">nv/obj/glb/ directory</a>', "glb_get_cusp_points.pro", "", "", " NAME: 	glb_get_cusp_points    PURPOSE: 	Iteratively computes the two points that occupy the limb from two 	different viewpoints for each given globe object.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	cusp_pts = glb_get_cusp_points(gbd, r1, r2, epsilon, niter)    ARGUMENTS:   INPUT: 	gbd:	 Array (nt) of any subclass of GLOBE descriptors.  	r1, r2:	 Arrays (1,3,nt) of viewer positions in the BODY frame.  	epsilon:	Controls the precision of the iteration.  Default 			is 1d-3.  	niter:	Maximum number of iterations, default is 1000     OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (2, 3, nt) of cusp points in the BODY frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/glb/glb_get_cusp_points.html#_glb_get_cusp_points", "_glb_get_cusp_points", 'routine in <a href="nv/obj/glb/glb_get_cusp_points.html">glb_get_cusp_points.pro</a>', "glb_get_cusp_points.pro", "", "_glb_get_cusp_points", "", "gbdr1r2epsilonniter", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/glb/glb_get_cusp_points.html#glb_get_cusp_points", "glb_get_cusp_points", 'routine in <a href="nv/obj/glb/glb_get_cusp_points.html">glb_get_cusp_points.pro</a>', "glb_get_cusp_points.pro", "", "glb_get_cusp_points", "", "gbdr1r2epsilonniter", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/glb/glb_get_grid_points.html", "glb_get_grid_points.pro", '.pro file in <a href="nv/obj/glb/dir-overview.html">nv/obj/glb/ directory</a>', "glb_get_grid_points.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/glb/glb_get_grid_points.html#glb_get_grid_points", "glb_get_grid_points", 'routine in <a href="nv/obj/glb/glb_get_grid_points.html">glb_get_grid_points.pro</a>', "glb_get_grid_points.pro", "", "glb_get_grid_points", "", "latlonscan_latscan_longbd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/glb/glb_get_limb_points.html", "glb_get_limb_points.pro", '.pro file in <a href="nv/obj/glb/dir-overview.html">nv/obj/glb/ directory</a>', "glb_get_limb_points.pro", "", "", " NAME: 	glb_get_limb_points    PURPOSE: 	Iteratively computes the points on the limb for each given globe 	object.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	limb_pts = glb_get_limb_points(gbd, r, np, epsilon, niter)    ARGUMENTS:   INPUT: 	gbd:	Array (nt) of any subclass of GLOBE descriptors.  	r:	Array (1,3,nt) giving viewer position in the BODY frame.  	np:	Number of points to compute around the limb.  	epsilon:	Controls the precision of the iteration.  Default 			is 1d-3.  	niter:	Maximum number of iterations, default is 1000     OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	alpha:	Array (np) of azimuths for each output point.    RETURN: 	Array (np, 3, nt) of limb points in the BODY frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/glb/glb_get_limb_points.html#_glb_get_limb_points", "_glb_get_limb_points", 'routine in <a href="nv/obj/glb/glb_get_limb_points.html">glb_get_limb_points.pro</a>', "glb_get_limb_points.pro", "", "_glb_get_limb_points", "", "alphagbdrn_pointsepsilonniter", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/glb/glb_get_limb_points.html#glb_get_limb_points", "glb_get_limb_points", 'routine in <a href="nv/obj/glb/glb_get_limb_points.html">glb_get_limb_points.pro</a>', "glb_get_limb_points.pro", "", "glb_get_limb_points", "", "alphagbdrn_pointsepsilonniter", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/glb/glb_get_radius.html", "glb_get_radius.pro", '.pro file in <a href="nv/obj/glb/dir-overview.html">nv/obj/glb/ directory</a>', "glb_get_radius.pro", "", "", " NAME: 	glb_get_radius    PURPOSE: 	Computes the local radius of a GLOBE object at the given lat/lon.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	radius = glb_get_radius(gbd, lat, lon)    ARGUMENTS:   INPUT: 	gbd:	Array (nt) of any subclass of GLOBE descriptors.  	lat:	Array (nv) of latitudes.  	lon:	Array (nv) of longitudes.     OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (nv, nt) of radius values.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/glb/glb_get_radius.html#glb_get_radius", "glb_get_radius", 'routine in <a href="nv/obj/glb/glb_get_radius.html">glb_get_radius.pro</a>', "glb_get_radius.pro", "", "glb_get_radius", "", "noeventgbdlatlon", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/glb/glb_get_ranges.html", "glb_get_ranges.pro", '.pro file in <a href="nv/obj/glb/dir-overview.html">nv/obj/glb/ directory</a>', "glb_get_ranges.pro", "", "", " NAME: 	glb_get_ranges    PURPOSE: 	Returns ranges of valid coordinates for the given GLOBE object.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	ranges = glb_get_ranges(gbd)    ARGUMENTS:   INPUT: 	bx:	 Any subclass of GLOBE.     OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Array (2 x 3) giving the ranges in globe coordinates.    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/glb/glb_get_ranges.html#glb_get_ranges", "glb_get_ranges", 'routine in <a href="nv/obj/glb/glb_get_ranges.html">glb_get_ranges.pro</a>', "glb_get_ranges.pro", "", "glb_get_ranges", "", "gbd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/glb/glb_get_surface_normal.html", "glb_get_surface_normal.pro", '.pro file in <a href="nv/obj/glb/dir-overview.html">nv/obj/glb/ directory</a>', "glb_get_surface_normal.pro", "", "", " NAME: 	glb_get_surface_normal    PURPOSE: 	Computes the surface normal of a GLOBE object at the given 	globe position.   CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	n = glb_get_surface_normal_body(gbd, p)    ARGUMENTS:   INPUT: 	gbd:	Array (nt) of any subclass of GLOBE descriptors.  	p:	Array (nv,3,nt) of points in the GLOBE system.     OUTPUT: NONE    KEYWORDS:   INPUT: 	nonorm:	If set, the returned vectors are not normalized.  	body:	If set, the inputs given in the BODY system instead of GLOBE.    OUTPUT: NONE    RETURN: 	Array (nv, 3, nt) of surface normals in the BODY frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/glb/glb_get_surface_normal.html#glb_get_surface_normal", "glb_get_surface_normal", 'routine in <a href="nv/obj/glb/glb_get_surface_normal.html">glb_get_surface_normal.pro</a>', "glb_get_surface_normal.pro", "", "glb_get_surface_normal", "", "noeventnonormbodygbdglobe_pts", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/glb/glb_get_surface_normal.html#___glb_get_surface_normal", "___glb_get_surface_normal", 'routine in <a href="nv/obj/glb/glb_get_surface_normal.html">glb_get_surface_normal.pro</a>', "glb_get_surface_normal.pro", "", "___glb_get_surface_normal", "", "noeventgbdlatlon", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/glb/glb_globe_to_body.html", "glb_globe_to_body.pro", '.pro file in <a href="nv/obj/glb/dir-overview.html">nv/obj/glb/ directory</a>', "glb_globe_to_body.pro", "", "", " NAME: 	glb_globe_to_body   PURPOSE:        Transforms the given column vectors from the globe coordinate        system to the body coordinate system.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	body_pts = glb_globe_to_body(gbd, globe_pts)    ARGUMENTS:   INPUT: 	gbd:	        Array (nt) of any subclass of GLOBE descriptors.  	globe_pts:	Array (nv,3,nt) of column vectors in the globe frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (nv,3,nt) of column vectors in the body frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/glb/glb_globe_to_body.html#glb_globe_to_body", "glb_globe_to_body", 'routine in <a href="nv/obj/glb/glb_globe_to_body.html">glb_globe_to_body.pro</a>', "glb_globe_to_body.pro", "", "glb_globe_to_body", "", "gbdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/glb/glb_globe_to_graphic.html", "glb_globe_to_graphic.pro", '.pro file in <a href="nv/obj/glb/dir-overview.html">nv/obj/glb/ directory</a>', "glb_globe_to_graphic.pro", "", "", " NAME: 	glb_globe_to_graphic    PURPOSE:        Converts the given vectors from the globe coordinate        system to the graphic coordinate system.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	graphic_pts = glb_globe_to_graphic(gbd, globe_pts)    ARGUMENTS:   INPUT: 	gbd:	        Array (nt) of any subclass of GLOBE descriptors.  	globe_pts:	Array (nv,3,nt) of column vectors in the globe system.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (nv,3,nt) of column vectors in the graphic system.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/glb/glb_globe_to_graphic.html#glb_globe_to_graphic", "glb_globe_to_graphic", 'routine in <a href="nv/obj/glb/glb_globe_to_graphic.html">glb_globe_to_graphic.pro</a>', "glb_globe_to_graphic.pro", "", "glb_globe_to_graphic", "", "gbdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/glb/glb_graphic_to_globe.html", "glb_graphic_to_globe.pro", '.pro file in <a href="nv/obj/glb/dir-overview.html">nv/obj/glb/ directory</a>', "glb_graphic_to_globe.pro", "", "", " NAME: 	glb_graphic_to_globe    PURPOSE:        Converts the given vectors from the graphic coordinate        system to the globe coordinate system.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	globe_pts = glb_graphic_to_globe(gbd, graphic_pts)    ARGUMENTS:   INPUT: 	gbd:	        Array (nt) of any subclass of GLOBE descriptors.  	graphic_pts:	Array (nv,3,nt) of column vectors in the graphic system.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (nv,3,nt) of column vectors in the globe system.    STATUS: 	 Not complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/glb/glb_graphic_to_globe.html#glb_graphic_to_globe", "glb_graphic_to_globe", 'routine in <a href="nv/obj/glb/glb_graphic_to_globe.html">glb_graphic_to_globe.pro</a>', "glb_graphic_to_globe.pro", "", "glb_graphic_to_globe", "", "noeventgbdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/glb/glb_hide_points.html", "glb_hide_points.pro", '.pro file in <a href="nv/obj/glb/dir-overview.html">nv/obj/glb/ directory</a>', "glb_hide_points.pro", "", "", " NAME: 	glb_hide_points    PURPOSE: 	Hides points that are obscured by a GLOBE with respect to a given 	viewpoint.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	sub = glb_hide_points(gbd, r, p)    ARGUMENTS:   INPUT: 	gbd:	Array (nt) of any subclass of GLOBE descriptors.  	r:	Columns vector giving the BODY-frame position of the viewer.  	p:	Array (nv) of BODY-frame vectors giving the points to hide.     OUTPUT: NONE    KEYWORDS:   INPUT: 	rm:	If set, points are flagged for being in front of or behind 		the globe, rather then just behind it.    OUTPUT: NONE    RETURN: 	Subscripts of the points in p that are hidden by the object.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/glb/glb_hide_points.html#glb_hide_points", "glb_hide_points", 'routine in <a href="nv/obj/glb/glb_hide_points.html">glb_hide_points.pro</a>', "glb_hide_points.pro", "", "glb_hide_points", "", "rmgbdvpoints", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/glb/glb_hide_points_limb.html", "glb_hide_points_limb.pro", '.pro file in <a href="nv/obj/glb/dir-overview.html">nv/obj/glb/ directory</a>', "glb_hide_points_limb.pro", "", "", " NAME: 	glb_hide_points_limb    PURPOSE: 	Hides points lying on the surface of a GLOBE object that are 	obscured by the limb with respect to a given viewpoint.  This 	procedure is much faster then the more general glb_hide_points.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	sub = glb_hide_points_limb(gbd, r, p)    ARGUMENTS:   INPUT: 	gbd:	Array (nt) of any subclass of GLOBE descriptors.  	r:	Columns vector givnng the BODY-frame position of the viewer.  	p:	Array (nv) of BODY-frame vectors giving the points to hide.     OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Subscripts of the points in p that are hidden by the object. 	Note that this routine is only valid for points that lie on 	the surface of the globe.  This routine is faster than 	glb_hide_points.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/glb/glb_hide_points_limb.html#glb_hide_points_limb", "glb_hide_points_limb", 'routine in <a href="nv/obj/glb/glb_hide_points_limb.html">glb_hide_points_limb.pro</a>', "glb_hide_points_limb.pro", "", "glb_hide_points_limb", "", "gbdrpoints", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/glb_image_bounds.html", "glb_image_bounds.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "glb_image_bounds.pro", "", "", " NAME:        glb_image_bounds    PURPOSE: 	Determines globe coordinate ranges visible in an image described 	by a given camera descriptor.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        glb_image_bounds, cd, gbx, $ 	        latmin=latmin, latmax=latmax, lonmin=lonmin, lonmax=lonmax    ARGUMENTS:   INPUT: 	cd:	Camera descripor.  	gbx:	Any subclass of GLOBE.    OUTPUT:  NONE    KEYOWRDS:   INPUT: 	corners:	Array(2,2) giving corers of image region to consider.  	slop:	Number of pixels by which to expand the image in each 		direction.     OUTPUT: 	latmin:	Minimum latitude in image.  	latmax:	Maximum latitude in image.  	lonmin:	Minimum longitude in image.  	lonmax:	Maximum longitude in image.  	border_pts_im:	Array (2,np) of points along the edge of the image.  	status:	-1 if no globe in the image, 0 otherwise.    RETURN: NONE    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/glb_image_bounds.html#glb_image_bounds", "glb_image_bounds", 'routine in <a href="nv/obj/tools/glb_image_bounds.html">glb_image_bounds.pro</a>', "glb_image_bounds.pro", "", "glb_image_bounds", "", "slopborder_pts_imcornerscenterlatminlatmaxlonminlonmaxstatuscdpd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/glb/glb_intersect.html", "glb_intersect.pro", '.pro file in <a href="nv/obj/glb/dir-overview.html">nv/obj/glb/ directory</a>', "glb_intersect.pro", "", "", " NAME: 	glb_intersect    PURPOSE: 	Computes the intersection of rays with GLOBE objects.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	int_pts = glb_intersect(gbd, v, r)    ARGUMENTS:   INPUT: 	gbd:	Array (nt) of any subclass of GLOBE descriptors.  	v:	Array (nv,3,nt) giving ray origins in the BODY frame.  	r:	Array (nv,3,nt) giving ray directions in the BODY frame.     OUTPUT: NONE    KEYWORDS:   INPUT: 	near:	If set, only the  near  points are returned.  More specifically, 		these points correspond to the furthest along the ray from the 		observer to the globe.  If the observer is exterior, these are 		the nearest interesections to the observer; if the observer is 		interior, these intersections are behind the observer.  	far:	If set, only the  far  points are returned.  See above; if the 		observer is exterior, these are the furthest interesections from 		the observer; if the observer is interior, these intersections 		are in front of the observer.  	hit:	Array giving the indices of rays the hit the object.  	valid:	Array in which each element indicates whether the object 		was hit.  	nosolve: If set, the intersections are not computed, though the 		 discrimiant is.    OUTPUT: 	discriminant:	Discriminant of the quadriatic equation used to 			determine the intersections.    RETURN: 	Array (2*nv,3,nt) of points in the BODY frame, where 	int_pts[0:nv-1,*,*] correspond to the near-side intersections 	and int_pts[nv:2*nv-1,*,1] correspond to the far side.  Zero 	vector is returned for points with no solution.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/glb/glb_intersect.html#glb_intersect", "glb_intersect", 'routine in <a href="nv/obj/glb/glb_intersect.html">glb_intersect.pro</a>', "glb_intersect.pro", "", "glb_intersect", "", "hitnearfardiscriminantnosolvevalidgbdvr", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/glb/glb_intersect_discriminant.html", "glb_intersect_discriminant.pro", '.pro file in <a href="nv/obj/glb/dir-overview.html">nv/obj/glb/ directory</a>', "glb_intersect_discriminant.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/glb/glb_intersect_discriminant.html#glb_intersect_discriminant", "glb_intersect_discriminant", 'routine in <a href="nv/obj/glb/glb_intersect_discriminant.html">glb_intersect_discriminant.pro</a>', "glb_intersect_discriminant.pro", "", "glb_intersect_discriminant", "", "noeventalphabetagammagbdvr", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/glb/glb_intersect_plane.html", "glb_intersect_plane.pro", '.pro file in <a href="nv/obj/glb/dir-overview.html">nv/obj/glb/ directory</a>', "glb_intersect_plane.pro", "", "", " NAME: 	glb_intersect_plane    PURPOSE: 	Computesthe intersection of a plane with a GLOBE object.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	int_pts = glb_intersect_plane(gbd, v, n)    ARGUMENTS:   INPUT: 	gbd:	Array (nt) of any subclass of GLOBE descriptors.  	v:	Array (1,3,nt) giving plane origins in the BODY frame.  	n:	Array (1,3,nt) giving the plane unit normals in the 		BODY frame.     OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (np,3,nt) of points in the BODY frame, np is the number of 	points on the curve of intersection.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/glb/glb_intersect_plane.html#glb_intersect_plane", "glb_intersect_plane", 'routine in <a href="nv/obj/glb/glb_intersect_plane.html">glb_intersect_plane.pro</a>', "glb_intersect_plane.pro", "", "glb_intersect_plane", "", "npgbdvn", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/glb/glb_intersect_points.html", "glb_intersect_points.pro", '.pro file in <a href="nv/obj/glb/dir-overview.html">nv/obj/glb/ directory</a>', "glb_intersect_points.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/glb/glb_intersect_points.html#glb_intersect_points", "glb_intersect_points", 'routine in <a href="nv/obj/glb/glb_intersect_points.html">glb_intersect_points.pro</a>', "glb_intersect_points.pro", "", "glb_intersect_points", "", "validnosolvenearfargbdvrdiscriminantalphabetagamma", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/glb/glb_j.html", "glb_j.pro", '.pro file in <a href="nv/obj/glb/dir-overview.html">nv/obj/glb/ directory</a>', "glb_j.pro", "", "", " NAME: 	glb_j    PURPOSE:        Returns the zonal harmonics for each given globe descriptor.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	mass = glb_j(gbd)    ARGUMENTS:   INPUT: 	gbd:	 Array (nt) of any subclass of GLOBE descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN:        Array (nj,nt) of zonal harmonics associated with each given globe 	descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/glb/glb_j.html#glb_j", "glb_j", 'routine in <a href="nv/obj/glb/glb_j.html">glb_j.pro</a>', "glb_j.pro", "", "glb_j", "", "noeventgbd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/glb/glb_local_to_altaz.html", "glb_local_to_altaz.pro", '.pro file in <a href="nv/obj/glb/dir-overview.html">nv/obj/glb/ directory</a>', "glb_local_to_altaz.pro", "", "", " NAME: 	glb_local_to_altaz   PURPOSE:        Converts the given column vectors from the local coordinate        system to the altaz coordinate system.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	altaz_dir = glb_local_to_altaz(gbd, surf_pts, local_dir)    ARGUMENTS:   INPUT: 	gbd:	        Array (nt) of any subclass of GLOBE descriptors.  	body_pts:	Array (nv,3,nt) of column vectors in the body                        frame (representing points on the surface of                        the globe).         local_dir:      Array (3,nt) of column vectors in the local                        frame, giving the direction from each surf_pts.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (nv,3,nt) of column vectors in the altaz system.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/glb/glb_local_to_altaz.html#glb_local_to_altaz", "glb_local_to_altaz", 'routine in <a href="nv/obj/glb/glb_local_to_altaz.html">glb_local_to_altaz.pro</a>', "glb_local_to_altaz.pro", "", "glb_local_to_altaz", "", "gbdv_r", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/glb/glb_local_to_body.html", "glb_local_to_body.pro", '.pro file in <a href="nv/obj/glb/dir-overview.html">nv/obj/glb/ directory</a>', "glb_local_to_body.pro", "", "", " NAME: 	glb_local_to_body   PURPOSE:        Converts the given column vectors from the local coordinate        system to the body coordinate system.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	body_dir = glb_local_to_body(gbd, body_pts, local_dir)    ARGUMENTS:   INPUT: 	gbd:	        Array (nt) of any subclass of GLOBE descriptors.  	body_pts:	Array (nv,3,nt) of column vectors in the body                        frame (representing points on the surface of                        the globe).         local_dir:      Array (3,nt) of column vectors in the local                        system, giving the direction from each surface point.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (nv,3,nt) of column vectors in the body frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/glb/glb_local_to_body.html#glb_local_to_body", "glb_local_to_body", 'routine in <a href="nv/obj/glb/glb_local_to_body.html">glb_local_to_body.pro</a>', "glb_local_to_body.pro", "", "glb_local_to_body", "", "gbdvr", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/glb/glb_lora.html", "glb_lora.pro", '.pro file in <a href="nv/obj/glb/dir-overview.html">nv/obj/glb/ directory</a>', "glb_lora.pro", "", "", " NAME: 	glb_lora    PURPOSE: 	Returns the longitude of the first ellipsoid radius for each 	given globe descriptor.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	lora = glb_lora(gbd)    ARGUMENTS:   INPUT: 	gbd:	 Array (nt) of any subclass of GLOBE descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN:        Longitude of the first ellipsoid radius associated with each        given globe descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/glb/glb_lora.html#glb_lora", "glb_lora", 'routine in <a href="nv/obj/glb/glb_lora.html">glb_lora.pro</a>', "glb_lora.pro", "", "glb_lora", "", "noeventgbd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/glb/glb_lref.html", "glb_lref.pro", '.pro file in <a href="nv/obj/glb/dir-overview.html">nv/obj/glb/ directory</a>', "glb_lref.pro", "", "", " NAME: 	glb_lref    PURPOSE:        Returns the longitude system reference for each given globe        descriptor.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	lref = glb_lref(gbd)    ARGUMENTS:   INPUT: 	gbd:	 Array (nt) of any subclass of GLOBE descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN:        Longitude system reference associated with each given globe        descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/glb/glb_lref.html#glb_lref", "glb_lref", 'routine in <a href="nv/obj/glb/glb_lref.html">glb_lref.pro</a>', "glb_lref.pro", "", "glb_lref", "", "noeventgbd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/glb/glb_nj.html", "glb_nj.pro", '.pro file in <a href="nv/obj/glb/dir-overview.html">nv/obj/glb/ directory</a>', "glb_nj.pro", "", "", " NAME: 	glb_nj    PURPOSE: 	Returns an integer indicating the maximum number of zonal harmonics 	allowed in the 'j' field of the globe descriptor.  This number 	can be adjusted using the environment variable 'GLB_NJ'.  The default 	is 11.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	nj = glb_nj()    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: NONE     OUTPUT: NONE    ENVIRONMENT VARIABLES: 	GLB_NJ:		Sets the nj value.    RETURN: 	Current nj value.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/glb/glb_nj.html#glb_nj", "glb_nj", 'routine in <a href="nv/obj/glb/glb_nj.html">glb_nj.pro</a>', "glb_nj.pro", "", "glb_nj", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/glb_projected_resolution.html", "glb_projected_resolution.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "glb_projected_resolution.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/glb_projected_resolution.html#glb_projected_resolution", "glb_projected_resolution", 'routine in <a href="nv/obj/tools/glb_projected_resolution.html">glb_projected_resolution.pro</a>', "glb_projected_resolution.pro", "", "glb_projected_resolution", "", "minmaxrrgbdcdpscale", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/glb/glb_query.html", "glb_query.pro", '.pro file in <a href="nv/obj/glb/dir-overview.html">nv/obj/glb/ directory</a>', "glb_query.pro", "", "", " NAME: 	glb_query    PURPOSE: 	Returns the fields associated with a GLOBE object.  This is a 	convenient way of getting multiple fields in one call, and only a 	single event is generated.    CATEGORY: 	NV/OBJ/GLB    CALLING SEQUENCE: 	glb_query, gbd, <keywords>=<values>    ARGUMENTS:   INPUT: 	gbd:	GLOBE object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	GLOBE object fields to set.  	condition:	Structure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT object, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.  	cat:		If set, arrays from mulitple input objets are 			concatenated.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.  	noevent:	If set, no event is generated.    OUTPUT: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/glb/glb_query.html#glb_query", "glb_query", 'routine in <a href="nv/obj/glb/glb_query.html">glb_query.pro</a>', "glb_query.pro", "", "glb_query", "", "conditioncatnoeventxd@glb__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/glb/glb_radii.html", "glb_radii.pro", '.pro file in <a href="nv/obj/glb/dir-overview.html">nv/obj/glb/ directory</a>', "glb_radii.pro", "", "", " NAME: 	glb_radii    PURPOSE:        Returns the triaxial radii for each given globe descriptor.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	radii = glb_radii(gbd)    ARGUMENTS:   INPUT: 	gbd:	 Array (nt) of any subclass of GLOBE descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN:        Triaxial radii associated with each given globe descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/glb/glb_radii.html#glb_radii", "glb_radii", 'routine in <a href="nv/obj/glb/glb_radii.html">glb_radii.pro</a>', "glb_radii.pro", "", "glb_radii", "", "noeventgbd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/glb/glb_reflect.html", "glb_reflect.pro", '.pro file in <a href="nv/obj/glb/dir-overview.html">nv/obj/glb/ directory</a>', "glb_reflect.pro", "", "", " NAME: 	glb_reflect    PURPOSE: 	Computes the reflection of rays with GLOBE objects.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	int_pts = glb_reflect(gbd, v, r)    ARGUMENTS:   INPUT: 	gbd:	Array (nt) of any subclass of GLOBE descriptors.  	v:	Array (nv,3,nt) giving observer positions in the BODY frame.  	r:	Array (nv,3,nt) giving point positions in the BODY frame.  	epsilon:	Controls the precision of the iteration.  Default 			is 1d-3.  	niter:	Maximum number of iterations, default is 1000     OUTPUT: NONE    KEYWORDS:   INPUT: 	near:	If set, near-side reflections are computed.  This is the default.  	far: 	If set, far-side reflections are computed.    OUTPUT: NONE    RETURN: 	Array (2*nv,3,nt) of points in the BODY frame, where 	int_pts[0:nv-1,*,*] correspond to the near-side reflections 	and int_pts[nv:2*nv-1,*,1] correspond to the far side.  Zero 	vector is returned for points with no solution.    STATUS: 	Not well tested    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/glb/glb_reflect.html#glb_reflect", "glb_reflect", 'routine in <a href="nv/obj/glb/glb_reflect.html">glb_reflect.pro</a>', "glb_reflect.pro", "", "glb_reflect", "", "hitnearfarallvalidgbdvrepsilonniter", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/glb/glb_replicate.html", "glb_replicate.pro", '.pro file in <a href="nv/obj/glb/dir-overview.html">nv/obj/glb/ directory</a>', "glb_replicate.pro", "", "", " NAME: 	glb_replicate    PURPOSE: 	Replicates the given globe descriptor, producing an array of the given 	dimensions containing cloned versions of the input descriptor.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	new_gbd = cam_replicate(gbd, dim)    ARGUMENTS:   INPUT: 	gbd:	 One descriptor of any subclass of GLOBE descriptor  	dim:	 Dimensions of the result.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Array of the given dimensions containing cloned versions of the input 	globe descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/glb/glb_replicate.html#glb_replicate", "glb_replicate", 'routine in <a href="nv/obj/glb/glb_replicate.html">glb_replicate.pro</a>', "glb_replicate.pro", "", "glb_replicate", "", "gbddim", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/glb/glb_rref.html", "glb_rref.pro", '.pro file in <a href="nv/obj/glb/dir-overview.html">nv/obj/glb/ directory</a>', "glb_rref.pro", "", "", " NAME: 	glb_rref    PURPOSE:        Returns the reference radius for each given globe descriptor.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	mass = glb_rref(gbd)    ARGUMENTS:   INPUT: 	gbd:	 Array (nt) of any subclass of GLOBE descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN:        Array (nt) of reference radii associated with each given globe 	descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/glb/glb_rref.html#glb_rref", "glb_rref", 'routine in <a href="nv/obj/glb/glb_rref.html">glb_rref.pro</a>', "glb_rref.pro", "", "glb_rref", "", "noeventgbd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/glb/glb_set_j.html", "glb_set_j.pro", '.pro file in <a href="nv/obj/glb/dir-overview.html">nv/obj/glb/ directory</a>', "glb_set_j.pro", "", "", " NAME: 	glb_set_j    PURPOSE:        Replaces the zonal harmonics for each given globe descriptor.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	glb_set_j, gbd, j    ARGUMENTS:   INPUT: 	gbd:	 Array (nt) of any subclass of GLOBE descriptors.  	j:	 Array (nj,nt) of new zonal harmonics.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/glb/glb_set_j.html#glb_set_j", "glb_set_j", 'routine in <a href="nv/obj/glb/glb_set_j.html">glb_set_j.pro</a>', "glb_set_j.pro", "", "glb_set_j", "", "noeventgbdJ", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/glb/glb_set_lora.html", "glb_set_lora.pro", '.pro file in <a href="nv/obj/glb/dir-overview.html">nv/obj/glb/ directory</a>', "glb_set_lora.pro", "", "", " NAME: 	glb_set_lora    PURPOSE:        Replaces the longitude of the first ellipsoid radius for each        given globe descriptor.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	glb_set_lora, gbd, lora    ARGUMENTS:   INPUT: 	gbd:	 Array (nt) of any subclass of GLOBE descriptors.  	lora:	 Array (nt) of new longitude values of the first ellipsoid radius.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/glb/glb_set_lora.html#glb_set_lora", "glb_set_lora", 'routine in <a href="nv/obj/glb/glb_set_lora.html">glb_set_lora.pro</a>', "glb_set_lora.pro", "", "glb_set_lora", "", "noeventgbdlora", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/glb/glb_set_lref.html", "glb_set_lref.pro", '.pro file in <a href="nv/obj/glb/dir-overview.html">nv/obj/glb/ directory</a>', "glb_set_lref.pro", "", "", " NAME: 	glb_set_lref    PURPOSE:        Replaces the longitude system reference for each given globe        descriptor.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	glb_set_lref, gbd, lref    ARGUMENTS:   INPUT: 	gbd:	 Array (nt) of any subclass of GLOBE descriptors.  	lref:	 String array (nt) of new longitude system names.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/glb/glb_set_lref.html#glb_set_lref", "glb_set_lref", 'routine in <a href="nv/obj/glb/glb_set_lref.html">glb_set_lref.pro</a>', "glb_set_lref.pro", "", "glb_set_lref", "", "noeventgbdlref", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/glb/glb_set_radii.html", "glb_set_radii.pro", '.pro file in <a href="nv/obj/glb/dir-overview.html">nv/obj/glb/ directory</a>', "glb_set_radii.pro", "", "", " NAME: 	glb_set_radii    PURPOSE:        Replaces the triaxial radii for each given globe descriptor.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	glb_set_radii, gbd, radii    ARGUMENTS:   INPUT: 	gbd:	 Array (nt) of any subclass of GLOBE descriptors.  	radii:	 Array (3,nt) of new triaxial radii.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/glb/glb_set_radii.html#glb_set_radii", "glb_set_radii", 'routine in <a href="nv/obj/glb/glb_set_radii.html">glb_set_radii.pro</a>', "glb_set_radii.pro", "", "glb_set_radii", "", "noeventgbdradii", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/glb/glb_set_rref.html", "glb_set_rref.pro", '.pro file in <a href="nv/obj/glb/dir-overview.html">nv/obj/glb/ directory</a>', "glb_set_rref.pro", "", "", " NAME: 	glb_set_rref    PURPOSE:        Replaces the reference radius for each given globe descriptor.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	glb_set_rref, gbd, rref    ARGUMENTS:   INPUT: 	gbd:	 Array (nt) of any subclass of GLOBE descriptors.  	rref:	 String array (nt) of new reference radii.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/glb/glb_set_rref.html#glb_set_rref", "glb_set_rref", 'routine in <a href="nv/obj/glb/glb_set_rref.html">glb_set_rref.pro</a>', "glb_set_rref.pro", "", "glb_set_rref", "", "noeventgbdrref", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/glb/glb_set_type.html", "glb_set_type.pro", '.pro file in <a href="nv/obj/glb/dir-overview.html">nv/obj/glb/ directory</a>', "glb_set_type.pro", "", "", " NAME: 	glb_set_type    PURPOSE:        Replaces the type string for each given globe descriptor.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	glb_set_type, gbd, type    ARGUMENTS:   INPUT: 	gbd:	 Array (nt) of any subclass of GLOBE descriptors.  	type:	 String array (nt) of new type strings.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/glb/glb_set_type.html#glb_set_type", "glb_set_type", 'routine in <a href="nv/obj/glb/glb_set_type.html">glb_set_type.pro</a>', "glb_set_type.pro", "", "glb_set_type", "", "noeventgbdtype", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/glb/glb_sub_point.html", "glb_sub_point.pro", '.pro file in <a href="nv/obj/glb/dir-overview.html">nv/obj/glb/ directory</a>', "glb_sub_point.pro", "", "", " NAME: 	glb_sub_point    PURPOSE: 	Computes the planetocentric sub-point in body coordinates.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	n = glb_sub_point(gbd, r)    ARGUMENTS:   INPUT: 	gbd:	Array (nt) of any subclass of GLOBE descriptors.  	r:	Array (nv,3,nt) of points in the BODY frame.     OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (nv,3,nt) points in the BODY frame that lie on the surface 	of each globe, directly 'beneath' r, i.e., such that each 	planetocentric surface normal points at each r.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/glb/glb_sub_point.html#glb_sub_point", "glb_sub_point", 'routine in <a href="nv/obj/glb/glb_sub_point.html">glb_sub_point.pro</a>', "glb_sub_point.pro", "", "glb_sub_point", "", "noeventgbdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/glb/glb_sub_point_graphic.html", "glb_sub_point_graphic.pro", '.pro file in <a href="nv/obj/glb/dir-overview.html">nv/obj/glb/ directory</a>', "glb_sub_point_graphic.pro", "", "", " NAME: 	glb_sub_point_graphic    PURPOSE: 	Computes the planetographic sub-point in body coordinates.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	n = glb_sub_point_graphic(gbd, r)    ARGUMENTS:   INPUT: 	gbd:	Array (nt) of any subclass of GLOBE descriptors.  	r:	Array (nv,3,nt) of points in the BODY frame.     OUTPUT: NONE    KEYWORDS:   INPUT: 	epsilon:	Convergence criterion for angular deviation from normal. 			Default is 1d-8.  	niter:		Maximum number of iterations.  Default is 5000.    OUTPUT: NONE    RETURN: 	Array (nv,3,nt) points in the BODY frame that lie on the surface 	of each globe, directly 'beneath' r, i.e., such that each 	planetographic surface normal points at each r.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:		Spitale, 1/1998  	Adapted by:		Spitale, 5/2016 	Added iteration count:	Moretto, 8/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/glb/glb_sub_point_graphic.html#glb_sub_point_graphic", "glb_sub_point_graphic", 'routine in <a href="nv/obj/glb/glb_sub_point_graphic.html">glb_sub_point_graphic.pro</a>', "glb_sub_point_graphic.pro", "", "glb_sub_point_graphic", "", "noeventepsilonnitergbdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/glb/glb_type.html", "glb_type.pro", '.pro file in <a href="nv/obj/glb/dir-overview.html">nv/obj/glb/ directory</a>', "glb_type.pro", "", "", " NAME: 	glb_type    PURPOSE:        Returns the type string for each given globe descriptor.    CATEGORY: 	NV/LIB/GLB    CALLING SEQUENCE: 	type = glb_type(gbd)    ARGUMENTS:   INPUT: 	gbd:	 Array (nt) of any subclass of GLOBE descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN:        Array (nt) of type strings associated with each given globe 	descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/glb/glb_type.html#glb_type", "glb_type", 'routine in <a href="nv/obj/glb/glb_type.html">glb_type.pro</a>', "glb_type.pro", "", "glb_type", "", "noeventgbd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/gll/ssi/gll_cmat_to_orient_ssi.html", "gll_cmat_to_orient_ssi.pro", '.pro file in <a href="config/gll/ssi/dir-overview.html">config/gll/ssi/ directory</a>', "gll_cmat_to_orient_ssi.pro", "", "", " NAME: 	gll_cmat_to_orient_ssi    PURPOSE: 	Converts Galileo C matrix to a OMINAS camera orientation matrix.    CATEGORY: 	NV/CONFIG    CALLING SEQUENCE: 	result = gll_cmat_to_orient(cmat)    ARGUMENTS:   INPUT: 	cmat:	Galileo C matrix    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	NONE    OUTPUT: 	NONE    RETURN: 	OMINAS camera orientation matrix.    STATUS: 	Complete    SEE ALSO: 	gll_orient_to_cmat    MODIFICATION HISTORY:  	Written by:	Spitale, 1/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/gll/ssi/gll_cmat_to_orient_ssi.html#gll_cmat_to_orient_ssi", "gll_cmat_to_orient_ssi", 'routine in <a href="config/gll/ssi/gll_cmat_to_orient_ssi.html">gll_cmat_to_orient_ssi.pro</a>', "gll_cmat_to_orient_ssi.pro", "", "gll_cmat_to_orient_ssi", "", "cmat", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/gll/ssi/gll_format_comment.html", "gll_format_comment.pro", '.pro file in <a href="config/gll/ssi/dir-overview.html">config/gll/ssi/ directory</a>', "gll_format_comment.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/gll/ssi/gll_format_comment.html#gll_format_comment", "gll_format_comment", 'routine in <a href="config/gll/ssi/gll_format_comment.html">gll_format_comment.pro</a>', "gll_format_comment.pro", "", "gll_format_comment", "", "od", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/gll/ssi/gll_from_ominas.html", "gll_from_ominas.pro", '.pro file in <a href="config/gll/ssi/dir-overview.html">config/gll/ssi/ directory</a>', "gll_from_ominas.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/gll/ssi/gll_from_ominas.html#gll_from_ominas", "gll_from_ominas", 'routine in <a href="config/gll/ssi/gll_from_ominas.html">gll_from_ominas.pro</a>', "gll_from_ominas.pro", "", "gll_from_ominas", "", "odorient_fn", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/gll/ssi/gll_orient_to_cmat_ssi.html", "gll_orient_to_cmat_ssi.pro", '.pro file in <a href="config/gll/ssi/dir-overview.html">config/gll/ssi/ directory</a>', "gll_orient_to_cmat_ssi.pro", "", "", " NAME: 	gll_orient_to_cmat_ssi    PURPOSE: 	Converts Galileo C matrix to a OMINAS camera orientation matrix.    CATEGORY: 	NV/CONFIG    CALLING SEQUENCE: 	result = gll_orient_to_cmat(cmat)    ARGUMENTS:   INPUT: 	orient:		OMINAS camera orientation matrix.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	NONE    OUTPUT: 	NONE    RETURN: 	Galileo C matrix.    STATUS: 	Complete    SEE ALSO: 	gll_cmat_to_orient    MODIFICATION HISTORY:  	Written by:	Spitale, 1/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/gll/ssi/gll_orient_to_cmat_ssi.html#gll_orient_to_cmat_ssi", "gll_orient_to_cmat_ssi", 'routine in <a href="config/gll/ssi/gll_orient_to_cmat_ssi.html">gll_orient_to_cmat_ssi.pro</a>', "gll_orient_to_cmat_ssi.pro", "", "gll_orient_to_cmat_ssi", "", "orient", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/gll/ssi/gll_psf.html", "gll_psf.pro", '.pro file in <a href="config/gll/ssi/dir-overview.html">config/gll/ssi/ directory</a>', "gll_psf.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/gll/ssi/gll_psf.html#gll_psf", "gll_psf", 'routine in <a href="config/gll/ssi/gll_psf.html">gll_psf.pro</a>', "gll_psf.pro", "", "gll_psf", "", "cdxy", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/gll/gll_spice_fk_detect.html", "gll_spice_fk_detect.pro", '.pro file in <a href="config/gll/dir-overview.html">config/gll/ directory</a>', "gll_spice_fk_detect.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/gll/gll_spice_fk_detect.html#gll_spice_fk_detect", "gll_spice_fk_detect", 'routine in <a href="config/gll/gll_spice_fk_detect.html">gll_spice_fk_detect.pro</a>', "gll_spice_fk_detect.pro", "", "gll_spice_fk_detect", "", "sctimestrictallddkpath", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/gll/gll_spice_ik_detect.html", "gll_spice_ik_detect.pro", '.pro file in <a href="config/gll/dir-overview.html">config/gll/ directory</a>', "gll_spice_ik_detect.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/gll/gll_spice_ik_detect.html#gll_spice_ik_detect", "gll_spice_ik_detect", 'routine in <a href="config/gll/gll_spice_ik_detect.html">gll_spice_ik_detect.pro</a>', "gll_spice_ik_detect.pro", "", "gll_spice_ik_detect", "", "sctimestrictallddkpath", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/gll/ssi/gll_spice_input.html", "gll_spice_input.pro", '.pro file in <a href="config/gll/ssi/dir-overview.html">config/gll/ssi/ directory</a>', "gll_spice_input.pro", "", "", " NAME: 	gll_spice_input    PURPOSE: 	NAIF/SPICE input translator for Galileo.    CATEGORY: 	NV/CONFIG    CALLING SEQUENCE: 	result = gll_spice_input(dd, keyword)    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	keyword:	String giving the name of the translator quantity.     OUTPUT: 	NONE    KEYWORDS:   INPUT: 	key1:		Camera descriptor.    OUTPUT: 	status:		Zero if valid data is returned.     TRANSLATOR KEYWORDS: 	ref:		Name of the reference frame for the output quantities. 			Default is 'j2000'.  	j2000:		/j2000 is equivalent to specifying ref=j2000.  	b1950:		/b1950 is equivalent to specifying ref=b1950.  	klist:		Name of a file giving a list of SPICE kernels to use. 			If no path is included, the path is taken from the 			NV_SPICE_KER environment variable.  	ck_in:		List of input C kernel files to use.  List must be 			delineated by semimcolons with no space.  The kernel 			list file is still used, but these kernels take 			precedence.  Entries in this list may be file 			specification strings.  	planets:	List of planets to for which to request ephemeris. 			Must be delineated by semicolons with no space.  	reload:		If set, new kernels are loaded, as specified by the 			klist and ck_in keywords.    RETURN: 	Data associated with the requested keyword.    STATUS: 	Complete    SEE ALSO: 	gll_spice_output    MODIFICATION HISTORY:  	Written by:	Spitale, 10/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/gll/ssi/gll_spice_input.html#gll_spice_parse_labels", "gll_spice_parse_labels", 'routine in <a href="config/gll/ssi/gll_spice_input.html">gll_spice_input.pro</a>', "gll_spice_input.pro", "", "gll_spice_parse_labels", "", "exposuresizefiltersoaxisscaletargetdd_time", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/gll/ssi/gll_spice_input.html#gll_spice_cameras", "gll_spice_cameras", 'routine in <a href="config/gll/ssi/gll_spice_input.html">gll_spice_input.pro</a>', "gll_spice_input.pro", "", "gll_spice_cameras", "", "posconstantsn_objdimstatustimeorientobsddref", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/gll/ssi/gll_spice_input.html#gll_spice_planets", "gll_spice_planets", 'routine in <a href="config/gll/ssi/gll_spice_input.html">gll_spice_input.pro</a>', "gll_spice_input.pro", "", "gll_spice_planets", "", "timeplanetsn_objdimstatustarg_listconstantsobsddref", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/gll/ssi/gll_spice_input.html#gll_spice_sun", "gll_spice_sun", 'routine in <a href="config/gll/ssi/gll_spice_input.html">gll_spice_input.pro</a>', "gll_spice_input.pro", "", "gll_spice_sun", "", "n_objdimstatustimeconstantsobsddref", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/gll/ssi/gll_spice_input.html#gll_spice_input", "gll_spice_input", 'routine in <a href="config/gll/ssi/gll_spice_input.html">gll_spice_input.pro</a>', "gll_spice_input.pro", "", "gll_spice_input", "", "valuesstatusddkeyword@nv_trs_keywords_include.pro", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/gll/ssi/gll_spice_output.html", "gll_spice_output.pro", '.pro file in <a href="config/gll/ssi/dir-overview.html">config/gll/ssi/ directory</a>', "gll_spice_output.pro", "", "", " NAME: 	gll_spice_output    PURPOSE: 	NAIF/SPICE output translator for Galileo.    CATEGORY: 	NV/CONFIG    CALLING SEQUENCE(only to be called by nv_xx_value): 	gll_spice_output, dd, keyword, value    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	keyword:	String giving the name of the translator quantity.  	value:		The data to write.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	key1:		Camera descriptor.    OUTPUT: 	status:		Zero unless a problem occurs.     TRANSLATOR KEYWORDS: 	ref:		Name of the reference frame for the input quantities. 			Default is 'j2000'.  	j2000:		/j2000 is equivalent to specifying ref=j2000.  	b1950:		/b1950 is equivalent to specifying ref=b1950.  	ck_out:		String giving the name of the new C-kernel to write.    STATUS: 	Complete    SEE ALSO: 	gll_spice_input    MODIFICATION HISTORY:  	Written by:	Spitale, 10/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/gll/ssi/gll_spice_output.html#gll_spice_write_cameras", "gll_spice_write_cameras", 'routine in <a href="config/gll/ssi/gll_spice_output.html">gll_spice_output.pro</a>', "gll_spice_output.pro", "", "gll_spice_write_cameras", "", "reloadn_objdimstatusddvaluerefck_file", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/gll/ssi/gll_spice_output.html#gll_spice_output", "gll_spice_output", 'routine in <a href="config/gll/ssi/gll_spice_output.html">gll_spice_output.pro</a>', "gll_spice_output.pro", "", "gll_spice_output", "", "statusddkeywordvalue@nv_trs_keywords_include.pro", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/gll/gll_spice_sc.html", "gll_spice_sc.pro", '.pro file in <a href="config/gll/dir-overview.html">config/gll/ directory</a>', "gll_spice_sc.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/gll/gll_spice_sc.html#gll_spice_sc", "gll_spice_sc", 'routine in <a href="config/gll/gll_spice_sc.html">gll_spice_sc.pro</a>', "gll_spice_sc.pro", "", "gll_spice_sc", "", "dd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/gll/gll_spice_sck_detect.html", "gll_spice_sck_detect.pro", '.pro file in <a href="config/gll/dir-overview.html">config/gll/ directory</a>', "gll_spice_sck_detect.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/gll/gll_spice_sck_detect.html#gll_spice_sck_detect", "gll_spice_sck_detect", 'routine in <a href="config/gll/gll_spice_sck_detect.html">gll_spice_sck_detect.pro</a>', "gll_spice_sck_detect.pro", "", "gll_spice_sck_detect", "", "sctimestrictallddkpath", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/gll/gll_spice_sct2et.html", "gll_spice_sct2et.pro", '.pro file in <a href="config/gll/dir-overview.html">config/gll/ directory</a>', "gll_spice_sct2et.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/gll/gll_spice_sct2et.html#gll_spice_sct2et", "gll_spice_sct2et", 'routine in <a href="config/gll/gll_spice_sct2et.html">gll_spice_sct2et.pro</a>', "gll_spice_sct2et.pro", "", "gll_spice_sct2et", "", "ddtimes", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/gll/gll_spice_time.html", "gll_spice_time.pro", '.pro file in <a href="config/gll/dir-overview.html">config/gll/ directory</a>', "gll_spice_time.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/gll/gll_spice_time.html#gll_spice_time", "gll_spice_time", 'routine in <a href="config/gll/gll_spice_time.html">gll_spice_time.pro</a>', "gll_spice_time.pro", "", "gll_spice_time", "", "dtstringlabel", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/gll/ssi/gll_to_ominas.html", "gll_to_ominas.pro", '.pro file in <a href="config/gll/ssi/dir-overview.html">config/gll/ssi/ directory</a>', "gll_to_ominas.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/gll/ssi/gll_to_ominas.html#gll_to_ominas", "gll_to_ominas", 'routine in <a href="config/gll/ssi/gll_to_ominas.html">gll_to_ominas.pro</a>', "gll_to_ominas.pro", "", "gll_to_ominas", "", "odorient_fn", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/composite/globe_to_image.html", "globe_to_image.pro", '.pro file in <a href="nv/obj/tools/composite/dir-overview.html">nv/obj/tools/composite/ directory</a>', "globe_to_image.pro", "", "", " NAME:        globe_to_image    PURPOSE:        Transforms points in body globe coordinates to image coordinates.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = globe_to_image(cd, gbd, p)    ARGUMENTS:   INPUT: 	cd:	Array of nt Camera or map descriptor  	gbx:	Array of nt Object descriptor (of type GLOBE)  	p:	Array (nv x 3 x nt) of globe points    OUTPUT: 	body_pts:	Body coordinates of output points.    RETURN:        Array (2 x nv x nt) of image points.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale;  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/composite/globe_to_image.html#globe_to_image", "globe_to_image", 'routine in <a href="nv/obj/tools/composite/globe_to_image.html">globe_to_image.pro</a>', "globe_to_image.pro", "", "globe_to_image", "", "body_ptsvalidcdgbxp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/composite/globe_to_map.html", "globe_to_map.pro", '.pro file in <a href="nv/obj/tools/composite/dir-overview.html">nv/obj/tools/composite/ directory</a>', "globe_to_map.pro", "", "", " NAME:        globe_to_map    PURPOSE:        Transforms points in globe coordinates to map coordinates.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = globe_to_map(md, gbx, globe_pts)    ARGUMENTS:   INPUT: 	md:	Array of nt map descriptor.  	gbx:	Array of nt globe descriptor.  	globe_pts:	Array (nv x 3 x nt) of globe points.    OUTPUT:        NONE   KEYWORDS:    INPUT: NONE     OUTPUT: NONE    RETURN:        Array (2 x nv x nt) of map coordinates.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/composite/globe_to_map.html#globe_to_map", "globe_to_map", 'routine in <a href="nv/obj/tools/composite/globe_to_map.html">globe_to_map.pro</a>', "globe_to_map.pro", "", "globe_to_map", "", "mdgbxglobe_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/grim/interface/gr_draw.html", "gr_draw.pro", '.pro file in <a href="nv/grim/interface/dir-overview.html">nv/grim/interface/ directory</a>', "gr_draw.pro", "", "", " NAME: 	gr_    PURPOSE: 	xx    CATEGORY: 	NV/GR    CALLING SEQUENCE: 	result = xx(xx, xx) 	xx, xx, xx    ARGUMENTS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    KEYWORDS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    ENVIRONMENT VARIABLES: 	xx:	xx  	xx:	xx    RETURN: 	xx    COMMON BLOCKS: 	xx:	xx  	xx:	xx    SIDE EFFECTS: 	xx    RESTRICTIONS: 	xx    PROCEDURE: 	xx    EXAMPLE: 	xx    STATUS: 	xx    SEE ALSO: 	xx, xx, xx    MODIFICATION HISTORY:  	Written by:	xx, xx/xx/xxxx   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/grim/interface/gr_draw.html#gr_draw", "gr_draw", 'routine in <a href="nv/grim/interface/gr_draw.html">gr_draw.pro</a>', "gr_draw.pro", "", "gr_draw", "", "gdcdpdrdsdardstdsundodpsymsymsizecolortagpngrnumpp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/grim/tools/gr_lsqtool.html", "gr_lsqtool.pro", '.pro file in <a href="nv/grim/tools/dir-overview.html">nv/grim/tools/ directory</a>', "gr_lsqtool.pro", "", "", " NAME: 	gr_lsqtool    DESCRIPTION: 	Graphical least-squares navigation tool.    CALLING SEQUENCE:  	gr_lsqtool    ARGUMENTS:   INPUT: NONE     OUTPUT: NONE    KEYWORDS:   INPUT: NONE     OUTPUT: NONE    LAYOUT: 	The gr_lsqtool layout consists of the following items:  	 Scan width: 		Width if the scan about the model points.  	 Edge proximity: 		Points closer than this to the edge of the image are not 		scanned.  	 Min correlation: 		Miniumum acceptable correlation coefficient in the scan.  	 Max correlation: 		Maxiumum acceptable correlation coefficient in the scan.  	Scan button: 		Scans the image according to the current widget settings. 		The resulting points are entered as user points in the 		appropriate GRIM widget.  	Fix buttons: 		Select fit parameters to fix.  x and y are the image offsets 		in the repective direction, theta is the rotation about the 		center given by the parameter center_ptdp.  If center_ptdp 		contains no points, then theta is automatically fixed.  	Fit button: 		Performs a simultaneous linear least-square fit to all of the 		objects that have been scanned.  This button causes the given 		camera descriptor to be modified.  	Close button 		Causes gr_lsqtool to exit.     OPERATION:    gr_lsqtool allows the user to produce a subpixel  pointing correction    by fitting model points to those observed in the image.  When the     Scan  button is pressed, an image scan is performed for each active    array in the primary grim window.  Limbs, terminators, and rings are    scanned as edges, while stars and planet centers are scanned as point    sources.  Scans may also be performed individually on different objects.    The  Scan Width  entry specifies the width of the scan about each active    array.  The  Edge Proximity  field specifies the closest that a scan    will come to the image edge.  The correlation fields give the    correlation criterion for accepting scanned points.     After you have scanned your points, you can use the  Fit  button to    perform a least-square fit between each active object and the    corresponding scanned points.  The Fit statistics are displayed in    the text window at the bottom.  You can specify which parameters to    fix using the  Fix  buttons.     Because this fit is linear, it requires the initial guess to be close    to the actual solution.  You may need to iterate to converge to a    good solution; you must rescan your points each time, however.    STATUS: 	Incomplete.    MODIFICATION HISTORY:  	Written by:	Spitale 7/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_lsqtool.html#lsq_descriptor__define", "lsq_descriptor__define", 'routine in <a href="nv/grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "lsq_descriptor__define", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_lsqtool.html#grlsq_print", "grlsq_print", 'routine in <a href="nv/grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "grlsq_print", "", "cleardatas", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_lsqtool.html#grlsq_descriptor", "grlsq_descriptor", 'routine in <a href="nv/grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "grlsq_descriptor", "", "minmaxwidthedgefixscannedalgorithmmodel_fninvert", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_lsqtool.html#grlsq_parse_entry", "grlsq_parse_entry", 'routine in <a href="nv/grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "grlsq_parse_entry", "", "dropidstagstag", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_lsqtool.html#grlsq_set_entry", "grlsq_set_entry", 'routine in <a href="nv/grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "grlsq_set_entry", "", "dropsensitivebuttonidstagstagvalue", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_lsqtool.html#grlsq_form_to_lsqd", "grlsq_form_to_lsqd", 'routine in <a href="nv/grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "grlsq_form_to_lsqd", "", "objectdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_lsqtool.html#grlsq_lsqd_to_form", "grlsq_lsqd_to_form", 'routine in <a href="nv/grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "grlsq_lsqd_to_form", "", "datalsqd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_lsqtool.html#grlsq_get_ptdps", "grlsq_get_ptdps", 'routine in <a href="nv/grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "grlsq_get_ptdps", "", "pdsrdssdsgrim_datadatalsqd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_lsqtool.html#grlsq_invert_model", "grlsq_invert_model", 'routine in <a href="nv/grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "grlsq_invert_model", "", "modelmzero", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_lsqtool.html#grlsq_draw_models", "grlsq_draw_models", 'routine in <a href="nv/grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "grlsq_draw_models", "", "datamodel_pmzerotag", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_lsqtool.html#grlsq_edge_model_psf_ring", "grlsq_edge_model_psf_ring", 'routine in <a href="nv/grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "grlsq_edge_model_psf_ring", "", "zerogddesc", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_lsqtool.html#grlsq_edge_model_nav_ring", "grlsq_edge_model_nav_ring", 'routine in <a href="nv/grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "grlsq_edge_model_nav_ring", "", "zerogddesc", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_lsqtool.html#grlsq_edge_model_nav_limb", "grlsq_edge_model_nav_limb", 'routine in <a href="nv/grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "grlsq_edge_model_nav_limb", "", "zerogddesc", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_lsqtool.html#grlsq_edge_model_atan", "grlsq_edge_model_atan", 'routine in <a href="nv/grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "grlsq_edge_model_atan", "", "zerogddesc", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_lsqtool.html#grlsq_get_model_type", "grlsq_get_model_type", 'routine in <a href="nv/grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "grlsq_get_model_type", "", "_tag", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_lsqtool.html#grlsq_get_model_fn", "grlsq_get_model_fn", 'routine in <a href="nv/grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "grlsq_get_model_fn", "", "lsqdtag", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_lsqtool.html#grlsq_get_inner", "grlsq_get_inner", 'routine in <a href="nv/grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "grlsq_get_inner", "", "cdrdtag", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_lsqtool.html#grlsq_get_model", "grlsq_get_model", 'routine in <a href="nv/grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "grlsq_get_model", "", "cdrdlsqdtaglzero", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_lsqtool.html#grlsq_make_tag", "grlsq_make_tag", 'routine in <a href="nv/grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "grlsq_make_tag", "", "ptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_lsqtool.html#grlsq_scan", "grlsq_scan", 'routine in <a href="nv/grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "grlsq_scan", "", "nocreatestatusnoscanlsqdgrim_datadata", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_lsqtool.html#grlsq_fit", "grlsq_fit", 'routine in <a href="nv/grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "grlsq_fit", "", "statusgrim_datadatalsqd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_lsqtool.html#gr_lsqtool_event", "gr_lsqtool_event", 'routine in <a href="nv/grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "gr_lsqtool_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_lsqtool.html#grlsq_primary_notify", "grlsq_primary_notify", 'routine in <a href="nv/grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "grlsq_primary_notify", "", "init_data_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_lsqtool.html#grlsq_cleanup", "grlsq_cleanup", 'routine in <a href="nv/grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "grlsq_cleanup", "", "base", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_lsqtool.html#gr_lsqtool", "gr_lsqtool", 'routine in <a href="nv/grim/tools/gr_lsqtool.html">gr_lsqtool.pro</a>', "gr_lsqtool.pro", "", "gr_lsqtool", "", "top", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/grim/tools/gr_maptool.html", "gr_maptool.pro", '.pro file in <a href="nv/grim/tools/dir-overview.html">nv/grim/tools/ directory</a>', "gr_maptool.pro", "", "", " NAME: 	gr_maptool    DESCRIPTION: 	Graphical map projection tool.    CALLING SEQUENCE:  	gr_maptool    ARGUMENTS:   INPUT: NONE     OUTPUT: NONE    KEYWORDS:   INPUT: NONE     OUTPUT: NONE    LAYOUT: 	The gr_maptool layout consists of the following items:  	 Map projection control: 		A map projection is selected using the droplist and 		the map parameters are input using the text widgets below. 		Angles are in radians.  	'Ok' button: 		Creates the map projection described by the current widget 		settings and exits.  	'Apply' button: 		Creates the map projection described by the current widget 		settings without exiting.  	'Cancel' button 		Exits with no map projection.     OPERATION: 	gr_ maptool allows the user to create map projections of images 	using a simple graphical interface.  It is most easily run from within 	GRIM, but may be run directly from the command line as well.    STATUS: 	Incomplete.    MODIFICATION HISTORY:  	Written by:	Spitale 7/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_maptool.html#grmt_get_md", "grmt_get_md", 'routine in <a href="nv/grim/tools/gr_maptool.html">gr_maptool.pro</a>', "gr_maptool.pro", "", "grmt_get_md", "", "indexdatatype", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_maptool.html#grmt_create_map", "grmt_create_map", 'routine in <a href="nv/grim/tools/gr_maptool.html">gr_maptool.pro</a>', "gr_maptool.pro", "", "grmt_create_map", "", "datamd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_maptool.html#grmt_parse_entry", "grmt_parse_entry", 'routine in <a href="nv/grim/tools/gr_maptool.html">gr_maptool.pro</a>', "gr_maptool.pro", "", "grmt_parse_entry", "", "dropidstagstag", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_maptool.html#grmt_set_entry", "grmt_set_entry", 'routine in <a href="nv/grim/tools/gr_maptool.html">gr_maptool.pro</a>', "gr_maptool.pro", "", "grmt_set_entry", "", "dropidstagstagvalue", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_maptool.html#grmt_form_to_md", "grmt_form_to_md", 'routine in <a href="nv/grim/tools/gr_maptool.html">gr_maptool.pro</a>', "gr_maptool.pro", "", "grmt_form_to_md", "", "typedata", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_maptool.html#grmt_md_to_form", "grmt_md_to_form", 'routine in <a href="nv/grim/tools/gr_maptool.html">gr_maptool.pro</a>', "gr_maptool.pro", "", "grmt_md_to_form", "", "datamd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_maptool.html#grmt_cleanup", "grmt_cleanup", 'routine in <a href="nv/grim/tools/gr_maptool.html">gr_maptool.pro</a>', "gr_maptool.pro", "", "grmt_cleanup", "", "base", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_maptool.html#grmt_refresh_callback", "grmt_refresh_callback", 'routine in <a href="nv/grim/tools/gr_maptool.html">gr_maptool.pro</a>', "gr_maptool.pro", "", "grmt_refresh_callback", "", "data_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_maptool.html#gr_maptool_event", "gr_maptool_event", 'routine in <a href="nv/grim/tools/gr_maptool.html">gr_maptool.pro</a>', "gr_maptool.pro", "", "gr_maptool_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_maptool.html#gr_maptool", "gr_maptool", 'routine in <a href="nv/grim/tools/gr_maptool.html">gr_maptool.pro</a>', "gr_maptool.pro", "", "gr_maptool", "", "order", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/grim/tools/gr_phttool.html", "gr_phttool.pro", '.pro file in <a href="nv/grim/tools/dir-overview.html">nv/grim/tools/ directory</a>', "gr_phttool.pro", "", "", " NAME: 	gr_phttool    DESCRIPTION: 	Graphical photometric correction tool.    CALLING SEQUENCE:  	gr_phttool    ARGUMENTS:   INPUT: NONE     OUTPUT: NONE    KEYWORDS:   INPUT: NONE     OUTPUT: NONE    ENVIRONMENT VARIABLES: 	GR_PHT_DIR:	Sets the directory in which to find the photometric 			functions.    LAYOUT: 	The gr_phttool layout consists of the following items:  	 Reflectance function controls: 		A reflectance function is selected using the droplist and 		the relevant parameters (whose purpose depend on the specific 		function) are input using the text widgets below.  	 Phase function controls: 		A phase function is selected using the droplist and 		the relevant parameters (whose purpose depend on the specific 		function) are input using the text widgets below.  	   Reflectance and phase functions are determined by looking for any 	   complied function whose name starts with 'pht_refl_' or 'pht_phase', 	   or any routines in the directory pointed to by the environment variable 	   GR_PHT_DIR. The function lists may be updated using the corresponding 	   'Refresh' button.  The calling sequences are as follows:  	   refl_corr = refl_fn(mu, mu0, refl_parm) 	   phase_corr = phase_fn(g, phase_parm)  	   where the photometric arguments are all cosines, and the *_parm 	   arguments come from the corresponding input text widgets.   	'Ok' button: 		Applies the photometric correction described by the current 		widget settings and exits.  	'Apply' button: 		Applies the photometric correction described by the current 		widget settings without exiting.  	'Apply All' button: 		Applies the photometric correction described by the current 		widget settings to all planes of the primary grim window for 		which outline points have been activated.  	'Cancel' button 		Exits with no photometric correction.     OPERATION: 	gr_phttool allows the user to apply photometric corrections to images 	using a simple graphical interface.  Corrections are applied to data 	within any active limb points.    STATUS: 	Incomplete.    MODIFICATION HISTORY:  	Written by:	Spitale 7/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_phttool.html#pht_descriptor__define", "pht_descriptor__define", 'routine in <a href="nv/grim/tools/gr_phttool.html">gr_phttool.pro</a>', "gr_phttool.pro", "", "pht_descriptor__define", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_phttool.html#grpht_get_prefix", "grpht_get_prefix", 'routine in <a href="nv/grim/tools/gr_phttool.html">gr_phttool.pro</a>', "gr_phttool.pro", "", "grpht_get_prefix", "", "type", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_phttool.html#grpht_descriptor", "grpht_descriptor", 'routine in <a href="nv/grim/tools/gr_phttool.html">gr_phttool.pro</a>', "gr_phttool.pro", "", "grpht_descriptor", "", "refl_fnphase_fnrefl_parmphase_parmn_refl_parmn_phase_parm", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_phttool.html#grpht_get_phtd", "grpht_get_phtd", 'routine in <a href="nv/grim/tools/gr_phttool.html">gr_phttool.pro</a>', "gr_phttool.pro", "", "grpht_get_phtd", "", "indexdatarefl_fn", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_phttool.html#grpht_apply_correction", "grpht_apply_correction", 'routine in <a href="nv/grim/tools/gr_phttool.html">gr_phttool.pro</a>', "gr_phttool.pro", "", "grpht_apply_correction", "", "dataphtdddcdpdsundoutline_ptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_phttool.html#grpht_apply_correction_primary", "grpht_apply_correction_primary", 'routine in <a href="nv/grim/tools/gr_phttool.html">gr_phttool.pro</a>', "gr_phttool.pro", "", "grpht_apply_correction_primary", "", "grim_datadataphtd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_phttool.html#grpht_apply_correction_all", "grpht_apply_correction_all", 'routine in <a href="nv/grim/tools/gr_phttool.html">gr_phttool.pro</a>', "gr_phttool.pro", "", "grpht_apply_correction_all", "", "grim_datadataphtd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_phttool.html#grpht_parse_entry", "grpht_parse_entry", 'routine in <a href="nv/grim/tools/gr_phttool.html">gr_phttool.pro</a>', "gr_phttool.pro", "", "grpht_parse_entry", "", "nulldropidstagstag", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_phttool.html#grpht_set_entry", "grpht_set_entry", 'routine in <a href="nv/grim/tools/gr_phttool.html">gr_phttool.pro</a>', "gr_phttool.pro", "", "grpht_set_entry", "", "dropidstagstagvalue", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_phttool.html#grpht_form_to_phtd", "grpht_form_to_phtd", 'routine in <a href="nv/grim/tools/gr_phttool.html">gr_phttool.pro</a>', "gr_phttool.pro", "", "grpht_form_to_phtd", "", "refl_fndata", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_phttool.html#grpht_get_functions", "grpht_get_functions", 'routine in <a href="nv/grim/tools/gr_phttool.html">gr_phttool.pro</a>', "gr_phttool.pro", "", "grpht_get_functions", "", "defaulttype", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_phttool.html#grpht_refresh_fn", "grpht_refresh_fn", 'routine in <a href="nv/grim/tools/gr_phttool.html">gr_phttool.pro</a>', "gr_phttool.pro", "", "grpht_refresh_fn", "", "datatype", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_phttool.html#grpht_phtd_to_form", "grpht_phtd_to_form", 'routine in <a href="nv/grim/tools/gr_phttool.html">gr_phttool.pro</a>', "gr_phttool.pro", "", "grpht_phtd_to_form", "", "dataphtd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_phttool.html#gr_phttool_event", "gr_phttool_event", 'routine in <a href="nv/grim/tools/gr_phttool.html">gr_phttool.pro</a>', "gr_phttool.pro", "", "gr_phttool_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_phttool.html#grpht_primary_notify", "grpht_primary_notify", 'routine in <a href="nv/grim/tools/gr_phttool.html">gr_phttool.pro</a>', "gr_phttool.pro", "", "grpht_primary_notify", "", "init_data_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_phttool.html#grpht_cleanup", "grpht_cleanup", 'routine in <a href="nv/grim/tools/gr_phttool.html">gr_phttool.pro</a>', "gr_phttool.pro", "", "grpht_cleanup", "", "base", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/tools/gr_phttool.html#gr_phttool", "gr_phttool", 'routine in <a href="nv/grim/tools/gr_phttool.html">gr_phttool.pro</a>', "gr_phttool.pro", "", "gr_phttool", "", "top", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/grim/scripts/gr_png_all.html", "gr_png_all.pro", '.pro file in <a href="nv/grim/scripts/dir-overview.html">nv/grim/scripts/ directory</a>', "gr_png_all.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/grim/scripts/gr_png_all.html#gr_png_all", "gr_png_all", 'routine in <a href="nv/grim/scripts/gr_png_all.html">gr_png_all.pro</a>', "gr_png_all.pro", "", "gr_png_all", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/grim/interface/gr_tp.html", "gr_tp.pro", '.pro file in <a href="nv/grim/interface/dir-overview.html">nv/grim/interface/ directory</a>', "gr_tp.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/grim/interface/gr_tp.html#gr_tp", "gr_tp", 'routine in <a href="nv/grim/interface/gr_tp.html">gr_tp.pro</a>', "gr_tp.pro", "", "gr_tp", "", "pngrnumptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/graphic_to_centric.html", "graphic_to_centric.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "graphic_to_centric.pro", "", "", " NAME: 	graphic_to_centric    PURPOSE: 	Converts planetographic surface coordinates to planetocentric.    CATEGORY: 	UTIL    CALLING SEQUENCE: 	result = graphic_to_centric(radii, latlon)    ARGUMENTS:   INPUT: 	radii:	Ellipsoid (3,nt) radii.  	latlon:	Array (2,nv,nt) giving the planetographic latitudes and 		longitudes.    OUTPUT: NONE    KEYWORDS: NONE    RETURN: 	Planetographic coordinates.    STATUS: 	Not complete    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2014   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/graphic_to_centric.html#graphic_to_centric", "graphic_to_centric", 'routine in <a href="util/graphic_to_centric.html">graphic_to_centric.pro</a>', "graphic_to_centric.pro", "", "graphic_to_centric", "", "radiiv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/graphic_to_centric_lat.html", "graphic_to_centric_lat.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "graphic_to_centric_lat.pro", "", "", " NAME: 	graphic_to_centric_lat    PURPOSE: 	Converts planetographic latitudes to planetocentric latitudes.    CATEGORY: 	UTIL    CALLING SEQUENCE: 	result = graphic_to_centric_lat(a, b, lat0)    ARGUMENTS:   INPUT: 	a:	Polar radius.  	b:	Equatorial radius.  	lat0:	Planetocentric latitudes.    OUTPUT: NONE    KEYWORDS: NONE    RETURN: 	Planetographic latitudes.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 11/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/graphic_to_centric_lat.html#graphic_to_centric_lat", "graphic_to_centric_lat", 'routine in <a href="util/graphic_to_centric_lat.html">graphic_to_centric_lat.pro</a>', "graphic_to_centric_lat.pro", "", "graphic_to_centric_lat", "", "ablat0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/grid_correlate.html", "grid_correlate.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "grid_correlate.pro", "", "", " grid_correlate   PURPOSE :    Search for the vector offset, t, at which image2 best correlates with  image1 (without searching the entire array).     The algorithm works as follows:   1) begin with a grid of size nsamples covering the entire image1,     for example, for nsample=[4,4], the grid might look like :              -------------------------            |   .     .     .     .   |            |                         |<-----image array            |                         |            |   .     .     .     .   |            |                         |            |                         |            |   .     .     .     .<--|---sample each of these offsets            |                         |            |                         |            |   .     .     .     .   |             -------------------------   2) evaluate the cross correlation function of image1 and image2      at each point on the grid and determine which point gave the      best result.  Store this point and its correlation in      best_arr.   3) center a new grid of the same configuration at that point      but make it smaller by grid_ratio :              -------------------------         ---|---.   .   .   .     .   |          | |                         |<-----image array     new  | |   .   .   .   .         |     grid | |         +<----------.---|----best point from last scan          | |   .   .   .   .         |          | |                         |         ---|---.   .   .   .     .   |            |                         |            |                         |            |   .     .     .     .   |             -------------------------   4) continue until the entire grid becomes smaller than 1 pixel across.   5) return the point in best_arr which gave the best correlation.   Accuracy:   The offset vector returned by this routine should usually    lie within one pixel of the actual maximum correlation.  The    result can only be guaranteed, though, if nsamples is set to the    size of the array, but this is almost never practical.   Speed:   If you use nsamples of [2,2], the default, then each search cycle    will be as fast as possible, but it will take many cycles to converge    on the maximum.  If you use a very fine grid, then it may take only    a few cycles, but the cycles will take very long.  Of course,    generally one would expect it to be much faster to use a coarse grid    as opposed to one of the same size as the array, otherwise, there    would have been no reason to write this program.  The total time    should scale as:           t = nsamples(0)*nsamples(1)  *  ncycles     where ncycles is the number of search cycles necessary to converge.    The exact value depends on the two images and their initial    offsets.    NOTE: Unless /nohome is set, the first point in best_arr always corresponds        to t=[0,0], i.e; no shift at all.  Thus, if the        images never needed to be shifted, then the result        the result will always be zero offset.     CALLING SEQUENCE :     t=grid_correlate(im1, im2, correlation)    ARGUMENTS   INPUT : im1 - reference image            im2 - image to be shifted    OUTPUT : correlation - cross correlation value after im2 has been                          shifted by t.     KEYWORDS   INPUT : show - Show the search.            nsamples - 2D vector giving the dimensions of the search grid,                      default is [2,2].            nohome - Do not check the offset [0,0] for best correlation.            function_min, function_max - Name of a function to either                                        minimize or maximize.  The                                        function should be declared as                                        follows:                                           function [name], f, g, t                                         and should return a number which                                        indicates the degree of correlation                                        between f ang g, with g shifted by t.            indices - This keyword will only work properly if both images                     are of the same dimensions.  It allows the caller                     to specify a region over which the correlation                     will be optomized by giving an array of the 1D subscripts                     which lie within that region.            kill_char - Key which can be used to abort the search and return                       an offset of [0,0], with the corresponding correlation.                       This slows down the loop a bit, but not significantly                       for large images, in which it may be more important                       for the user to be able to abort.  	   region - Size of region to scan, centered at offset [0,0].  If not 		    specified, the entire image is scanned.    OUTPUT : NONE     RETURN : t, the vector offset by which im2 had to be shifted for           maximum correlation with im1.      KNOWN BUGS : see 'Accuracy' above.     ORIGINAL AUTHOR : J. Spitale ; 8/94   UPDATE HISTORY : Spitale, 4/2002 -- added 'region' keyword   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/grid_correlate.html#ic_optimal", "ic_optimal", 'routine in <a href="util/grid_correlate.html">grid_correlate.pro</a>', "grid_correlate.pro", "", "ic_optimal", "", "corrdataminmax", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/grid_correlate.html#ic_get_correlation", "ic_get_correlation", 'routine in <a href="util/grid_correlate.html">grid_correlate.pro</a>', "grid_correlate.pro", "", "ic_get_correlation", "", "cornersnormfn_image_xxt", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/grid_correlate.html#ic_bias", "ic_bias", 'routine in <a href="util/grid_correlate.html">grid_correlate.pro</a>', "grid_correlate.pro", "", "ic_bias", "", "cctbiaspixn", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/grid_correlate.html#ic_reduce_t", "ic_reduce_t", 'routine in <a href="util/grid_correlate.html">grid_correlate.pro</a>', "grid_correlate.pro", "", "ic_reduce_t", "", "nxnyt", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/grid_correlate.html#ic_get_width", "ic_get_width", 'routine in <a href="util/grid_correlate.html">grid_correlate.pro</a>', "grid_correlate.pro", "", "ic_get_width", "", "datatxtyscan_pixnsampleswxwy", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/grid_correlate.html#grid_correlate", "grid_correlate", 'routine in <a href="util/grid_correlate.html">grid_correlate.pro</a>', "grid_correlate.pro", "", "grid_correlate", "", "shownsamplesnohomefunction_minfunction_maxcornerskill_charregiondatawxwyno_widthbiasfn_shownosearchimagexxcorrelation", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/gen/gridgen.html", "gridgen.pro", '.pro file in <a href="util/gen/dir-overview.html">util/gen/ directory</a>', "gridgen.pro", "", "", " NAME: 	gridgen    PURPOSE: 	Constructs a grid of subscripts.    CATEGORY: 	UTIL/GEN    CALLING SEQUENCE: 	sub = gridgen(dim)    ARGUMENTS:   INPUT: 	dim:	 Dimensions of output grid.     OUTPUT: NONE    KEYWORDS:   INPUT: 	rectangular: If set, the output array has dimensions (ndim,dim[0],dim[1],...) 	             instead of (ndim,dim[0]*dim[1]*...).  In this case, 	             sub[i, x_0,x_1,x_2,x3,...] = x_i.  	p0:          Array (ndim) giving the starting point for the grid.  	             Default is [0,0,..].  	center:	     If given, p0 is taken to be the center of the grid instead. 	             of the corner.  	double:      If set, output is double instead of long.     OUTPUT: NONE    RETURN: 	Array (ndim, dim[0]*dim[1]*...) of subscripts, or (ndim,dim[0],dim[1],...) 	if /rectangular.    EXAMPLE: 	gridgen([3], /rec) returns an array (1,3) with elements:  			0 1 2   	gridgen([3,4], /rec) returns an array (2,3,4) with elements:  			0 1 2 			0 1 2 			0 1 2 			0 1 2  			0 0 0 			1 1 1 			2 2 2 			3 3 3   	gridgen([3,4,2], /rec) returns an array (3,3,4,2) with elements:  			0 1 2   0 1 2 			0 1 2   0 1 2 			0 1 2   0 1 2 			0 1 2   0 1 2  			0 0 0   0 0 0 			1 1 1   1 1 1 			2 2 2   2 2 2 			3 3 3   3 3 3  			0 0 0   1 1 1 			0 0 0   1 1 1 			0 0 0   1 1 1 			0 0 0   1 1 1    KNOWN BUGS: 	In some circumstances gridgen will return duplicate subscripts. 	This happens when the grid spans zero and the grid locations are not 	not integers.  In that case, converting to integer type could cause 	neighboring elements to both round to zero, or to round to either side, 	omitting zero entirely.    STATUS: 	Some bugs.    MODIFICATION HISTORY:  	Written by:	Spitale; 	7/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/gen/gridgen.html#gridgen", "gridgen", 'routine in <a href="util/gen/gridgen.html">gridgen.pro</a>', "gridgen.pro", "", "gridgen", "", "rectangularp0centerdoubledim", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/grim/grim.html", "grim.pro", '.pro file in <a href="nv/grim/dir-overview.html">nv/grim/ directory</a>', "grim.pro", "", "", " NAME: 	GRIM    PURPOSE: 	General-purpose GRaphical Interface for oMinas.    CATEGORY: 	NV/GR    CALLING SEQUENCE:  	grim, arg1, arg2    ARGUMENTS:   INPUT: 	arg1, arg2: 		Grim accepts up to two arguments, which can appear in either 		order.  Possible arguments are:   			data descriptors (object) 			file specification (string)  			grnum (scalar)  			plot (1d array)  			image (2d array)  			cube (3d array)  	Plots are displayed as graphs whose abscissa are the array index, unless 	an abscissa is present in the data descriptor.  Many functions are not 	available in this mode.  	Cubes are handled as multiple image planes unless /rgb is used 	(see below).  All grim planes will contain the same data array, 	but display only data ranges corresponding to one channel of the cube. 	For /rgb (assuming the cube has three channels), the data are placed 	on a single image plane with each cube channel assigned the R, G, or B 	color channel.     OUTPUT: NONE    KEYWORDS:   INPUT: 	Descriptor Keywords 	------------------- 	The following inputs replace objects already maintained by GRIM.  For 	the case of a single plane, all given descriptors are placed in that 	plane.  In that case, only one cd, od, or sund are allowed.  For a cube, 	cd and od must have either one element, or the same number of elements 	as the number of channels in the cube, and are assigned one-to-one to 	the grim planes.  In this case, all other decriptors are assigned to all 	planes.  For multiple images, descriptors are assigned to planes by 	matching their generic decsriptor dd fields (or assoc_dd if given) to 	the data descriptor for each plane.  	 cd:	Replaces the current camera descriptor.  This may also be 		a map descriptor, in which case some of GRIM's functions 		will not be available.  When using a map descriptor instead 		of a camera descriptor, you can specify a camera descriptor 		as the observer descriptor (see the 'od' keyword below) and 		some additional geometry functions will be available.  	 od:	Replaces the current observer descriptor.  The observer 		descriptor is used to allow some geometry objects (limb, 		terminator) to be computed when using a map descriptor instead 		of a camera descriptor.  	 sund:	Replaces the current sun descriptor.  	 pd:	Adds/replaces planet descriptors.  	 rd:	Adds/replaces ring descriptors.  	 sd:	Adds/replaces star descriptors.  	 std:	Adds/replaces station descriptors  	 ard:	Adds/replaces array descriptors  	 gd:	Generic descriptor containing some or all of the above 		descriptors.  	 assoc_dd: 		If given, use these data descriptors to assign descriptors to 		planes instead of matching the data descriptors from their 		generic descriptors.   	Descriptor Select Keywords 	-------------------------- 	Descriptor select keywords (see pg_get_*) are specified using the 	standard prefix corresponding to the descriptor type.  For example, 	the fov keyword to pg_get_planets would be given to grim as plt_fov.   	Initial Colormap Keywords 	------------------------- 	The colormap structure (see colormap_descriptor__define) can be 	be initialized via keywords prefied with 'cmd_', e.g., 'cmd_shade'. 	In addition, the following keywords apply to the initial color map:  	*auto_stretch: 		If set, the color table for each plane is automatically 		stretched.  This is identical to using the 'Auto' button 		on on the grim color tool.   	Translator Keywords 	------------------- 	The following keywords are passed directly to the translators, which 	are responsible for interpreting their meanings.  	*cam_trs: 		String giving translator keywords for the camera descriptors.  	*sun_trs: 		String giving translator keywords for the sun descriptors.  	*plt_trs: 		String giving translator keywords for the planet descriptors.   	*rng_trs: 		String giving translator keywords for the ring descriptors.   	*str_trs: 		String giving translator keywords for the star descriptors.   	*stn_trs: 		String giving translator keywords for the stations descriptors.   	*arr_trs: 		String giving translator keywords for the array descriptors.   	TVIM Keywords 	------------- 	The following keywords set the initial viewing parameters and are 	simply passed to TVIM.  	*xsize:	Size of the graphics window in the x direction.  Defaults to 		400 pixels.  	*ysize:	Size of the graphics window in the y direction.  Defaults to 		400 pixels.  	*zoom:	Initial zoom to be applied to the image.  If not given, grim 		computes an initial zoom such that the entire image fits on the 		screen.  	*rotate: 		Initial rotate value to be applied to the image (as in the IDL 		ROTATE routine).  If not given, 0 is assumed.  	*order:	Initial display order to be applied to the image.  	*offset: 		Initial offset (dx,dy) to be applied to the image.  	 doffset: 		Change the offset viewing parameter by this amount.  	 default: 		If set, use default tvim properties (zoom=[1,1], offset=[0,0]                order=0 [bottom-up])  	 previous: 		If set, restore last-used tvim viewing parameters.  	 restore: 		If set, use saved tvim viewing paramters.   	Customization Keywords 	---------------------- 	*menu_extensions: 		Array of strings giving the names of functions that return 		menu definitions, as defined by cw_pdmenu.  These menus are 		added to the built-in GRIM menus between the Overlays menu 		and the Help menu.  The default is 'grim_default_menus'.  If 		the first character in the first menu function is '+', then 		grim_default_menus is retained an the new menu are appended 		after that menu.  Otherwise, 'grim_default_menus' is replaced.  	*button_extensions: 		Array of strings giving the names of definition functions 		for custom cursor modes to be added after the built-in 		cursor modes.  The definition function takes one argument 		(see arg_extensions below) and returns a grim_user_mode_struct.  	*arg_extensions: 		Argument to be provided to the button extension definition 		function above.  	*menu_fname: 		Name of a file containing additional menus to add to 		the grim widget.  The file syntax follows that for cw_pdmenu.   	Other Keywords 	-------------- 	*extensions: 		String array giving extensions to try for each input file. 		see dat_read.  	*new:	If set, a new grim instance is created and all keywords apply 		to that instance.  	 erase:	If set, erase the current image before doing anything else.  	*mode_init: 		Initial cursor mode.  See below.  	*mode_args: 		Array giving arguments for the cursor modes initialization 		functions.  If a string, then syntax is NAME:ARG, where NAME 		is the name of the cursor mode, and ARG is the argument for 		that mode.  For example:  			mode_args='READOUT:myreadout_fn'  		would cause the function 'myreadout_fn' to be added to 		the list of functions called by pg_cursor and pg_measure 		via the readout cursor mode.  If not a string, the argument 		is passed to the initialization function with no processing.  	*retain: 		Retain settings for backing store (see  backing store  in 		the IDL reference guide).  Defaults to 2.  	*clip:	Controls the number of fields of view in which overlays are 		computed.  	*fov:	Controls the number of fields of view in which to request 		planet, ring and star descriptors.  Values are as follows:   			 0 : get all descriptors                   	<0 : relative to viewport                  	>0 : relative to image / optic axis  		Note that fov > 0 is the same as setting the fov descriptor 		select keywords (see above).  Default is 0, but stars operate 		best when fov > 0.  	*hide:	If set, overlays are hidden w.r.t shadows and obstructions.  		Default is on.  	 no_erase: 		If set, GRIM does not erase the draw window.  When called.  	*rgb:	If set, grim interprets a 3-plane cube as a 3-channel image                to be displayed on a single plane.  	*channel: 		Array of bitmasks specifying the color channel in which to 		display each given image: 1b, 2b, or 4b.  	*visibility: 		Initial visibility setting for planes:                  	0: Only the current plane is drawn.                 	1: All planes are drawn.                  Default is 0.  	*max:	Maximum data value to scale to when displaying images. 		Values larger than this are set to the maximum color table 		index.  If not set, the maximum value in the data set is used. 		In cases where the data array is being subsampled, this value 		may not be known, resulting in varying image scaling as more 		and more data values are sampled.  That problem may be 		eliminated via this keyword.  	 exit:	If set, GRIM immediately exits.  This can be used to kill an 		existing GRIM window.  	 modal:	If set, grim is run as a modal widget, i.e., there is no command 		prompt.  	*frame:	If set, the initial view is set such that all members of the 		named overlay types are are visible.  If /frame, then all 		overlays are framed.  Note that object types that rely on the 		view to determine which objects to compute (e.g., stars) 		cannot be framed in this way.  	 refresh_callbacks: 		Array of strings giving the names of procedures to be 		called after each refresh.  See CALLBACK PROCEDURES 		below.  Refresh callbacks receive only the data argument.  	 refresh_callback_data_ps: 		Array of pointers (one per callback) to data for the refresh 		callback procedures specified using the refresh_callbacks 		keyword.  See CALLBACK PROCEDURES below.  	 plane_callbacks: 		Array of strings giving the names of procedures to be 		called after each plane change.  See CALLBACK PROCEDURES 		below.  Plane callbacks receive only the data argument.  	 plane_callback_data_ps: 		Array of pointers (one per callback) to data for the plane 		callback procedures specified using the plane_callbacks 		keyword.  See CALLBACK PROCEDURES below.  	*nhist:	History setting to be applied to data decriptor (see 		ominas_data__define).  GRIM uses data descriptor history to 		undo changes to the data array.  If nhist is not set, or is 		equal to 1, the undo menu option will not function.  	*maintain: 		If given, this maintainance setting is applied to the data 		descriptor (see ominas_data__define).  	*compress: 		Compression setting to be applied to data decriptor (see 		ominas_data__define).  	*filter: 		Initial filter to use when loading or browsing files.  	*load_path: 		Initial path for the file loading dialog.  	*save_path: 		Initial path for the file saving dialog.  	*path:	Sets both load_path and save_path to this value.  	*workdir: 		Default directory for saving user points, masks, tie 		points, curves  	 user_psym: 		Default plotting symbol for user overlays.  	 grnum:	Identifies a specific GRIM window by number.  Grim numbers are 		displayed in the status bar, e.g.: grim <grnum>.  	 pn:	Directs GRIM to change to the plane correspondng to this plane 		number.  	*cursor_swap: 		If set, cursor bitmaps are byte-order swapped.  	*loadct: 		Index of color table to load.  	*beta:	If set beta features are enabled.  	*npoints: 		Number of point to compute for various overlays.  Default is 1000.   	*plane_syncing: Turns plane syncing on (1) or off(0).  Default is 0.   	*tiepoint_syncing: Turns tiepoint syncing on (1) or off(0).  Default is 0.   	*curve_syncing: Turns curve syncing on (1) or off(0).  Default is 0.   	 position: 		Sets the plot position; see the POSITION grahics keyword.   	 color:	Sets the line color index for plots.  One element per plane.   	 xrange: 		Sets the X-axis range for plots.   	 yrange: 		Sets the Y-axis range for plots.  	 thick:	Sets the line thickness for plots.  One element per plane.  	 title:	For plots, sets the plot title for plots; one element per plane. 		For images, sets the base default title.  	 xtitle: 		Sets the X-axis label for plots.  One element per plane.  	 ytitle: 		Sets the Y-axis label for plots.  One element per plane.  	 psym:	Sets the plotting symbol for plots.  One element per plane.  	 nsum:	See OPLOT.  One element per plane.   	*overlays: 		List of initial overlays to compute on startup.  Each element 		is of the form:                            type[:name1,name2,...]  		where 'type' is one of {limb, terminator, planet_center, 		star, ring, planet_grid, array, station} and the names 		identify the name of the desired object.  Note that grim 		will load more objects than named if required by another 		startup overlay.  For example:                           overlays='ring:a_ring'  		will cause only one ring descriptor to load, whereas                           overlays=['limb:saturn', 'ring:a_ring']  		will cause all of Saturn's rings to load because they are 		required in computing the limb points (for hiding).  		Different results may be obtained using translator keywords, 		because those keywords are evaluated at the translator level. 		For example:  			overlays='ring:fn54'  		may result in no ring, while:  			overlays='ring', trs_rd='name=fn54'  		would be more likely to yield a ring.  In the former example, 		the specified name is compared against whatever default ring 		descriptors are returned by the tranlators, while in the latter 		case, the 'name' translator keyword is compared against all 		rings available to the translator.   	*delay_overlays: 		If set, initial overlays (see 'overlays' above) are not computed 		until the first time they are accessed.  This option can greatly 		improve performance in cases where a large number of image planes 		are loaded with initial overlays, particularly if it is not 		expected that all planes will necesarily be viewed or otherwise 		accessed.  Typically this option will cause overlays to be 		computed only for the initially visible planes, with other 		planes loading overlays only as they are made visible.  However, 		there may be other cirumstances that can cause initial overlays 		to be loaded without actually viewing a plane.  	*activate: 		If set, inital overlay are activated.  	*ndd: 	Sets the global ndd value in the OMINAS sate structure, which 		controls the maximum number of data descriptors with maintain == 1 		to keep in memory at any given time  	*render_sample: 		Over-sampling value for rendering.  See pg_render.  	*render_pht_min: 		Minimum value to assign to photometric output in renderings. 		See pg_render.   	Incomplete Keywords 	------------------- 	*rendering: 		If set, perform a rendering on the initial descriptor set.     OUTPUT: NONE    RESOURCE FILE: 	The keywords marked above with an asterisk may be overridden using 	the file $HOME/.ominas/grimrc.  Keyword=value pairs may be entered, one per 	line, using the same syntax as if the keyword were entered on the IDL 	command line to invoke grim.  Lines beginning with '#' are ignored. 	Keywords entered in the resource file override the default values, and 	are themselves overridden by keywords entered on the command line.   SHELL INTERFACE 	The 'grim' alias may be used to start grim from the shell prompt 	via the XIDL interface.  The shell interface accepts all keywords 	marked above with an asterisk.  See grim.bat.  	Example (assuming the grim alias described in grim.bat):  	 % grim -beta data/*.img overlay=planet_center,limb:JUPITER    ENVIRONMENT VARIABLES: 	Grim currently defines no environment variables..    COMMON BLOCKS: 	 grim_block: 		Keeps track of most recent grim instance and which ones are 		selected.    SIDE EFFECTS: 	Grim operates directly on the memory images of the descriptors that 	it is given.  Therefore, those descriptors are modified during 	a session.  This architecture allows data to be operated on concurrently 	through grim and from the command line; see ingrid.pro for details.    LAYOUT: 	The philosphy that drives GRIM's layout is that the maximum possible 	screen space should be devoted to displaying the data.  This policy 	allows for many GRIM windows to be used simultaneously without being 	obscured by crazy control panels full of buttons, gadgets, widgets, 	doodads, whirly-gigs, and what-nots.  The grim layout consists of the 	following items:  	 Title bar: 		The title bar displays the grim window number (grnum), 		the current plane number (pn), the total number of planes, the 		name field of the data descriptor for the current plane, the 		default title (if given; see the title keyword above), and 		a string indicating which RGB channels are associated with the 		current plane.  	 Menu bar: 		Most of grim's functionality is accessed through the 		system of pulldown menus at the top.  Individual menu 		items are described in their own sections.  	 Shortcut buttons: 		Some commonly used menu options are duplicated as shortcut 		buttons arranged horizontally just beneath the menu bar.  The 		function of each button is displayed in the status bar (see 		below) when the mouse cursor is hovered ove the button.  	 Cursor mode buttons: 		Cursor mode shortcut buttons are arranged vertically along the 		left side of the GRIM window, and as provided as shortcuts 		for the corresponding options in the Mode menu.  The following 		modes are available:  		Activate: 			In activate mode, overlay objects may be activated 			or deactivated by clicking and/or dragging using the 			left or right mouse buttons respectively.  This 			activation mechanism allows the user to select which 			among a certain type of objects should be used in a 			given menu selection.  A left click on an overlay 			activates that overlay and a right click deactivates 			it.  A double click activates or deactivates all 			overlays associated with a given descriptor, or all 			stars.  Active overlays appear in the colors selected 			in the 'Overlay Settings' menu selection.  Inactive 			overlays appear in cyan.  A descriptor is active 			whenever any of its overlays are active.  		Zoom:	The zoom button puts grim in a zoom cursor mode, wherein 			the image zoom and offset are controlled by selecting 			a box in the image.  When the box is created using the 			left mouse button, zoom and offset are changed so that 			the contents of the box best fill the current graphics 			window.  When the right button is used, the contents of 			the current graphics window are shrunken so as to best 			fill the box.  In other words, the left button zooms in 			and the right button zooms out.  		Pan: 	The pan button puts grim in a pan cursor mode, wherein the 			image offset is controlled by selecting an offset vector 			using the left mouse button.  The middle button may be 			used to center the image on a selected point.  		Pixel Readout: 			In pixel readout mode, a text window appears 			and displays data about the pixel selected 			using the left mouse button.  		Tiepoint: 			In tiepoint mode, tiepoints are added using the 			left mouse button and deleted using the right button. 			Tiepoints appear as crosses identified by numbers. 			The use of tiepoints is determined by the particular 			option selected by the user.  		Curve: 			In curve mode, curves are added using the 			left mouse button and deleted using the right button. 			Curves appear as red lines identified by numbers at 			each end.  The use of curves is determined by the 			particular option selected by the user.  		Mask: 			GRIM maintains a mask for each plane whose use is 			appication-dependent.  Mask mode allows pixels in the 			mask to be toggled on and off.  		Magnify: 			In magnify mode, image pixels in the graphics 			window may be magnifed using either the right or left 			mouse buttons.  The left button magnifies the displayed 			pixels, directly from the graphics window.  The right 			button magnifies the data itself, without the overlays.  		XY Zoom: 			Same as 'zoom' above, except the aspect ratio is 			set by the proportions of the selected box.  		Remove overlays: 			Allows the user to remove overlay arrays.  		Trim overlays: 			Allows the user to trim points from overlay arrays.  		Select within overlays: 			Allows the user to select points within overlay arrays.  		Define Region: 			Allows the user to define GRIM's region of interest.  		Smooth: 			Allows the user to select a smoothing box to be applied 			to the data array.  		Select Plane: 			Allows the user to change planes using the pointer. 			This option is only useful in cases where multiple 			planes are displayed.  		Drag Image: 			Allows the user to reposition the current plane by 			clicking and dragging.  		Navigate: 			Allows the user to modify the camera position and 			orientation usng the mouse.   	 Graphics window: 		The graphics window displays the data associated with the 		given data descriptor using the current zoom, offset, and 		display order.  The edges of an image are indicated by a dotted 		line.  The camera optic axis is indicated by a large red cross.  	 Pixel readout: 		The cursor position and corresponding data value are are 		displayed beneath the graphics window, next to the message line.  	 Message line: 		The message line displays short messages pertaining GRIM's 		 current state, or displayng button functions.   CALLBACK PROCEDURES: 	GRIM callback procedures are called with one or two arguments:        the first argument is a pointer to data that was provided 	when the callback was added.  The second argument, if present, depends 	on the applicatation.    RESOURCE NAMES 	The following X-windows resource names apply to grim: 	 grim_base:		top level base 	 grim_mbar:		menu bar 	 grim_shortcuts_base:	base containing shortcut buttons 	 grim_modes_base:	base containing modes buttons 	 grim_draw:		grim draw widget 	 grim_label:		grim bottom label widget  	To turn off the confusing higlight box around the modes buttons, 	put the following line in your ~/.Xdefaults file:  	 Idl*grim_modes_base*highlightThickness:	0    OPERATION: 	GRIM displays 1-, 2-, and 3-dimensional data sets.  1-dimensional 	data arrays are displayed as plots.  In that case, the abscissa is 	the sample number unless the data descriptor contains an abscissa. 	2- and 3-dimensional arrays are displaye as image planes.  The only 	difference between images and cubes in GRIM is that images planes 	each have their own data descriptor, while cubes are represented by 	multiple image planes that share a common data descriptor; each plane 	in a cube corresponds to a unique offset in the data array stored in 	the common data descriptor.  Some functionality is not available when 	working with plots.  In that case, those options do not appear in the 	menus.  	GRIM requests only the data samples needed for the current viewing 	parameters.  Therefore, GRIM can display data sets of arbitrary size 	when used with a file reader that supports subsampling.  However, note 	that specific menu options may request the entire data array, depending 	on the application.  	Each GRIM window may contain any number of planes as well as 	associated geometric data (i.e. object descriptors) and overlay arrays 	for displaying various geometric objects -- limbs, rings, stars, etc. 	An array of user overlay points is maintained to be used for application- 	specific purposes.  Generally, a set of overlay points or a descriptor 	must be activated in order to be used as input to a menu item; see 	activate mode above.  	There are exclusive and non-exclusive mechanisms for selecting grim 	windows.  Grim windows may be non-exclusively selected using the select 	mode button mentioned above (upper-left corner).  The exclusive 	selection mechanism consists of a  primary  GRIM window, indicated by 	a red outline in the graphics window.  The primary selection is 	changed by pressing any mode or shortcut button, or by clicking in 	the graphics area of the desired grim window.  The meaning of the 	various selections depends on the application.  	The functions of the left and right mouse buttons are determined by the 	cursor mode; some cursor modes define modifier keys to broaden the number 	of functions available in that mode.  The middle mouse button toggles 	the activation state of overlay arrays, or pans the image if no overlay 	appears beneath the cursor.  The mouse wheel cycles among cursor modes, 	or zooms about the cursor position if the control key is held down.  	Objects maintained by GRIM are accessible via the INGRID interface, 	for example:  		IDL> ingrid, dd=dd, cd=cd, pd=pd, limb_ptd=limb_ptd  	returns the data desciptor, camera descriptor, planet descriptors, 	and limb points associated with the current plane.  	GRIM registers event handlers for all of its objects, so the window 	is updated any time an object is modifed, whether by GRIM or by some 	other program, or from the command line.    EXAMPLES: 	(1) To create a new grim instance with no data:  		IDL> grim, /new  	(2) To create a new grim instance with data from a file of name 	     filename :  		IDL> dd = dat_read(filename) 		IDL> grim, dd  		   or  		IDL> grim, filename  	(3) To give an existing grim instance a new camera descriptor:  		IDL> grim, cd=cd    KNOWN BUGS: 	Window resizing is not precise.  GRIM tries to resize to the selected 	size, but typically overshoots.  This is probably platform-dependent.  	Objects inherited by rendering planes do not respond to events.  	Image shifting: 	 -  Descriptors not updated if shift performed form another window 	    because the there's no way for the irst window to know to 	    update its descriptors         - fix wrap-around; clip instead  	Plane->Coregister does not update descriptors  	Navigate mode gets weird when you do certain modifer key presses 	   --> maybe a conflict with <ctrl> wheel zoom action  	Crashes occur with File->Close  	/no_erase is not enabled for images, just plots.  Probably should fix 	that.  	Initial visibility setting does not seem to work until applied 	using plane settings window.  	/frame causes a crash if there are no initial overlays.  	It's not clear whether the symsize keyword is actually used.  	pn keyword does not function.  	Crash when tiepoint syncing is on and tiepoint selected with 	multiple planes.  	Title keyword does not properly map multiple elements to multiple 	planes.  	Nsum keyword does not properly map multiple elements to multiple 	planes.  	Plane syncing appears to be incomplete and I don't remember what it 	was supposed to be.  I'm sure it was awesome, though.  	Not sure what slave_overlays keyword does, or was supposed to do.  	Overlays on rendered planes do not respond to events  	Menu toggles don't update propoerly in some circumsumstances.  	grim_message sometimes pops up messages from nv_message, which can 	be pretty obnxious.  This probably has to do with the calls to 	grim_message in grim_compute.include    STATUS: 	Incomplete.    SEE ALSO: 	ingrid, gr_draw    MODIFICATION HISTORY:  	Written by:	Spitale 7/2002    FILE MENU    NAME: 	grim_menu_file_load_event    PURPOSE: 	Allows user to load images into new image planes.  The user is 	prompted for filenames and dat_read is used to read each image. 	Multiple images may be selected and a new plane is created for 	each image.  On X-windows systems, multiple files may be selected 	either by dragging across the filenames or by holding down the 	control key to toggle the selected files.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002    NAME: 	grim_menu_file_browse_event    PURPOSE: 	Allows user to load images into new image planes using the brim 	browser.  Images are selected using the left mouse button and 	each image is loaded on a new plane.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 10/2002    NAME: 	grim_menu_file_save_event    PURPOSE: 	Allows user to save the current image plane and geometry.  If there 	is no current filename for the current plane, then the user is 	prompted for one.  All descriptors are written through the translators 	and then dat_write is used to write the data file.  Specific behavior 	is governed by OMINAS' configuration.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002    NAME: 	grim_menu_file_save_as_event    PURPOSE: 	Same as 'Save' above, except always prompts for a filename.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002    NAME: 	grim_menu_open_as_rgb_event    PURPOSE: 	Opens a new grim window with the current channal configuration 	reduced to a 3-channel RGB cube.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2016    NAME: 	grim_menu_file_save_user_ptd_event    PURPOSE: 	Writes user points for the current plane to a file called 	[image name].user_ptd    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2004    NAME: 	grim_menu_file_save_all_user_ptd_event    PURPOSE: 	Writes user points for all planes to files called 	[image name].user_ptd    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2004    NAME: 	grim_menu_file_load_user_ptd_event    PURPOSE: 	loads user points for the current plane from a file called 	[image name].user_ptd    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2004    NAME: 	grim_menu_file_load_all_user_ptd_event    PURPOSE: 	Loads user points for all planes from files called 	[image name].user_ptd    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2004    NAME: 	grim_menu_file_save_tie_ptd_event    PURPOSE: 	Writes tie points for the current plane to a file called 	[image name].tie_ptd    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2004    NAME: 	grim_menu_file_save_all_tie_ptd_event    PURPOSE: 	Writes tie points for all planes to files called 	[image name].tie_ptd    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2004    NAME: 	grim_menu_file_load_tie_ptd_event    PURPOSE: 	loads tie points for the current plane from a file called 	[image name].tie_ptd    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2004    NAME: 	grim_menu_file_load_all_tie_ptd_event    PURPOSE: 	Loads tie points for all planes from files called 	[image name].tie_ptd    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2004    NAME: 	grim_menu_file_save_curves_event    PURPOSE: 	Writes curves for the current plane to a file called 	[image name].curve_ptd    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 12/2015    NAME: 	grim_menu_file_save_all_curves_event    PURPOSE: 	Writes curves for all planes to files called 	[image name].curve_ptd    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 12/2015    NAME: 	grim_menu_file_load_curves_event    PURPOSE: 	loads curves for the current plane from a file called 	[image name].curve_ptd    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 12/2015    NAME: 	grim_menu_file_load_all_curves_event    PURPOSE: 	Loads curves for all planes from files called 	[image name].curve_ptd    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 12/2015    NAME: 	grim_menu_file_save_mask_event    PURPOSE: 	Writes mask points for the current plane to a file called 	[image name].mask    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2013    NAME: 	grim_menu_file_save_all_masks_event    PURPOSE: 	Writes mask points for all planes to files called 	[image name].mask    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2013    NAME: 	grim_menu_file_load_mask_event    PURPOSE: 	loads mask points for the current plane from a file called 	[image name].mask    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2013    NAME: 	grim_menu_file_load_all_masks_event    PURPOSE: 	Loads mask points for all planes from files called 	[image name].mask    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2013    NAME: 	grim_menu_file_save_ps_event    PURPOSE: 	Saves the current view as a postscript file.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 12/2002    NAME: 	grim_menu_repeat_event    PURPOSE: 	Repeats the last menu option.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2006    NAME: 	grim_menu_undo_event    PURPOSE: 	Undoes the last data modification.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 11/2006    NAME: 	grim_menu_redo_event    PURPOSE: 	Redoes the last data modification.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 11/2006    NAME: 	grim_select_event    PURPOSE: 	Selects or unselects a grim window.  This functionality is for use 	with functions that require input from more than one grim instance. 	The selected state is red; unselected is gray.    CATEGORY: 	NV/GR    OPERATION: 	This option toggles a given grim instance between selected 	and unselected states, for use with functions that require 	input from more than one grim instance.  When a given instance 	is selected, this button displays an asterisk.    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002    NAME: 	grim_identify_event    PURPOSE: 	Causes grim to identify itself on the IDL command line.    CATEGORY: 	NV/GR    OPERATION: 	This option causes grim to print a message on the IDL command line. 	It is useful in cases where multiple grim instances are running in 	multiple IDL sessions.    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2009    NAME: 	grim_menu_file_close_event    PURPOSE: 	Closes the current image plane.  All other image plane numbers 	remain the same.  If there is only one image plane, the grim exits.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002    PLANE MENU    NAME: 	grim_menu_plane_next_event    PURPOSE: 	Changes to the next-numbered image plane.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002    NAME: 	grim_menu_plane_previous_event    PURPOSE: 	Changes to the previous-numbered image plane.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002    NAME: 	grim_menu_plane_jump_event    PURPOSE: 	Prompts the user and jumps to a new plane.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 5/2005    NAME: 	grim_menu_plane_browse_event    PURPOSE: 	Opens a brim browser showing all planes.  The left mouse button 	may be used to jump among planes.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 10/2002    NAME: 	grim_menu_plane_open_event    PURPOSE: 	Opens the image of the current plane in a new grim window.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 11/2002    NAME: 	grim_menu_plane_evolve_event    PURPOSE: 	Evolves the selected objects onto all other planes.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2004    NAME: 	grim_menu_plane_crop_event    PURPOSE: 	Crops the data to the current viewing parameters.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2013    NAME: 	grim_menu_plane_reorder_time_event    PURPOSE: 	Rearranges all planes in time order.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2004    NAME: 	grim_menu_plane_sequence_event    PURPOSE: 	Displays all planes in sequence using xinteranimate.  This option is 	useful or blinking as well.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2002    NAME: 	grim_menu_plane_dump_event    PURPOSE: 	Dumps all planes to png files entitled [filename].png.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2004    NAME: 	grim_menu_plane_coregister_event    PURPOSE: 	Shifts the images on each plane so as to center the active object 	at the same pixel on each plane.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 11/2002    NAME: 	grim_menu_plane_coadd_event    PURPOSE: 	Averages all planes.  Not implemented.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 5/2004    NAME: 	grim_menu_plane_toggle_plane_syncing_event    PURPOSE: 	Toggles plane syncing on/off.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2016    NAME: 	grim_menu_plane_highlight_event    PURPOSE: 	Toggles highlighting of the current plane image.  Useful when 	multiple planes are visible simultaneously.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2008    NAME: 	grim_menu_plane_copy_tiepoints_event    PURPOSE: 	Copies all tieppoints from the current plane to all other planes.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2004    NAME: 	grim_menu_plane_propagate_tiepoints_event    PURPOSE: 	Copies all tieppoints from the current plane to all other planes.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2004    NAME: 	grim_menu_plane_toggle_tiepoint_syncing_event    PURPOSE: 	Toggles tiepoint syncing on/off.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 10/2012    NAME: 	grim_menu_plane_clear_tiepoints_event    PURPOSE: 	Clears all tiepoints from the current plane.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 11/2004    NAME: 	grim_menu_plane_copy_curves_event    PURPOSE: 	Copies all curves from the current plane to all other planes.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2004    NAME: 	grim_menu_plane_toggle_curve_syncing_event    PURPOSE: 	Toggles curve syncing on/off.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 10/2012    NAME: 	grim_menu_plane_clear_curves_event    PURPOSE: 	Clears all curves from the current plane.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 11/2004    NAME: 	grim_menu_plane_copy_mask_event    PURPOSE: 	Copies mask from the current plane to all other planes.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2013    NAME: 	grim_menu_plane_clear_mask_event    PURPOSE: 	Clears the mask from the current plane.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2013    NAME: 	grim_menu_plane_settings_event    PURPOSE: 	Allows the user modify settings for the loaded image planes. 	Each plane may displayed in any combination of the three color 	channels.  Also, a plane may be made visible even when it is not 	the current plane, instead of the default behavior, which is to 	display the plane only whenit is current.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2002    DATA MENU    NAME: 	grim_menu_data_adjust_event    PURPOSE: 	This option allows the user to adjust data values.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2014    VIEW MENU    NAME: 	grim_menu_view_refresh_event    PURPOSE: 	Redraws the overlays on the graphics display.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002    NAME: 	grim_menu_view_zoom_event    PURPOSE: 	Prompts the user for a new zoom factor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 5/2005    NAME: 	grim_menu_view_zoom_double_event    PURPOSE: 	Doubles the current zoom, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2008    NAME: 	grim_menu_view_zoom_half_event    PURPOSE: 	Halves the current zoom, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2008    NAME: 	grim_menu_view_zoom_1_event    PURPOSE: 	Sets the current zoom to 1, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2008    NAME: 	grim_menu_view_zoom_2_event    PURPOSE: 	Sets the current zoom to 2, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2008    NAME: 	grim_menu_view_zoom_3_event    PURPOSE: 	Sets the current zoom to 3, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2008    NAME: 	grim_menu_view_zoom_4_event    PURPOSE: 	Sets the current zoom to 4, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2008    NAME: 	grim_menu_view_zoom_5_event    PURPOSE: 	Sets the current zoom to 5, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2008    NAME: 	grim_menu_view_zoom_6_event    PURPOSE: 	Sets the current zoom to 6, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2008    NAME: 	grim_menu_view_zoom_7_event    PURPOSE: 	Sets the current zoom to 7, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2008    NAME: 	grim_menu_view_zoom_8_event    PURPOSE: 	Sets the current zoom to 8, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2008    NAME: 	grim_menu_view_zoom_9_event    PURPOSE: 	Sets the current zoom to 9, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2008    NAME: 	grim_menu_view_zoom_10_event    PURPOSE: 	Sets the current zoom to 10, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2008    NAME: 	grim_menu_view_zoom_1_2_event    PURPOSE: 	Sets the current zoom to 1/2, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2008    NAME: 	grim_menu_view_zoom_1_3_event    PURPOSE: 	Sets the current zoom to 1/3, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2008    NAME: 	grim_menu_view_zoom_1_4_event    PURPOSE: 	Sets the current zoom to 1/4, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2008    NAME: 	grim_menu_view_zoom_1_5_event    PURPOSE: 	Sets the current zoom to 1/5, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2008    NAME: 	grim_menu_view_zoom_1_5_event    PURPOSE: 	Sets the current zoom to 1/5, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2008    NAME: 	grim_menu_view_zoom_1_6_event    PURPOSE: 	Sets the current zoom to 1/6, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2008    NAME: 	grim_menu_view_zoom_1_7_event    PURPOSE: 	Sets the current zoom to 1/7, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2008    NAME: 	grim_menu_view_zoom_1_8_event    PURPOSE: 	Sets the current zoom to 1/8, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2008    NAME: 	grim_menu_view_zoom_1_9_event    PURPOSE: 	Sets the current zoom to 1/9, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2008    NAME: 	grim_menu_view_zoom_1_10_event    PURPOSE: 	Sets the current zoom to 1/10, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2008    NAME: 	grim_menu_view_rotate_0_event    PURPOSE: 	Sets the current rotate to 0, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2013    NAME: 	grim_menu_view_rotate_1_event    PURPOSE: 	Sets the current rotate to 1, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2013    NAME: 	grim_menu_view_rotate_2_event    PURPOSE: 	Sets the current rotate to 2, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2013    NAME: 	grim_menu_view_rotate_3_event    PURPOSE: 	Sets the current rotate to 3, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2013    NAME: 	grim_menu_view_rotate_4_event    PURPOSE: 	Sets the current rotate to 4, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2013    NAME: 	grim_menu_view_rotate_5_event    PURPOSE: 	Sets the current rotate to 5, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2013    NAME: 	grim_menu_view_rotate_6_event    PURPOSE: 	Sets the current rotate to 6, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2013    NAME: 	grim_menu_view_rotate_7_event    PURPOSE: 	Sets the current rotate to 7, centered at the mouse cursor.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2013    NAME: 	grim_menu_view_recenter_event    PURPOSE: 	Recenters the view at the cursor position.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2008    NAME: 	grim_menu_view_apply_event    PURPOSE: 	Applys the current view to all planes.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2016    NAME: 	grim_menu_view_home_event    PURPOSE: 	Sets the tvim home view settings.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 5/2005    NAME: 	grim_menu_view_save_event    PURPOSE: 	Saves the current view settings.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002    NAME: 	grim_menu_view_restore_event    PURPOSE: 	Restores the last-saved view settings.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002    NAME: 	grim_menu_view_previous_event    PURPOSE: 	Restores the previous view settings.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002    NAME: 	grim_menu_view_entire_event    PURPOSE: 	Applies the 'entire' display parameters, as given in tvim.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002    NAME: 	grim_menu_view_initial_event    PURPOSE: 	Reverts to the initial view parameters for this grim widget.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 10/2007    NAME: 	grim_menu_view_flip_event    PURPOSE: 	Reverses the curent display order.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002    NAME: 	grim_menu_view_frame_event    PURPOSE: 	Modifies view settings so as to display the either all overlays 	or those that are active.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 9/2007    NAME: 	grim_menu_view_header_event    PURPOSE: 	Opens a text window showing the image header.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 10/2003    NAME: 	grim_menu_notes_event    PURPOSE: 	Opens a text window allowing the user to enter notes for each plane.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 10/2003    NAME: 	grim_menu_toggle_image_event    PURPOSE: 	Toggles the image On/Off.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 9/2012    NAME: 	grim_menu_toggle_image_overlays_event    PURPOSE: 	Toggles the image and overlays On/Off.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 9/2012    NAME: 	grim_menu_context_event    PURPOSE: 	Toggles the context window On/Off.   CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 9/2005    NAME: 	grim_menu_axes_event    PURPOSE: 	Toggles the axes window On/Off.  The colors are as follows:  	 Blue	- Inertial axes. 	 Red	- Camera axes. 	 Green	- Direction to primary planet, not foreshortened. 	 Yellow	- Direction to Sun, not foreshortened.  	Vectors pointing away from the camera are dotted.  The vectors are 	rooted at a point 1d5 distance units in front of the camera . 	In the direction corresponding to the image position of the drawn 	axes.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 9/2005    NAME: 	grim_menu_render_event    PURPOSE: 	Renders the visible scene and places it in a new plane unless 	the current plane is already rendering.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015    NAME: 	grim_menu_view_colors_event    PURPOSE: 	Opens grim_colortool.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002    OVERLAYS MENU    NAME: 	grim_menu_points_planet_centers_event    PURPOSE: 	Obtains the necessary descriptors through the translators and computes 	planet center positions using pg_center for all active objects.  If no 	active objects, then all centers are computed.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002    NAME: 	grim_menu_points_limbs_event    PURPOSE: 	Obtains the necessary descriptors through the translators and computes 	limbs using pg_limbs for all active objects.  If no active objects, 	then all limbs are computed.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002    NAME: 	grim_menu_points_terminators_event    PURPOSE: 	Obtains the necessary descriptors through the translators and computes 	terminators using pg_limb with the sun as the observer for all active 	objects.  If no active objects, then all terminators are computed.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002    NAME: 	grim_menu_points_planet_grids_event    PURPOSE: 	Obtains the necessary descriptors through the translators and computes 	planet grids using pg_grid for all active objects.  If no active 	objects, then all grids are computed.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002    NAME: 	grim_menu_points_rings_event    PURPOSE: 	Obtains the necessary descriptors through the translators and computes 	ring outlines using pg_disk.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002    NAME: 	grim_menu_points_ring_grids_event    PURPOSE: 	Obtains the necessary descriptors through the translators and computes 	ring grids using pg_grid for all active objects.  If no active 	objects, then all grids are computed.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2004    NAME: 	grim_menu_points_stations_event    PURPOSE: 	Obtains the necessary descriptors through the translators and computes 	planet stations for all active objects.  If no active objects, then 	all stations are computed.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2009    NAME: 	grim_menu_points_arrays_event    PURPOSE: 	Obtains the necessary descriptors through the translators and computes 	arrays for all active objects.  If no active objects, then 	all arrays are computed.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2012    NAME: 	grim_menu_points_stars_event    PURPOSE: 	Obtains the necessary descriptors through the translators and computes 	star positions using pg_center.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002    NAME: 	grim_menu_points_shadows_event    PURPOSE: 	Obtains the necessary descriptors through the translators and computes 	shadows of the currently active overlay points on all other objects. 	Note that you may have to disable overlay hiding in order to compute 	and activate all of the appropriate source points for the shadows 	since many point that are not visible to the observer may still have 	a line of sight to the sun.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 1/2003    NAME: 	grim_menu_points_reflections_event    PURPOSE: 	Obtains the necessary descriptors through the translators and computes 	reflections of the currently active overlay points on all other objects. 	Note that you may have to disable overlay hiding in order to compute 	and activate all of the appropriate source points for the reflections 	since many point that are not visible to the observer may still have 	a line of sight to the sun.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 1/2003    NAME: 	grim_menu_hide_all_event    PURPOSE: 	 Hides/unhides all overlay objects.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 1/2003    NAME: 	grim_menu_clear_all_event    PURPOSE: 	 Clears all objects.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 9/2002    NAME: 	grim_menu_clear_active_event    PURPOSE: 	 Clears all active objects.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 9/2002    NAME: 	grim_menu_activate_all_event    PURPOSE: 	 Activates all objects.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 9/2002    NAME: 	grim_menu_deactivate_all_event    PURPOSE: 	 Deactivates all objects.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 9/2002    NAME: 	grim_menu_invert_all_event    PURPOSE: 	 Inverts current overlay activations.  Desccriptor activations are 	 determined by the resulting overlay activations.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 11/2002    NAME: 	grim_menu_points_settings_event    PURPOSE: 	Allows the user modify settings relevant to the overlay points.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_constants", "grim_constants", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_constants", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_resize", "grim_resize", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_resize", "", "initgrim_database_xsizebase_ysize", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_set_tracking", "grim_set_tracking", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_set_tracking", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_test_motion_event", "grim_test_motion_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_test_motion_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_set_ct", "grim_set_ct", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_set_ct", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_set_mode", "grim_set_mode", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_set_mode", "", "newinitdata_pgrim_datamode", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_write_ptd", "grim_write_ptd", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_write_ptd", "", "grim_datafilename", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_write", "grim_write", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_write", "", "filetypegrim_datafilename", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_get_save_filename", "grim_get_save_filename", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_get_save_filename", "", "filetypegrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_kill_notify", "grim_kill_notify", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_kill_notify", "", "top", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_load_files", "grim_load_files", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_load_files", "", "load_pathgrim_datafilenames", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_deactivate_all", "grim_deactivate_all", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_deactivate_all", "", "grim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_activate_all", "grim_activate_all", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_activate_all", "", "grim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_modify_colors", "grim_modify_colors", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_modify_colors", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_edit_header", "grim_edit_header", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_edit_header", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_edit_notes", "grim_edit_notes", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_edit_notes", "", "planegrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_user_ptd_fname", "grim_user_ptd_fname", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_user_ptd_fname", "", "basenamegrim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_write_user_points", "grim_write_user_points", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_write_user_points", "", "fnamegrim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_mask_fname", "grim_mask_fname", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_mask_fname", "", "basenamegrim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_write_mask", "grim_write_mask", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_write_mask", "", "fnamegrim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_read_user_points", "grim_read_user_points", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_read_user_points", "", "grim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_read_mask", "grim_read_mask", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_read_mask", "", "fnamegrim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_jumpto", "grim_jumpto", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_jumpto", "", "grim_dataid", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_recenter", "grim_recenter", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_recenter", "", "grim_datap", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_zoom", "grim_zoom", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_zoom", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_zoom_to_cursor", "grim_zoom_to_cursor", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_zoom_to_cursor", "", "relativezoomzz", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_modes_list", "grim_modes_list", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_modes_list", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_interrupt_begin", "grim_interrupt_begin", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_interrupt_begin", "", "planegrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_interrupt_end", "grim_interrupt_end", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_interrupt_end", "", "planegrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_toggle_context", "grim_toggle_context", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_toggle_context", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_toggle_axes", "grim_toggle_axes", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_toggle_axes", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_render", "grim_render", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_render", "", "planegrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_erase_guideline", "grim_erase_guideline", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_erase_guideline", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_draw_guideline", "grim_draw_guideline", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_draw_guideline", "", "grim_dataxy", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_repeat", "grim_repeat", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_repeat", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_exit", "grim_exit", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_exit", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_undo", "grim_undo", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_undo", "", "grim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_redo", "grim_redo", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_redo", "", "grim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_interrupt_callback", "grim_interrupt_callback", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_interrupt_callback", "", "data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_sampling_fn", "grim_sampling_fn", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_sampling_fn", "", "ddsource_image_pts_sampledata", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_render_dim_fn", "grim_render_dim_fn", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_render_dim_fn", "", "dddim_orig", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_render_sampling_fn", "grim_render_sampling_fn", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_render_sampling_fn", "", "ddsource_image_pts_samplesource_image_pts_grid", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_draw_vectors", "grim_draw_vectors", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_draw_vectors", "", "cdcurves_ptdpoints_ptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_increment_mode", "grim_increment_mode", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_increment_mode", "", "grim_datadm", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_event", "grim_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_update_guideline", "grim_update_guideline", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_update_guideline", "", "grim_dataplanexy", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_update_xy_label", "grim_update_xy_label", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_update_xy_label", "", "grim_dataplanexy", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_scroll", "grim_scroll", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_scroll", "", "grim_dataplaneclicksmodifiers", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_middle", "grim_middle", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_middle", "", "grim_dataplaneidxypressclicksmodifiersoutput_wnum", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_draw_event", "grim_draw_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_draw_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_file_load_help_event", "grim_menu_file_load_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_load_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_file_load_event", "grim_menu_file_load_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_load_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_file_browse_help_event", "grim_menu_file_browse_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_browse_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_browse_file_left_event", "grim_browse_file_left_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_browse_file_left_event", "", "statusbaseiid", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_file_browse_event", "grim_menu_file_browse_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_browse_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_file_save_help_event", "grim_menu_file_save_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_save_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_file_save_event", "grim_menu_file_save_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_save_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_file_save_as_help_event", "grim_menu_file_save_as_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_save_as_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_file_save_as_event", "grim_menu_file_save_as_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_save_as_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_open_as_rgb_help_event", "grim_menu_open_as_rgb_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_open_as_rgb_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_open_as_rgb_event", "grim_menu_open_as_rgb_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_open_as_rgb_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_file_save_user_ptd_help_event", "grim_menu_file_save_user_ptd_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_save_user_ptd_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_file_save_user_ptd_event", "grim_menu_file_save_user_ptd_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_save_user_ptd_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_file_save_all_user_ptd_help_event", "grim_menu_file_save_all_user_ptd_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_save_all_user_ptd_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_file_save_all_user_ptd_event", "grim_menu_file_save_all_user_ptd_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_save_all_user_ptd_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_file_load_user_ptd_help_event", "grim_menu_file_load_user_ptd_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_load_user_ptd_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_file_load_user_ptd_event", "grim_menu_file_load_user_ptd_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_load_user_ptd_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_file_load_all_user_ptd_help_event", "grim_menu_file_load_all_user_ptd_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_load_all_user_ptd_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_file_load_all_user_ptd_event", "grim_menu_file_load_all_user_ptd_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_load_all_user_ptd_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_file_save_tie_ptd_help_event", "grim_menu_file_save_tie_ptd_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_save_tie_ptd_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_file_save_tie_ptd_event", "grim_menu_file_save_tie_ptd_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_save_tie_ptd_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_file_save_all_tie_ptd_help_event", "grim_menu_file_save_all_tie_ptd_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_save_all_tie_ptd_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_file_save_all_tie_ptd_event", "grim_menu_file_save_all_tie_ptd_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_save_all_tie_ptd_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_file_load_tie_ptd_help_event", "grim_menu_file_load_tie_ptd_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_load_tie_ptd_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_file_load_tie_ptd_event", "grim_menu_file_load_tie_ptd_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_load_tie_ptd_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_file_load_all_tie_ptd_help_event", "grim_menu_file_load_all_tie_ptd_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_load_all_tie_ptd_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_file_load_all_tie_ptd_event", "grim_menu_file_load_all_tie_ptd_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_load_all_tie_ptd_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_file_save_curves_help_event", "grim_menu_file_save_curves_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_save_curves_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_file_save_curves_event", "grim_menu_file_save_curves_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_save_curves_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_file_save_all_curves_help_event", "grim_menu_file_save_all_curves_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_save_all_curves_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_file_save_all_curves_event", "grim_menu_file_save_all_curves_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_save_all_curves_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_file_load_curves_help_event", "grim_menu_file_load_curves_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_load_curves_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_file_load_curves_event", "grim_menu_file_load_curves_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_load_curves_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_file_load_all_curves_help_event", "grim_menu_file_load_all_curves_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_load_all_curves_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_file_load_all_curves_event", "grim_menu_file_load_all_curves_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_load_all_curves_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_file_save_mask_help_event", "grim_menu_file_save_mask_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_save_mask_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_file_save_mask_event", "grim_menu_file_save_mask_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_save_mask_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_file_save_all_masks_help_event", "grim_menu_file_save_all_masks_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_save_all_masks_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_file_save_all_masks_event", "grim_menu_file_save_all_masks_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_save_all_masks_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_file_load_mask_help_event", "grim_menu_file_load_mask_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_load_mask_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_file_load_mask_event", "grim_menu_file_load_mask_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_load_mask_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_file_load_all_masks_help_event", "grim_menu_file_load_all_masks_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_load_all_masks_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_file_load_all_masks_event", "grim_menu_file_load_all_masks_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_load_all_masks_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_file_save_ps_help_event", "grim_menu_file_save_ps_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_save_ps_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_file_save_ps_event", "grim_menu_file_save_ps_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_save_ps_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_repeat_help_event", "grim_menu_repeat_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_repeat_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_repeat_event", "grim_menu_repeat_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_repeat_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_undo_help_event", "grim_menu_undo_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_undo_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_undo_event", "grim_menu_undo_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_undo_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_redo_help_event", "grim_menu_redo_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_redo_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_redo_event", "grim_menu_redo_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_redo_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_select_help_event", "grim_select_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_select_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_select_event", "grim_select_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_select_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_identify_help_event", "grim_identify_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_identify_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_identify_event", "grim_identify_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_identify_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_file_close_help_event", "grim_menu_file_close_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_close_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_file_close_event", "grim_menu_file_close_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_file_close_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_plane_next_help_event", "grim_menu_plane_next_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_next_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_plane_next_event", "grim_menu_plane_next_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_next_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_plane_previous_help_event", "grim_menu_plane_previous_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_previous_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_plane_previous_event", "grim_menu_plane_previous_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_previous_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_plane_jump_help_event", "grim_menu_plane_jump_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_jump_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_plane_jump_event", "grim_menu_plane_jump_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_jump_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_plane_browse_help_event", "grim_menu_plane_browse_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_browse_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_browse_plane_left_event", "grim_browse_plane_left_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_browse_plane_left_event", "", "statusbaseiid", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_browse_refresh_event", "grim_browse_refresh_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_browse_refresh_event", "", "data_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_plane_browse_event", "grim_menu_plane_browse_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_browse_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_plane_open_help_event", "grim_menu_plane_open_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_open_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_plane_open_event", "grim_menu_plane_open_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_open_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_plane_evolve_help_event", "grim_menu_plane_evolve_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_evolve_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_plane_evolve_event", "grim_menu_plane_evolve_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_evolve_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_plane_crop_help_event", "grim_menu_plane_crop_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_crop_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_plane_crop_event", "grim_menu_plane_crop_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_crop_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_plane_reorder_time_help_event", "grim_menu_plane_reorder_time_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_reorder_time_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_plane_reorder_time_event", "grim_menu_plane_reorder_time_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_reorder_time_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_plane_sequence_help_event", "grim_menu_plane_sequence_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_sequence_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_plane_sequence_event", "grim_menu_plane_sequence_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_sequence_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_plane_dump_help_event", "grim_menu_plane_dump_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_dump_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_plane_dump_event", "grim_menu_plane_dump_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_dump_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_plane_coregister_help_event", "grim_menu_plane_coregister_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_coregister_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_plane_coregister_event", "grim_menu_plane_coregister_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_coregister_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_plane_coadd_help_event", "grim_menu_plane_coadd_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_coadd_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_plane_coadd_event", "grim_menu_plane_coadd_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_coadd_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_plane_toggle_plane_syncing_help_event", "grim_menu_plane_toggle_plane_syncing_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_toggle_plane_syncing_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_plane_toggle_plane_syncing_event", "grim_menu_plane_toggle_plane_syncing_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_toggle_plane_syncing_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_plane_highlight_help_event", "grim_menu_plane_highlight_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_highlight_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_plane_highlight_event", "grim_menu_plane_highlight_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_highlight_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_plane_copy_tiepoints_help_event", "grim_menu_plane_copy_tiepoints_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_copy_tiepoints_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_plane_copy_tiepoints_event", "grim_menu_plane_copy_tiepoints_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_copy_tiepoints_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_plane_propagate_tiepoints_help_event", "grim_menu_plane_propagate_tiepoints_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_propagate_tiepoints_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_plane_propagate_tiepoints_event", "grim_menu_plane_propagate_tiepoints_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_propagate_tiepoints_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_plane_toggle_tiepoint_syncing_help_event", "grim_menu_plane_toggle_tiepoint_syncing_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_toggle_tiepoint_syncing_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_plane_toggle_tiepoint_syncing_event", "grim_menu_plane_toggle_tiepoint_syncing_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_toggle_tiepoint_syncing_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_plane_clear_tiepoints_help_event", "grim_menu_plane_clear_tiepoints_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_clear_tiepoints_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_plane_clear_tiepoints_event", "grim_menu_plane_clear_tiepoints_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_clear_tiepoints_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_plane_copy_curves_help_event", "grim_menu_plane_copy_curves_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_copy_curves_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_plane_copy_curves_event", "grim_menu_plane_copy_curves_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_copy_curves_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_plane_toggle_curve_syncing_help_event", "grim_menu_plane_toggle_curve_syncing_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_toggle_curve_syncing_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_plane_toggle_curve_syncing_event", "grim_menu_plane_toggle_curve_syncing_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_toggle_curve_syncing_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_plane_clear_curves_help_event", "grim_menu_plane_clear_curves_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_clear_curves_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_plane_clear_curves_event", "grim_menu_plane_clear_curves_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_clear_curves_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_plane_copy_mask_help_event", "grim_menu_plane_copy_mask_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_copy_mask_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_plane_copy_mask_event", "grim_menu_plane_copy_mask_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_copy_mask_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_plane_clear_mask_help_event", "grim_menu_plane_clear_mask_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_clear_mask_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_plane_clear_mask_event", "grim_menu_plane_clear_mask_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_clear_mask_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_plane_settings_help_event", "grim_menu_plane_settings_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_settings_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_plane_settings_event", "grim_menu_plane_settings_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_plane_settings_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_data_adjust_help_event", "grim_menu_data_adjust_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_data_adjust_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_data_adjust_event", "grim_menu_data_adjust_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_data_adjust_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_refresh_help_event", "grim_menu_view_refresh_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_refresh_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_refresh_event", "grim_menu_view_refresh_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_refresh_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_zoom_help_event", "grim_menu_view_zoom_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_zoom_event", "grim_menu_view_zoom_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_zoom_double_help_event", "grim_menu_view_zoom_double_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_double_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_zoom_double_event", "grim_menu_view_zoom_double_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_double_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_zoom_half_help_event", "grim_menu_view_zoom_half_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_half_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_zoom_half_event", "grim_menu_view_zoom_half_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_half_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_zoom_1_help_event", "grim_menu_view_zoom_1_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_1_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_zoom_1_event", "grim_menu_view_zoom_1_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_1_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_zoom_2_help_event", "grim_menu_view_zoom_2_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_2_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_zoom_2_event", "grim_menu_view_zoom_2_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_2_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_zoom_3_help_event", "grim_menu_view_zoom_3_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_3_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_zoom_3_event", "grim_menu_view_zoom_3_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_3_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_zoom_4_help_event", "grim_menu_view_zoom_4_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_4_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_zoom_4_event", "grim_menu_view_zoom_4_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_4_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_zoom_5_help_event", "grim_menu_view_zoom_5_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_5_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_zoom_5_event", "grim_menu_view_zoom_5_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_5_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_zoom_6_help_event", "grim_menu_view_zoom_6_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_6_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_zoom_6_event", "grim_menu_view_zoom_6_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_6_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_zoom_7_help_event", "grim_menu_view_zoom_7_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_7_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_zoom_7_event", "grim_menu_view_zoom_7_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_7_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_zoom_8_help_event", "grim_menu_view_zoom_8_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_8_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_zoom_8_event", "grim_menu_view_zoom_8_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_8_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_zoom_9_help_event", "grim_menu_view_zoom_9_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_9_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_zoom_9_event", "grim_menu_view_zoom_9_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_9_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_zoom_10_help_event", "grim_menu_view_zoom_10_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_10_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_zoom_10_event", "grim_menu_view_zoom_10_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_10_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_zoom_1_2_help_event", "grim_menu_view_zoom_1_2_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_1_2_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_zoom_1_2_event", "grim_menu_view_zoom_1_2_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_1_2_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_zoom_1_3_help_event", "grim_menu_view_zoom_1_3_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_1_3_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_zoom_1_3_event", "grim_menu_view_zoom_1_3_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_1_3_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_zoom_1_4_help_event", "grim_menu_view_zoom_1_4_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_1_4_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_zoom_1_4_event", "grim_menu_view_zoom_1_4_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_1_4_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_zoom_1_5_help_event", "grim_menu_view_zoom_1_5_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_1_5_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_zoom_1_5_event", "grim_menu_view_zoom_1_5_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_1_5_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_zoom_1_5_help_event", "grim_menu_view_zoom_1_5_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_1_5_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_zoom_1_5_event", "grim_menu_view_zoom_1_5_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_1_5_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_zoom_1_6_help_event", "grim_menu_view_zoom_1_6_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_1_6_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_zoom_1_6_event", "grim_menu_view_zoom_1_6_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_1_6_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_zoom_1_7_help_event", "grim_menu_view_zoom_1_7_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_1_7_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_zoom_1_7_event", "grim_menu_view_zoom_1_7_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_1_7_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_zoom_1_8_help_event", "grim_menu_view_zoom_1_8_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_1_8_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_zoom_1_8_event", "grim_menu_view_zoom_1_8_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_1_8_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_zoom_1_9_help_event", "grim_menu_view_zoom_1_9_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_1_9_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_zoom_1_9_event", "grim_menu_view_zoom_1_9_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_1_9_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_zoom_1_10_help_event", "grim_menu_view_zoom_1_10_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_1_10_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_zoom_1_10_event", "grim_menu_view_zoom_1_10_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_zoom_1_10_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_rotate_0_help_event", "grim_menu_view_rotate_0_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_rotate_0_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_rotate_0_event", "grim_menu_view_rotate_0_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_rotate_0_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_rotate_1_help_event", "grim_menu_view_rotate_1_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_rotate_1_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_rotate_1_event", "grim_menu_view_rotate_1_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_rotate_1_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_rotate_2_help_event", "grim_menu_view_rotate_2_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_rotate_2_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_rotate_2_event", "grim_menu_view_rotate_2_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_rotate_2_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_rotate_3_help_event", "grim_menu_view_rotate_3_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_rotate_3_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_rotate_3_event", "grim_menu_view_rotate_3_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_rotate_3_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_rotate_4_help_event", "grim_menu_view_rotate_4_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_rotate_4_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_rotate_4_event", "grim_menu_view_rotate_4_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_rotate_4_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_rotate_5_help_event", "grim_menu_view_rotate_5_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_rotate_5_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_rotate_5_event", "grim_menu_view_rotate_5_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_rotate_5_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_rotate_6_help_event", "grim_menu_view_rotate_6_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_rotate_6_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_rotate_6_event", "grim_menu_view_rotate_6_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_rotate_6_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_rotate_7_help_event", "grim_menu_view_rotate_7_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_rotate_7_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_rotate_7_event", "grim_menu_view_rotate_7_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_rotate_7_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_recenter_help_event", "grim_menu_view_recenter_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_recenter_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_recenter_event", "grim_menu_view_recenter_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_recenter_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_apply_help_event", "grim_menu_view_apply_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_apply_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_apply_event", "grim_menu_view_apply_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_apply_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_home_help_event", "grim_menu_view_home_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_home_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_home_event", "grim_menu_view_home_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_home_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_save_help_event", "grim_menu_view_save_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_save_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_save_event", "grim_menu_view_save_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_save_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_restore_help_event", "grim_menu_view_restore_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_restore_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_restore_event", "grim_menu_view_restore_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_restore_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_previous_help_event", "grim_menu_view_previous_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_previous_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_previous_event", "grim_menu_view_previous_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_previous_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_entire_help_event", "grim_menu_view_entire_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_entire_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_entire_event", "grim_menu_view_entire_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_entire_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_initial_help_event", "grim_menu_view_initial_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_initial_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_initial_event", "grim_menu_view_initial_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_initial_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_flip_help_event", "grim_menu_view_flip_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_flip_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_flip_event", "grim_menu_view_flip_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_flip_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_frame_help_event", "grim_menu_view_frame_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_frame_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_frame_event", "grim_menu_view_frame_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_frame_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_header_help_event", "grim_menu_view_header_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_header_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_header_event", "grim_menu_view_header_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_header_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_notes_help_event", "grim_menu_notes_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_notes_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_notes_event", "grim_menu_notes_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_notes_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_image_help_event", "grim_menu_image_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_image_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_toggle_image_event", "grim_menu_toggle_image_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_toggle_image_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_image_overlays_help_event", "grim_menu_image_overlays_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_image_overlays_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_toggle_image_overlays_event", "grim_menu_toggle_image_overlays_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_toggle_image_overlays_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_context_help_event", "grim_menu_context_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_context_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_context_event", "grim_menu_context_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_context_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_axes_help_event", "grim_menu_axes_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_axes_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_axes_event", "grim_menu_axes_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_axes_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_render_help_event", "grim_menu_render_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_render_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_render_event", "grim_menu_render_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_render_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_colors_help_event", "grim_menu_view_colors_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_colors_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_view_colors_event", "grim_menu_view_colors_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_view_colors_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_points_planet_centers_help_event", "grim_menu_points_planet_centers_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_points_planet_centers_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_points_planet_centers_event", "grim_menu_points_planet_centers_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_points_planet_centers_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_points_limbs_help_event", "grim_menu_points_limbs_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_points_limbs_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_points_limbs_event", "grim_menu_points_limbs_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_points_limbs_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_points_terminators_help_event", "grim_menu_points_terminators_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_points_terminators_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_points_terminators_event", "grim_menu_points_terminators_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_points_terminators_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_points_planet_grids_help_event", "grim_menu_points_planet_grids_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_points_planet_grids_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_points_planet_grids_event", "grim_menu_points_planet_grids_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_points_planet_grids_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_points_rings_help_event", "grim_menu_points_rings_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_points_rings_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_points_rings_event", "grim_menu_points_rings_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_points_rings_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_points_ring_grids_help_event", "grim_menu_points_ring_grids_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_points_ring_grids_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_points_ring_grids_event", "grim_menu_points_ring_grids_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_points_ring_grids_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_points_stations_help_event", "grim_menu_points_stations_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_points_stations_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_points_stations_event", "grim_menu_points_stations_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_points_stations_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_points_arrays_help_event", "grim_menu_points_arrays_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_points_arrays_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_points_arrays_event", "grim_menu_points_arrays_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_points_arrays_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_points_stars_help_event", "grim_menu_points_stars_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_points_stars_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_points_stars_event", "grim_menu_points_stars_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_points_stars_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_points_shadows_help_event", "grim_menu_points_shadows_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_points_shadows_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_points_shadows_event", "grim_menu_points_shadows_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_points_shadows_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_points_reflections_help_event", "grim_menu_points_reflections_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_points_reflections_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_points_reflections_event", "grim_menu_points_reflections_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_points_reflections_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_hide_all_help_event", "grim_menu_hide_all_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_hide_all_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_hide_all_event", "grim_menu_hide_all_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_hide_all_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_clear_all_help_event", "grim_menu_clear_all_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_clear_all_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_clear_all_event", "grim_menu_clear_all_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_clear_all_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_clear_active_help_event", "grim_menu_clear_active_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_clear_active_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_clear_active_event", "grim_menu_clear_active_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_clear_active_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_activate_all_help_event", "grim_menu_activate_all_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_activate_all_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_activate_all_event", "grim_menu_activate_all_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_activate_all_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_deactivate_all_help_event", "grim_menu_deactivate_all_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_deactivate_all_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_deactivate_all_event", "grim_menu_deactivate_all_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_deactivate_all_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_invert_all_help_event", "grim_menu_invert_all_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_invert_all_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_invert_event", "grim_menu_invert_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_invert_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_points_settings_help_event", "grim_menu_points_settings_help_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_points_settings_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_points_settings_event", "grim_menu_points_settings_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_points_settings_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_previous_event", "grim_previous_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_previous_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_jumpto_event", "grim_jumpto_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_jumpto_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_next_event", "grim_next_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_next_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_crop_event", "grim_crop_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_crop_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_refresh_event", "grim_refresh_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_refresh_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_entire_event", "grim_entire_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_entire_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_view_previous_event", "grim_view_previous_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_view_previous_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_colors_event", "grim_colors_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_colors_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_settings_event", "grim_settings_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_settings_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_header_event", "grim_header_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_header_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_notes_event", "grim_notes_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_notes_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_undo_event", "grim_undo_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_undo_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_redo_event", "grim_redo_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_redo_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_toggle_image_event", "grim_toggle_image_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_toggle_image_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_toggle_image_overlays_event", "grim_toggle_image_overlays_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_toggle_image_overlays_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_hide_event", "grim_hide_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_hide_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_tracking_event", "grim_tracking_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_tracking_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_grid_event", "grim_grid_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_grid_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_pixel_grid_event", "grim_pixel_grid_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_pixel_grid_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_guideline_event", "grim_guideline_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_guideline_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_context_event", "grim_context_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_context_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_axes_event", "grim_axes_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_axes_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_render_event", "grim_render_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_render_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_activate_all_event", "grim_activate_all_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_activate_all_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_deactivate_all_event", "grim_deactivate_all_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_deactivate_all_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_repeat_event", "grim_repeat_event", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_repeat_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_help", "grim_help", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_help", "", "grim_datatext", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_create_help_menu", "grim_create_help_menu", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_create_help_menu", "", "_menu_desc", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_cull_menu_desc", "grim_cull_menu_desc", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_cull_menu_desc", "", "map_itemsmap_indicesod_map_itemsod_map_indicesplot_itemsplot_indicesplot_only_itemsplot_only_indicesbeta_only_indices_menu_descplotmapbeta", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_parse_menu_desc", "grim_parse_menu_desc", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_parse_menu_desc", "", "map_itemsmap_indicesod_map_itemsod_map_indicesplot_itemsplot_indicesplot_only_itemsplot_only_indicesbeta_only_indices_menu_desc", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_desc", "grim_menu_desc", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_desc", "", "cursor_modes", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_get_window_size", "grim_get_window_size", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_get_window_size", "", "xsizeysizegrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_menu_capture", "grim_menu_capture", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_menu_capture", "", "fnevent", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_widgets", "grim_widgets", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_widgets", "", "xsizeysizecursor_modesmenu_fnamemenu_extensionsgrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_get_default_zoom", "grim_get_default_zoom", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_get_default_zoom", "", "dd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_save_initial_view", "grim_save_initial_view", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_save_initial_view", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_initial_framing", "grim_initial_framing", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_initial_framing", "", "delay_overlaysgrim_dataframe", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_initial_overlays", "grim_initial_overlays", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_initial_overlays", "", "planeexcludeonlytempptdgrim_data_overlays", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_rgb_dim_fn", "grim_rgb_dim_fn", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_rgb_dim_fn", "", "dddat", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_get_arg", "grim_get_arg", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_get_arg", "", "ddgrnumextensionsarg", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_get_args", "grim_get_args", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_get_args", "", "ddgrnumtypexzeronhistmaintaincompressextensionsrgbarg1arg2", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim_create_cursor_mode", "grim_create_cursor_mode", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_create_cursor_mode", "", "no_prefixnamemode_argscursor_modes", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim.html#grim", "grim", 'routine in <a href="nv/grim/grim.html">grim.pro</a>', "grim.pro", "", "grim", "", "gd_extracdpdrdsdstdardsundodnewxsizeysizedefaultpreviousrestoreactivatedoffsetno_erasefilterrgbvisibilitychannelexitzoomrotateorderoffsetretainmaintainmode_initmodalxzeroframerefresh_callbacksrefresh_callback_data_psplane_callbacksplane_callback_data_psnhistcompresspathsymsizeuser_psymworkdirmode_argssave_pathload_pathoverlayspnmenu_fnamecursor_swapfovcliphidemenu_extensionsbutton_extensionsarg_extensionsloadctmaxgrnumextensionsbetarenderingnpointscam_trsplt_trsrng_trsstr_trssun_trsstn_trsarr_trsassoc_ddplane_syncingtiepoint_syncingcurve_syncingrender_samplerender_pht_minslave_overlayspositiondelay_overlaysauto_stretchcolorxrangeyrangethicknsumnddxtitleytitlepsymtitlearg1arg2", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/grim/grim_bitmaps_include.html", "grim_bitmaps_include.pro", '.pro file in <a href="nv/grim/dir-overview.html">nv/grim/ directory</a>', "grim_bitmaps_include.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/grim/grim_bitmaps_include.html#grim_identify_bitmap", "grim_identify_bitmap", 'routine in <a href="nv/grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_identify_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_bitmaps_include.html#grim_rotate_bitmap", "grim_rotate_bitmap", 'routine in <a href="nv/grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_rotate_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_bitmaps_include.html#grim_reorient_bitmap", "grim_reorient_bitmap", 'routine in <a href="nv/grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_reorient_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_bitmaps_include.html#grim_mp40_bitmap", "grim_mp40_bitmap", 'routine in <a href="nv/grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_mp40_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_bitmaps_include.html#grim_dagger_bitmap", "grim_dagger_bitmap", 'routine in <a href="nv/grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_dagger_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_bitmaps_include.html#grim_crop_bitmap", "grim_crop_bitmap", 'routine in <a href="nv/grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_crop_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_bitmaps_include.html#grim_redo_bitmap", "grim_redo_bitmap", 'routine in <a href="nv/grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_redo_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_bitmaps_include.html#grim_undo_bitmap", "grim_undo_bitmap", 'routine in <a href="nv/grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_undo_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_bitmaps_include.html#grim_notes_bitmap", "grim_notes_bitmap", 'routine in <a href="nv/grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_notes_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_bitmaps_include.html#grim_remove1_bitmap", "grim_remove1_bitmap", 'routine in <a href="nv/grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_remove1_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_bitmaps_include.html#grim_remove2_bitmap", "grim_remove2_bitmap", 'routine in <a href="nv/grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_remove2_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_bitmaps_include.html#grim_repeat_bitmap", "grim_repeat_bitmap", 'routine in <a href="nv/grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_repeat_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_bitmaps_include.html#grim_unselect_bitmap", "grim_unselect_bitmap", 'routine in <a href="nv/grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_unselect_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_bitmaps_include.html#grim_select_bitmap", "grim_select_bitmap", 'routine in <a href="nv/grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_select_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_bitmaps_include.html#grim_context_bitmap", "grim_context_bitmap", 'routine in <a href="nv/grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_context_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_bitmaps_include.html#grim_previous_bitmap", "grim_previous_bitmap", 'routine in <a href="nv/grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_previous_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_bitmaps_include.html#grim_next_bitmap", "grim_next_bitmap", 'routine in <a href="nv/grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_next_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_bitmaps_include.html#grim_mag_bitmap", "grim_mag_bitmap", 'routine in <a href="nv/grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_mag_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_bitmaps_include.html#grim_refresh_bitmap", "grim_refresh_bitmap", 'routine in <a href="nv/grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_refresh_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_bitmaps_include.html#grim_entire_bitmap", "grim_entire_bitmap", 'routine in <a href="nv/grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_entire_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_bitmaps_include.html#grim_view_previous_bitmap", "grim_view_previous_bitmap", 'routine in <a href="nv/grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_view_previous_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_bitmaps_include.html#grim_hide_bitmap", "grim_hide_bitmap", 'routine in <a href="nv/grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_hide_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_bitmaps_include.html#grim_unhide_bitmap", "grim_unhide_bitmap", 'routine in <a href="nv/grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_unhide_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_bitmaps_include.html#grim_colors_bitmap", "grim_colors_bitmap", 'routine in <a href="nv/grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_colors_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_bitmaps_include.html#grim_tracking_bitmap", "grim_tracking_bitmap", 'routine in <a href="nv/grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_tracking_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_bitmaps_include.html#grim_activate_all_bitmap", "grim_activate_all_bitmap", 'routine in <a href="nv/grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_activate_all_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_bitmaps_include.html#grim_deactivate_all_bitmap", "grim_deactivate_all_bitmap", 'routine in <a href="nv/grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_deactivate_all_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_bitmaps_include.html#grim_grid_bitmap", "grim_grid_bitmap", 'routine in <a href="nv/grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_grid_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_bitmaps_include.html#grim_header_bitmap", "grim_header_bitmap", 'routine in <a href="nv/grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_header_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_bitmaps_include.html#grim_axes_bitmap", "grim_axes_bitmap", 'routine in <a href="nv/grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_axes_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_bitmaps_include.html#grim_unhide_image_bitmap", "grim_unhide_image_bitmap", 'routine in <a href="nv/grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_unhide_image_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_bitmaps_include.html#grim_hide_image_bitmap", "grim_hide_image_bitmap", 'routine in <a href="nv/grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_hide_image_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_bitmaps_include.html#grim_unrender_bitmap", "grim_unrender_bitmap", 'routine in <a href="nv/grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_unrender_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_bitmaps_include.html#grim_render_bitmap", "grim_render_bitmap", 'routine in <a href="nv/grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_render_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_bitmaps_include.html#grim_settings_bitmap", "grim_settings_bitmap", 'routine in <a href="nv/grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_settings_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_bitmaps_include.html#grim_pixel_grid_bitmap", "grim_pixel_grid_bitmap", 'routine in <a href="nv/grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_pixel_grid_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_bitmaps_include.html#grim_guideline_bitmap", "grim_guideline_bitmap", 'routine in <a href="nv/grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_guideline_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_bitmaps_include.html#grim_bitmaps_include", "grim_bitmaps_include", 'routine in <a href="nv/grim/grim_bitmaps_include.html">grim_bitmaps_include.pro</a>', "grim_bitmaps_include.pro", "", "grim_bitmaps_include", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/grim/grim_colortool.html", "grim_colortool.pro", '.pro file in <a href="nv/grim/dir-overview.html">nv/grim/ directory</a>', "grim_colortool.pro", "", "", " NAME: 	GRIM_COLORTOOL    PURPOSE: 	Tool for adjusting colors in GRIM.    CATEGORY: 	NV/GRIM    CALLING SEQUENCE:  	grim_colortool    ARGUMENTS: NONE    KEYWORDS: NONE    OPERATION: 	Color table plot: 		Displays a plot of the current color table, with a color 		bar at the bottom.  	Stretch Top slider: 		Controls the top value for the color table stretch.  	Stretch Bottom slider: 		Controls the bottom value for the color table stretch.  	Gamma slider: 		Controls the gamma value for the color table stretch.  	Shade slider: 		Vertial slider on the left side of the tool controlling the 		total brightness.  	Color table droplist: 		Selects IDL color table.  	Auto button: 		Performs an automatic stretch.  	All button: 		If set (or activated), the current color table is applied 		to all GRIM planes.  If 'Auto' is pressed while 'All' is 		on, the automatic stretch is performed independently for 		each plane.    SEE ALSO: 	grim    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/grim/grim_colortool.html#grct_slider_to_gamma", "grct_slider_to_gamma", 'routine in <a href="nv/grim/grim_colortool.html">grim_colortool.pro</a>', "grim_colortool.pro", "", "grct_slider_to_gamma", "", "value", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_colortool.html#grct_gamma_to_slider", "grct_gamma_to_slider", 'routine in <a href="nv/grim/grim_colortool.html">grim_colortool.pro</a>', "grim_colortool.pro", "", "grct_gamma_to_slider", "", "value", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_colortool.html#grct_print_gamma", "grct_print_gamma", 'routine in <a href="nv/grim/grim_colortool.html">grim_colortool.pro</a>', "grim_colortool.pro", "", "grct_print_gamma", "", "data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_colortool.html#grct_widget_to_descriptor", "grct_widget_to_descriptor", 'routine in <a href="nv/grim/grim_colortool.html">grim_colortool.pro</a>', "grim_colortool.pro", "", "grct_widget_to_descriptor", "", "datacmd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_colortool.html#grct_descriptor_to_widget", "grct_descriptor_to_widget", 'routine in <a href="nv/grim/grim_colortool.html">grim_colortool.pro</a>', "grim_colortool.pro", "", "grct_descriptor_to_widget", "", "noslidedatacmd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_colortool.html#grct_plot", "grct_plot", 'routine in <a href="nv/grim/grim_colortool.html">grim_colortool.pro</a>', "grim_colortool.pro", "", "grct_plot", "", "data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_colortool.html#grct_cleanup", "grct_cleanup", 'routine in <a href="nv/grim/grim_colortool.html">grim_colortool.pro</a>', "grim_colortool.pro", "", "grct_cleanup", "", "base", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_colortool.html#grct_update", "grct_update", 'routine in <a href="nv/grim/grim_colortool.html">grim_colortool.pro</a>', "grim_colortool.pro", "", "grct_update", "", "allautocmd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_colortool.html#grim_colortool_event", "grim_colortool_event", 'routine in <a href="nv/grim/grim_colortool.html">grim_colortool.pro</a>', "grim_colortool.pro", "", "grim_colortool_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_colortool.html#grim_colortool_change", "grim_colortool_change", 'routine in <a href="nv/grim/grim_colortool.html">grim_colortool.pro</a>', "grim_colortool.pro", "", "grim_colortool_change", "", "base", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_colortool.html#grct_primary_notify", "grct_primary_notify", 'routine in <a href="nv/grim/grim_colortool.html">grim_colortool.pro</a>', "grim_colortool.pro", "", "grct_primary_notify", "", "data_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_colortool.html#grim_colortool", "grim_colortool", 'routine in <a href="nv/grim/grim_colortool.html">grim_colortool.pro</a>', "grim_colortool.pro", "", "grim_colortool", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/grim/grim_compute_include.html", "grim_compute_include.pro", '.pro file in <a href="nv/grim/dir-overview.html">nv/grim/ directory</a>', "grim_compute_include.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/grim/grim_compute_include.html#grim_compute_planet_center", "grim_compute_planet_center", 'routine in <a href="nv/grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_compute_planet_center", "", "mapcliphidegdactive_xdsactive_ptddatanpoints", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_compute_include.html#grim_symsize_planet_center", "grim_symsize_planet_center", 'routine in <a href="nv/grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_symsize_planet_center", "", "data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_compute_include.html#grim_shade_planet_center", "grim_shade_planet_center", 'routine in <a href="nv/grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_shade_planet_center", "", "dataptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_compute_include.html#grim_compute_limb", "grim_compute_limb", 'routine in <a href="nv/grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_compute_limb", "", "mapcliphidegdactive_xdsactive_ptddatanpoints", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_compute_include.html#grim_symsize_limb", "grim_symsize_limb", 'routine in <a href="nv/grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_symsize_limb", "", "data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_compute_include.html#grim_shade_limb", "grim_shade_limb", 'routine in <a href="nv/grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_shade_limb", "", "dataptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_compute_include.html#grim_compute_terminator", "grim_compute_terminator", 'routine in <a href="nv/grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_compute_terminator", "", "mapcliphidegdactive_xdsactive_ptddatanpoints", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_compute_include.html#grim_symsize_terminator", "grim_symsize_terminator", 'routine in <a href="nv/grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_symsize_terminator", "", "data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_compute_include.html#grim_shade_terminator", "grim_shade_terminator", 'routine in <a href="nv/grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_shade_terminator", "", "dataptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_compute_include.html#grim_compute_planet_grid", "grim_compute_planet_grid", 'routine in <a href="nv/grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_compute_planet_grid", "", "mapcliphidegdactive_xdsactive_ptddatanpoints", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_compute_include.html#grim_symsize_planet_grid", "grim_symsize_planet_grid", 'routine in <a href="nv/grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_symsize_planet_grid", "", "data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_compute_include.html#grim_shade_planet_grid", "grim_shade_planet_grid", 'routine in <a href="nv/grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_shade_planet_grid", "", "dataptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_compute_include.html#grim_compute_station", "grim_compute_station", 'routine in <a href="nv/grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_compute_station", "", "mapcliphidegdactive_xdsactive_ptddatanpoints", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_compute_include.html#grim_symsize_station", "grim_symsize_station", 'routine in <a href="nv/grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_symsize_station", "", "data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_compute_include.html#grim_shade_station", "grim_shade_station", 'routine in <a href="nv/grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_shade_station", "", "dataptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_compute_include.html#grim_compute_array", "grim_compute_array", 'routine in <a href="nv/grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_compute_array", "", "mapcliphidegdactive_xdsactive_ptddatanpoints", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_compute_include.html#grim_symsize_array", "grim_symsize_array", 'routine in <a href="nv/grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_symsize_array", "", "data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_compute_include.html#grim_shade_array", "grim_shade_array", 'routine in <a href="nv/grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_shade_array", "", "dataptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_compute_include.html#grim_compute_star", "grim_compute_star", 'routine in <a href="nv/grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_compute_star", "", "mapcliphidegdactive_xdsactive_ptddatanpoints", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_compute_include.html#grim_symsize_star", "grim_symsize_star", 'routine in <a href="nv/grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_symsize_star", "", "data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_compute_include.html#grim_shade_star", "grim_shade_star", 'routine in <a href="nv/grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_shade_star", "", "dataptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_compute_include.html#grim_compute_shadow", "grim_compute_shadow", 'routine in <a href="nv/grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_compute_shadow", "", "mapcliphidegdactive_xdsactive_ptddatanpoints", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_compute_include.html#grim_symsize_shadow", "grim_symsize_shadow", 'routine in <a href="nv/grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_symsize_shadow", "", "data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_compute_include.html#grim_shade_shadow", "grim_shade_shadow", 'routine in <a href="nv/grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_shade_shadow", "", "dataptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_compute_include.html#grim_compute_reflection", "grim_compute_reflection", 'routine in <a href="nv/grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_compute_reflection", "", "mapcliphidegdactive_xdsactive_ptddatanpoints", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_compute_include.html#grim_symsize_reflection", "grim_symsize_reflection", 'routine in <a href="nv/grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_symsize_reflection", "", "data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_compute_include.html#grim_shade_reflection", "grim_shade_reflection", 'routine in <a href="nv/grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_shade_reflection", "", "dataptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_compute_include.html#grim_compute_ring", "grim_compute_ring", 'routine in <a href="nv/grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_compute_ring", "", "mapcliphidegdactive_xdsactive_ptddatanpoints", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_compute_include.html#grim_symsize_ring", "grim_symsize_ring", 'routine in <a href="nv/grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_symsize_ring", "", "data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_compute_include.html#grim_shade_ring", "grim_shade_ring", 'routine in <a href="nv/grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_shade_ring", "", "dataptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_compute_include.html#grim_compute_ring_grid", "grim_compute_ring_grid", 'routine in <a href="nv/grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_compute_ring_grid", "", "mapcliphidegdactive_xdsactive_ptddatanpoints", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_compute_include.html#grim_symsize_ring_grid", "grim_symsize_ring_grid", 'routine in <a href="nv/grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_symsize_ring_grid", "", "data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_compute_include.html#grim_shade_ring_grid", "grim_shade_ring_grid", 'routine in <a href="nv/grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_shade_ring_grid", "", "dataptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_compute_include.html#grim_compute_include", "grim_compute_include", 'routine in <a href="nv/grim/grim_compute_include.html">grim_compute_include.pro</a>', "grim_compute_include.pro", "", "grim_compute_include", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/grim/grim_data_include.html", "grim_data_include.pro", '.pro file in <a href="nv/grim/dir-overview.html">nv/grim/ directory</a>', "grim_data_include.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/grim/grim_data_include.html#grim_blank", "grim_blank", 'routine in <a href="nv/grim/grim_data_include.html">grim_data_include.pro</a>', "grim_data_include.pro", "", "grim_blank", "", "xsizeysize", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_data_include.html#grim_init", "grim_init", 'routine in <a href="nv/grim/grim_data_include.html">grim_data_include.pro</a>', "grim_data_include.pro", "", "grim_init", "", "dd0zoomwnumgrnumfilterretainuser_callbacksuser_psymuser_graphics_fnuser_thickuser_linecursor_swapcmdpathsave_pathload_pathfovclipcam_trsplt_trsrng_trsstr_trsstn_trsarr_trssun_trshidetypecam_selectplt_selectrng_selectsun_selectstr_selectstn_selectarr_selectcolorxrangeyrangepositionnpointsthicknsumxtitleytitlepsymcursor_modessymsizenhistmaintainworkdircompressextensionsmaxbetavisibilitychanneltitleslave_overlaysrender_samplerender_pht_minoverlaysactivatedd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_data_include.html#grim_exists", "grim_exists", 'routine in <a href="nv/grim/grim_data_include.html">grim_data_include.pro</a>', "grim_data_include.pro", "", "grim_exists", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_data_include.html#grim_grnum_to_top", "grim_grnum_to_top", 'routine in <a href="nv/grim/grim_data_include.html">grim_data_include.pro</a>', "grim_data_include.pro", "", "grim_grnum_to_top", "", "grnum", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_data_include.html#grim_get_data", "grim_get_data", 'routine in <a href="nv/grim/grim_data_include.html">grim_data_include.pro</a>', "grim_data_include.pro", "", "grim_get_data", "", "grnumplanedeadprimaryno_wsettop", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_data_include.html#grim_set_data", "grim_set_data", 'routine in <a href="nv/grim/grim_data_include.html">grim_data_include.pro</a>', "grim_data_include.pro", "", "grim_set_data", "", "primarygrim_datatop", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_data_include.html#grim_set_primary", "grim_set_primary", 'routine in <a href="nv/grim/grim_data_include.html">grim_data_include.pro</a>', "grim_data_include.pro", "", "grim_set_primary", "", "top", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_data_include.html#grim_set_mode_data", "grim_set_mode_data", 'routine in <a href="nv/grim/grim_data_include.html">grim_data_include.pro</a>', "grim_data_include.pro", "", "grim_set_mode_data", "", "grim_datadata", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_data_include.html#grim_add_primary_callback", "grim_add_primary_callback", 'routine in <a href="nv/grim/grim_data_include.html">grim_data_include.pro</a>', "grim_data_include.pro", "", "grim_add_primary_callback", "", "callbacksdata_ps", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_data_include.html#grim_rm_primary_callback", "grim_rm_primary_callback", 'routine in <a href="nv/grim/grim_data_include.html">grim_data_include.pro</a>', "grim_data_include.pro", "", "grim_rm_primary_callback", "", "data_ps", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_data_include.html#grim_call_primary_callbacks", "grim_call_primary_callbacks", 'routine in <a href="nv/grim/grim_data_include.html">grim_data_include.pro</a>', "grim_data_include.pro", "", "grim_call_primary_callbacks", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_data_include.html#grim_add_plane_callback", "grim_add_plane_callback", 'routine in <a href="nv/grim/grim_data_include.html">grim_data_include.pro</a>', "grim_data_include.pro", "", "grim_add_plane_callback", "", "topno_wsetcallbacksdata_ps", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_data_include.html#grim_rm_plane_callback", "grim_rm_plane_callback", 'routine in <a href="nv/grim/grim_data_include.html">grim_data_include.pro</a>', "grim_data_include.pro", "", "grim_rm_plane_callback", "", "topdata_ps", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_data_include.html#grim_call_plane_callbacks", "grim_call_plane_callbacks", 'routine in <a href="nv/grim/grim_data_include.html">grim_data_include.pro</a>', "grim_data_include.pro", "", "grim_call_plane_callbacks", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_data_include.html#grim_get_selected", "grim_get_selected", 'routine in <a href="nv/grim/grim_data_include.html">grim_data_include.pro</a>', "grim_data_include.pro", "", "grim_get_selected", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_data_include.html#grim_select", "grim_select", 'routine in <a href="nv/grim/grim_data_include.html">grim_data_include.pro</a>', "grim_data_include.pro", "", "grim_select", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_data_include.html#grim_identify", "grim_identify", 'routine in <a href="nv/grim/grim_data_include.html">grim_data_include.pro</a>', "grim_data_include.pro", "", "grim_identify", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_data_include.html#grim_grnum_create", "grim_grnum_create", 'routine in <a href="nv/grim/grim_data_include.html">grim_data_include.pro</a>', "grim_data_include.pro", "", "grim_grnum_create", "", "top", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_data_include.html#grim_grnum_destroy", "grim_grnum_destroy", 'routine in <a href="nv/grim/grim_data_include.html">grim_data_include.pro</a>', "grim_data_include.pro", "", "grim_grnum_destroy", "", "grnum", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_data_include.html#grim_top_to_grnum", "grim_top_to_grnum", 'routine in <a href="nv/grim/grim_data_include.html">grim_data_include.pro</a>', "grim_data_include.pro", "", "grim_top_to_grnum", "", "newtop", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_data_include.html#grim_jump_to_plane", "grim_jump_to_plane", 'routine in <a href="nv/grim/grim_data_include.html">grim_data_include.pro</a>', "grim_data_include.pro", "", "grim_jump_to_plane", "", "validnosyncgrim_datapn", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_data_include.html#grim_sync_planes", "grim_sync_planes", 'routine in <a href="nv/grim/grim_data_include.html">grim_data_include.pro</a>', "grim_data_include.pro", "", "grim_sync_planes", "", "norefreshgrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_data_include.html#grim_data_include", "grim_data_include", 'routine in <a href="nv/grim/grim_data_include.html">grim_data_include.pro</a>', "grim_data_include.pro", "", "grim_data_include", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html", "grim_default_menus.pro", '.pro file in <a href="nv/grim/dir-overview.html">nv/grim/ directory</a>', "grim_default_menus.pro", "", "", " NAME: 	grim_menu_core_event    PURPOSE: 	This option allows you extract a brightness profile at the selected 	location for each plane in the image.  The left button selects a single 	point, and the right button selects a region to average over.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2016    NAME: 	grim_menu_image_profile_event    PURPOSE: 	This option allows you extract a brightness profile in an arbitrary 	direction in the image.  The left button selects the region's length 	and then width; the right button selects a region with a width of 	one-pixel.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2005    NAME: 	grim_menu_ring_box_profile_radial_event    PURPOSE:   This option allows you create a radial brightness profile from a   rectangular image region.     1) Activate the ring from which you wish to extract the profile.     2) Select this option and use the mouse to outline a ring sector:    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2003    NAME: 	grim_menu_ring_box_profile_longitudinal_event    PURPOSE:   This option allows you create a longitudinal brightness profile from a   rectangular image region.      1) Activate the ring from which you wish to extract the profile.      2) Select this option and use the mouse to outline a ring sector.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 5/2003    NAME: 	grim_menu_ring_profile_radial_event    PURPOSE:   This option allows you create a radial brightness profile.     1) Activate the ring from which you wish to extract the profile.     2) Select this option and use the mouse to outline a ring sector:        Left Button:   the sector is bounded by lines of constant                      longitude.', $       Middle Button: the sector is selected in an arbitrary direction.       Left Button:   the sector is bounded by lines perpendicular to                      the projected longitudinal direction.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 5/2003    NAME: 	grim_menu_ring_profile_longitudinal_event    PURPOSE:   This option allows you create a longitudinal brightness profile.      1) Activate the ring from which you wish to extract the profile.      2) Select this option and use the mouse to outline a ring sector.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 5/2003    NAME: 	grim_menu_limb_profile_azimuthal_event    PURPOSE:   This option allows you create an azimutal brightness profile about a limb.      1) Activate the planet from which you wish to extract the profile.      2) Select this option and use the mouse to outline a sector.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2006    NAME: 	grim_menu_limb_profile_radial_event    PURPOSE:   This option allows you create radial brightness profile across a limb.      1) Activate the planet from which you wish to extract the profile.      2) Select this option and use the mouse to outline a sector.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2006    NAME: 	grim_menu_pointing_manual_event    PURPOSE:    This option allows you to change the pointing manually using pg_drag.      1) Activate the points that you wish to drag.      2) Select this option and use the left button to translate your        points, the middle button to rotate them, and the right button        to accept the change and correct the pointing.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002    NAME: 	grim_menu_pointing_farfit_event    PURPOSE:    This option produces a rough pointing correction by comparing the    active points with edges detected in the image using pg_edges and    pg_farfit.      1) Activate the edges that you wish to correlate.      2) Select this option.     Only active limbs, terminators, and ring edges are used.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002    NAME: 	grim_menu_pointing_renderfit_event    PURPOSE:    This option uses pg_renderfit to produce a pointing correction by comparing    the image with a simulated image.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2017    NAME: 	grim_menu_pointing_lsq_event    PURPOSE: 	Opens a gr_lsqtool widget.  Using the current data, camera, active 	planet, and active ring descriptors.  See gr_lsqtool.pro for details.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2002    NAME: 	grim_menu_toggle_reorigin_event    PURPOSE:    This option allows the user to set whether geometry descriptors are    updated whenever the data array is shifted.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 12/2016    NAME: 	grim_menu_shift_enter_step_event    PURPOSE:    This option prompts the user to enter the step size for the image-shift    menu options.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 1/2012    NAME: 	grim_menu_shift_enter_offset_event    PURPOSE:    This option prompts the user to shift an image by entering an offset.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 1/2012    NAME: 	grim_menu_shift_left_event    PURPOSE:    This option shifts the image left and corrects the camera pointing    accordingly.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2002    NAME: 	grim_menu_shift_right_event    PURPOSE:    This option shifts the image right and corrects the camera pointing    accordingly.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2002    NAME: 	grim_menu_shift_up_event    PURPOSE:    This option shifts the image up and corrects the camera pointing    accordingly.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2002    NAME: 	grim_menu_shift_down_event    PURPOSE:    This option shifts the image down and corrects the camera pointing    accordingly.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2002    NAME: 	grim_menu_corrections_photometry_event    PURPOSE: 	Opens a gr_phttool widget.  Using the primary data, camera, planet, and 	ring descriptors.  See gr_phttool.pro for details.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002    NAME: 	grim_menu_project_map_event    PURPOSE: 	Opens a gr_maptool widget.  Using the primary data, camera, planet, and 	ring descriptors.  See gr_maptool.pro for details.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002    NAME: 	grim_menu_mosaic_event    PURPOSE: 	Uses pg_mosaic to combine all visible image planes into a mosaic. 	The new mosiac is opened in a new grim instance.    CATEGORY: 	NV/GR    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html#grim_menu_core_help_event", "grim_menu_core_help_event", 'routine in <a href="nv/grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_core_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html#grim_menu_core_event", "grim_menu_core_event", 'routine in <a href="nv/grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_core_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html#grim_menu_image_profile_help_event", "grim_menu_image_profile_help_event", 'routine in <a href="nv/grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_image_profile_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html#grim_menu_image_profile_event", "grim_menu_image_profile_event", 'routine in <a href="nv/grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_image_profile_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html#grim_menu_ring_box_profile_radial_help_event", "grim_menu_ring_box_profile_radial_help_event", 'routine in <a href="nv/grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_ring_box_profile_radial_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html#grim_menu_ring_box_profile_radial_event", "grim_menu_ring_box_profile_radial_event", 'routine in <a href="nv/grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_ring_box_profile_radial_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html#grim_menu_ring_box_profile_longitudinal_help_event", "grim_menu_ring_box_profile_longitudinal_help_event", 'routine in <a href="nv/grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_ring_box_profile_longitudinal_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html#grim_menu_ring_box_profile_longitudinal_event", "grim_menu_ring_box_profile_longitudinal_event", 'routine in <a href="nv/grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_ring_box_profile_longitudinal_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html#grim_menu_ring_profile_radial_help_event", "grim_menu_ring_profile_radial_help_event", 'routine in <a href="nv/grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_ring_profile_radial_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html#grim_menu_ring_profile_radial_event", "grim_menu_ring_profile_radial_event", 'routine in <a href="nv/grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_ring_profile_radial_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html#grim_menu_ring_profile_longitudinal_help_event", "grim_menu_ring_profile_longitudinal_help_event", 'routine in <a href="nv/grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_ring_profile_longitudinal_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html#grim_menu_ring_profile_longitudinal_event", "grim_menu_ring_profile_longitudinal_event", 'routine in <a href="nv/grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_ring_profile_longitudinal_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html#grim_menu_limb_profile_azimuthal_help_event", "grim_menu_limb_profile_azimuthal_help_event", 'routine in <a href="nv/grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_limb_profile_azimuthal_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html#grim_menu_limb_profile_azimuthal_event", "grim_menu_limb_profile_azimuthal_event", 'routine in <a href="nv/grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_limb_profile_azimuthal_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html#grim_menu_limb_profile_radial_help_event", "grim_menu_limb_profile_radial_help_event", 'routine in <a href="nv/grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_limb_profile_radial_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html#grim_menu_limb_profile_radial_event", "grim_menu_limb_profile_radial_event", 'routine in <a href="nv/grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_limb_profile_radial_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html#grim_menu_pointing_manual_help_event", "grim_menu_pointing_manual_help_event", 'routine in <a href="nv/grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_pointing_manual_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html#grim_menu_pointing_manual_event", "grim_menu_pointing_manual_event", 'routine in <a href="nv/grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_pointing_manual_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html#grim_menu_pointing_farfit_help_event", "grim_menu_pointing_farfit_help_event", 'routine in <a href="nv/grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_pointing_farfit_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html#grim_menu_pointing_farfit_event", "grim_menu_pointing_farfit_event", 'routine in <a href="nv/grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_pointing_farfit_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html#grim_menu_pointing_renderfit_help_event", "grim_menu_pointing_renderfit_help_event", 'routine in <a href="nv/grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_pointing_renderfit_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html#grim_menu_pointing_renderfit_event", "grim_menu_pointing_renderfit_event", 'routine in <a href="nv/grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_pointing_renderfit_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html#grim_menu_pointing_lsq_help_event", "grim_menu_pointing_lsq_help_event", 'routine in <a href="nv/grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_pointing_lsq_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html#grim_menu_pointing_lsq_event", "grim_menu_pointing_lsq_event", 'routine in <a href="nv/grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_pointing_lsq_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html#grim_get_shift_step", "grim_get_shift_step", 'routine in <a href="nv/grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_get_shift_step", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html#grim_reposition", "grim_reposition", 'routine in <a href="nv/grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_reposition", "", "cdgrim_dataplaneshift", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html#grim_menu_toggle_reorigin_event_help_event", "grim_menu_toggle_reorigin_event_help_event", 'routine in <a href="nv/grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_toggle_reorigin_event_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html#grim_menu_toggle_reorigin_event", "grim_menu_toggle_reorigin_event", 'routine in <a href="nv/grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_toggle_reorigin_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html#grim_menu_shift_enter_step_event_help_event", "grim_menu_shift_enter_step_event_help_event", 'routine in <a href="nv/grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_shift_enter_step_event_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html#grim_menu_shift_enter_step_event", "grim_menu_shift_enter_step_event", 'routine in <a href="nv/grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_shift_enter_step_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html#grim_menu_shift_enter_offset_event_help_event", "grim_menu_shift_enter_offset_event_help_event", 'routine in <a href="nv/grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_shift_enter_offset_event_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html#grim_menu_shift_enter_offset_event", "grim_menu_shift_enter_offset_event", 'routine in <a href="nv/grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_shift_enter_offset_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html#grim_menu_shift_left_help_event", "grim_menu_shift_left_help_event", 'routine in <a href="nv/grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_shift_left_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html#grim_menu_shift_left_event", "grim_menu_shift_left_event", 'routine in <a href="nv/grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_shift_left_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html#grim_menu_shift_right_help_event", "grim_menu_shift_right_help_event", 'routine in <a href="nv/grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_shift_right_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html#grim_menu_shift_right_event", "grim_menu_shift_right_event", 'routine in <a href="nv/grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_shift_right_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html#grim_menu_shift_up_help_event", "grim_menu_shift_up_help_event", 'routine in <a href="nv/grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_shift_up_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html#grim_menu_shift_up_event", "grim_menu_shift_up_event", 'routine in <a href="nv/grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_shift_up_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html#grim_menu_shift_down_help_event", "grim_menu_shift_down_help_event", 'routine in <a href="nv/grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_shift_down_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html#grim_menu_shift_down_event", "grim_menu_shift_down_event", 'routine in <a href="nv/grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_shift_down_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html#grim_menu_corrections_photometry_help_event", "grim_menu_corrections_photometry_help_event", 'routine in <a href="nv/grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_corrections_photometry_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html#grim_menu_corrections_photometry_event", "grim_menu_corrections_photometry_event", 'routine in <a href="nv/grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_corrections_photometry_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html#grim_menu_project_map_help_event", "grim_menu_project_map_help_event", 'routine in <a href="nv/grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_project_map_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html#grim_menu_project_map_event", "grim_menu_project_map_event", 'routine in <a href="nv/grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_project_map_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html#grim_menu_mosaic_help_event", "grim_menu_mosaic_help_event", 'routine in <a href="nv/grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_mosaic_help_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html#grim_menu_mosaic_event", "grim_menu_mosaic_event", 'routine in <a href="nv/grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_mosaic_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html#grim_menu_read_mind_event", "grim_menu_read_mind_event", 'routine in <a href="nv/grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_read_mind_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html#grim_default_menus_init", "grim_default_menus_init", 'routine in <a href="nv/grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_default_menus_init", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_default_menus.html#grim_default_menus", "grim_default_menus", 'routine in <a href="nv/grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_default_menus", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/grim/grim_descriptors_include.html", "grim_descriptors_include.pro", '.pro file in <a href="nv/grim/dir-overview.html">nv/grim/ directory</a>', "grim_descriptors_include.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/grim/grim_descriptors_include.html#grim_compute_fov", "grim_compute_fov", 'routine in <a href="nv/grim/grim_descriptors_include.html">grim_descriptors_include.pro</a>', "grim_descriptors_include.pro", "", "grim_compute_fov", "", "covgrim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_descriptors_include.html#grim_descriptor_notify_handle", "grim_descriptor_notify_handle", 'routine in <a href="nv/grim/grim_descriptors_include.html">grim_descriptors_include.pro</a>', "grim_descriptors_include.pro", "", "grim_descriptor_notify_handle", "", "refreshnewgrim_dataxd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_descriptors_include.html#grim_suspend_events", "grim_suspend_events", 'routine in <a href="nv/grim/grim_descriptors_include.html">grim_descriptors_include.pro</a>', "grim_descriptors_include.pro", "", "grim_suspend_events", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_descriptors_include.html#grim_resume_events", "grim_resume_events", 'routine in <a href="nv/grim/grim_descriptors_include.html">grim_descriptors_include.pro</a>', "grim_descriptors_include.pro", "", "grim_resume_events", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_descriptors_include.html#grim_descriptor_notify", "grim_descriptor_notify", 'routine in <a href="nv/grim/grim_descriptors_include.html">grim_descriptors_include.pro</a>', "grim_descriptors_include.pro", "", "grim_descriptor_notify", "", "refreshnewevents", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_descriptors_include.html#grim_rm_descriptor", "grim_rm_descriptor", 'routine in <a href="nv/grim/grim_descriptors_include.html">grim_descriptors_include.pro</a>', "grim_descriptors_include.pro", "", "grim_rm_descriptor", "", "planegrim_dataxdpxd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_descriptors_include.html#grim_mark_descriptor", "grim_mark_descriptor", 'routine in <a href="nv/grim/grim_descriptors_include.html">grim_descriptors_include.pro</a>', "grim_descriptors_include.pro", "", "grim_mark_descriptor", "", "xdval", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_descriptors_include.html#grim_demark_descriptor", "grim_demark_descriptor", 'routine in <a href="nv/grim/grim_descriptors_include.html">grim_descriptors_include.pro</a>', "grim_descriptors_include.pro", "", "grim_demark_descriptor", "", "xd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_descriptors_include.html#grim_mark_descriptors", "grim_mark_descriptors", 'routine in <a href="nv/grim/grim_descriptors_include.html">grim_descriptors_include.pro</a>', "grim_descriptors_include.pro", "", "grim_mark_descriptors", "", "allcdpdrdsdstdardsundplanesgrim_dataval", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_descriptors_include.html#grim_add_descriptor", "grim_add_descriptor", 'routine in <a href="nv/grim/grim_descriptors_include.html">grim_descriptors_include.pro</a>', "grim_descriptors_include.pro", "", "grim_add_descriptor", "", "onenoregisterassoc_ddgrim_dataxdp_xd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_descriptors_include.html#grim_get_cameras", "grim_get_cameras", 'routine in <a href="nv/grim/grim_descriptors_include.html">grim_descriptors_include.pro</a>', "grim_descriptors_include.pro", "", "grim_get_cameras", "", "planegrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_descriptors_include.html#grim_get_planets", "grim_get_planets", 'routine in <a href="nv/grim/grim_descriptors_include.html">grim_descriptors_include.pro</a>', "grim_descriptors_include.pro", "", "grim_get_planets", "", "planenamesgrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_descriptors_include.html#grim_get_sun", "grim_get_sun", 'routine in <a href="nv/grim/grim_descriptors_include.html">grim_descriptors_include.pro</a>', "grim_descriptors_include.pro", "", "grim_get_sun", "", "planegrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_descriptors_include.html#grim_get_stars", "grim_get_stars", 'routine in <a href="nv/grim/grim_descriptors_include.html">grim_descriptors_include.pro</a>', "grim_descriptors_include.pro", "", "grim_get_stars", "", "planenamesgrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_descriptors_include.html#grim_get_rings", "grim_get_rings", 'routine in <a href="nv/grim/grim_descriptors_include.html">grim_descriptors_include.pro</a>', "grim_descriptors_include.pro", "", "grim_get_rings", "", "planenamesgrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_descriptors_include.html#grim_get_stations", "grim_get_stations", 'routine in <a href="nv/grim/grim_descriptors_include.html">grim_descriptors_include.pro</a>', "grim_descriptors_include.pro", "", "grim_get_stations", "", "planenamesgrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_descriptors_include.html#grim_get_arrays", "grim_get_arrays", 'routine in <a href="nv/grim/grim_descriptors_include.html">grim_descriptors_include.pro</a>', "grim_descriptors_include.pro", "", "grim_get_arrays", "", "planenamesgrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_descriptors_include.html#grim_clear_descriptors", "grim_clear_descriptors", 'routine in <a href="nv/grim/grim_descriptors_include.html">grim_descriptors_include.pro</a>', "grim_descriptors_include.pro", "", "grim_clear_descriptors", "", "planesgrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_descriptors_include.html#grim_load_descriptors", "grim_load_descriptors", 'routine in <a href="nv/grim/grim_descriptors_include.html">grim_descriptors_include.pro</a>', "grim_descriptors_include.pro", "", "grim_load_descriptors", "", "planeclasscdpdrdsundsdardstdodobj_namegdgrim_dataname", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_descriptors_include.html#grim_descriptors_include", "grim_descriptors_include", 'routine in <a href="nv/grim/grim_descriptors_include.html">grim_descriptors_include.pro</a>', "grim_descriptors_include.pro", "", "grim_descriptors_include", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("demo/grim_example.html", "grim_example.pro", '.pro file in <a href="demo/dir-overview.html">demo/ directory</a>', "grim_example.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("nv/grim/grim_footprint_cursor.html", "grim_footprint_cursor.pro", '.pro file in <a href="nv/grim/dir-overview.html">nv/grim/ directory</a>', "grim_footprint_cursor.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/grim/grim_footprint_cursor.html#grim_footprint_cursor", "grim_footprint_cursor", 'routine in <a href="nv/grim/grim_footprint_cursor.html">grim_footprint_cursor.pro</a>', "grim_footprint_cursor.pro", "", "grim_footprint_cursor", "", "swap", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/grim/grim_image_include.html", "grim_image_include.pro", '.pro file in <a href="nv/grim/dir-overview.html">nv/grim/ directory</a>', "grim_image_include.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/grim/grim_image_include.html#grim_get_n_colors", "grim_get_n_colors", 'routine in <a href="nv/grim/grim_image_include.html">grim_image_include.pro</a>', "grim_image_include.pro", "", "grim_get_n_colors", "", "planetypegrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_image_include.html#grim_visible_planes", "grim_visible_planes", 'routine in <a href="nv/grim/grim_image_include.html">grim_image_include.pro</a>', "grim_image_include.pro", "", "grim_visible_planes", "", "planecurrentgrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_image_include.html#grim_get_plane_by_xy", "grim_get_plane_by_xy", 'routine in <a href="nv/grim/grim_image_include.html">grim_image_include.pro</a>', "grim_image_include.pro", "", "grim_get_plane_by_xy", "", "grim_dataxy", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_image_include.html#grim_get_plane_by_overlay", "grim_get_plane_by_overlay", 'routine in <a href="nv/grim/grim_image_include.html">grim_image_include.pro</a>', "grim_image_include.pro", "", "grim_get_plane_by_overlay", "", "grim_dataxy", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_image_include.html#grim_test_single_channel", "grim_test_single_channel", 'routine in <a href="nv/grim/grim_image_include.html">grim_image_include.pro</a>', "grim_image_include.pro", "", "grim_test_single_channel", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_image_include.html#grim_toggle_image", "grim_toggle_image", 'routine in <a href="nv/grim/grim_image_include.html">grim_image_include.pro</a>', "grim_image_include.pro", "", "grim_toggle_image", "", "no_refreshbmgrim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_image_include.html#grim_toggle_image_overlays", "grim_toggle_image_overlays", 'routine in <a href="nv/grim/grim_image_include.html">grim_image_include.pro</a>', "grim_image_include.pro", "", "grim_toggle_image_overlays", "", "no_refreshgrim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_image_include.html#grim_render_image", "grim_render_image", 'routine in <a href="nv/grim/grim_image_include.html">grim_image_include.pro</a>', "grim_image_include.pro", "", "grim_render_image", "", "planeimage_ptsgrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_image_include.html#grim_image", "grim_image", 'routine in <a href="nv/grim/grim_image_include.html">grim_image_include.pro</a>', "grim_image_include.pro", "", "grim_image", "", "planepncolormapchannelcurrentxrangeyrangegrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_image_include.html#grim_scale_image", "grim_scale_image", 'routine in <a href="nv/grim/grim_image_include.html">grim_image_include.pro</a>', "grim_image_include.pro", "", "grim_scale_image", "", "currentplaneno_scaletopxrangeyrangegrim_datargb", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_image_include.html#grim_display_image", "grim_display_image", 'routine in <a href="nv/grim/grim_image_include.html">grim_image_include.pro</a>', "grim_image_include.pro", "", "grim_display_image", "", "planeentirewnumdoffsetzoomrotateorderdefaultpreviousfliprestorexsizeysizeoffsettopnoplotno_scaleno_wsetno_coordtvimagehomedraw_pixmapcurrentno_copygrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_image_include.html#grim_display_plot", "grim_display_plot", 'routine in <a href="nv/grim/grim_image_include.html">grim_image_include.pro</a>', "grim_image_include.pro", "", "grim_display_plot", "", "planedoffsetwnumxrangeyrangeno_wsetdefaultpreviousfliprestorexsizeysizepositiondxdyentireeraseno_coordcolornodrawcurrentgrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_image_include.html#grim_display", "grim_display", 'routine in <a href="nv/grim/grim_image_include.html">grim_image_include.pro</a>', "grim_image_include.pro", "", "grim_display", "", "planewnumhomeno_imageno_axesdoffsetno_erasezoomrotateorderxsizeysizeoffsetdefaultpreviousfliprestoreuse_pixmappixmap_box_centerno_copypixmap_box_sideno_backentireno_wsetno_coordtvimageno_plotnodrawxrangeyrangedxdycurrentpixmap_to_usegrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_image_include.html#grim_show_context_image", "grim_show_context_image", 'routine in <a href="nv/grim/grim_image_include.html">grim_image_include.pro</a>', "grim_image_include.pro", "", "grim_show_context_image", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_image_include.html#grim_show_axes", "grim_show_axes", 'routine in <a href="nv/grim/grim_image_include.html">grim_image_include.pro</a>', "grim_image_include.pro", "", "grim_show_axes", "", "grim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_image_include.html#grim_add_refresh_callback", "grim_add_refresh_callback", 'routine in <a href="nv/grim/grim_image_include.html">grim_image_include.pro</a>', "grim_image_include.pro", "", "grim_add_refresh_callback", "", "topno_wsetcallbacksdata_ps", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_image_include.html#grim_rm_refresh_callback", "grim_rm_refresh_callback", 'routine in <a href="nv/grim/grim_image_include.html">grim_image_include.pro</a>', "grim_image_include.pro", "", "grim_rm_refresh_callback", "", "topdata_ps", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_image_include.html#grim_call_refresh_callbacks", "grim_call_refresh_callbacks", 'routine in <a href="nv/grim/grim_image_include.html">grim_image_include.pro</a>', "grim_image_include.pro", "", "grim_call_refresh_callbacks", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_image_include.html#grim_title", "grim_title", 'routine in <a href="nv/grim/grim_image_include.html">grim_image_include.pro</a>', "grim_image_include.pro", "", "grim_title", "", "primaryplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_image_include.html#grim_channel_string", "grim_channel_string", 'routine in <a href="nv/grim/grim_image_include.html">grim_image_include.pro</a>', "grim_image_include.pro", "", "grim_channel_string", "", "plane", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_image_include.html#grim_refresh", "grim_refresh", 'routine in <a href="nv/grim/grim_image_include.html">grim_image_include.pro</a>', "grim_image_include.pro", "", "grim_refresh", "", "wnumplaneno_imageno_objectsno_axesno_titlehomexrangeyrangedoffsetno_erasezoomrotateorderdefaultpreviousfliprestorexsizeysizeoffsetuse_pixmappixmap_box_centerpixmap_box_sidecontextentirenoglassno_wsetno_contextno_callbackno_backno_coordtvimageno_plotjust_imagedxdyupdatecurrentno_copyno_mainno_usergrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_image_include.html#grim_image_include", "grim_image_include", 'routine in <a href="nv/grim/grim_image_include.html">grim_image_include.pro</a>', "grim_image_include.pro", "", "grim_image_include", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/grim/grim_message.html", "grim_message.pro", '.pro file in <a href="nv/grim/dir-overview.html">nv/grim/ directory</a>', "grim_message.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/grim/grim_message.html#grim_message", "grim_message", 'routine in <a href="nv/grim/grim_message.html">grim_message.pro</a>', "grim_message.pro", "", "grim_message", "", "clearsuspendrestorequestionresultmessage", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/grim/grim_mode_activate.html", "grim_mode_activate.pro", '.pro file in <a href="nv/grim/dir-overview.html">nv/grim/ directory</a>', "grim_mode_activate.pro", "", "", " NAME: 	grim_mode_activate_button_event    PURPOSE: 	Selects the activate cursor mode.    CATEGORY: 	NV/GR    OPERATION:  	Overlay objects may be activated or deactivated by clicking 	and/or dragging using the left or right mouse buttons 	respectively.  This activation mechanism allows the user to 	select which among a certain type of objects should be used 	in a given menu selection.  A left click on an overlay 	activates that overlay and a right click deactivates it.  A 	double click activates or deactivates all overlays associated 	with a given descriptor, or all stars.  Active overlays appear 	in the colors selected in the 'Overlay Settings' menu selection. 	Inactive overlays appear in cyan.  A descriptor is active 	whenever any of its overlays are active.    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_activate.html#grim_mode_activate_bitmap", "grim_mode_activate_bitmap", 'routine in <a href="nv/grim/grim_mode_activate.html">grim_mode_activate.pro</a>', "grim_mode_activate.pro", "", "grim_mode_activate_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_activate.html#grim_mode_activate_mouse_event", "grim_mode_activate_mouse_event", 'routine in <a href="nv/grim/grim_mode_activate.html">grim_mode_activate.pro</a>', "grim_mode_activate.pro", "", "grim_mode_activate_mouse_event", "", "eventdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_activate.html#grim_mode_activate_mode", "grim_mode_activate_mode", 'routine in <a href="nv/grim/grim_mode_activate.html">grim_mode_activate.pro</a>', "grim_mode_activate.pro", "", "grim_mode_activate_mode", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_activate.html#grim_mode_activate_button_event", "grim_mode_activate_button_event", 'routine in <a href="nv/grim/grim_mode_activate.html">grim_mode_activate.pro</a>', "grim_mode_activate.pro", "", "grim_mode_activate_button_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_activate.html#grim_mode_activate_init", "grim_mode_activate_init", 'routine in <a href="nv/grim/grim_mode_activate.html">grim_mode_activate.pro</a>', "grim_mode_activate.pro", "", "grim_mode_activate_init", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_activate.html#grim_mode_activate", "grim_mode_activate", 'routine in <a href="nv/grim/grim_mode_activate.html">grim_mode_activate.pro</a>', "grim_mode_activate.pro", "", "grim_mode_activate", "", "arg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/grim/grim_mode_curves.html", "grim_mode_curves.pro", '.pro file in <a href="nv/grim/dir-overview.html">nv/grim/ directory</a>', "grim_mode_curves.pro", "", "", " NAME: 	grim_mode_curves_button_event    PURPOSE: 	Selects the curves cursor mode.    CATEGORY: 	NV/GR    OPERATION: 	curves are added using the left mouse button and deleted 	using the right button.    MODIFICATION HISTORY:  	Written by:	Spitale, 10/2012   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_curves.html#grim_mode_curves_bitmap", "grim_mode_curves_bitmap", 'routine in <a href="nv/grim/grim_mode_curves.html">grim_mode_curves.pro</a>', "grim_mode_curves.pro", "", "grim_mode_curves_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_curves.html#grim_mode_curves_mouse_event", "grim_mode_curves_mouse_event", 'routine in <a href="nv/grim/grim_mode_curves.html">grim_mode_curves.pro</a>', "grim_mode_curves.pro", "", "grim_mode_curves_mouse_event", "", "eventdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_curves.html#grim_mode_curves_cursor", "grim_mode_curves_cursor", 'routine in <a href="nv/grim/grim_mode_curves.html">grim_mode_curves.pro</a>', "grim_mode_curves.pro", "", "grim_mode_curves_cursor", "", "swap", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_curves.html#grim_mode_curves_mode", "grim_mode_curves_mode", 'routine in <a href="nv/grim/grim_mode_curves.html">grim_mode_curves.pro</a>', "grim_mode_curves.pro", "", "grim_mode_curves_mode", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_curves.html#grim_mode_curves_button_event", "grim_mode_curves_button_event", 'routine in <a href="nv/grim/grim_mode_curves.html">grim_mode_curves.pro</a>', "grim_mode_curves.pro", "", "grim_mode_curves_button_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_curves.html#grim_mode_curves_init", "grim_mode_curves_init", 'routine in <a href="nv/grim/grim_mode_curves.html">grim_mode_curves.pro</a>', "grim_mode_curves.pro", "", "grim_mode_curves_init", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_curves.html#grim_mode_curves", "grim_mode_curves", 'routine in <a href="nv/grim/grim_mode_curves.html">grim_mode_curves.pro</a>', "grim_mode_curves.pro", "", "grim_mode_curves", "", "arg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/grim/grim_mode_drag.html", "grim_mode_drag.pro", '.pro file in <a href="nv/grim/dir-overview.html">nv/grim/ directory</a>', "grim_mode_drag.pro", "", "", " NAME: 	grim_mode_drag_button_event    PURPOSE: 	Selects the drag cursor mode.    CATEGORY: 	NV/GR    OPERATION: 	Allow the user to drag the image.    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2009   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_drag.html#grim_mode_drag_bitmap", "grim_mode_drag_bitmap", 'routine in <a href="nv/grim/grim_mode_drag.html">grim_mode_drag.pro</a>', "grim_mode_drag.pro", "", "grim_mode_drag_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_drag.html#grim_mode_drag_translate", "grim_mode_drag_translate", 'routine in <a href="nv/grim/grim_mode_drag.html">grim_mode_drag.pro</a>', "grim_mode_drag.pro", "", "grim_mode_drag_translate", "", "dataxarryarrpixmapwin_num", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_drag.html#grim_mode_drag_mouse_event", "grim_mode_drag_mouse_event", 'routine in <a href="nv/grim/grim_mode_drag.html">grim_mode_drag.pro</a>', "grim_mode_drag.pro", "", "grim_mode_drag_mouse_event", "", "eventdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_drag.html#grim_mode_drag_mode", "grim_mode_drag_mode", 'routine in <a href="nv/grim/grim_mode_drag.html">grim_mode_drag.pro</a>', "grim_mode_drag.pro", "", "grim_mode_drag_mode", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_drag.html#grim_mode_drag_button_event", "grim_mode_drag_button_event", 'routine in <a href="nv/grim/grim_mode_drag.html">grim_mode_drag.pro</a>', "grim_mode_drag.pro", "", "grim_mode_drag_button_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_drag.html#grim_mode_drag_init", "grim_mode_drag_init", 'routine in <a href="nv/grim/grim_mode_drag.html">grim_mode_drag.pro</a>', "grim_mode_drag.pro", "", "grim_mode_drag_init", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_drag.html#grim_mode_drag", "grim_mode_drag", 'routine in <a href="nv/grim/grim_mode_drag.html">grim_mode_drag.pro</a>', "grim_mode_drag.pro", "", "grim_mode_drag", "", "arg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/grim/grim_mode_magnify.html", "grim_mode_magnify.pro", '.pro file in <a href="nv/grim/dir-overview.html">nv/grim/ directory</a>', "grim_mode_magnify.pro", "", "", " NAME: 	grim_mode_magnify_button_event    PURPOSE: 	Selects the magnify cursor mode.    CATEGORY: 	NV/GR    OPERATION: 	Image pixels in the graphics window may be magnifed using 	either the left or right mouse buttons.  The left button 	magnifies the displayed pixels, directly from the graphics 	window.  The right button magnifies the data itself, without 	the overlays.    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_magnify.html#grim_mode_magnify_bitmap", "grim_mode_magnify_bitmap", 'routine in <a href="nv/grim/grim_mode_magnify.html">grim_mode_magnify.pro</a>', "grim_mode_magnify.pro", "", "grim_mode_magnify_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_magnify.html#grim_mode_magnify_cursor", "grim_mode_magnify_cursor", 'routine in <a href="nv/grim/grim_mode_magnify.html">grim_mode_magnify.pro</a>', "grim_mode_magnify.pro", "", "grim_mode_magnify_cursor", "", "swap", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_magnify.html#grim_mag_erase", "grim_mag_erase", 'routine in <a href="nv/grim/grim_mode_magnify.html">grim_mode_magnify.pro</a>', "grim_mode_magnify.pro", "", "grim_mag_erase", "", "grim_datawnum", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_magnify.html#grim_mag_frame", "grim_mag_frame", 'routine in <a href="nv/grim/grim_mode_magnify.html">grim_mode_magnify.pro</a>', "grim_mode_magnify.pro", "", "grim_mag_frame", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_magnify.html#grim_magnify", "grim_magnify", 'routine in <a href="nv/grim/grim_mode_magnify.html">grim_mode_magnify.pro</a>', "grim_mode_magnify.pro", "", "grim_magnify", "", "datagrim_dataplanep_device", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_magnify.html#grim_mode_magnify_mouse_event", "grim_mode_magnify_mouse_event", 'routine in <a href="nv/grim/grim_mode_magnify.html">grim_mode_magnify.pro</a>', "grim_mode_magnify.pro", "", "grim_mode_magnify_mouse_event", "", "eventdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_magnify.html#grim_mode_magnify_mode", "grim_mode_magnify_mode", 'routine in <a href="nv/grim/grim_mode_magnify.html">grim_mode_magnify.pro</a>', "grim_mode_magnify.pro", "", "grim_mode_magnify_mode", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_magnify.html#grim_mode_magnify_button_event", "grim_mode_magnify_button_event", 'routine in <a href="nv/grim/grim_mode_magnify.html">grim_mode_magnify.pro</a>', "grim_mode_magnify.pro", "", "grim_mode_magnify_button_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_magnify.html#grim_mode_magnify_init", "grim_mode_magnify_init", 'routine in <a href="nv/grim/grim_mode_magnify.html">grim_mode_magnify.pro</a>', "grim_mode_magnify.pro", "", "grim_mode_magnify_init", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_magnify.html#grim_mode_magnify", "grim_mode_magnify", 'routine in <a href="nv/grim/grim_mode_magnify.html">grim_mode_magnify.pro</a>', "grim_mode_magnify.pro", "", "grim_mode_magnify", "", "arg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/grim/grim_mode_mask.html", "grim_mode_mask.pro", '.pro file in <a href="nv/grim/dir-overview.html">nv/grim/ directory</a>', "grim_mode_mask.pro", "", "", " NAME: 	grim_mode_mask_button_event    PURPOSE: 	Selects the mask cursor mode.    CATEGORY: 	NV/GR    OPERATION: 	Allowqs the user to select pixel to include in the mask.    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2013   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_mask.html#grim_mode_mask_bitmap", "grim_mode_mask_bitmap", 'routine in <a href="nv/grim/grim_mode_mask.html">grim_mode_mask.pro</a>', "grim_mode_mask.pro", "", "grim_mode_mask_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_mask.html#grim_mode_mask_mouse_event", "grim_mode_mask_mouse_event", 'routine in <a href="nv/grim/grim_mode_mask.html">grim_mode_mask.pro</a>', "grim_mode_mask.pro", "", "grim_mode_mask_mouse_event", "", "eventdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_mask.html#grim_mode_mask_mode", "grim_mode_mask_mode", 'routine in <a href="nv/grim/grim_mode_mask.html">grim_mode_mask.pro</a>', "grim_mode_mask.pro", "", "grim_mode_mask_mode", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_mask.html#grim_mode_mask_button_event", "grim_mode_mask_button_event", 'routine in <a href="nv/grim/grim_mode_mask.html">grim_mode_mask.pro</a>', "grim_mode_mask.pro", "", "grim_mode_mask_button_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_mask.html#grim_mode_mask_init", "grim_mode_mask_init", 'routine in <a href="nv/grim/grim_mode_mask.html">grim_mode_mask.pro</a>', "grim_mode_mask.pro", "", "grim_mode_mask_init", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_mask.html#grim_mode_mask", "grim_mode_mask", 'routine in <a href="nv/grim/grim_mode_mask.html">grim_mode_mask.pro</a>', "grim_mode_mask.pro", "", "grim_mode_mask", "", "arg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/grim/grim_mode_navigate.html", "grim_mode_navigate.pro", '.pro file in <a href="nv/grim/dir-overview.html">nv/grim/ directory</a>', "grim_mode_navigate.pro", "", "", " NAME: 	grim_mode_navigate_button_event    PURPOSE: 	Selects the navigate cursor mode.  	 Camera orientation: 	   Left button:		Allows the optic axis to be repointed.  	   Right button:	Allows the camera to twist about an axis 				corresponding to the selected pixel location.  	 Camera position: 	   <Shift> Left:	Allows the camera to be repositioned in the 				X-Z plane (image plane).  Speeds depend on 				the object under the cursor.  	   <Shift> Right:	Allows the camera to be repositioned and 				reoriented simultaneosly by tracking the 				object under the cursor.  	   <Shift> Wheel:	Allows the camera to be repositioned in the 				Y (optic axis) direction.  Speeds depend on 				the object under the cursor.    CATEGORY: 	NV/GR    OPERATION: 	Allow the user to fly around the system.    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2009   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_navigate.html#grim_mode_navigate_bitmap", "grim_mode_navigate_bitmap", 'routine in <a href="nv/grim/grim_mode_navigate.html">grim_mode_navigate.pro</a>', "grim_mode_navigate.pro", "", "grim_mode_navigate_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_navigate.html#grim_mode_navigate_get_points", "grim_mode_navigate_get_points", 'routine in <a href="nv/grim/grim_mode_navigate.html">grim_mode_navigate.pro</a>', "grim_mode_navigate.pro", "", "grim_mode_navigate_get_points", "", "planegrim_datapoints_ptdcurves_ptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_navigate.html#grim_mode_navigate_reposition", "grim_mode_navigate_reposition", 'routine in <a href="nv/grim/grim_mode_navigate.html">grim_mode_navigate.pro</a>', "grim_mode_navigate.pro", "", "grim_mode_navigate_reposition", "", "axescdcd0curves_ptdpoints_ptdtrackingxarryarr", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_navigate.html#grim_mode_navigate_reposition_xy", "grim_mode_navigate_reposition_xy", 'routine in <a href="nv/grim/grim_mode_navigate.html">grim_mode_navigate.pro</a>', "grim_mode_navigate.pro", "", "grim_mode_navigate_reposition_xy", "", "dataxarryarrpixmapwin_num", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_navigate.html#grim_mode_navigate_reposition_xz", "grim_mode_navigate_reposition_xz", 'routine in <a href="nv/grim/grim_mode_navigate.html">grim_mode_navigate.pro</a>', "grim_mode_navigate.pro", "", "grim_mode_navigate_reposition_xz", "", "dataxarryarrpixmapwin_num", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_navigate.html#grim_mode_navigate_reposition_track", "grim_mode_navigate_reposition_track", 'routine in <a href="nv/grim/grim_mode_navigate.html">grim_mode_navigate.pro</a>', "grim_mode_navigate.pro", "", "grim_mode_navigate_reposition_track", "", "dataxarryarrpixmapwin_num", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_navigate.html#grim_mode_navigate_draw", "grim_mode_navigate_draw", 'routine in <a href="nv/grim/grim_mode_navigate.html">grim_mode_navigate.pro</a>', "grim_mode_navigate.pro", "", "grim_mode_navigate_draw", "", "wnumpixmaperase_pixmapcdcurves_ptdpoints_ptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_navigate.html#grim_mode_navigate_reposition_y_event", "grim_mode_navigate_reposition_y_event", 'routine in <a href="nv/grim/grim_mode_navigate.html">grim_mode_navigate.pro</a>', "grim_mode_navigate.pro", "", "grim_mode_navigate_reposition_y_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_navigate.html#grim_mode_navigate_reposition_y", "grim_mode_navigate_reposition_y", 'routine in <a href="nv/grim/grim_mode_navigate.html">grim_mode_navigate.pro</a>', "grim_mode_navigate.pro", "", "grim_mode_navigate_reposition_y", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_navigate.html#grim_mode_navigate_reorient_nod", "grim_mode_navigate_reorient_nod", 'routine in <a href="nv/grim/grim_mode_navigate.html">grim_mode_navigate.pro</a>', "grim_mode_navigate.pro", "", "grim_mode_navigate_reorient_nod", "", "dataxarryarrpixmapwin_num", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_navigate.html#grim_mode_navigate_reorient_twist", "grim_mode_navigate_reorient_twist", 'routine in <a href="nv/grim/grim_mode_navigate.html">grim_mode_navigate.pro</a>', "grim_mode_navigate.pro", "", "grim_mode_navigate_reorient_twist", "", "dataxarryarrpixmapwin_num", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_navigate.html#grim_mode_navigate_mouse_event", "grim_mode_navigate_mouse_event", 'routine in <a href="nv/grim/grim_mode_navigate.html">grim_mode_navigate.pro</a>', "grim_mode_navigate.pro", "", "grim_mode_navigate_mouse_event", "", "eventdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_navigate.html#grim_mode_navigate_mode", "grim_mode_navigate_mode", 'routine in <a href="nv/grim/grim_mode_navigate.html">grim_mode_navigate.pro</a>', "grim_mode_navigate.pro", "", "grim_mode_navigate_mode", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_navigate.html#grim_mode_navigate_button_event", "grim_mode_navigate_button_event", 'routine in <a href="nv/grim/grim_mode_navigate.html">grim_mode_navigate.pro</a>', "grim_mode_navigate.pro", "", "grim_mode_navigate_button_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_navigate.html#grim_mode_navigate_init", "grim_mode_navigate_init", 'routine in <a href="nv/grim/grim_mode_navigate.html">grim_mode_navigate.pro</a>', "grim_mode_navigate.pro", "", "grim_mode_navigate_init", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_navigate.html#grim_mode_navigate", "grim_mode_navigate", 'routine in <a href="nv/grim/grim_mode_navigate.html">grim_mode_navigate.pro</a>', "grim_mode_navigate.pro", "", "grim_mode_navigate", "", "arg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/grim/grim_mode_pan.html", "grim_mode_pan.pro", '.pro file in <a href="nv/grim/dir-overview.html">nv/grim/ directory</a>', "grim_mode_pan.pro", "", "", " NAME: 	grim_mode_pan_button_event    PURPOSE: 	Selects the pan cursor mode.    CATEGORY: 	NV/GR    OPERATION: 	The image offset is controlled by selecting an offset vector 	using the left mouse button, or the middle button may be 	used to center the image on a selected point.    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_pan.html#grim_mode_pan_bitmap", "grim_mode_pan_bitmap", 'routine in <a href="nv/grim/grim_mode_pan.html">grim_mode_pan.pro</a>', "grim_mode_pan.pro", "", "grim_mode_pan_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_pan.html#grim_mode_pan_mouse_event", "grim_mode_pan_mouse_event", 'routine in <a href="nv/grim/grim_mode_pan.html">grim_mode_pan.pro</a>', "grim_mode_pan.pro", "", "grim_mode_pan_mouse_event", "", "eventdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_pan.html#grim_mode_pan_mode", "grim_mode_pan_mode", 'routine in <a href="nv/grim/grim_mode_pan.html">grim_mode_pan.pro</a>', "grim_mode_pan.pro", "", "grim_mode_pan_mode", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_pan.html#grim_mode_pan_button_event", "grim_mode_pan_button_event", 'routine in <a href="nv/grim/grim_mode_pan.html">grim_mode_pan.pro</a>', "grim_mode_pan.pro", "", "grim_mode_pan_button_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_pan.html#grim_mode_pan_init", "grim_mode_pan_init", 'routine in <a href="nv/grim/grim_mode_pan.html">grim_mode_pan.pro</a>', "grim_mode_pan.pro", "", "grim_mode_pan_init", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_pan.html#grim_mode_pan", "grim_mode_pan", 'routine in <a href="nv/grim/grim_mode_pan.html">grim_mode_pan.pro</a>', "grim_mode_pan.pro", "", "grim_mode_pan", "", "arg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/grim/grim_mode_pan_plot.html", "grim_mode_pan_plot.pro", '.pro file in <a href="nv/grim/dir-overview.html">nv/grim/ directory</a>', "grim_mode_pan_plot.pro", "", "", " NAME: 	grim_mode_pan_plot_button_event    PURPOSE: 	Selects the pan cursor mode.    CATEGORY: 	NV/GR    OPERATION: 	The image offset is controlled by selecting an offset vector 	using the left mouse button, or the middle button may be 	used to center the image on a selected point.    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_pan_plot.html#grim_mode_pan_plot_bitmap", "grim_mode_pan_plot_bitmap", 'routine in <a href="nv/grim/grim_mode_pan_plot.html">grim_mode_pan_plot.pro</a>', "grim_mode_pan_plot.pro", "", "grim_mode_pan_plot_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_pan_plot.html#grim_mode_pan_plot_mouse_event", "grim_mode_pan_plot_mouse_event", 'routine in <a href="nv/grim/grim_mode_pan_plot.html">grim_mode_pan_plot.pro</a>', "grim_mode_pan_plot.pro", "", "grim_mode_pan_plot_mouse_event", "", "eventdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_pan_plot.html#grim_mode_pan_plot_mode", "grim_mode_pan_plot_mode", 'routine in <a href="nv/grim/grim_mode_pan_plot.html">grim_mode_pan_plot.pro</a>', "grim_mode_pan_plot.pro", "", "grim_mode_pan_plot_mode", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_pan_plot.html#grim_mode_pan_plot_button_event", "grim_mode_pan_plot_button_event", 'routine in <a href="nv/grim/grim_mode_pan_plot.html">grim_mode_pan_plot.pro</a>', "grim_mode_pan_plot.pro", "", "grim_mode_pan_plot_button_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_pan_plot.html#grim_mode_pan_plot_init", "grim_mode_pan_plot_init", 'routine in <a href="nv/grim/grim_mode_pan_plot.html">grim_mode_pan_plot.pro</a>', "grim_mode_pan_plot.pro", "", "grim_mode_pan_plot_init", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_pan_plot.html#grim_mode_pan_plot", "grim_mode_pan_plot", 'routine in <a href="nv/grim/grim_mode_pan_plot.html">grim_mode_pan_plot.pro</a>', "grim_mode_pan_plot.pro", "", "grim_mode_pan_plot", "", "arg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/grim/grim_mode_plane.html", "grim_mode_plane.pro", '.pro file in <a href="nv/grim/dir-overview.html">nv/grim/ directory</a>', "grim_mode_plane.pro", "", "", " NAME: 	grim_mode_plane_button_event    PURPOSE: 	Selects the plane cursor mode.    CATEGORY: 	NV/GR    OPERATION: 	Planes can be selected by clicking in the image window.  This option 	is not useful unless planes other than the current plane are visible. 	If more than one plane under the cursor contains data, the one with 	the lowest plane number is selected, unless one of them is the current 	plane.    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2008   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_plane.html#grim_mode_plane_bitmap", "grim_mode_plane_bitmap", 'routine in <a href="nv/grim/grim_mode_plane.html">grim_mode_plane.pro</a>', "grim_mode_plane.pro", "", "grim_mode_plane_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_plane.html#grim_mode_plane_mouse_event", "grim_mode_plane_mouse_event", 'routine in <a href="nv/grim/grim_mode_plane.html">grim_mode_plane.pro</a>', "grim_mode_plane.pro", "", "grim_mode_plane_mouse_event", "", "eventdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_plane.html#grim_mode_plane_mode", "grim_mode_plane_mode", 'routine in <a href="nv/grim/grim_mode_plane.html">grim_mode_plane.pro</a>', "grim_mode_plane.pro", "", "grim_mode_plane_mode", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_plane.html#grim_mode_plane_button_event", "grim_mode_plane_button_event", 'routine in <a href="nv/grim/grim_mode_plane.html">grim_mode_plane.pro</a>', "grim_mode_plane.pro", "", "grim_mode_plane_button_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_plane.html#grim_mode_plane_init", "grim_mode_plane_init", 'routine in <a href="nv/grim/grim_mode_plane.html">grim_mode_plane.pro</a>', "grim_mode_plane.pro", "", "grim_mode_plane_init", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_plane.html#grim_mode_plane", "grim_mode_plane", 'routine in <a href="nv/grim/grim_mode_plane.html">grim_mode_plane.pro</a>', "grim_mode_plane.pro", "", "grim_mode_plane", "", "arg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/grim/grim_mode_readout.html", "grim_mode_readout.pro", '.pro file in <a href="nv/grim/dir-overview.html">nv/grim/ directory</a>', "grim_mode_readout.pro", "", "", " NAME: 	grim_mode_readout_button_event    PURPOSE: 	Selects the readout cursor mode.    CATEGORY: 	NV/GR    OPERATION: 	A text window appears and displays data about the pixel selected 	using the left mouse button.  The amount and type of information 	displayed depends on which descriptors are loaded.    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_readout.html#grim_mode_readout_bitmap", "grim_mode_readout_bitmap", 'routine in <a href="nv/grim/grim_mode_readout.html">grim_mode_readout.pro</a>', "grim_mode_readout.pro", "", "grim_mode_readout_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_readout.html#grim_mode_readout_cursor", "grim_mode_readout_cursor", 'routine in <a href="nv/grim/grim_mode_readout.html">grim_mode_readout.pro</a>', "grim_mode_readout.pro", "", "grim_mode_readout_cursor", "", "swap", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_readout.html#grim_pixel_readout_event", "grim_pixel_readout_event", 'routine in <a href="nv/grim/grim_mode_readout.html">grim_mode_readout.pro</a>', "grim_mode_readout.pro", "", "grim_pixel_readout_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_readout.html#grpr_hide_button_event", "grpr_hide_button_event", 'routine in <a href="nv/grim/grim_mode_readout.html">grim_mode_readout.pro</a>', "grim_mode_readout.pro", "", "grpr_hide_button_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_readout.html#grim_pixel_readout", "grim_pixel_readout", 'routine in <a href="nv/grim/grim_mode_readout.html">grim_mode_readout.pro</a>', "grim_mode_readout.pro", "", "grim_pixel_readout", "", "textgrnumbase", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_readout.html#grim_mode_readout_mouse_event", "grim_mode_readout_mouse_event", 'routine in <a href="nv/grim/grim_mode_readout.html">grim_mode_readout.pro</a>', "grim_mode_readout.pro", "", "grim_mode_readout_mouse_event", "", "eventdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_readout.html#grim_mode_readout_mode", "grim_mode_readout_mode", 'routine in <a href="nv/grim/grim_mode_readout.html">grim_mode_readout.pro</a>', "grim_mode_readout.pro", "", "grim_mode_readout_mode", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_readout.html#grim_mode_readout_button_event", "grim_mode_readout_button_event", 'routine in <a href="nv/grim/grim_mode_readout.html">grim_mode_readout.pro</a>', "grim_mode_readout.pro", "", "grim_mode_readout_button_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_readout.html#grim_mode_readout_init", "grim_mode_readout_init", 'routine in <a href="nv/grim/grim_mode_readout.html">grim_mode_readout.pro</a>', "grim_mode_readout.pro", "", "grim_mode_readout_init", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_readout.html#grim_mode_readout", "grim_mode_readout", 'routine in <a href="nv/grim/grim_mode_readout.html">grim_mode_readout.pro</a>', "grim_mode_readout.pro", "", "grim_mode_readout", "", "arg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/grim/grim_mode_region.html", "grim_mode_region.pro", '.pro file in <a href="nv/grim/dir-overview.html">nv/grim/ directory</a>', "grim_mode_region.pro", "", "", " NAME: 	grim_mode_region_button_event    PURPOSE: 	Selects the 'region' cursor mode.    CATEGORY: 	NV/GR    OPERATION: 	An image region is defined by clicking and dragging a box or curve.    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2014   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_region.html#grim_mode_region_bitmap", "grim_mode_region_bitmap", 'routine in <a href="nv/grim/grim_mode_region.html">grim_mode_region.pro</a>', "grim_mode_region.pro", "", "grim_mode_region_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_region.html#grim_mode_region_mouse_event", "grim_mode_region_mouse_event", 'routine in <a href="nv/grim/grim_mode_region.html">grim_mode_region.pro</a>', "grim_mode_region.pro", "", "grim_mode_region_mouse_event", "", "eventdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_region.html#grim_mode_region_mode", "grim_mode_region_mode", 'routine in <a href="nv/grim/grim_mode_region.html">grim_mode_region.pro</a>', "grim_mode_region.pro", "", "grim_mode_region_mode", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_region.html#grim_mode_region_button_event", "grim_mode_region_button_event", 'routine in <a href="nv/grim/grim_mode_region.html">grim_mode_region.pro</a>', "grim_mode_region.pro", "", "grim_mode_region_button_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_region.html#grim_mode_region_init", "grim_mode_region_init", 'routine in <a href="nv/grim/grim_mode_region.html">grim_mode_region.pro</a>', "grim_mode_region.pro", "", "grim_mode_region_init", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_region.html#grim_mode_region", "grim_mode_region", 'routine in <a href="nv/grim/grim_mode_region.html">grim_mode_region.pro</a>', "grim_mode_region.pro", "", "grim_mode_region", "", "arg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/grim/grim_mode_remove.html", "grim_mode_remove.pro", '.pro file in <a href="nv/grim/dir-overview.html">nv/grim/ directory</a>', "grim_mode_remove.pro", "", "", " NAME: 	grim_mode_remove_button_event    PURPOSE: 	Selects the remove cursor mode.    CATEGORY: 	NV/GR    OPERATION: 	A single click on an overlay causes it to be deleted.  A        double click causes the entire object to be deleted.  The left 	button applies to standard overlays; the right button applies 	to user overlays.    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2006   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_remove.html#grim_mode_remove_bitmap", "grim_mode_remove_bitmap", 'routine in <a href="nv/grim/grim_mode_remove.html">grim_mode_remove.pro</a>', "grim_mode_remove.pro", "", "grim_mode_remove_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_remove.html#grim_mode_remove_flash", "grim_mode_remove_flash", 'routine in <a href="nv/grim/grim_mode_remove.html">grim_mode_remove.pro</a>', "grim_mode_remove.pro", "", "grim_mode_remove_flash", "", "p", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_remove.html#grim_mode_remove_mouse_event", "grim_mode_remove_mouse_event", 'routine in <a href="nv/grim/grim_mode_remove.html">grim_mode_remove.pro</a>', "grim_mode_remove.pro", "", "grim_mode_remove_mouse_event", "", "eventdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_remove.html#grim_mode_remove_cursor", "grim_mode_remove_cursor", 'routine in <a href="nv/grim/grim_mode_remove.html">grim_mode_remove.pro</a>', "grim_mode_remove.pro", "", "grim_mode_remove_cursor", "", "swap", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_remove.html#grim_mode_remove_mode", "grim_mode_remove_mode", 'routine in <a href="nv/grim/grim_mode_remove.html">grim_mode_remove.pro</a>', "grim_mode_remove.pro", "", "grim_mode_remove_mode", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_remove.html#grim_mode_remove_button_event", "grim_mode_remove_button_event", 'routine in <a href="nv/grim/grim_mode_remove.html">grim_mode_remove.pro</a>', "grim_mode_remove.pro", "", "grim_mode_remove_button_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_remove.html#grim_mode_remove_init", "grim_mode_remove_init", 'routine in <a href="nv/grim/grim_mode_remove.html">grim_mode_remove.pro</a>', "grim_mode_remove.pro", "", "grim_mode_remove_init", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_remove.html#grim_mode_remove", "grim_mode_remove", 'routine in <a href="nv/grim/grim_mode_remove.html">grim_mode_remove.pro</a>', "grim_mode_remove.pro", "", "grim_mode_remove", "", "arg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/grim/grim_mode_select.html", "grim_mode_select.pro", '.pro file in <a href="nv/grim/dir-overview.html">nv/grim/ directory</a>', "grim_mode_select.pro", "", "", " NAME: 	grim_mode_select_button_event    PURPOSE: 	Selects the 'select' cursor mode.    CATEGORY: 	NV/GR    OPERATION: 	Overlay points are selected by clicking and dragging and curve around 	the desired points.  The left button selects overlay points, the right 	deselects overlay points.    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2014   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_select.html#grim_mode_select_bitmap", "grim_mode_select_bitmap", 'routine in <a href="nv/grim/grim_mode_select.html">grim_mode_select.pro</a>', "grim_mode_select.pro", "", "grim_mode_select_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_select.html#grim_mode_select_mouse_event", "grim_mode_select_mouse_event", 'routine in <a href="nv/grim/grim_mode_select.html">grim_mode_select.pro</a>', "grim_mode_select.pro", "", "grim_mode_select_mouse_event", "", "eventdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_select.html#grim_mode_select_cursor", "grim_mode_select_cursor", 'routine in <a href="nv/grim/grim_mode_select.html">grim_mode_select.pro</a>', "grim_mode_select.pro", "", "grim_mode_select_cursor", "", "swap", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_select.html#grim_mode_select_mode", "grim_mode_select_mode", 'routine in <a href="nv/grim/grim_mode_select.html">grim_mode_select.pro</a>', "grim_mode_select.pro", "", "grim_mode_select_mode", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_select.html#grim_mode_select_button_event", "grim_mode_select_button_event", 'routine in <a href="nv/grim/grim_mode_select.html">grim_mode_select.pro</a>', "grim_mode_select.pro", "", "grim_mode_select_button_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_select.html#grim_mode_select_init", "grim_mode_select_init", 'routine in <a href="nv/grim/grim_mode_select.html">grim_mode_select.pro</a>', "grim_mode_select.pro", "", "grim_mode_select_init", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_select.html#grim_mode_select", "grim_mode_select", 'routine in <a href="nv/grim/grim_mode_select.html">grim_mode_select.pro</a>', "grim_mode_select.pro", "", "grim_mode_select", "", "arg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/grim/grim_mode_smooth.html", "grim_mode_smooth.pro", '.pro file in <a href="nv/grim/dir-overview.html">nv/grim/ directory</a>', "grim_mode_smooth.pro", "", "", " NAME: 	grim_mode_smooth_button_event    PURPOSE: 	Selects the smooth cursor mode.    CATEGORY: 	NV/GR    OPERATION: 	The user selects a box, which is used to determine the kernel 	size for smothing the data set.    MODIFICATION HISTORY:  	Written by:	Spitale, 10/2006   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_smooth.html#grim_mode_smooth_bitmap", "grim_mode_smooth_bitmap", 'routine in <a href="nv/grim/grim_mode_smooth.html">grim_mode_smooth.pro</a>', "grim_mode_smooth.pro", "", "grim_mode_smooth_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_smooth.html#grim_smooth", "grim_smooth", 'routine in <a href="nv/grim/grim_mode_smooth.html">grim_mode_smooth.pro</a>', "grim_mode_smooth.pro", "", "grim_smooth", "", "planegrim_databox", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_smooth.html#grim_mode_smooth_mouse_event", "grim_mode_smooth_mouse_event", 'routine in <a href="nv/grim/grim_mode_smooth.html">grim_mode_smooth.pro</a>', "grim_mode_smooth.pro", "", "grim_mode_smooth_mouse_event", "", "eventdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_smooth.html#grim_mode_smooth_mode", "grim_mode_smooth_mode", 'routine in <a href="nv/grim/grim_mode_smooth.html">grim_mode_smooth.pro</a>', "grim_mode_smooth.pro", "", "grim_mode_smooth_mode", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_smooth.html#grim_mode_smooth_button_event", "grim_mode_smooth_button_event", 'routine in <a href="nv/grim/grim_mode_smooth.html">grim_mode_smooth.pro</a>', "grim_mode_smooth.pro", "", "grim_mode_smooth_button_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_smooth.html#grim_mode_smooth_init", "grim_mode_smooth_init", 'routine in <a href="nv/grim/grim_mode_smooth.html">grim_mode_smooth.pro</a>', "grim_mode_smooth.pro", "", "grim_mode_smooth_init", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_smooth.html#grim_mode_smooth", "grim_mode_smooth", 'routine in <a href="nv/grim/grim_mode_smooth.html">grim_mode_smooth.pro</a>', "grim_mode_smooth.pro", "", "grim_mode_smooth", "", "arg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/grim/grim_mode_tiepoints.html", "grim_mode_tiepoints.pro", '.pro file in <a href="nv/grim/dir-overview.html">nv/grim/ directory</a>', "grim_mode_tiepoints.pro", "", "", " NAME: 	grim_mode_tiepoints_button_event    PURPOSE: 	Selects the tiepoints cursor mode.    CATEGORY: 	NV/GR    OPERATION: 	Tiepoints are added using the left mouse button and deleted 	using the right button.  Tiepoints appear as crosses labeled 	by numbers.  The use of tiepoints is determined by the 	particular option selected by the user.    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_tiepoints.html#grim_mode_tiepoints_bitmap", "grim_mode_tiepoints_bitmap", 'routine in <a href="nv/grim/grim_mode_tiepoints.html">grim_mode_tiepoints.pro</a>', "grim_mode_tiepoints.pro", "", "grim_mode_tiepoints_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_tiepoints.html#grim_mode_tiepoints_mouse_event", "grim_mode_tiepoints_mouse_event", 'routine in <a href="nv/grim/grim_mode_tiepoints.html">grim_mode_tiepoints.pro</a>', "grim_mode_tiepoints.pro", "", "grim_mode_tiepoints_mouse_event", "", "eventdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_tiepoints.html#grim_mode_tiepoints_cursor", "grim_mode_tiepoints_cursor", 'routine in <a href="nv/grim/grim_mode_tiepoints.html">grim_mode_tiepoints.pro</a>', "grim_mode_tiepoints.pro", "", "grim_mode_tiepoints_cursor", "", "swap", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_tiepoints.html#grim_mode_tiepoints_mode", "grim_mode_tiepoints_mode", 'routine in <a href="nv/grim/grim_mode_tiepoints.html">grim_mode_tiepoints.pro</a>', "grim_mode_tiepoints.pro", "", "grim_mode_tiepoints_mode", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_tiepoints.html#grim_mode_tiepoints_button_event", "grim_mode_tiepoints_button_event", 'routine in <a href="nv/grim/grim_mode_tiepoints.html">grim_mode_tiepoints.pro</a>', "grim_mode_tiepoints.pro", "", "grim_mode_tiepoints_button_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_tiepoints.html#grim_mode_tiepoints_init", "grim_mode_tiepoints_init", 'routine in <a href="nv/grim/grim_mode_tiepoints.html">grim_mode_tiepoints.pro</a>', "grim_mode_tiepoints.pro", "", "grim_mode_tiepoints_init", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_tiepoints.html#grim_mode_tiepoints", "grim_mode_tiepoints", 'routine in <a href="nv/grim/grim_mode_tiepoints.html">grim_mode_tiepoints.pro</a>', "grim_mode_tiepoints.pro", "", "grim_mode_tiepoints", "", "arg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/grim/grim_mode_trim.html", "grim_mode_trim.pro", '.pro file in <a href="nv/grim/dir-overview.html">nv/grim/ directory</a>', "grim_mode_trim.pro", "", "", " NAME: 	grim_mode_trim_button_event    PURPOSE: 	Selects the trim cursor mode.    CATEGORY: 	NV/GR    OPERATION: 	Overlay points are trimmed by clicking and dragging and curve around 	the desired points.  The left button trims standard overlays, the right 	trims user overlay points.    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2006   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_trim.html#grim_mode_trim_bitmap", "grim_mode_trim_bitmap", 'routine in <a href="nv/grim/grim_mode_trim.html">grim_mode_trim.pro</a>', "grim_mode_trim.pro", "", "grim_mode_trim_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_trim.html#grim_mode_trim_mouse_event", "grim_mode_trim_mouse_event", 'routine in <a href="nv/grim/grim_mode_trim.html">grim_mode_trim.pro</a>', "grim_mode_trim.pro", "", "grim_mode_trim_mouse_event", "", "eventdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_trim.html#grim_mode_trim_cursor", "grim_mode_trim_cursor", 'routine in <a href="nv/grim/grim_mode_trim.html">grim_mode_trim.pro</a>', "grim_mode_trim.pro", "", "grim_mode_trim_cursor", "", "swap", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_trim.html#grim_mode_trim_mode", "grim_mode_trim_mode", 'routine in <a href="nv/grim/grim_mode_trim.html">grim_mode_trim.pro</a>', "grim_mode_trim.pro", "", "grim_mode_trim_mode", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_trim.html#grim_mode_trim_button_event", "grim_mode_trim_button_event", 'routine in <a href="nv/grim/grim_mode_trim.html">grim_mode_trim.pro</a>', "grim_mode_trim.pro", "", "grim_mode_trim_button_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_trim.html#grim_mode_trim_init", "grim_mode_trim_init", 'routine in <a href="nv/grim/grim_mode_trim.html">grim_mode_trim.pro</a>', "grim_mode_trim.pro", "", "grim_mode_trim_init", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_trim.html#grim_mode_trim", "grim_mode_trim", 'routine in <a href="nv/grim/grim_mode_trim.html">grim_mode_trim.pro</a>', "grim_mode_trim.pro", "", "grim_mode_trim", "", "arg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/grim/grim_mode_xyzoom.html", "grim_mode_xyzoom.pro", '.pro file in <a href="nv/grim/dir-overview.html">nv/grim/ directory</a>', "grim_mode_xyzoom.pro", "", "", " NAME: 	grim_mode_xyzoom_button_event    PURPOSE: 	Selects the xy-zoom cursor mode.    CATEGORY: 	NV/GR    OPERATION: 	Same as 'zoom' mode, except the aspect ratio is set by the 	proportions of the selected box.    MODIFICATION HISTORY:  	Written by:	Spitale, 5/2005   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_xyzoom.html#grim_mode_xyzoom_bitmap", "grim_mode_xyzoom_bitmap", 'routine in <a href="nv/grim/grim_mode_xyzoom.html">grim_mode_xyzoom.pro</a>', "grim_mode_xyzoom.pro", "", "grim_mode_xyzoom_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_xyzoom.html#grim_mode_xyzoom_mouse_event", "grim_mode_xyzoom_mouse_event", 'routine in <a href="nv/grim/grim_mode_xyzoom.html">grim_mode_xyzoom.pro</a>', "grim_mode_xyzoom.pro", "", "grim_mode_xyzoom_mouse_event", "", "eventdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_xyzoom.html#grim_mode_xyzoom_cursor", "grim_mode_xyzoom_cursor", 'routine in <a href="nv/grim/grim_mode_xyzoom.html">grim_mode_xyzoom.pro</a>', "grim_mode_xyzoom.pro", "", "grim_mode_xyzoom_cursor", "", "swap", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_xyzoom.html#grim_mode_xyzoom_mode", "grim_mode_xyzoom_mode", 'routine in <a href="nv/grim/grim_mode_xyzoom.html">grim_mode_xyzoom.pro</a>', "grim_mode_xyzoom.pro", "", "grim_mode_xyzoom_mode", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_xyzoom.html#grim_mode_xyzoom_button_event", "grim_mode_xyzoom_button_event", 'routine in <a href="nv/grim/grim_mode_xyzoom.html">grim_mode_xyzoom.pro</a>', "grim_mode_xyzoom.pro", "", "grim_mode_xyzoom_button_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_xyzoom.html#grim_mode_xyzoom_init", "grim_mode_xyzoom_init", 'routine in <a href="nv/grim/grim_mode_xyzoom.html">grim_mode_xyzoom.pro</a>', "grim_mode_xyzoom.pro", "", "grim_mode_xyzoom_init", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_xyzoom.html#grim_mode_xyzoom", "grim_mode_xyzoom", 'routine in <a href="nv/grim/grim_mode_xyzoom.html">grim_mode_xyzoom.pro</a>', "grim_mode_xyzoom.pro", "", "grim_mode_xyzoom", "", "arg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/grim/grim_mode_zoom.html", "grim_mode_zoom.pro", '.pro file in <a href="nv/grim/dir-overview.html">nv/grim/ directory</a>', "grim_mode_zoom.pro", "", "", " NAME: 	grim_mode_zoom_button_event    PURPOSE: 	Selects the zoom cursor mode.    CATEGORY: 	NV/GR    OPERATION: 	The image zoom and offset are controlled by selecting 	a box in the image.  When the box is created using the 	left mouse button, zoom and offset are changed so that 	the contents of the box best fill the current graphics 	window.  When the right button is used, the contents of 	the current graphics window are shrunken so as to best 	fill the box.  In other words, the left button zooms in 	and the right button zooms out.    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_zoom.html#grim_mode_zoom_bitmap", "grim_mode_zoom_bitmap", 'routine in <a href="nv/grim/grim_mode_zoom.html">grim_mode_zoom.pro</a>', "grim_mode_zoom.pro", "", "grim_mode_zoom_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_zoom.html#grim_mode_zoom_mouse_event", "grim_mode_zoom_mouse_event", 'routine in <a href="nv/grim/grim_mode_zoom.html">grim_mode_zoom.pro</a>', "grim_mode_zoom.pro", "", "grim_mode_zoom_mouse_event", "", "eventdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_zoom.html#grim_mode_zoom_mode", "grim_mode_zoom_mode", 'routine in <a href="nv/grim/grim_mode_zoom.html">grim_mode_zoom.pro</a>', "grim_mode_zoom.pro", "", "grim_mode_zoom_mode", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_zoom.html#grim_mode_zoom_button_event", "grim_mode_zoom_button_event", 'routine in <a href="nv/grim/grim_mode_zoom.html">grim_mode_zoom.pro</a>', "grim_mode_zoom.pro", "", "grim_mode_zoom_button_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_zoom.html#grim_mode_zoom_init", "grim_mode_zoom_init", 'routine in <a href="nv/grim/grim_mode_zoom.html">grim_mode_zoom.pro</a>', "grim_mode_zoom.pro", "", "grim_mode_zoom_init", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_zoom.html#grim_mode_zoom", "grim_mode_zoom", 'routine in <a href="nv/grim/grim_mode_zoom.html">grim_mode_zoom.pro</a>', "grim_mode_zoom.pro", "", "grim_mode_zoom", "", "arg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/grim/grim_mode_zoom_plot.html", "grim_mode_zoom_plot.pro", '.pro file in <a href="nv/grim/dir-overview.html">nv/grim/ directory</a>', "grim_mode_zoom_plot.pro", "", "", " NAME: 	grim_mode_zoom_plot_button_event    PURPOSE: 	Selects the zoom cursor mode.    CATEGORY: 	NV/GR    OPERATION: 	The image zoom and offset are controlled by selecting 	a box in the image.  When the box is created using the 	left mouse button, zoom and offset are changed so that 	the contents of the box best fill the current graphics 	window.  When the right button is used, the contents of 	the current graphics window are shrunken so as to best 	fill the box.  In other words, the left button zooms in 	and the right button zooms out.    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_zoom_plot.html#grim_mode_zoom_plot_bitmap", "grim_mode_zoom_plot_bitmap", 'routine in <a href="nv/grim/grim_mode_zoom_plot.html">grim_mode_zoom_plot.pro</a>', "grim_mode_zoom_plot.pro", "", "grim_mode_zoom_plot_bitmap", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_zoom_plot.html#grim_mode_zoom_plot_mouse_event", "grim_mode_zoom_plot_mouse_event", 'routine in <a href="nv/grim/grim_mode_zoom_plot.html">grim_mode_zoom_plot.pro</a>', "grim_mode_zoom_plot.pro", "", "grim_mode_zoom_plot_mouse_event", "", "eventdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_zoom_plot.html#grim_mode_zoom_plot_mode", "grim_mode_zoom_plot_mode", 'routine in <a href="nv/grim/grim_mode_zoom_plot.html">grim_mode_zoom_plot.pro</a>', "grim_mode_zoom_plot.pro", "", "grim_mode_zoom_plot_mode", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_zoom_plot.html#grim_mode_zoom_plot_button_event", "grim_mode_zoom_plot_button_event", 'routine in <a href="nv/grim/grim_mode_zoom_plot.html">grim_mode_zoom_plot.pro</a>', "grim_mode_zoom_plot.pro", "", "grim_mode_zoom_plot_button_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_zoom_plot.html#grim_mode_zoom_plot_init", "grim_mode_zoom_plot_init", 'routine in <a href="nv/grim/grim_mode_zoom_plot.html">grim_mode_zoom_plot.pro</a>', "grim_mode_zoom_plot.pro", "", "grim_mode_zoom_plot_init", "", "grim_datadata_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_mode_zoom_plot.html#grim_mode_zoom_plot", "grim_mode_zoom_plot", 'routine in <a href="nv/grim/grim_mode_zoom_plot.html">grim_mode_zoom_plot.pro</a>', "grim_mode_zoom_plot.pro", "", "grim_mode_zoom_plot", "", "arg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/grim/grim_no_cursor.html", "grim_no_cursor.pro", '.pro file in <a href="nv/grim/dir-overview.html">nv/grim/ directory</a>', "grim_no_cursor.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/grim/grim_no_cursor.html#grim_no_cursor", "grim_no_cursor", 'routine in <a href="nv/grim/grim_no_cursor.html">grim_no_cursor.pro</a>', "grim_no_cursor.pro", "", "grim_no_cursor", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/grim/grim_overlay_settings.html", "grim_overlay_settings.pro", '.pro file in <a href="nv/grim/dir-overview.html">nv/grim/ directory</a>', "grim_overlay_settings.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlay_settings.html#gros_user_tag", "gros_user_tag", 'routine in <a href="nv/grim/grim_overlay_settings.html">grim_overlay_settings.pro</a>', "grim_overlay_settings.pro", "", "gros_user_tag", "", "iname", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlay_settings.html#gros_overlay_tag", "gros_overlay_tag", 'routine in <a href="nv/grim/grim_overlay_settings.html">grim_overlay_settings.pro</a>', "grim_overlay_settings.pro", "", "gros_overlay_tag", "", "iname", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlay_settings.html#gros_update_form", "gros_update_form", 'routine in <a href="nv/grim/grim_overlay_settings.html">grim_overlay_settings.pro</a>', "grim_overlay_settings.pro", "", "gros_update_form", "", "grim_dataplanebase", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlay_settings.html#gros_cleanup", "gros_cleanup", 'routine in <a href="nv/grim/grim_overlay_settings.html">grim_overlay_settings.pro</a>', "grim_overlay_settings.pro", "", "gros_cleanup", "", "base", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlay_settings.html#gros_apply_settings", "gros_apply_settings", 'routine in <a href="nv/grim/grim_overlay_settings.html">grim_overlay_settings.pro</a>', "grim_overlay_settings.pro", "", "gros_apply_settings", "", "data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlay_settings.html#gros_ok", "gros_ok", 'routine in <a href="nv/grim/grim_overlay_settings.html">grim_overlay_settings.pro</a>', "grim_overlay_settings.pro", "", "gros_ok", "", "database", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlay_settings.html#grim_overlay_settings_event", "grim_overlay_settings_event", 'routine in <a href="nv/grim/grim_overlay_settings.html">grim_overlay_settings.pro</a>', "grim_overlay_settings.pro", "", "grim_overlay_settings_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlay_settings.html#grim_overlay_settings", "grim_overlay_settings", 'routine in <a href="nv/grim/grim_overlay_settings.html">grim_overlay_settings.pro</a>', "grim_overlay_settings.pro", "", "grim_overlay_settings", "", "grim_dataplane", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html", "grim_overlays_include.pro", '.pro file in <a href="nv/grim/dir-overview.html">nv/grim/ directory</a>', "grim_overlays_include.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_set_overlay_update_flag", "grim_set_overlay_update_flag", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_set_overlay_update_flag", "", "ptdvalue", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_get_overlay_update_flag", "grim_get_overlay_update_flag", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_get_overlay_update_flag", "", "ptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_get_updated_ptd", "grim_get_updated_ptd", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_get_updated_ptd", "", "iiclear_ptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_get_xd", "grim_get_xd", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_get_xd", "", "planegrim_dataclass", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_get_overlay_ptdp", "grim_get_overlay_ptdp", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_get_overlay_ptdp", "", "planedataclassdeplabelsiicolorpsymtlabtshadesymsizeshadetfillgenrefastgrim_dataname", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_get_active_overlays", "grim_get_active_overlays", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_get_active_overlays", "", "planeactive_indicesinactive_indicesgrim_datatype", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_get_all_active_overlays", "grim_get_all_active_overlays", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_get_all_active_overlays", "", "planenamesgrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_get_all_overlays", "grim_get_all_overlays", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_get_all_overlays", "", "planenamesgrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_get_active_xds", "grim_get_active_xds", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_get_active_xds", "", "active_indicesinactive_indicesplaneclass", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_update_activated", "grim_update_activated", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_update_activated", "", "planegrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_add_activation_callback", "grim_add_activation_callback", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_add_activation_callback", "", "topno_wsetcallbacksdata_ps", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_rm_activation_callback", "grim_rm_activation_callback", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_rm_activation_callback", "", "topdata_ps", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_call_activation_callbacks", "grim_call_activation_callbacks", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_call_activation_callbacks", "", "planeptdarg", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_fill", "grim_fill", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_fill", "", "ptdnamecolor", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_draw_standard_points", "grim_draw_standard_points", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_draw_standard_points", "", "psympsizeplabelslabel_shadegrim_dataplane_ptdnamedatacolortshadeshade", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_draw_standard_overlays", "grim_draw_standard_overlays", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_draw_standard_overlays", "", "updatemlabgrim_dataplaneinactive_color", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_draw_user_points", "grim_draw_user_points", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_draw_user_points", "", "xmapgrim_dataplanetags", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_draw_user_overlays", "grim_draw_user_overlays", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_draw_user_overlays", "", "grim_dataplaneinactive_color", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_draw_roi", "grim_draw_roi", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_draw_roi", "", "grim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_draw_indexed_arrays", "grim_draw_indexed_arrays", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_draw_indexed_arrays", "", "psymptdp", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_draw_curves", "grim_draw_curves", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_draw_curves", "", "grim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_draw_tiepoints", "grim_draw_tiepoints", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_draw_tiepoints", "", "grim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_draw_mask", "grim_draw_mask", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_draw_mask", "", "grim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_draw", "grim_draw", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_draw", "", "planesallwnumusertiepointsmaskcurveslabelreadoutmeasureupdatenopointsroino_usergrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_draw_grids", "grim_draw_grids", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_draw_grids", "", "planeno_wsetgrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_draw_axes", "grim_draw_axes", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_draw_axes", "", "planeno_contextno_wsetgrim_datadata", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_cat_points", "grim_cat_points", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_cat_points", "", "allactiveplanegrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_rm_points", "grim_rm_points", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_rm_points", "", "planeptdpii", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_match_overlays", "grim_match_overlays", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_match_overlays", "", "ptdptd0", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_add_new_points", "grim_add_new_points", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_add_new_points", "", "planegrim_dataptdpptdnamecd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_rm_matched_points", "grim_rm_matched_points", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_rm_matched_points", "", "planegrim_dataptdpptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_update_points", "grim_update_points", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_update_points", "", "planegrim_dataptd0ptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_add_points", "grim_add_points", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_add_points", "", "planenamecddatagrim_dataptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_default_activations", "grim_default_activations", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_default_activations", "", "planegrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_clear_overlay_points", "grim_clear_overlay_points", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_clear_overlay_points", "", "ptdpactive_ptdp", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_clear_active_overlays", "grim_clear_active_overlays", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_clear_active_overlays", "", "grim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_frame_overlays", "grim_frame_overlays", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_frame_overlays", "", "slopxygrim_dataplaneptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_hide_overlays", "grim_hide_overlays", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_hide_overlays", "", "no_refreshbmgrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_clear_objects", "grim_clear_objects", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_clear_objects", "", "allcdpdrdsdstdsundplanesgrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_place_readout_mark", "grim_place_readout_mark", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_place_readout_mark", "", "grim_datap", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_place_measure_mark", "grim_place_measure_mark", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_place_measure_mark", "", "grim_datap", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_get_indexed_array", "grim_get_indexed_array", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_get_indexed_array", "", "planename", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_indexed_array_fname", "grim_indexed_array_fname", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_indexed_array_fname", "", "basenamegrim_dataplanename", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_write_indexed_arrays", "grim_write_indexed_arrays", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_write_indexed_arrays", "", "fnamegrim_dataplanename", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_read_indexed_arrays", "grim_read_indexed_arrays", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_read_indexed_arrays", "", "fnamegrim_dataplanename", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_unique_array_label", "grim_unique_array_label", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_unique_array_label", "", "ptdp", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_add_indexed_array", "grim_add_indexed_array", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_add_indexed_array", "", "ptdnointerpspacingflagslabelptdpp", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_select_array_by_box", "grim_select_array_by_box", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_select_array_by_box", "", "planegrim_dataptdcxcy", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_select_array_by_point", "grim_select_array_by_point", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_select_array_by_point", "", "allplanegrim_dataptdp", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_select_array", "grim_select_array", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_select_array", "", "planegrim_dataptdp", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_rm_indexed_array", "grim_rm_indexed_array", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_rm_indexed_array", "", "planeallgrim_datanamep", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_add_tiepoint", "grim_add_tiepoint", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_add_tiepoint", "", "planenointerpspacingno_syncflagsgrim_datap", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_add_curve", "grim_add_curve", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_add_curve", "", "planenointerpspacingno_syncflagsgrim_datap", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_rm_tiepoint", "grim_rm_tiepoint", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_rm_tiepoint", "", "allplanenosyncgrim_datap", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_rm_curve", "grim_rm_curve", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_rm_curve", "", "allplanenosyncgrim_datap", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_set_roi", "grim_set_roi", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_set_roi", "", "planegrim_dataroip", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_add_mask", "grim_add_mask", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_add_mask", "", "planereplacesubscriptgrim_datap", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_copy_mask", "grim_copy_mask", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_copy_mask", "", "grim_dataplaneplanes", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_copy_indexed_array", "grim_copy_indexed_array", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_copy_indexed_array", "", "grim_dataplaneplanesname", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_copy_tiepoint", "grim_copy_tiepoint", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_copy_tiepoint", "", "grim_dataplaneplanes", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_copy_curve", "grim_copy_curve", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_copy_curve", "", "grim_dataplaneplanes", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_get_tiepoint_indices", "grim_get_tiepoint_indices", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_get_tiepoint_indices", "", "planegrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_replace_tiepoints", "grim_replace_tiepoints", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_replace_tiepoints", "", "planegrim_dataiip", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_image_to_surface", "grim_image_to_surface", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_image_to_surface", "", "body_ptsfar_ptsnamesbxgrim_dataplaneimage_pts", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_surface_to_image", "grim_surface_to_image", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_surface_to_image", "", "validgrim_dataplanesurf_ptsnames", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_sync_indexed_array", "grim_sync_indexed_array", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_sync_indexed_array", "", "grim_dataplaneptd_grim_data_plane_ptdp", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_push_indexed_array", "grim_push_indexed_array", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_push_indexed_array", "", "rmgrim_dataptdname", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_rm_mask_by_point", "grim_rm_mask_by_point", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_rm_mask_by_point", "", "planeppgrim_datap", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_rm_mask_by_box", "grim_rm_mask_by_box", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_rm_mask_by_box", "", "planeppgrim_datacxcy", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_rm_mask", "grim_rm_mask", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_rm_mask", "", "allplaneppgrim_datap", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_get_object_overlays", "grim_get_object_overlays", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_get_object_overlays", "", "grim_dataplanexd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_deactivate_xd", "grim_deactivate_xd", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_deactivate_xd", "", "planexds", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_deactivate_overlay", "grim_deactivate_overlay", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_deactivate_overlay", "", "xdsassoc_xdspptdno_callbackgrim_dataplaneptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_activate_xd", "grim_activate_xd", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_activate_xd", "", "planexds", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_deactivate_all_xds", "grim_deactivate_all_xds", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_deactivate_all_xds", "", "plane", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_activate_all_xds", "grim_activate_all_xds", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_activate_all_xds", "", "plane", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_activate_overlay", "grim_activate_overlay", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_activate_overlay", "", "xdspptdno_callbackgrim_dataplaneptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_activate_all_overlays", "grim_activate_all_overlays", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_activate_all_overlays", "", "grim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_deactivate_all_overlays", "grim_deactivate_all_overlays", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_deactivate_all_overlays", "", "grim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_invert_active_overlays", "grim_invert_active_overlays", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_invert_active_overlays", "", "xdsgrim_dataplaneptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_invert_all_overlays", "grim_invert_all_overlays", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_invert_all_overlays", "", "grim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_nearest_overlay", "grim_nearest_overlay", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_nearest_overlay", "", "mmplanepobject_ptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_enclosed_overlays", "grim_enclosed_overlays", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_enclosed_overlays", "", "mmcornersobject_ptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_remove_by_point", "grim_remove_by_point", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_remove_by_point", "", "clicksuserplanep0", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_activate_by_point", "grim_activate_by_point", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_activate_by_point", "", "deactivateclicksinvertgrim_dataplanep0", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_trim_overlays", "grim_trim_overlays", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_trim_overlays", "", "planegrim_dataregion", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_select_overlay_points", "grim_select_overlay_points", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_select_overlay_points", "", "planedeselectgrim_dataregion", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_remove_by_box", "grim_remove_by_box", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_remove_by_box", "", "statuserplanecxcy", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_activate_by_box", "grim_activate_by_box", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_activate_by_box", "", "deactivategrim_dataplanecxcy", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_activate_select", "grim_activate_select", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_activate_select", "", "deactivateclicksptdgrim_dataplanep0", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_remove_overlays", "grim_remove_overlays", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_remove_overlays", "", "clicksstatuserplanep0", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_create_overlay", "grim_create_overlay", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_create_overlay", "", "classdep_classescolorpsymsymsizeshadetlabtshadetfillgenregrim_dataplanenamedep_overlays", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_create_overlays", "grim_create_overlays", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_create_overlays", "", "grim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_hide", "grim_hide", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_hide", "", "gdgrim_dataplaneptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_overlay", "grim_overlay", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_overlay", "", "planedepptdsource_ptdobj_nametempgrim_dataname", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_overlays_include.html#grim_overlays_include", "grim_overlays_include", 'routine in <a href="nv/grim/grim_overlays_include.html">grim_overlays_include.pro</a>', "grim_overlays_include.pro", "", "grim_overlays_include", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/grim/grim_plane_settings.html", "grim_plane_settings.pro", '.pro file in <a href="nv/grim/dir-overview.html">nv/grim/ directory</a>', "grim_plane_settings.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/grim/grim_plane_settings.html#grps_overlay_tag", "grps_overlay_tag", 'routine in <a href="nv/grim/grim_plane_settings.html">grim_plane_settings.pro</a>', "grim_plane_settings.pro", "", "grps_overlay_tag", "", "iname", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_plane_settings.html#grps_update_form", "grps_update_form", 'routine in <a href="nv/grim/grim_plane_settings.html">grim_plane_settings.pro</a>', "grim_plane_settings.pro", "", "grps_update_form", "", "grim_dataplanebase", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_plane_settings.html#grps_invert", "grps_invert", 'routine in <a href="nv/grim/grim_plane_settings.html">grim_plane_settings.pro</a>', "grim_plane_settings.pro", "", "grps_invert", "", "databases", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_plane_settings.html#grps_cleanup", "grps_cleanup", 'routine in <a href="nv/grim/grim_plane_settings.html">grim_plane_settings.pro</a>', "grim_plane_settings.pro", "", "grps_cleanup", "", "base", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_plane_settings.html#grps_apply_settings", "grps_apply_settings", 'routine in <a href="nv/grim/grim_plane_settings.html">grim_plane_settings.pro</a>', "grim_plane_settings.pro", "", "grps_apply_settings", "", "data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_plane_settings.html#grps_ok", "grps_ok", 'routine in <a href="nv/grim/grim_plane_settings.html">grim_plane_settings.pro</a>', "grim_plane_settings.pro", "", "grps_ok", "", "database", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_plane_settings.html#grim_plane_settings_event", "grim_plane_settings_event", 'routine in <a href="nv/grim/grim_plane_settings.html">grim_plane_settings.pro</a>', "grim_plane_settings.pro", "", "grim_plane_settings_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_plane_settings.html#grim_plane_settings", "grim_plane_settings", 'routine in <a href="nv/grim/grim_plane_settings.html">grim_plane_settings.pro</a>', "grim_plane_settings.pro", "", "grim_plane_settings", "", "grim_data", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/grim/grim_planes_include.html", "grim_planes_include.pro", '.pro file in <a href="nv/grim/dir-overview.html">nv/grim/ directory</a>', "grim_planes_include.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/grim/grim_planes_include.html#grim_next_plane", "grim_next_plane", 'routine in <a href="nv/grim/grim_planes_include.html">grim_planes_include.pro</a>', "grim_planes_include.pro", "", "grim_next_plane", "", "norefreshgrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_planes_include.html#grim_previous_plane", "grim_previous_plane", 'routine in <a href="nv/grim/grim_planes_include.html">grim_planes_include.pro</a>', "grim_planes_include.pro", "", "grim_previous_plane", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_planes_include.html#grim_get_plane", "grim_get_plane", 'routine in <a href="nv/grim/grim_planes_include.html">grim_planes_include.pro</a>', "grim_planes_include.pro", "", "grim_get_plane", "", "allpnvisiblegrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_planes_include.html#grim_test_map", "grim_test_map", 'routine in <a href="nv/grim/grim_planes_include.html">grim_planes_include.pro</a>', "grim_planes_include.pro", "", "grim_test_map", "", "planegrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_planes_include.html#grim_test_rgb", "grim_test_rgb", 'routine in <a href="nv/grim/grim_planes_include.html">grim_planes_include.pro</a>', "grim_planes_include.pro", "", "grim_test_rgb", "", "grim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_planes_include.html#grim_get_image", "grim_get_image", 'routine in <a href="nv/grim/grim_planes_include.html">grim_planes_include.pro</a>', "grim_planes_include.pro", "", "grim_get_image", "", "planeabscissacurrentsamplechannelndgrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_planes_include.html#grim_stretch_plane", "grim_stretch_plane", 'routine in <a href="nv/grim/grim_planes_include.html">grim_planes_include.pro</a>', "grim_planes_include.pro", "", "grim_stretch_plane", "", "grim_dataplanes", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_planes_include.html#grim_plane_set_visible", "grim_plane_set_visible", 'routine in <a href="nv/grim/grim_planes_include.html">grim_planes_include.pro</a>', "grim_planes_include.pro", "", "grim_plane_set_visible", "", "togglegrim_dataplanesval", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_planes_include.html#grim_get_visible_planes", "grim_get_visible_planes", 'routine in <a href="nv/grim/grim_planes_include.html">grim_planes_include.pro</a>', "grim_planes_include.pro", "", "grim_get_visible_planes", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_planes_include.html#grim_set_plane", "grim_set_plane", 'routine in <a href="nv/grim/grim_planes_include.html">grim_planes_include.pro</a>', "grim_planes_include.pro", "", "grim_set_plane", "", "pngrim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_planes_include.html#grim_rm_plane", "grim_rm_plane", 'routine in <a href="nv/grim/grim_planes_include.html">grim_planes_include.pro</a>', "grim_planes_include.pro", "", "grim_rm_plane", "", "grim_datapn", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_planes_include.html#grim_crop_plane", "grim_crop_plane", 'routine in <a href="nv/grim/grim_planes_include.html">grim_planes_include.pro</a>', "grim_planes_include.pro", "", "grim_crop_plane", "", "grim_dataplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_planes_include.html#grim_init_parms", "grim_init_parms", 'routine in <a href="nv/grim/grim_planes_include.html">grim_planes_include.pro</a>', "grim_planes_include.pro", "", "grim_init_parms", "", "colorthicknsumpsymsymsizen", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_planes_include.html#grim_clone_plane", "grim_clone_plane", 'routine in <a href="nv/grim/grim_planes_include.html">grim_planes_include.pro</a>', "grim_planes_include.pro", "", "grim_clone_plane", "", "planespawngrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_planes_include.html#grim_channel_to_rgb", "grim_channel_to_rgb", 'routine in <a href="nv/grim/grim_planes_include.html">grim_planes_include.pro</a>', "grim_planes_include.pro", "", "grim_channel_to_rgb", "", "channel", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_planes_include.html#grim_add_planes", "grim_add_planes", 'routine in <a href="nv/grim/grim_planes_include.html">grim_planes_include.pro</a>', "grim_planes_include.pro", "", "grim_add_planes", "", "pnsfilterfovcliphidepathsave_pathload_pathcam_trsplt_trsrng_trsstr_trsstn_trsarr_trssun_trscolorpositionxrangeyrangethicknsumxtitleytitlepsymsymsizemaxvisibilitychannelrender_samplerender_pht_minoverlayscmdgrim_datadd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_planes_include.html#grim_planes_include", "grim_planes_include", 'routine in <a href="nv/grim/grim_planes_include.html">grim_planes_include.pro</a>', "grim_planes_include.pro", "", "grim_planes_include", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/grim/grim_print.html", "grim_print.pro", '.pro file in <a href="nv/grim/dir-overview.html">nv/grim/ directory</a>', "grim_print.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/grim/grim_print.html#grim_print", "grim_print", 'routine in <a href="nv/grim/grim_print.html">grim_print.pro</a>', "grim_print.pro", "", "grim_print", "", "appendarg1arg2", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/grim/grim_rc_settings.html", "grim_rc_settings.pro", '.pro file in <a href="nv/grim/dir-overview.html">nv/grim/ directory</a>', "grim_rc_settings.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/grim/grim_rc_settings.html#grim_rc_value", "grim_rc_value", 'routine in <a href="nv/grim/grim_rc_settings.html">grim_rc_settings.pro</a>', "grim_rc_settings.pro", "", "grim_rc_value", "", "keywordsvalue_pskeyword", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_rc_settings.html#grim_rc_add_values", "grim_rc_add_values", 'routine in <a href="nv/grim/grim_rc_settings.html">grim_rc_settings.pro</a>', "grim_rc_settings.pro", "", "grim_rc_add_values", "", "selectkeywordsvalue_psprefix", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_rc_settings.html#grim_rc_selections", "grim_rc_selections", 'routine in <a href="nv/grim/grim_rc_settings.html">grim_rc_settings.pro</a>', "grim_rc_settings.pro", "", "grim_rc_selections", "", "cam_selectplt_selectrng_selectstr_selectstn_selectarr_selectsun_selectkeywordsvalue_pskeyvals", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_rc_settings.html#grim_rc_settings", "grim_rc_settings", 'routine in <a href="nv/grim/grim_rc_settings.html">grim_rc_settings.pro</a>', "grim_rc_settings.pro", "", "grim_rc_settings", "", "rcfilekeyvalscam_selectplt_selectrng_selectstr_selectstn_selectarr_selectsun_selectcmdnewxsizeysizemode_initnpointszoomrotateorderoffsetfilterretainpathsave_pathload_pathsymsizeoverlaysmenu_fnamecursor_swapfovclipmenu_extensionsbutton_extensionscam_trsplt_trsrng_trsstr_trsstn_trsarr_trssun_trsfiletypehidemode_argsxzerorgbpsymnhistmaintainnddworkdiractivateframecompressloadctmaxarg_extensionsextensionsbetarenderingplane_syncingtiepoint_syncingcurve_syncingvisibilitychannelrender_samplerender_pht_minslave_overlaysdelay_overlaysauto_stretch", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/grim/grim_user_include.html", "grim_user_include.pro", '.pro file in <a href="nv/grim/dir-overview.html">nv/grim/ directory</a>', "grim_user_include.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/grim/grim_user_include.html#grim_user_ptd_struct__define", "grim_user_ptd_struct__define", 'routine in <a href="nv/grim/grim_user_include.html">grim_user_include.pro</a>', "grim_user_include.pro", "", "grim_user_ptd_struct__define", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_user_include.html#grim_add_user_points", "grim_add_user_points", 'routine in <a href="nv/grim/grim_user_include.html">grim_user_include.pro</a>', "grim_user_include.pro", "", "grim_add_user_points", "", "grnumupdatecolorshade_fnpsymthicklinesymsizeshade_thresholdgraphics_fnxgraphicsnodrawinactiveno_refreshplaneuser_ptdtag", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_user_include.html#grim_user_notify", "grim_user_notify", 'routine in <a href="nv/grim/grim_user_include.html">grim_user_include.pro</a>', "grim_user_include.pro", "", "grim_user_notify", "", "planegrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_user_include.html#grim_update_user_points", "grim_update_user_points", 'routine in <a href="nv/grim/grim_user_include.html">grim_user_include.pro</a>', "grim_user_include.pro", "", "grim_update_user_points", "", "planegrnumcolorshade_fnpsymthicklinesymsizeshade_thresholdgraphics_fnxgraphicsnodrawno_refreshuser_ptdtag", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_user_include.html#grim_rm_user_points", "grim_rm_user_points", 'routine in <a href="nv/grim/grim_user_include.html">grim_user_include.pro</a>', "grim_user_include.pro", "", "grim_rm_user_points", "", "planegrnumgrim_datatag", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_user_include.html#grim_test_active_user_ptd", "grim_test_active_user_ptd", 'routine in <a href="nv/grim/grim_user_include.html">grim_user_include.pro</a>', "grim_user_include.pro", "", "grim_test_active_user_ptd", "", "prefixplanetag", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_user_include.html#grim_get_user_ptd", "grim_get_user_ptd", 'routine in <a href="nv/grim/grim_user_include.html">grim_user_include.pro</a>', "grim_user_include.pro", "", "grim_get_user_ptd", "", "grnumprefixplanecolorshade_fnxgraphicsgraphics_fnshade_thresholdpsymthicklinesymsizetagsactivetag", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_user_include.html#grim_get_active_user_overlays", "grim_get_active_user_overlays", 'routine in <a href="nv/grim/grim_user_include.html">grim_user_include.pro</a>', "grim_user_include.pro", "", "grim_get_active_user_overlays", "", "active_tagsinactive_tagsplane", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_user_include.html#grim_trim_user_overlays", "grim_trim_user_overlays", 'routine in <a href="nv/grim/grim_user_include.html">grim_user_include.pro</a>', "grim_user_include.pro", "", "grim_trim_user_overlays", "", "planegrim_dataregion", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_user_include.html#grim_activate_user_overlay", "grim_activate_user_overlay", 'routine in <a href="nv/grim/grim_user_include.html">grim_user_include.pro</a>', "grim_user_include.pro", "", "grim_activate_user_overlay", "", "planeindices", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_user_include.html#grim_deactivate_user_overlay", "grim_deactivate_user_overlay", 'routine in <a href="nv/grim/grim_user_include.html">grim_user_include.pro</a>', "grim_user_include.pro", "", "grim_deactivate_user_overlay", "", "planeindices", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_user_include.html#grim_clear_user_overlays", "grim_clear_user_overlays", 'routine in <a href="nv/grim/grim_user_include.html">grim_user_include.pro</a>', "grim_user_include.pro", "", "grim_clear_user_overlays", "", "planetags", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_user_include.html#grim_clear_active_user_overlays", "grim_clear_active_user_overlays", 'routine in <a href="nv/grim/grim_user_include.html">grim_user_include.pro</a>', "grim_user_include.pro", "", "grim_clear_active_user_overlays", "", "plane", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_user_include.html#grim_invert_active_user_overlays", "grim_invert_active_user_overlays", 'routine in <a href="nv/grim/grim_user_include.html">grim_user_include.pro</a>', "grim_user_include.pro", "", "grim_invert_active_user_overlays", "", "plane", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_user_include.html#grim_user_include", "grim_user_include", 'routine in <a href="nv/grim/grim_user_include.html">grim_user_include.pro</a>', "grim_user_include.pro", "", "grim_user_include", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/grim/grim_user_mode_struct__define.html", "grim_user_mode_struct__define.pro", '.pro file in <a href="nv/grim/dir-overview.html">nv/grim/ directory</a>', "grim_user_mode_struct__define.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/grim/grim_user_mode_struct__define.html#grim_user_mode_struct__define", "grim_user_mode_struct__define", 'routine in <a href="nv/grim/grim_user_mode_struct__define.html">grim_user_mode_struct__define.pro</a>', "grim_user_mode_struct__define.pro", "", "grim_user_mode_struct__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/grim/grim_util_include.html", "grim_util_include.pro", '.pro file in <a href="nv/grim/dir-overview.html">nv/grim/ directory</a>', "grim_util_include.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/grim/grim_util_include.html#grim_set_user_data", "grim_set_user_data", 'routine in <a href="nv/grim/grim_util_include.html">grim_util_include.pro</a>', "grim_util_include.pro", "", "grim_set_user_data", "", "grim_datatagdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_util_include.html#grim_get_user_data", "grim_get_user_data", 'routine in <a href="nv/grim/grim_util_include.html">grim_util_include.pro</a>', "grim_util_include.pro", "", "grim_get_user_data", "", "grim_datatag", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_util_include.html#grim_n_colors", "grim_n_colors", 'routine in <a href="nv/grim/grim_util_include.html">grim_util_include.pro</a>', "grim_util_include.pro", "", "grim_n_colors", "", "type", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_util_include.html#grim_get_body_by_name_single", "grim_get_body_by_name_single", 'routine in <a href="nv/grim/grim_util_include.html">grim_util_include.pro</a>', "grim_util_include.pro", "", "grim_get_body_by_name_single", "", "xd_pname", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_util_include.html#grim_get_body_by_name", "grim_get_body_by_name", 'routine in <a href="nv/grim/grim_util_include.html">grim_util_include.pro</a>', "grim_util_include.pro", "", "grim_get_body_by_name", "", "planename", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_util_include.html#grim_shade_threshold", "grim_shade_threshold", 'routine in <a href="nv/grim/grim_util_include.html">grim_util_include.pro</a>', "grim_util_include.pro", "", "grim_shade_threshold", "", "ptdshadethreshold", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_util_include.html#grim_parse_overlay", "grim_parse_overlay", 'routine in <a href="nv/grim/grim_util_include.html">grim_util_include.pro</a>', "grim_util_include.pro", "", "grim_parse_overlay", "", "overlaynames", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_util_include.html#grim_cat_bodies", "grim_cat_bodies", 'routine in <a href="nv/grim/grim_util_include.html">grim_util_include.pro</a>', "grim_util_include.pro", "", "grim_cat_bodies", "", "plane", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_util_include.html#grim_get_cursor_swap", "grim_get_cursor_swap", 'routine in <a href="nv/grim/grim_util_include.html">grim_util_include.pro</a>', "grim_util_include.pro", "", "grim_get_cursor_swap", "", "grim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_util_include.html#grim_wset", "grim_wset", 'routine in <a href="nv/grim/grim_util_include.html">grim_util_include.pro</a>', "grim_util_include.pro", "", "grim_wset", "", "get_infosavenoplotgrim_datawnum", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_util_include.html#grim_logging_callback", "grim_logging_callback", 'routine in <a href="nv/grim/grim_util_include.html">grim_util_include.pro</a>', "grim_util_include.pro", "", "grim_logging_callback", "", "data_pmessage", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_util_include.html#grim_logging", "grim_logging", 'routine in <a href="nv/grim/grim_util_include.html">grim_util_include.pro</a>', "grim_util_include.pro", "", "grim_logging", "", "startstopgrim_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_util_include.html#grim_menu_delim_event", "grim_menu_delim_event", 'routine in <a href="nv/grim/grim_util_include.html">grim_util_include.pro</a>', "grim_util_include.pro", "", "grim_menu_delim_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_util_include.html#grim_parse_form_entry", "grim_parse_form_entry", 'routine in <a href="nv/grim/grim_util_include.html">grim_util_include.pro</a>', "grim_util_include.pro", "", "grim_parse_form_entry", "", "nulldropnumericstringidstagstag", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_util_include.html#grim_set_form_entry", "grim_set_form_entry", 'routine in <a href="nv/grim/grim_util_include.html">grim_util_include.pro</a>', "grim_util_include.pro", "", "grim_set_form_entry", "", "dropcwbuttonsensitiveidstagstagvalue", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_util_include.html#grim_add_callback", "grim_add_callback", 'routine in <a href="nv/grim/grim_util_include.html">grim_util_include.pro</a>', "grim_util_include.pro", "", "grim_add_callback", "", "callbacksdata_pscallbacks_listdata_ps_list", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_util_include.html#grim_rm_callback", "grim_rm_callback", 'routine in <a href="nv/grim/grim_util_include.html">grim_util_include.pro</a>', "grim_util_include.pro", "", "grim_rm_callback", "", "data_pscallbacks_listdata_ps_list", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_util_include.html#grim_call_callbacks", "grim_call_callbacks", 'routine in <a href="nv/grim/grim_util_include.html">grim_util_include.pro</a>', "grim_util_include.pro", "", "grim_call_callbacks", "", "_callbacks_list_data_ps_listevent", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_util_include.html#grim_get_menu_id", "grim_get_menu_id", 'routine in <a href="nv/grim/grim_util_include.html">grim_util_include.pro</a>', "grim_util_include.pro", "", "grim_get_menu_id", "", "grim_datadesc", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_util_include.html#grim_update_menu_toggle", "grim_update_menu_toggle", 'routine in <a href="nv/grim/grim_util_include.html">grim_util_include.pro</a>', "grim_util_include.pro", "", "grim_update_menu_toggle", "", "grim_datanameflag", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_util_include.html#grim_get_toggle_flag", "grim_get_toggle_flag", 'routine in <a href="nv/grim/grim_util_include.html">grim_util_include.pro</a>', "grim_util_include.pro", "", "grim_get_toggle_flag", "", "grim_dataname", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_util_include.html#grim_set_toggle_flag", "grim_set_toggle_flag", 'routine in <a href="nv/grim/grim_util_include.html">grim_util_include.pro</a>', "grim_util_include.pro", "", "grim_set_toggle_flag", "", "grim_datanameflag", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_util_include.html#grim_compare", "grim_compare", 'routine in <a href="nv/grim/grim_util_include.html">grim_util_include.pro</a>', "grim_util_include.pro", "", "grim_compare", "", "x1x2", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/grim/grim_util_include.html#grim_util_include", "grim_util_include", 'routine in <a href="nv/grim/grim_util_include.html">grim_util_include.pro</a>', "grim_util_include.pro", "", "grim_util_include", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/strcat/gsc2/gsc2_catalog_inputs.html", "gsc2_catalog_inputs.pro", '.pro file in <a href="config/strcat/gsc2/dir-overview.html">config/strcat/gsc2/ directory</a>', "gsc2_catalog_inputs.pro", "	Spitale, 2/2002   ", "", " Generates commands necessary for obtaining a prtion of the GSCII  guide star catalog and converting it to a format readable by the  translator strcat_gsc2_input. See also: strcat_gsc2_input   PROCEDURE   This procedure uses the given information to generate and print a URL  that the user can enter into a web browser to automatically search the  guide star catalog.  The user is instructed to save the results in  a file in the directory given by the environment variable NV_GSC2_DATA.  A command is then printed that will convert all such data files in that  directory into a single binary file in the same directory, readable by  the gsc2 translator.   ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("config/strcat/gsc2/gsc2_record__define.html", "gsc2_record__define.pro", '.pro file in <a href="config/strcat/gsc2/dir-overview.html">config/strcat/gsc2/ directory</a>', "gsc2_record__define.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/strcat/gsc2/gsc2_record__define.html#gsc2_record__define", "gsc2_record__define", 'routine in <a href="config/strcat/gsc2/gsc2_record__define.html">gsc2_record__define.pro</a>', "gsc2_record__define.pro", "", "gsc2_record__define", " Format of the standardized star catalog record for gsc2.   ", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/strcat/gsc_record__define.html", "gsc_record__define.pro", '.pro file in <a href="config/strcat/dir-overview.html">config/strcat/ directory</a>', "gsc_record__define.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/strcat/gsc_record__define.html#gsc_record__define", "gsc_record__define", 'routine in <a href="config/strcat/gsc_record__define.html">gsc_record__define.pro</a>', "gsc_record__define.pro", "", "gsc_record__define", " Specifies the format of a standard GSC record   ", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/strcat/gsc_region__define.html", "gsc_region__define.pro", '.pro file in <a href="config/strcat/dir-overview.html">config/strcat/ directory</a>', "gsc_region__define.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/strcat/gsc_region__define.html#gsc_region__define", "gsc_region__define", 'routine in <a href="config/strcat/gsc_region__define.html">gsc_region__define.pro</a>', "gsc_region__define.pro", "", "gsc_region__define", " Format of a GSC region file record   ", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/abbrev/h.html", "h.pro", '.pro file in <a href="util/abbrev/dir-overview.html">util/abbrev/ directory</a>', "h.pro", "", "", " NAME: 	h   PURPOSE: 	Abbreviation for the help command   CATEGORY:        UTIL/ABBREV  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/abbrev/h.html#h", "h", 'routine in <a href="util/abbrev/h.html">h.pro</a>', "h.pro", "", "h", "", "x", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/h.html", "h.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "h.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/h.html#h", "h", 'routine in <a href="util/h.html">h.pro</a>', "h.pro", "", "h", "", "arg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/headpds.html", "headpds.pro", '.pro file in <a href="config/pds/Readpds_4.4/dir-overview.html">config/pds/Readpds_4.4/ directory</a>', "headpds.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/headpds.html#get_struct_name", "get_struct_name", 'routine in <a href="config/pds/Readpds_4.4/headpds.html">headpds.pro</a>', "headpds.pro", "", "get_struct_name", "", "labelobjindex", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/headpds.html#headpds", "headpds", 'routine in <a href="config/pds/Readpds_4.4/headpds.html">headpds.pro</a>', "headpds.pro", "", "headpds", "", "SILENTFILEFORMATinput_filename", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/hhmmss_to_deg.html", "hhmmss_to_deg.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "hhmmss_to_deg.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/hhmmss_to_deg.html#hhmmss_to_deg", "hhmmss_to_deg", 'routine in <a href="util/hhmmss_to_deg.html">hhmmss_to_deg.pro</a>', "hhmmss_to_deg.pro", "", "hhmmss_to_deg", "", "hhmmss", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/hhmmss_to_sec.html", "hhmmss_to_sec.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "hhmmss_to_sec.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/hhmmss_to_sec.html#hhmmss_to_sec", "hhmmss_to_sec", 'routine in <a href="util/hhmmss_to_sec.html">hhmmss_to_sec.pro</a>', "hhmmss_to_sec.pro", "", "hhmmss_to_sec", "", "hhmmss", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/composite/hide_points.html", "hide_points.pro", '.pro file in <a href="nv/obj/tools/composite/dir-overview.html">nv/obj/tools/composite/ directory</a>', "hide_points.pro", "", "", " NAME:        hide_points    PURPOSE: 	Hides points with respect to given object and observer.   CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = hide_points(bx, r, p)    ARGUMENTS:   INPUT: 	bx:	Array (nt) of any subclass of BODY.  	r:	Columns vector giving the BODY-frame position of the viewer.  	p:	Array (nv) of BODY-frame vectors giving the points to hide.    OUTPUT:        NONE   KEYWORDS:    INPUT: 	rm:	If set, points are flagged for being in front of or behind 		the globe, rather then just behind it.     OUTPUT: NONE    RETURN: 	Subscripts of the points in p that are hidden by the object.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale	3/2017  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/composite/hide_points.html#hide_points", "hide_points", 'routine in <a href="nv/obj/tools/composite/hide_points.html">hide_points.pro</a>', "hide_points.pro", "", "hide_points", "", "rmbxrp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/highpass.html", "highpass.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "highpass.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/highpass.html#highpass", "highpass", 'routine in <a href="util/highpass.html">highpass.pro</a>', "highpass.pro", "", "highpass", "", "x", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/hist__2d.html", "hist__2d.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "hist__2d.pro", "", "", " NAME: 	HIST_2D   PURPOSE: 	Return the density function (histogram) of two variables.   CATEGORY: 	Image processing, statistics, probability.   CALLING SEQUENCE: 	Result = hist_2d(V1, V2)  INPUTS: 	V1 and V2 = arrays containing the variables.  May be any non-complex 		numeric type.   Keyword Inputs:        MIN1:   MIN1 is the minimum V1 value to consider. If this                keyword is not specified, then V1 si searched for 		its smallest value.         MIN2:   MIN2 is the minimum V2 value to consider. If this                keyword is not specified, then V2 si searched for 		its smallest value.         MAX1:   MAX1 is the maximum V1 value to consider. If this                keyword is not specified, then V1 is searched for                its largest value.         MAX2    MAX2 is the maximum V2 value to consider. If this                keyword is not specified, then V2 is searched for                its largest value.         BIN1    The size of each bin in the V1 direction (column                width).  If this keyword is not specified, the                size is set to 1.         BIN2    The size of each bin in the V2 direction (row                height).  If this keyword is not specified, the                size is set to 1.   OUTPUTS: 	The two dimensional density function of the two variables, 	a longword array of dimensions (m1, m2), where: 		m1 = Floor((max1-min1)/bin1) + 1 	   and  m2 = Floor((max2-min2)/bin2) + 1 	and Result(i,j) is equal to the number of sumultaneous occurences 	of an element of V1 falling in the ith bin, with the same element 	of V2 falling in the jth bin, where: 		i = (v1 < max1 - min1 > 0) / b1 	   and  j = (v2 < max2 - min2 > 0) / b2  	Note: elements larger than the max or smaller than the min are 	truncated to the max and min, respectively.   COMMON BLOCKS: 	None.  SIDE EFFECTS: 	None.  RESTRICTIONS: 	Not usable with complex or string data.  PROCEDURE: 	Creates a combines array from the two variables, equal to the 	linear subscript in the resulting 2D histogram, then applies 	the standard histogram function.   EXAMPLE: 	Return the 2D histogram of two byte images: 		R = HIST_2D(image1, image2)  	Return the 2D histogram made from two floating point images 	with range of -1 to +1, and with 101 (= 2/.02 + 1) bins: 		R = HIST_2D(f1, f2, MIN1=-1, MIN2=-1, MAX1=1, MAX2=1, $ 			BIN1=.02, BIN2=.02)   MODIFICATION HISTORY:  	Written by: 	DMS, Sept, 1992		Written 	DMS, Oct, 1995		Added MIN, MAX, BIN keywords following 				suggestion of Kevin Trupie, GSC, NASA/GSFC. 	Spitale, Jun 2002	Copied from hist_2d; Added reverse_indices keyword   NOTICES: 	Portions 2017 Exelis Visual Information Solutions, Inc., provided 	under license to the Jet Propulsion Laboratory. THE EXELIS VISUAL 	INFORMATION SOLUTIONS, INC. CODE IS PROVIDED  AS IS  AND ANY EXPRESS 	OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 	WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 	ARE DISCLAIMED. IN NO EVENT SHALL EXELIS VISUAL INFORMATION SOLUTIONS, 	INC., ITS AFFILIATES, OFFICERS, DIRECTORS, EMPLOYEES, AGENTS, SUPPLIERS 	OR LICENSORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 	EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 	PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 	PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 	OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING 	NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 	SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/hist__2d.html#hist__2d", "hist__2d", 'routine in <a href="util/hist__2d.html">hist__2d.pro</a>', "hist__2d.pro", "", "hist__2d", "", "Min1Min2Max1Max2Bin1Bin2reverse_indicesim1im2", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/histogram.html", "histogram.pro", '.pro file in <a href="config/pds/Readpds_4.4/dir-overview.html">config/pds/Readpds_4.4/ directory</a>', "histogram.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/histogram.html#rm_tag", "rm_tag", 'routine in <a href="config/pds/Readpds_4.4/histogram.html">histogram.pro</a>', "histogram.pro", "", "rm_tag", "", "inputbadtag", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/histogram.html#makecon", "makecon", 'routine in <a href="config/pds/Readpds_4.4/histogram.html">histogram.pro</a>', "histogram.pro", "", "makecon", "", "cacheitrshiftxshifty", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/histogram.html#xvals", "xvals", 'routine in <a href="config/pds/Readpds_4.4/histogram.html">histogram.pro</a>', "histogram.pro", "", "xvals", "", "cache", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/histogram.html#dimensions", "dimensions", 'routine in <a href="config/pds/Readpds_4.4/histogram.html">histogram.pro</a>', "histogram.pro", "", "dimensions", "", "iTable", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/histogram.html#makehist", "makehist", 'routine in <a href="config/pds/Readpds_4.4/histogram.html">histogram.pro</a>', "histogram.pro", "", "makehist", "", "cacheitr", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/histogram.html#helpinfo", "helpinfo", 'routine in <a href="config/pds/Readpds_4.4/histogram.html">histogram.pro</a>', "histogram.pro", "", "helpinfo", "", "ev", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/histogram.html#disptype_dist", "disptype_dist", 'routine in <a href="config/pds/Readpds_4.4/histogram.html">histogram.pro</a>', "histogram.pro", "", "disptype_dist", "", "ev", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/histogram.html#disptype_hist", "disptype_hist", 'routine in <a href="config/pds/Readpds_4.4/histogram.html">histogram.pro</a>', "histogram.pro", "", "disptype_hist", "", "ev", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/histogram.html#highlight", "highlight", 'routine in <a href="config/pds/Readpds_4.4/histogram.html">histogram.pro</a>', "histogram.pro", "", "highlight", "", "ev", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/histogram.html#tvscl", "tvscl", 'routine in <a href="config/pds/Readpds_4.4/histogram.html">histogram.pro</a>', "histogram.pro", "", "tvscl", "", "ev", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/histogram.html#plothist", "plothist", 'routine in <a href="config/pds/Readpds_4.4/histogram.html">histogram.pro</a>', "histogram.pro", "", "plothist", "", "ev", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/histogram.html#newform", "newform", 'routine in <a href="config/pds/Readpds_4.4/histogram.html">histogram.pro</a>', "histogram.pro", "", "newform", "", "ev", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/histogram.html#save", "save", 'routine in <a href="config/pds/Readpds_4.4/histogram.html">histogram.pro</a>', "histogram.pro", "", "save", "", "ev", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/histogram.html#exit", "exit", 'routine in <a href="config/pds/Readpds_4.4/histogram.html">histogram.pro</a>', "histogram.pro", "", "exit", "", "ev", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/histogram.html#zoomed_event", "zoomed_event", 'routine in <a href="config/pds/Readpds_4.4/histogram.html">histogram.pro</a>', "histogram.pro", "", "zoomed_event", "", "ev", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/histogram.html#histogram_event", "histogram_event", 'routine in <a href="config/pds/Readpds_4.4/histogram.html">histogram.pro</a>', "histogram.pro", "", "histogram_event", "", "ev", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/histogram.html#histogram", "histogram", 'routine in <a href="config/pds/Readpds_4.4/histogram.html">histogram.pro</a>', "histogram.pro", "", "histogram", "", "pdsftabitr", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/fits/host_to_ieee.html", "host_to_ieee.pro", '.pro file in <a href="config/fits/dir-overview.html">config/fits/ directory</a>', "host_to_ieee.pro", "", "", " NAME: 	host_to_ieee    PURPOSE: 	Translates an IDL variable from the host machine representation 	into IEEE-754 representation (as used, for example, in FITS data).    CATEGORY: 	UTIL/FITS    CALLING SEQUENCE: 	host_to_ieee, data, [ IDLTYPE = IDLTYPE ]    ARGUMENTS:   INPUT: 	data:	Any IDL variable, scalar or vector.   It will be modified by 		HOST_TO_IEEE to convert from host to IEEE representation.  Byte 		and string variables are returned by HOST_TO_IEEE unchanged.    OUTPUT: 	data:	See above.    KEYWORDS:   INPUT: 	IDLTYPE:	Scalar integer (1-7) specifying the IDL datatype 			according to the code given by the SIZE function. 			This keyword will usually be used when suppying a byte 			array that needs to be interpreted as another data type 			(e.g. FLOAT).    OUTPUT: NONE    RETURN: NONE    RESTRICTIONS: 	Assumes the IDL version is since 2.2.2 when the /XDRTOF keyword 	became available to BYTEORDER.    There were two bad implementations 	in BYTEORDER for double precision: (1) in IDL V3.* for DecStations 	(!VERSION.ARCH = 'mipsel') and (2) on Dec Alpha OSF machines. 	IEEE_TO_HOST works around these cases by swapping the byte order 	directly.    PROCEDURE: 	The BYTEORDER procedure is called with the appropriate keywords    EXAMPLE: 	Suppose FITARR is a 2880 element byte array to be converted to a FITS 	record and interpreted a FLOAT data.  	IDL> host_to_ieee, FITARR, IDLTYPE = 4    STATUS: 	Complete    SEE ALSO: 	ieee_to_host, conv_unix_vax, conv_vax_unix    MODIFICATION HISTORY: 	Adapted from CONV_UNIX_VAX, W. Landsman   Hughes/STX    January, 1992 	Fixed Case statement for Float and Double      September, 1992 	Workaround for /DTOXDR on DecStations          January, 1993 	Workaround for /DTOXDR on Alpha OSF            July 1994 	Assume since Version 2.2.2, Ultrix problems persist   November 1994 	Add support for double complex        July, 1995 	Workaround for VAX VMS bug in BYTEORDER,/FTOXDR in V4.0   August 1995 	Workaround for VMS bug in BYTEORDER,/FTOXDR and /DTOXDR in 		V4.0.1 (sigh...)  W. Landsman   August 1995 	Workaround for /FTOXDR bug in OSF V4.0.1 September 1995   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/fits/host_to_ieee.html#host_to_ieee", "host_to_ieee", 'routine in <a href="config/fits/host_to_ieee.html">host_to_ieee.pro</a>', "host_to_ieee.pro", "", "host_to_ieee", "", "IDLTYPEdata", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/icv/icv_chisq.html", "icv_chisq.pro", '.pro file in <a href="nv/obj/tools/icv/dir-overview.html">nv/obj/tools/icv/ directory</a>', "icv_chisq.pro", "", "", " NAME: 	icv_chisq    PURPOSE: 	Computes chi-squared value for given curve fit parameters.    CATEGORY: 	NV/LIB/TOOLS/ICV    CALLING SEQUENCE: 	result = icv_chisq(dxy, dtheta, fix, cos_alpha, sin_alpha, scan_offsets)    ARGUMENTS:   INPUT: 	dxy:		Array (2) giving x- and y-offset solution.  	dtheta:		Scalar giving theta-offset solution.  	fix:		Array specifying which parameters to fix as 			[dx,dy,dtheta].  	cos_alpha:	Array (n_points) of direction cosines computed by 			icv_compute_directions.  	sin_alpha:	Array (n_points) of direction sines computed by 			icv_compute_directions.  	scan_offsets:	Array (n_points) containing offset of best correlation 			at each point on the curve.  Produced by icv_scan_strip.  	scan_pts:	Array (2, n_points) of image coordinates corresponding 			to each scan offset.  	axis:		Array (2) giving image coordinates of rotation axis 			in the case of a 3-parameter fit.    OUTPUT: NONE    KEYWORDS:   INPUT: 	norm:		If set, the returned value is normalized by dividing 			it by the number of degrees of freedom.    OUTPUT: NONE    RETURN: 	The chi-squared value is returned.    STATUS: 	Complete.    MODIFICATION HISTORY:  	Written by:	Spitale, 6/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/icv/icv_chisq.html#icv_chisq", "icv_chisq", 'routine in <a href="nv/obj/tools/icv/icv_chisq.html">icv_chisq.pro</a>', "icv_chisq.pro", "", "icv_chisq", "", "normdxydthetafixcos_alphasin_alphascan_offsetsscan_ptsaxis", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/icv/icv_coeff.html", "icv_coeff.pro", '.pro file in <a href="nv/obj/tools/icv/dir-overview.html">nv/obj/tools/icv/ directory</a>', "icv_coeff.pro", "", "", " NAME: 	icv_coeff    PURPOSE: 	Computes coefficients for the 2- or 3-parameter linear least-square fit.    CATEGORY: 	NV/LIB/TOOLS/ICV    CALLING SEQUENCE: 	icv_coeff, cos_alpha, sin_alpha, scan_offsets, scan_pts, axis, M=M, b=b    ARGUMENTS:   INPUT: 	cos_alpha:	Array (n_points) of direction cosines computed by 			icv_compute_directions.  	sin_alpha:	Array (n_points) of direction sines computed by 			icv_compute_directions.  	scan_offsets:	Array (n_points) containing offset of best correlation 			at each point on the curve.  Produced by icv_scan_strip.  	scan_pts:	Array (2, n_points) of image coordinates corresponding 			to each scan offset.  	axis:		Array (2) giving image coordinates of rotation axis 			in the case of a 3-parameter fit.    OUTPUT: NONE    KEYWORDS:   INPUT: 	sigma:	Uncertainty in each scan_offset.  Defaults to 1.    OUTPUT: 	M:	3x3 matrix of coefficients for the linear fit.  	b:	3-element column vector rhs of the linear fit.    PROCEDURE: 	Since the fit has been linearized, it can be written as a matrix 	equation:  				Mx = b,  	where x is the 3-element column vector [dx, dy, dtheta] of the 	independent variables. 	This routine computes the matrix M and the 	vector b.  Once these are known, mbfit can be used to solve the 	linear system.  Moreover, since the fit is linear, a simultaneous 	fit can be performed by simply adding together any number of 	coefficient matrices and vectors, which can also be done using 	mbfit.    RESTRICTIONS: 	The fit associated with these coefficients has been linearized 	and is only valid for small corrections.  For larger corrections, 	this procedure can be iterated.    STATUS: 	Complete.    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/icv/icv_coeff.html#icv_coeff", "icv_coeff", 'routine in <a href="nv/obj/tools/icv/icv_coeff.html">icv_coeff.pro</a>', "icv_coeff.pro", "", "icv_coeff", "", "sigmaMb_cos_alpha_sin_alphascan_offsetsscan_ptsaxis", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/icv/icv_compute_directions.html", "icv_compute_directions.pro", '.pro file in <a href="nv/obj/tools/icv/dir-overview.html">nv/obj/tools/icv/ directory</a>', "icv_compute_directions.pro", "", "", " NAME: 	icv_compute_directions    PURPOSE: 	Computes the normal to a specified curve at every point.    CATEGORY: 	NV/LIB/TOOLS/ICV    CALLING SEQUENCE: 	icv_compute_directions, curve_pts, $ 	                        cos_alpha=cos_alpha, sin_alpha=sin_alpha    ARGUMENTS:   INPUT: 	curve_pts:	Array (2, n_points) of image points making up the curve.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	cos_alpha:	Array (n_points) of direction cosines.  	sin_alpha:	Array (n_points) of direction sines.    RETURN: 	NONE    RESTRICTIONS: 	It is assumed that the curve is closed; if this is not the case, then 	the results will not be meaningful at the endpoints of the curve.    PROCEDURE: 	At each point on the specified curve, the two nearest neighbors are 	used to compute the components of the normal.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/icv/icv_compute_directions.html#icv_compute_directions", "icv_compute_directions", 'routine in <a href="nv/obj/tools/icv/icv_compute_directions.html">icv_compute_directions.pro</a>', "icv_compute_directions.pro", "", "icv_compute_directions", "", "centercos_alphasin_alphacurve_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/icv/icv_convert_scan_offsets.html", "icv_convert_scan_offsets.pro", '.pro file in <a href="nv/obj/tools/icv/dir-overview.html">nv/obj/tools/icv/ directory</a>', "icv_convert_scan_offsets.pro", "", "", " NAME: 	icv_convert_scan_offsets    PURPOSE: 	Converts offsets produced by icv_scan_strip to image coordinates.    CATEGORY: 	NV/LIB/TOOLS/ICV    CALLING SEQUENCE: 	result = icv_convert_scan_offsets(curve_pts, scan_offsets, $ 	                                  cos_alpha, sin_alpha)   ARGUMENTS:   INPUT: 	curve_pts:	Array (2, n_points) of image points making up the curve.  	scan_offsets:	Array (n_points) containing offset of best correlation 			at each point on the curve.  Produced by icv_scan_strip.  	cos_alpha:	Array (n_points) of direction cosines computed by 			icv_compute_directions.  	sin_alpha:	Array (n_points) of direction sines computed by 			icv_compute_directions.    OUTPUT: NONE    KEYWORDS: NONE    RETURN: 	Array (2, n_points) of image coordinates corresponding to each scan 	offset.    STATUS: 	Complete.    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/icv/icv_convert_scan_offsets.html#icv_convert_scan_offsets", "icv_convert_scan_offsets", 'routine in <a href="nv/obj/tools/icv/icv_convert_scan_offsets.html">icv_convert_scan_offsets.pro</a>', "icv_convert_scan_offsets.pro", "", "icv_convert_scan_offsets", "", "curve_ptsscan_offsetscos_alphasin_alpha", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/icv/icv_invert_scan_offsets.html", "icv_invert_scan_offsets.pro", '.pro file in <a href="nv/obj/tools/icv/dir-overview.html">nv/obj/tools/icv/ directory</a>', "icv_invert_scan_offsets.pro", "", "", " NAME: 	icv_invert_scan_offsets    PURPOSE: 	Uses scan image coordinates to produce scan offsets and angles.  This 	routine is the reverse of icv_convert_scan_offsets.    CATEGORY: 	NV/LIB/TOOLS/ICV    CALLING SEQUENCE: 	result = icv_invert_scan_offsets(curve_pts, scan_pts, $ 	                                       cos_alpha, sin_alpha)   ARGUMENTS:   INPUT: 	curve_pts:	Array (2, n_points) of image points making up the curve.  	scan_pts:	Array (2, n_points) of image coordinates corresponding to each scan 			offset.  	cos_alpha:	Array (n_points) of direction cosines.  	sin_alpha:	Array (n_points) of direction sines.    OUTPUT: NONE    KEYWORDS: NONE    RETURN: 	Array (2, n_points) of image coordinates corresponding to each scan 	offset.    STATUS: 	Complete.    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/icv/icv_invert_scan_offsets.html#icv_invert_scan_offsets", "icv_invert_scan_offsets", 'routine in <a href="nv/obj/tools/icv/icv_invert_scan_offsets.html">icv_invert_scan_offsets.pro</a>', "icv_invert_scan_offsets.pro", "", "icv_invert_scan_offsets", "", "curve_ptsscan_ptscos_alphasin_alpha", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/icv/icv_reset_scan_precision.html", "icv_reset_scan_precision.pro", '.pro file in <a href="nv/obj/tools/icv/dir-overview.html">nv/obj/tools/icv/ directory</a>', "icv_reset_scan_precision.pro", "", "", " NAME: 	icv_reset_scan_precision    PURPOSE: 	Modifies the scan precision by rebinning the given image strip.    CATEGORY: 	NV/LIB/TOOLS/ICV    CALLING SEQUENCE: 	icv_reset_scan_precision, strip, model, szero, mzero, precision    ARGUMENTS:   INPUT: 	strip:		Image strip to modify.  	model:		Corresponding edge models.  	szero:		Zero-offset position in the strip.  	mzero:		Zero-offset position in the model.  	precision:	New precision in inverse pixels.    OUTPUT: 	strip:		Modified image strip.  	model:		Modified edge models.  	szero:		Zero-offset position in the modified strip.  	mzero:		Zero-offset position in the modified model.     KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	NONE    PROCEDURE: 	The strip and model are rebinned by the specified precision factor 	using cubic interpolation.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/icv/icv_reset_scan_precision.html#icv_reset_scan_precision", "icv_reset_scan_precision", 'routine in <a href="nv/obj/tools/icv/icv_reset_scan_precision.html">icv_reset_scan_precision.pro</a>', "icv_reset_scan_precision.pro", "", "icv_reset_scan_precision", "", "stripmodelszeromzeroprecision", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/icv/icv_scan_strip.html", "icv_scan_strip.pro", '.pro file in <a href="nv/obj/tools/icv/dir-overview.html">nv/obj/tools/icv/ directory</a>', "icv_scan_strip.pro", "", "", " NAME: 	icv_scan_strip    PURPOSE: 	At each point along an image strip, determines the point at which 	some criterion is optimized, depending on an externally-supplied 	function.    CATEGORY: 	NV/LIB/TOOLS/ICV    CALLING SEQUENCE: 	result = icv_scan_strip(strip, model, szero, mzero, algorithm=algorithm)    ARGUMENTS:   INPUT: 	strip:	Image strip (n_points,ns) to be scanned.  Output from 		icv_strip_curve ns must be even.  	model:	Model (n_points,nm) to correlate with strip at each point 		on the curve.  Must have nm < ns.  	szero:	Zero-offset position in the strip.  	mzero:	Zero-offset position in the model.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	cc:	Maximum correlation coefficient at each point on the curve.  	sigma:	Offset uncertainty for each point on the curve, computed as 		one half of the half-width of the correlation peak.  	algorithm:	String giving the subscript for the name of a 			function as icv_scan_strip_<algorithm>.  The algorithm 			function should be structured like the present function, 			except with no  algorithm  keyword.  Default is 			'model'.    RETURN: 	Offset of best correlation at each point on the curve.    PROCEDURE: 	This program is a wrapper for a number of functions that use various 	algorithms determined by the 'algorithm' keyword.    STATUS: 	Complete.    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/icv/icv_scan_strip.html#icv_scan_strip", "icv_scan_strip", 'routine in <a href="nv/obj/tools/icv/icv_scan_strip.html">icv_scan_strip.pro</a>', "icv_scan_strip.pro", "", "icv_scan_strip", "", "ccsigmaalgorithmargstripmodelszeromzero", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/icv/icv_scan_strip_grad.html", "icv_scan_strip_grad.pro", '.pro file in <a href="nv/obj/tools/icv/dir-overview.html">nv/obj/tools/icv/ directory</a>', "icv_scan_strip_grad.pro", "", "", " NAME: 	icv_scan_strip_grad    PURPOSE: 	At each point along an image strip, finds a sharp edge using the 	maximum-gradient method.    CATEGORY: 	NV/LIB/TOOLS/ICV    CALLING SEQUENCE: 	result = icv_scan_strip_grad(strip, model, szero, mzero)    ARGUMENTS:   INPUT: 	strip:	Image strip (n_points,ns) to be scanned.  Output from 		icv_strip_curve ns must be even.  	model:	Not used.  	szero:	Zero-offset position in the strip.  	mzero:	Not used.    OUTPUT: NONE    KEYWORDS:   INPUT: 	norm:	If set, only the absolute value of the gradient is evaluated.    OUTPUT: 	cc:	Not used, hardwired to 0.9999999d.  	sigma:	Offset uncertainty for each point on the curve, computed as 		one half of the half-width of the gradient peak.    RETURN: 	Offset of maximum gradient points at each point on the curve.    STATUS: 	Complete.    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/icv/icv_scan_strip_grad.html#icv_scan_strip_grad", "icv_scan_strip_grad", 'routine in <a href="nv/obj/tools/icv/icv_scan_strip_grad.html">icv_scan_strip_grad.pro</a>', "icv_scan_strip_grad.pro", "", "icv_scan_strip_grad", "", "argccsigmanormstripmodelszeromzero", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/icv/icv_scan_strip_grad_norm.html", "icv_scan_strip_grad_norm.pro", '.pro file in <a href="nv/obj/tools/icv/dir-overview.html">nv/obj/tools/icv/ directory</a>', "icv_scan_strip_grad_norm.pro", "", "", " NAME: 	icv_scan_strip_grad_norm    PURPOSE: 	Calls icv_scan_strip_grad with /norm set.    CATEGORY: 	NV/LIB/TOOLS/ICV    CALLING SEQUENCE: 	result = icv_scan_strip_grad_norm(strip, model, szero, mzero)    ARGUMENTS:   INPUT: 	strip:	Image strip (n_points,ns) to be scanned.  Output from 		icv_strip_curve ns must be even.  	model:	Not used.  	szero:	Zero-offset position in the strip.  	mzero:	Not used.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	cc:	Not used, hardwired to 0.9999999d.  	sigma:	Offset uncertainty for each point on the curve, computed as 		one half of the half-width of the gradient peak.    RETURN: 	Offset of maximum gradient points at each point on the curve.    STATUS: 	Complete.    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/icv/icv_scan_strip_grad_norm.html#icv_scan_strip_grad_norm", "icv_scan_strip_grad_norm", 'routine in <a href="nv/obj/tools/icv/icv_scan_strip_grad_norm.html">icv_scan_strip_grad_norm.pro</a>', "icv_scan_strip_grad_norm.pro", "", "icv_scan_strip_grad_norm", "", "argccsigmastripmodelszeromzero", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/icv/icv_scan_strip_half.html", "icv_scan_strip_half.pro", '.pro file in <a href="nv/obj/tools/icv/dir-overview.html">nv/obj/tools/icv/ directory</a>', "icv_scan_strip_half.pro", "", "", " NAME: 	icv_scan_strip_half    PURPOSE: 	At each point along an image strip, finds a sharp edge using the 	half-power method.    CATEGORY: 	NV/LIB/TOOLS/ICV    CALLING SEQUENCE: 	result = icv_scan_strip_half(strip, model, szero, mzero)    ARGUMENTS:   INPUT: 	strip:	Image strip (n_points,ns) to be scanned.  Output from 		icv_strip_curve ns must be even.  	model:	Not used.  	szero:	Zero-offset position in the strip.  	mzero:	Not used.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	cc:	Not used, hardwired to 0.9999999d.  	sigma:	Offset uncertainty for each point on the curve, computed as 		one half of the half-width of the half-power peak.    RETURN: 	Offset of half-power points at each point on the curve.    STATUS: 	Complete.    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/icv/icv_scan_strip_half.html#icv_scan_strip_half", "icv_scan_strip_half", 'routine in <a href="nv/obj/tools/icv/icv_scan_strip_half.html">icv_scan_strip_half.pro</a>', "icv_scan_strip_half.pro", "", "icv_scan_strip_half", "", "argccsigmacenterstripmodelszeromzero", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/icv/icv_scan_strip_inflection.html", "icv_scan_strip_inflection.pro", '.pro file in <a href="nv/obj/tools/icv/dir-overview.html">nv/obj/tools/icv/ directory</a>', "icv_scan_strip_inflection.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/icv/icv_scan_strip_inflection.html#icv_scan_strip_inflection", "icv_scan_strip_inflection", 'routine in <a href="nv/obj/tools/icv/icv_scan_strip_inflection.html">icv_scan_strip_inflection.pro</a>', "icv_scan_strip_inflection.pro", "", "icv_scan_strip_inflection", "", "argccsigmanormstripmodelszeromzero", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/icv/icv_scan_strip_model.html", "icv_scan_strip_model.pro", '.pro file in <a href="nv/obj/tools/icv/dir-overview.html">nv/obj/tools/icv/ directory</a>', "icv_scan_strip_model.pro", "", "", " NAME: 	icv_scan_strip_model    PURPOSE: 	At each point along an image strip, determines the subpixel offset at 	which the correlation coefficient between a specified model and the 	image is maximum.    CATEGORY: 	NV/LIB/TOOLS/ICV    CALLING SEQUENCE: 	result = icv_scan_strip_model(strip, model, szero, mzero)    ARGUMENTS:   INPUT: 	strip:	Image strip (n_points,ns) to be scanned.  Output from 		icv_strip_curve ns must be even.  	model:	Model (n_points,nm) to correlate with strip at each point 		on the curve.  Must have nm < ns.  	szero:	Zero-offset position in the strip.  	mzero:	Zero-offset position in the model.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	cc:	Maximum correlation coefficient at each point on the curve.  	sigma:	Offset uncertainty for each point on the curve, computed as 		one half of the half-width of the correlation peak.    RETURN: 	Offset of best correlation at each point on the curve.    PROCEDURE: 	At every point on the curve, a correlation coefficient is computed 	for every offset at which the model completely overlays the strip. 	In other words, the model is swept across the strip.  	At each point, Lagrange interpolation is used on the three correlations 	surrounding the correlation peak to find the subpixel offset of maximum 	correlation.    STATUS: 	Complete.    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/icv/icv_scan_strip_model.html#icv_scan_strip_model", "icv_scan_strip_model", 'routine in <a href="nv/obj/tools/icv/icv_scan_strip_model.html">icv_scan_strip_model.pro</a>', "icv_scan_strip_model.pro", "", "icv_scan_strip_model", "", "argccsigmacenterstripmodelszeromzero", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/icv/icv_strip_curve.html", "icv_strip_curve.pro", '.pro file in <a href="nv/obj/tools/icv/dir-overview.html">nv/obj/tools/icv/ directory</a>', "icv_strip_curve.pro", "", "", " NAME: 	icv_strip_curve    PURPOSE: 	Using Lagrange interpolation, extracts an image strip of a specified 	width centered on the specified curve.    CATEGORY: 	NV/LIB/TOOLS/ICV    CALLING SEQUENCE: 	strip = icv_strip_curve(cd, image, curve_pts, width, nD, $                                                    cos_alpha, sin_alpha)    ARGUMENTS:   INPUT: 	cd:		Camera descriptor.  	image:		Image from which to extract the strip.  	curve_pts:	Array (2, n_points) of image points making up the curve.  	width:		Width of the strip in pixels.  	nD:		Number of samples across the width of the strip.  	cos_alpha:	Array (n_points) of direction cosines computed by 			icv_compute_directions.  	sin_alpha:	Array (n_points) of direction sines computed by 			icv_compute_directions.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	zero:		Zero-offset position in the strip.  This position 			corresponds to where the specified curve falls in the 			strip.    RETURN: 	Image strip (n_points, nD).    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/icv/icv_strip_curve.html#icv_strip_curve", "icv_strip_curve", 'routine in <a href="nv/obj/tools/icv/icv_strip_curve.html">icv_strip_curve.pro</a>', "icv_strip_curve.pro", "", "icv_strip_curve", "", "zerogrid_xgrid_ycdimagecurve_ptswidthnDcos_alphasin_alpha", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/gen/idgen.html", "idgen.pro", '.pro file in <a href="util/gen/dir-overview.html">util/gen/ directory</a>', "idgen.pro", "", "", " NAME: 	idgen    PURPOSE: 	Constructs an n x n identity matrix.    CATEGORY: 	UTIL/GEN    CALLING SEQUENCE: 	id = idgen(n)    ARGUMENTS:   INPUT: 	n:	 Degree of matrix, i.e., number of rows / columns.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Array (n x n) with all diagonal elements set to 1.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/gen/idgen.html#idgen", "idgen", 'routine in <a href="util/gen/idgen.html">idgen.pro</a>', "idgen.pro", "", "idgen", "", "n", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/idl_v_chrono.html", "idl_v_chrono.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "idl_v_chrono.pro", "", "", " idl_v_chrono   PURPOSE : `   Return a value which monotonically increases with IDL release number.  This can be used to compare the chronological order of two IDL releases.    CALLING SEQUENCE :      result = idl_v_chrono(release)    ARGUMENTS   INPUT : release - String containing the IDL release number,                     i.e; '3.6.1a'.    OUTPUT : NONE     KEYWORDS   INPUT : NONE    OUTPUT : NONE     RETURN : See above.     ORIGINAL AUTHOR : J. Spitale ; 10/94   UPDATE HISTORY :   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/idl_v_chrono.html#idl_v_chrono", "idl_v_chrono", 'routine in <a href="util/idl_v_chrono.html">idl_v_chrono.pro</a>', "idl_v_chrono.pro", "", "idl_v_chrono", "", "release", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/downloader/idlastro_download.html", "idlastro_download.pro", '.pro file in <a href="util/downloader/dir-overview.html">util/downloader/ directory</a>', "idlastro_download.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/downloader/idlastro_download.html#idlastro_download", "idlastro_download", 'routine in <a href="util/downloader/idlastro_download.html">idlastro_download.pro</a>', "idlastro_download.pro", "", "idlastro_download", "", "autoorcominasdir", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/fits/ieee_to_host.html", "ieee_to_host.pro", '.pro file in <a href="config/fits/dir-overview.html">config/fits/ directory</a>', "ieee_to_host.pro", "", "", " NAME: 	ieee_to_host    PURPOSE: 	Translates an IDL variable in IEEE-754 representation (as used, for 	example, in FITS data ), into the host machine architecture.    CATEGORY: 	UTIL/FITS    CALLING SEQUENCE: 	ieee_to_host, data, [ IDLTYPE = IDLTYPE ]    ARGUMENTS:   INPUT: 	data:	Any IDL variable, scalar or vector.   It will be modified by 		IEEE_TO_HOST to convert from IEEE to host representation.  Byte 		and string variables are returned by IEEE_TO_HOST unchanged.    OUTPUT: 	data:	See above.    KEYWORDS:   INPUT: 	IDLTYPE:	Scalar integer (1-7) specifying the IDL datatype 			according to the code given by the SIZE function. 			This keyword will usually be used when suppying a byte 			array that needs to be interpreted as another data type 			(e.g. FLOAT).    OUTPUT: NONE    RETURN: NONE    RESTRICTIONS: 	Assumes the IDL version is since 2.2.2 when the /XDRTOF keyword 	became available to BYTEORDER.    There were two bad implementations 	in BYTEORDER for double precision: (1) in IDL V3.* for DecStations 	(!VERSION.ARCH = 'mipsel') and (2) on Dec Alpha OSF machines. 	IEEE_TO_HOST works around these cases by swapping the byte order 	directly.    PROCEDURE: 	The BYTEORDER procedure is called with the appropriate keywords    EXAMPLE: 	A 2880 byte array (named FITARR) from a FITS record is to be 	interpreted as floating and converted to the host representaton:  	IDL> IEEE_TO_HOST, fitarr, IDLTYPE = 4    STATUS: 	Complete    SEE ALSO: 	host_to_ieee, conv_unix_vax, conv_vax_unix    MODIFICATION HISTORY: 	Written, W. Landsman   Hughes/STX   May, 1992 	Fixed error Case statement for float and double   September 1992 	Workaround to /XDRTOD problem on DecStations January 1993 	Assume since Version 2.2, correct double precision problems in 	Alpha/OSF, implement Ultrix corrections from Tom McGlynn November 1994 	Added support for double precision complex   July 1995 	Workaround for BYTEORDER, /FTOXDR bug in VAX VMS V4.0  August 1995   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/fits/ieee_to_host.html#ieee_to_host", "ieee_to_host", 'routine in <a href="config/fits/ieee_to_host.html">ieee_to_host.pro</a>', "ieee_to_host.pro", "", "ieee_to_host", "", "IDLTYPEdata", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/illumination_fraction.html", "illumination_fraction.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "illumination_fraction.pro", "", "", " NAME:        illumination_fraction    PURPOSE: 	Assuming the body gbx is a sphere, this routine computes the fraction of 	its disk that appears illuminated by the source sund, as seen from the 	inertial position vectors v.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        v = illumination_fraction(gbx, sund, v)    ARGUMENTS:   INPUT: 	gbx:	Any subclass of GLOBE.  	sund:	Any subclass of STAR representing the sun.  	v:	Array (nv,3) Inertial positions of viewer.    OUTPUT:        NONE    KEYOWRDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (nv) giving the illumination fraction for each gbx.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/illumination_fraction.html#illumination_fraction", "illumination_fraction", 'routine in <a href="nv/obj/tools/illumination_fraction.html">illumination_fraction.pro</a>', "illumination_fraction.pro", "", "illumination_fraction", "", "gbxsundv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/imag.html", "imag.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "imag.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/imag.html#imag", "imag", 'routine in <a href="util/imag.html">imag.pro</a>', "imag.pro", "", "imag", "", "z", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/image_ansa.html", "image_ansa.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "image_ansa.pro", "", "", " NAME:        image_ansa    PURPOSE: 	Computes ring ansa true anomalies.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        tas = image_ansa(cd, rd, radius)    ARGUMENTS:   INPUT: 	cd:	Camera descriptor.  	dkx:	Any subclass of DISK.  	radius:	Disk radius at which to compute ansa.    OUTPUT:  NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	image_pts:	Image points corresponding to each ansa true anomaly 			at the given radius.    RETURN: 	Array (2) of true anomalies    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/image_ansa.html#ia_compute", "ia_compute", 'routine in <a href="nv/obj/tools/image_ansa.html">image_ansa.pro</a>', "image_ansa.pro", "", "ia_compute", "", "image_ptcdrdradiusta0", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/tools/image_ansa.html#image_ansa", "image_ansa", 'routine in <a href="nv/obj/tools/image_ansa.html">image_ansa.pro</a>', "image_ansa.pro", "", "image_ansa", "", "image_ptscdrdradius", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/image_ansa_far.html", "image_ansa_far.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "image_ansa_far.pro", "", "", " NAME:        image_ansa_far    PURPOSE: 	Computes ring ansa longitudes assuming observer is very far from the 	rings.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        lons = image_ansa_far(cd, rd)    ARGUMENTS:   INPUT: 	cd:	Camera descriptor.  	dkx:	Any subclass of DISK.    OUTPUT:  NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (2) of longitudes    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/image_ansa_far.html#image_ansa_far", "image_ansa_far", 'routine in <a href="nv/obj/tools/image_ansa_far.html">image_ansa_far.pro</a>', "image_ansa_far.pro", "", "image_ansa_far", "", "cdrd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/image_auto_stretch.html", "image_auto_stretch.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "image_auto_stretch.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/image_auto_stretch.html#image_auto_stretch", "image_auto_stretch", 'routine in <a href="util/image_auto_stretch.html">image_auto_stretch.pro</a>', "image_auto_stretch.pro", "", "image_auto_stretch", "", "minmaximage", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/image_autoscale.html", "image_autoscale.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "image_autoscale.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/image_autoscale.html#image_autoscale", "image_autoscale", 'routine in <a href="util/image_autoscale.html">image_autoscale.pro</a>', "image_autoscale.pro", "", "image_autoscale", "", "histminminmaximage", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/image_azimuth.html", "image_azimuth.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "image_azimuth.pro", "", "", " NAME:        image_azimuth_pos    PURPOSE: 	Computes azimuth angle of projection of inertial vector v 	into the image plane.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        v = image_azimuth_pos(cd, v)    ARGUMENTS:   INPUT: 	cd:	Any subclass of GLOBE.  	v:	Inertial vector.    OUTPUT:        NONE    KEYOWRDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Image azimuth.  When the image is displayed with (0,0) at 	the top-left, the azimuth angle is measured counterclockwise from 	 up .    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/image_azimuth.html#image_azimuth", "image_azimuth", 'routine in <a href="nv/obj/tools/image_azimuth.html">image_azimuth.pro</a>', "image_azimuth.pro", "", "image_azimuth", "", "cdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/image_azimuth_pos.html", "image_azimuth_pos.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "image_azimuth_pos.pro", "", "", " NAME:        image_azimuth_pos    PURPOSE: 	Computes azimuth angle of projection of inertial position vector v 	into the image plane.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        v = image_azimuth_pos(cd, v)    ARGUMENTS:   INPUT: 	cd:	Any subclass of GLOBE.  	v:	Inertial position vector.    OUTPUT:        NONE    KEYOWRDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Image azimuth.  When the image is displayed with (0,0) at 	the top-left, the azimuth angle is measured counterclockwise from 	 up .    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/image_azimuth_pos.html#image_azimuth_pos", "image_azimuth_pos", 'routine in <a href="nv/obj/tools/image_azimuth_pos.html">image_azimuth_pos.pro</a>', "image_azimuth_pos.pro", "", "image_azimuth_pos", "", "cdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/image_bg.html", "image_bg.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "image_bg.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/image_bg.html#image_bg", "image_bg", 'routine in <a href="util/image_bg.html">image_bg.pro</a>', "image_bg.pro", "", "image_bg", "", "smimage", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/image_celestial_northangle.html", "image_celestial_northangle.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "image_celestial_northangle.pro", "", "", " NAME:        image_celestial_northangle    PURPOSE: 	Computes the image azimuth (see image_azimuth.pro) of celestial north.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        result = image_celestial_northangle(cd)    ARGUMENTS:   INPUT: 	cd:	Camera descriptor.    OUTPUT:  NONE    KEYOWRDS:   INPUT: 	orient:	Orientation matrix to use instead of cd.    OUTPUT: NONE    RETURN:        Angle in radians.     MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/image_celestial_northangle.html#image_celestial_northangle", "image_celestial_northangle", 'routine in <a href="nv/obj/tools/image_celestial_northangle.html">image_celestial_northangle.pro</a>', "image_celestial_northangle.pro", "", "image_celestial_northangle", "", "orientcd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/image_centroid.html", "image_centroid.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "image_centroid.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/image_centroid.html#image_centroid", "image_centroid", 'routine in <a href="util/image_centroid.html">image_centroid.pro</a>', "image_centroid.pro", "", "image_centroid", "", "im", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/image_clusters.html", "image_clusters.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "image_clusters.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/image_clusters.html#image_clusters", "image_clusters", 'routine in <a href="util/image_clusters.html">image_clusters.pro</a>', "image_clusters.pro", "", "image_clusters", "", "thresholdsallimagescale", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/image_clusters.html#___image_clusters", "___image_clusters", 'routine in <a href="util/image_clusters.html">image_clusters.pro</a>', "image_clusters.pro", "", "___image_clusters", "", "cutoff_imagescalemincluster", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/image_correlate.html", "image_correlate.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "image_correlate.pro", "", "", " image_correlate   PURPOSE :    Search for the vector offset, t, at which image2 best correlates with  image1 (without searching the entire array).     The algorithm works as follows:   1) begin with a grid of size nsamples covering the entire image1,     for example, for nsample=[4,4], the grid might look like :              -------------------------            |   .     .     .     .   |            |                         |<-----image array            |                         |            |   .     .     .     .   |            |                         |            |                         |            |   .     .     .     .<--|---sample each of these offsets            |                         |            |                         |            |   .     .     .     .   |             -------------------------   2) evaluate the cross correlation function of image1 and image2      at each point on the grid and determine which point gave the      best result.  Store this point and its correlation in      best_arr.   3) center a new grid of the same configuration at that point      but make it smaller by grid_ratio :              -------------------------         ---|---.   .   .   .     .   |          | |                         |<-----image array     new  | |   .   .   .   .         |     grid | |         +<----------.---|----best point from last scan          | |   .   .   .   .         |          | |                         |         ---|---.   .   .   .     .   |            |                         |            |                         |            |   .     .     .     .   |             -------------------------   4) continue until the entire grid becomes smaller than 1 pixel across.   5) return the point in best_arr which gave the best correlation.   Accuracy:   The offset vector returned by this routine should usually    lie within one pixel of the actual maximum correlation.  The    result can only be guaranteed, though, if nsamples is set to the    size of the array, but this is almost never practical.   Speed:   If you use nsamples of [2,2], the default, then each search cycle    will be as fast as possible, but it will take many cycles to converge    on the maximum.  If you use a very fine grid, then it may take only    a few cycles, but the cycles will take very long.  Of course,    generally one would expect it to be much faster to use a coarse grid    as opposed to one of the same size as the array, otherwise, there    would have been no reason to write this program.  The total time    should scale as:           t = nsamples(0)*nsamples(1)  *  ncycles     where ncycles is the number of search cycles necessary to converge.    The exact value depends on the two images and their initial    offsets.    NOTE: Unless /nohome is set, the first point in best_arr always corresponds        to t=[0,0], i.e; no shift at all.  Thus, if the        images never needed to be shifted, then the result        the result will always be zero offset.     CALLING SEQUENCE :     t=image_correlate(im1, im2, correlation)    ARGUMENTS   INPUT : im1 - reference image            im2 - image to be shifted    OUTPUT : correlation - cross correlation value after im2 has been                          shifted by t.     KEYWORDS   INPUT : show - Show the search.            nsamples - 2D vector giving the dimensions of the search grid,                      default is [2,2].            nohome - Do not check the offset [0,0] for best correlation.            function_min, function_max - Name of a function to either                                        minimize or maximize.  The                                        function should be declared as                                        follows:                                           function [name], f, g, t                                         and should return a number which                                        indicates the degree of correlation                                        between f ang g, with g shifted by t.            indices - This keyword will only work properly if both images                     are of the same dimensions.  It allows the caller                     to specify a region over which the correlation                     will be optomized by giving an array of the 1D subscripts                     which lie within that region.            kill_char - Key which can be used to abort the search and return                       an offset of [0,0], with the corresponding correlation.                       This slows down the loop a bit, but not significantly                       for large images, in which it may be more important                       for the user to be able to abort.  	   region - Size of region to scan, centered at offset [0,0].  If not 		    specified, the entire image is scanned.    OUTPUT : NONE     RETURN : t, the vector offset by which im2 had to be shifted for           maximum correlation with im1.      KNOWN BUGS : see 'Accuracy' above.     ORIGINAL AUTHOR : J. Spitale ; 8/94   UPDATE HISTORY : Spitale, 4/2002 -- added 'region' keyword   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/image_correlate.html#image_correlate", "image_correlate", 'routine in <a href="util/image_correlate.html">image_correlate.pro</a>', "image_correlate.pro", "", "image_correlate", "", "shownsamplesnohomefunction_minfunction_maxcornerskill_charregiondatawxwyno_widthbiasnosearchim1im2correlation", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/image_eq.html", "image_eq.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "image_eq.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/image_eq.html#image_eq", "image_eq", 'routine in <a href="util/image_eq.html">image_eq.pro</a>', "image_eq.pro", "", "image_eq", "", "fractionlowminmaximage", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/image_gaussfit.html", "image_gaussfit.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "image_gaussfit.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/image_gaussfit.html#image_gaussfit", "image_gaussfit", 'routine in <a href="util/image_gaussfit.html">image_gaussfit.pro</a>', "image_gaussfit.pro", "", "image_gaussfit", "", "levelcoeffsamplemap", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/image_gradient.html", "image_gradient.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "image_gradient.pro", "", "", " NAME:        image_gradient    PURPOSE:        To calculate the image gradiant.    CATEGORY:        UTIL    CALLING SEQUENCE:        result = image_gradient(im)    ARGUMENTS:   INPUT:        im:     An image.    OUTPUT:        NONE   RETURN:        The image gradiant.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/image_gradient.html#image_gradient", "image_gradient", 'routine in <a href="util/image_gradient.html">image_gradient.pro</a>', "image_gradient.pro", "", "image_gradient", "", "im", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/image_interp/image_interp.html", "image_interp.pro", '.pro file in <a href="util/image_interp/dir-overview.html">util/image_interp/ directory</a>', "image_interp.pro", "", "", " NAME:        image_interp    PURPOSE:        Extracts a region from an image using the desired interpolation.    CATEGORY:        UTIL    CALLING SEQUENCE:        result = image_interp(image, grid_x, grid_y)    ARGUMENTS:   INPUT:         image:         An array of image point arrays.         grid_x:         The grid of x positions for interpolation         grid_y:         The grid of y positions for interpolation    OUTPUT:        NONE   RETURN:        Array of interpolated points at the (grid_x, grid_y) points.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/image_interp/image_interp.html#image_interp", "image_interp", 'routine in <a href="util/image_interp/image_interp.html">image_interp.pro</a>', "image_interp.pro", "", "image_interp", "", "polysinckcubicnearestmeanpsf_fnpsf_datamaxkmaskzmaskvalidimagegrid_xgrid_yargsfwhm", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/image_interp_cam.html", "image_interp_cam.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "image_interp_cam.pro", "", "", " NAME:        image_interp_cam    PURPOSE:        Extracts a region from an image using the desired interpolation, 	accouting for the camera point-spread function is applicable.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        result = image_interp_cam(image, grid_x, grid_y, args)    ARGUMENTS:   INPUT: 	image:	An array of image point arrays.  	grid_x:	The grid of x positions for interpolation  	grid_y:	The grid of y positions for interpolation  	args:	Arguments to pass to the interpolation function.    OUTPUT:  NONE    KEYOWRDS:   INPUT: 	cd:	Camera descriptor.  	interp:	Type of interpolation to use.  Options are: 		'nearest', 'mean', 'bilinear', 'cubic', 'sinc'.  	k:	 Half-width  of the convolution window.  The 		window actually covers the central pixel, plus 		k pixel in each direction.  Default is 3, which 		gives a 7x7 window.  	kmax:	Maximum value for k.    OUTPUT: NONE    RETURN:        Array of interpolated points at the (grid_x, grid_y) points.     MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/image_interp_cam.html#image_interp_cam", "image_interp_cam", 'routine in <a href="nv/obj/tools/image_interp_cam.html">image_interp_cam.pro</a>', "image_interp_cam.pro", "", "image_interp_cam", "", "cdvalidkinterpkmaxmaskzmaskimagegrid_xgrid_yargs", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/image_interp/image_interp_cubic.html", "image_interp_cubic.pro", '.pro file in <a href="util/image_interp/dir-overview.html">util/image_interp/ directory</a>', "image_interp_cubic.pro", "", "", " NAME:        image_interp_cubic    PURPOSE:        Extracts a region from an image using cubic interpolation.    CATEGORY:        UTIL    CALLING SEQUENCE:        result = image_interp_cubic(image, grid_x, grid_y)    ARGUMENTS:   INPUT:         image:         An array of image point arrays.         grid_x:         The grid of x positions for interpolation         grid_y:         The grid of y positions for interpolation  	     k:		 Half-width  of the convolution window.  The 			window actually covers the central pixel, plus 			k pixels in each direction.  Default is 3, which 			gives a 7x7 window.  	fwhm:		If set, a gaussian with this half width is used for 			the psf instead of caling the user-supplied function.    OUTPUT:        NONE    KEYORDS:   INPUT: 	psf_fn:		Name of a function to compute the psf:  				psf_fn(psf_data, x,y)  			where x and y are the location relative to the 			center, and must accept arrays of any dimension.  	psf_data:	Data for psf function as shown above.  	mask:		Byte image indcating which pixels (value GT 0) should 			be excluded from the interpolation.    OUTPUT:        NONE    RETURN:        Array of interpolated points at the (grid_x, grid_y) points.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/image_interp/image_interp_cubic.html#image_interp_cubic", "image_interp_cubic", 'routine in <a href="util/image_interp/image_interp_cubic.html">image_interp_cubic.pro</a>', "image_interp_cubic.pro", "", "image_interp_cubic", "", "validpsf_fnpsf_datamaskzmaskimagegrid_xgrid_ykfwhm", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/image_interp/image_interp_mean.html", "image_interp_mean.pro", '.pro file in <a href="util/image_interp/dir-overview.html">util/image_interp/ directory</a>', "image_interp_mean.pro", "", "", " NAME:        image_interp_mean    PURPOSE:        Extracts a region from an image using averaging interpolation.    CATEGORY:        UTIL    CALLING SEQUENCE:        result = image_interp(image, grid_x, grid_y)    ARGUMENTS:   INPUT:         image:         An array of image point arrays.         grid_x:         The grid of x positions for interpolation         grid_y:         The grid of y positions for interpolation    OUTPUT:        NONE   RETURN:        Array of interpolated points at the (grid_x, grid_y) points.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/image_interp/image_interp_mean.html#image_interp_mean", "image_interp_mean", 'routine in <a href="util/image_interp/image_interp_mean.html">image_interp_mean.pro</a>', "image_interp_mean.pro", "", "image_interp_mean", "", "maskzmaskvalidimagegrid_xgrid_ykwidth", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/image_interp/image_interp_nearest.html", "image_interp_nearest.pro", '.pro file in <a href="util/image_interp/dir-overview.html">util/image_interp/ directory</a>', "image_interp_nearest.pro", "", "", " NAME:        image_interp_sinc    PURPOSE:        Extracts a region from an image using sinc interpolation.    CATEGORY:        UTIL    CALLING SEQUENCE:        result = image_interp_sinc(image, grid_x, grid_y)    ARGUMENTS:   INPUT:         image:         An array of image point arrays.         grid_x:         The grid of x positions for interpolation         grid_y:         The grid of y positions for interpolation  	     k:		 Half-width  of the convolution window.  The 			window actually covers the central pixel, plus 			k pixels in each direction.  Default is 3, which 			gives a 7x7 window.  	fwhm:		If set, a gaussian with this half width is used for 			the psf instead of caling the user-supplied function.    OUTPUT:        NONE    KEYORDS:   INPUT: 	psf_fn:		Name of a function to compute the psf:  				psf_fn(psf_data, x,y)  			where x and y are the location relative to the 			center, and must accept arrays of any dimension.  	psf_data:	Data for psf function as shown above.  	mask:		Byte image indcating which pixels (value GT 0) should 			be excluded from the interpolation.    OUTPUT:        NONE    RETURN:        Array of interpolated points at the (grid_x, grid_y) points.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/image_interp/image_interp_nearest.html#image_interp_nearest", "image_interp_nearest", 'routine in <a href="util/image_interp/image_interp_nearest.html">image_interp_nearest.pro</a>', "image_interp_nearest.pro", "", "image_interp_nearest", "", "maskzmaskvalidimagegrid_xgrid_y", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/image_interp/image_interp_poly.html", "image_interp_poly.pro", '.pro file in <a href="util/image_interp/dir-overview.html">util/image_interp/ directory</a>', "image_interp_poly.pro", "", "", " NAME:        image_interp_poly    PURPOSE:        Extracts a region from an image using Lagrange polynomial 	interpolation.    CATEGORY:        UTIL    CALLING SEQUENCE:        result = image_interp(image, grid_x, grid_y)    ARGUMENTS:   INPUT:         image:         An array of image point arrays.         grid_x:         The grid of x positions for interpolation         grid_y:         The grid of y positions for interpolation    OUTPUT:        NONE   RETURN:        Array of interpolated points at the (grid_x, grid_y) points.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/image_interp/image_interp_poly.html#image_interp_poly", "image_interp_poly", 'routine in <a href="util/image_interp/image_interp_poly.html">image_interp_poly.pro</a>', "image_interp_poly.pro", "", "image_interp_poly", "", "maskzmaskvalidimagegrid_xgrid_y", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/image_interp/image_interp_sinc.html", "image_interp_sinc.pro", '.pro file in <a href="util/image_interp/dir-overview.html">util/image_interp/ directory</a>', "image_interp_sinc.pro", "", "", " NAME:        image_interp_sinc    PURPOSE:        Extracts a region from an image using sinc interpolation.    CATEGORY:        UTIL    CALLING SEQUENCE:        result = image_interp_sinc(image, grid_x, grid_y)    ARGUMENTS:   INPUT:         image:         An array of image point arrays.         grid_x:         The grid of x positions for interpolation         grid_y:         The grid of y positions for interpolation  	     k:		 Half-width  of the convolution window.  The 			window actually covers the central pixel, plus 			k pixels in each direction.  Default is 3, which 			gives a 7x7 window.  	fwhm:		If set, a gaussian with this half width is used for 			the psf instead of calling the user-supplied function.    OUTPUT:        NONE    KEYORDS:   INPUT: 	psf_fn:		Name of a function to compute the psf:  				psf_fn(psf_data, x,y)  			where x and y are the location relative to the 			center, and must accept arrays of any dimension.  	psf_data:	Data for psf function as shown above.  	mask:		Byte image indcating which pixels (value GT 0) should 			be excluded from the interpolation.    OUTPUT:        NONE    RETURN:        Array of interpolated points at the (grid_x, grid_y) points.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/image_interp/image_interp_sinc.html#image_interp_sinc", "image_interp_sinc", 'routine in <a href="util/image_interp/image_interp_sinc.html">image_interp_sinc.pro</a>', "image_interp_sinc.pro", "", "image_interp_sinc", "", "validpsf_fnpsf_datakmaxmaskzmaskimagegrid_xgrid_ykfwhmpsf_frac", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/image_median.html", "image_median.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "image_median.pro", "", "", " NAME: 	image_median    PURPOSE: 	Produces an image in which each pixel is the median of the corresponding 	pixels in the input images.    CATEGORY: 	UTIL    CALLING SEQUENCE: 	result = image_median(images)    ARGUMENTS:   INPUT: 	images:	Array (xsize, ysize, n) containing the n input images.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	NONE    OUTPUT: 	NONE    RETURN: 	Array (xsize, ysize) with the output image.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/image_median.html#image_median", "image_median", 'routine in <a href="util/image_median.html">image_median.pro</a>', "image_median.pro", "", "image_median", "", "_images", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/image_northangle.html", "image_northangle.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "image_northangle.pro", "", "", " NAME:        image_northangle    PURPOSE: 	Computes the image azimuth (see image_azimuth.pro) of the north 	direction on the surface of the given body at the specified pixel 	location p.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        result = image_northangle(cd, gbx, p)    ARGUMENTS:   INPUT: 	cd:	Camera descriptor.  	gbx:	Any subclass of GLOBE.  	p:	Array (2) giving the image point.    OUTPUT:  NONE    KEYOWRDS:   INPUT: NONE    OUTPUT: 	valid:	Indicates whether the result has a solution.  -1 if no 		solution, 1 otherwise.    RETURN:        Angle in radians.     MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/image_northangle.html#image_northangle", "image_northangle", 'routine in <a href="nv/obj/tools/image_northangle.html">image_northangle.pro</a>', "image_northangle.pro", "", "image_northangle", "", "validcdgbxp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/image_offset.html", "image_offset.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "image_offset.pro", "", "", " NAME: 	image_offset    PURPOSE: 	Searches for the offset (dx,dy) that best locates an image within a 	a reference image.    CATEGORY: 	UTIL    CALLING SEQUENCE: 	dxy = image_offset(im0, im)    ARGUMENTS:   INPUT: 	im0:		Reference image.  	im:		Test image, must be smaller than im0.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	2-element array giving the fit offset as [dx,dy].    PROCEDURE: 	This routine considers every possble image offset by iterating over 	various correlation scales.    STATUS: 	Some bugs.     SEE ALSO: 	pg_farfit    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/image_offset.html#__ioff_peak", "__ioff_peak", 'routine in <a href="util/image_offset.html">image_offset.pro</a>', "image_offset.pro", "", "__ioff_peak", "", "corrgrid", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/image_offset.html#___ioff_peak", "___ioff_peak", 'routine in <a href="util/image_offset.html">image_offset.pro</a>', "image_offset.pro", "", "___ioff_peak", "", "corrgrid", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/image_offset.html#ioff_peak", "ioff_peak", 'routine in <a href="util/image_offset.html">image_offset.pro</a>', "image_offset.pro", "", "ioff_peak", "", "corrgrid", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/image_offset.html#ioff_variance", "ioff_variance", 'routine in <a href="util/image_offset.html">image_offset.pro</a>', "image_offset.pro", "", "ioff_variance", "", "im0im", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/image_offset.html#ioff_ccorr", "ioff_ccorr", 'routine in <a href="util/image_offset.html">image_offset.pro</a>', "image_offset.pro", "", "ioff_ccorr", "", "im0im", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/image_offset.html#ioff_correlate", "ioff_correlate", 'routine in <a href="util/image_offset.html">image_offset.pro</a>', "image_offset.pro", "", "ioff_correlate", "", "dxyim0immask_grid", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/image_offset.html#___image_offset", "___image_offset", 'routine in <a href="util/image_offset.html">image_offset.pro</a>', "image_offset.pro", "", "___image_offset", "", "_im0_im", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/image_offset.html#image_offset", "image_offset", 'routine in <a href="util/image_offset.html">image_offset.pro</a>', "image_offset.pro", "", "image_offset", "", "dxyxbin0_im0im", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/image_offset.html#test", "test", 'routine in <a href="util/image_offset.html">image_offset.pro</a>', "image_offset.pro", "", "test", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/composite/image_origin.html", "image_origin.pro", '.pro file in <a href="nv/obj/tools/composite/dir-overview.html">nv/obj/tools/composite/ directory</a>', "image_origin.pro", "", "", " NAME:        image_origin    PURPOSE: 	Returns the origin of a map or camera image.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        image_origin(xd)    ARGUMENTS:   INPUT: 	xd:      Camera or map descriptor     OUTPUT: NONE    KEYWORDS:    INPUT: NONE     OUTPUT: NONE    RETURN: 	2-element array giving the origin in the x and y directions.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/composite/image_origin.html#image_origin", "image_origin", 'routine in <a href="nv/obj/tools/composite/image_origin.html">image_origin.pro</a>', "image_origin.pro", "", "image_origin", "", "cd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/image_outline.html", "image_outline.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "image_outline.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/image_outline.html#image_outline", "image_outline", 'routine in <a href="util/image_outline.html">image_outline.pro</a>', "image_outline.pro", "", "image_outline", "", "samplerectifyimage", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/image_predict.html", "image_predict.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "image_predict.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/image_predict.html#image_predict", "image_predict", 'routine in <a href="nv/obj/tools/image_predict.html">image_predict.pro</a>', "image_predict.pro", "", "image_predict", "", "cGGposcdrxgbx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/image_predict_orbit.html", "image_predict_orbit.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "image_predict_orbit.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/image_predict_orbit.html#image_predict_orbit", "image_predict_orbit", 'routine in <a href="nv/obj/tools/image_predict_orbit.html">image_predict_orbit.pro</a>', "image_predict_orbit.pro", "", "image_predict_orbit", "", "cGGposppradecnotestsloprxtcdgbxrx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/image_predict_orbit_error.html", "image_predict_orbit_error.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "image_predict_orbit_error.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/image_predict_orbit_error.html#image_predict_orbit_error", "image_predict_orbit_error", 'routine in <a href="nv/obj/tools/image_predict_orbit_error.html">image_predict_orbit_error.pro</a>', "image_predict_orbit_error.pro", "", "image_predict_orbit_error", "", "cGGnsamplesimplecdgbxrxsig_rx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/image_predict_ring.html", "image_predict_ring.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "image_predict_ring.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/image_predict_ring.html#image_predict_ring", "image_predict_ring", 'routine in <a href="nv/obj/tools/image_predict_ring.html">image_predict_ring.pro</a>', "image_predict_ring.pro", "", "image_predict_ring", "", "sundrxtcdgbxrx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/image_predict_wind.html", "image_predict_wind.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "image_predict_wind.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/image_predict_wind.html#image_predict_wind", "image_predict_wind", 'routine in <a href="nv/obj/tools/image_predict_wind.html">image_predict_wind.pro</a>', "image_predict_wind.pro", "", "image_predict_wind", "", "posvdegcdgbxt0surf_ptvel", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/image_shift.html", "image_shift.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "image_shift.pro", "", "", " NAME:        image_shift    PURPOSE: 	Shifts an image by a specified (non-integer) amount using 	interpolation.  If applicable, the camera pont-spread function 	is accounted for in the interpolation.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        result = image_shift(image, dx, dy)    ARGUMENTS:   INPUT: 	image:	2-D array giving the image.  	dx:	Offset in the x direction.  	dy:	Offset in the y direction.    OUTPUT:  NONE    KEYOWRDS:   INPUT: 	cd:	Camera descriptor.    OUTPUT: NONE    RETURN:        Shifted image.     MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/image_shift.html#image_shift", "image_shift", 'routine in <a href="nv/obj/tools/image_shift.html">image_shift.pro</a>', "image_shift.pro", "", "image_shift", "", "cdimagedxdy", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/composite/image_size.html", "image_size.pro", '.pro file in <a href="nv/obj/tools/composite/dir-overview.html">nv/obj/tools/composite/ directory</a>', "image_size.pro", "", "", " NAME:        image_size    PURPOSE: 	Returns the size of a map or camera image.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        image_size(xd)    ARGUMENTS:   INPUT: 	xd:      Camera or map descriptor     OUTPUT: NONE    KEYWORDS:    INPUT: NONE     OUTPUT: NONE    RETURN: 	2-element array giving the size in the x and y directions.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/composite/image_size.html#image_size", "image_size", 'routine in <a href="nv/obj/tools/composite/image_size.html">image_size.pro</a>', "image_size.pro", "", "image_size", "", "cd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/composite/image_to_body.html", "image_to_body.pro", '.pro file in <a href="nv/obj/tools/composite/dir-overview.html">nv/obj/tools/composite/ directory</a>', "image_to_body.pro", "", "", " NAME:        image_to_body    PURPOSE:        Transforms points in image coordinates to body coordinates on the 	object.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = image_to_body(cd, bx, p)    ARGUMENTS:   INPUT: 	cd:       Array of nt camera or map descriptor.  	bx:       Array of nt body descriptor (subclass of GLOBE or DISK).  	p:       Array (2 x nv x nt) of image points.    OUTPUT:        hit:	Array with one element per input point.  1 if point 		falls on the body, 0 if not.   RETURN:        Array (nv x 3 x nt) of body-frame vectors.  Zero vectors are returned if a 	body point cannot be computed (e.g., the ray misses the planet).   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale; 8/2006  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/composite/image_to_body.html#image_to_body", "image_to_body", 'routine in <a href="nv/obj/tools/composite/image_to_body.html">image_to_body.pro</a>', "image_to_body.pro", "", "image_to_body", "", "hitbackallcdbxp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/composite/image_to_disk.html", "image_to_disk.pro", '.pro file in <a href="nv/obj/tools/composite/dir-overview.html">nv/obj/tools/composite/ directory</a>', "image_to_disk.pro", "", "", " NAME:        image_to_disk    PURPOSE:        Transforms points in image coordinates to disk coordinates    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = image_to_disk(cd, dkx, p)    ARGUMENTS:   INPUT: 	cd:	Array of nt camera or map descriptors.  	dkx:	Array of nt object descriptors (subclass of DISK).  	p:	Array (2 x nv x nt) of image points.    OUTPUT:        hit:	Array with one element per input point.  1 if point 		falls on the body, 0 if not.    KEYWORDS:    INPUT: NONE     OUTPUT: 	valid:	Indices of valid output points.         hit:	Array with one element per input point.  1 if point 		falls on the body, 0 if not.  	body_pts:	Body coordinates of output points.    RETURN:        Array (nv x 3 x nt) of disk positions.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Tiscareno (modified from image_to_surface)  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/composite/image_to_disk.html#image_to_disk", "image_to_disk", 'routine in <a href="nv/obj/tools/composite/image_to_disk.html">image_to_disk.pro</a>', "image_to_disk.pro", "", "image_to_disk", "", "hitvalidbody_ptscddkxp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/composite/image_to_globe.html", "image_to_globe.pro", '.pro file in <a href="nv/obj/tools/composite/dir-overview.html">nv/obj/tools/composite/ directory</a>', "image_to_globe.pro", "", "", " NAME:        image_to_globe    PURPOSE:        Transforms points in image coordinates to body globe coordinates    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = image_to_globe(cd, od, p)    ARGUMENTS:   INPUT: 	cd:       Array of nt camera or map descriptors.  	od:       Array of nt object descriptors (of type GLOBE).  	p:       Array (2 x nv x nt) of image points.    OUTPUT:        NONE   KEYWORDS:    INPUT: NONE     OUTPUT: 	valid:	Indices of valid output points.  	body_pts:	Body coordinates of output points.  	discriminant:	Determinant D from the ray trace.  No solutions for 			D<0, two solutions for D=0, one slution for D>0.    RETURN:        Array (nv x 3 x nt) of globe positions.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale;  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/composite/image_to_globe.html#image_to_globe", "image_to_globe", 'routine in <a href="nv/obj/tools/composite/image_to_globe.html">image_to_globe.pro</a>', "image_to_globe.pro", "", "image_to_globe", "", "body_ptsdiscriminantvalidcdodp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/composite/image_to_inertial.html", "image_to_inertial.pro", '.pro file in <a href="nv/obj/tools/composite/dir-overview.html">nv/obj/tools/composite/ directory</a>', "image_to_inertial.pro", "", "", " NAME:        image_to_inertial    PURPOSE:        Transforms points in image coordinates to unit vectors with 	inertial coordinates.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = image_to_inertial(cd, p)    ARGUMENTS:   INPUT: 	cd:	Array of nt camera descriptors.  	p:	Array (2 x nv x nt) of image points.    OUTPUT:        NONE   RETURN:        Array (nv x 3 x nt) of of inertial unit vectors.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale 4/2003  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/composite/image_to_inertial.html#image_to_inertial", "image_to_inertial", 'routine in <a href="nv/obj/tools/composite/image_to_inertial.html">image_to_inertial.pro</a>', "image_to_inertial.pro", "", "image_to_inertial", "", "cdp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/composite/image_to_map.html", "image_to_map.pro", '.pro file in <a href="nv/obj/tools/composite/dir-overview.html">nv/obj/tools/composite/ directory</a>', "image_to_map.pro", "", "", " NAME:        image_to_map    PURPOSE:        Transforms points in image coordinates to map coordinates.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = image_to_map(cd, gbd, p)    ARGUMENTS:   INPUT: 	md:	Array of nt map or camera descriptors.  	gbx:	Array of nt object descriptors (of type GLOBE).  	p:	Array (2 x nv x nt) of image points    OUTPUT:        NONE   KEYWORDS:    INPUT: 	bx:	If md is not a map descriptor, bx gives a subclass of BODY 		needed for transforming surface to map coordinates.     OUTPUT: 	valid:	Indices of valid output points.  	body_pts:	Body coordinates of output points.    RETURN:        Array (nv x 3 x nt) of map points.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale;  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/composite/image_to_map.html#image_to_map", "image_to_map", 'routine in <a href="nv/obj/tools/composite/image_to_map.html">image_to_map.pro</a>', "image_to_map.pro", "", "image_to_map", "", "bxvalidbody_ptsmdp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/composite/image_to_orbit.html", "image_to_orbit.pro", '.pro file in <a href="nv/obj/tools/composite/dir-overview.html">nv/obj/tools/composite/ directory</a>', "image_to_orbit.pro", "", "", " NAME:        image_to_orbit    PURPOSE: 	Computes orbital elements corresponding to image points, assuming 	a circular orbit.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        dkd = image_to_orbit(cd, gbx, dkx, image_pts)    ARGUMENTS:   INPUT: 	cd:	Array of nt camera or map descriptors.  	gbx:	Array of nt globe descriptor describing the primary body.  	dkx:	Array of nt disk descriptor describing the assumed orbit plane.  	image_pts:	Array (1,3,nt) of image points.     OUTPUT: NONE    KEYWORDS:    INPUT: NONE     OUTPUT: NONE    RETURN: 	Array of nt disk descriptors reresenting the computed orbits.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/composite/image_to_orbit.html#image_to_orbit", "image_to_orbit", 'routine in <a href="nv/obj/tools/composite/image_to_orbit.html">image_to_orbit.pro</a>', "image_to_orbit.pro", "", "image_to_orbit", "", "GG_cd_gbxdkx0image_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/composite/image_to_radec.html", "image_to_radec.pro", '.pro file in <a href="nv/obj/tools/composite/dir-overview.html">nv/obj/tools/composite/ directory</a>', "image_to_radec.pro", "", "", " NAME:        image_to_radec    PURPOSE:        Transforms points in image coordinates to polar ra/dec coords 	w.r.t the inertial frame.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = image_to_radec(cd, p)    ARGUMENTS:   INPUT: 	cd:	Array of nt camera descriptors.  	p:	Array (2 x nv x nt) of image points.    OUTPUT:        NONE   KEYWORDS:    INPUT: NONE     OUTPUT: 	body_pts:	Body coordinates of output points.    RETURN:        Array (nv x 3 x nt) of radec vectors in the cd BODY frame.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale 3/2002, to replace image_to_ra_dec  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/composite/image_to_radec.html#image_to_radec", "image_to_radec", 'routine in <a href="nv/obj/tools/composite/image_to_radec.html">image_to_radec.pro</a>', "image_to_radec.pro", "", "image_to_radec", "", "body_ptscdp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/composite/image_to_surface.html", "image_to_surface.pro", '.pro file in <a href="nv/obj/tools/composite/dir-overview.html">nv/obj/tools/composite/ directory</a>', "image_to_surface.pro", "", "", " NAME:        image_to_surface    PURPOSE:        Transforms points in image coordinates to surface coordinates.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = image_to_surface(cd, bx, p)    ARGUMENTS:   INPUT: 	cd:      Array of nt camera or map descriptor  	bx:      Array of nt object descriptors (subclass of BODY).  	p:       Array (2 x nv x nt) of image points.    OUTPUT:        NONE   KEYWORDS:    INPUT: NONE     OUTPUT: 	valid:	Indices of valid output points.         hit:	Array with one element per input point.  1 if point 		falls on the body, 0 if not.  	body_pts:	Body coordinates of output points.  	discriminant:	Determinant D from the ray trace.  No solutions for 			 D<0, two solutions for D=0, one slution for D>0.    RETURN:        Array (nv x 3 x nt) of surface points.  In the case of a camera descriptor, ray 	tracing is used.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/composite/image_to_surface.html#image_to_surface", "image_to_surface", 'routine in <a href="nv/obj/tools/composite/image_to_surface.html">image_to_surface.pro</a>', "image_to_surface.pro", "", "image_to_surface", "", "body_ptsdiscriminanthitvalidcdbxp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/imagepds.html", "imagepds.pro", '.pro file in <a href="config/pds/Readpds_4.4/dir-overview.html">config/pds/Readpds_4.4/ directory</a>', "imagepds.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/imagepds.html#extract_image_keywords", "extract_image_keywords", 'routine in <a href="config/pds/Readpds_4.4/imagepds.html">imagepds.pro</a>', "imagepds.pro", "", "extract_image_keywords", "", "start_indend_indlabelparamrequired", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/imagepds.html#is_string", "is_string", 'routine in <a href="config/pds/Readpds_4.4/imagepds.html">imagepds.pro</a>', "imagepds.pro", "", "is_string", "", "value", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/imagepds.html#check_image_keywords", "check_image_keywords", 'routine in <a href="config/pds/Readpds_4.4/imagepds.html">imagepds.pro</a>', "imagepds.pro", "", "check_image_keywords", "", "keywdssilent", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/imagepds.html#get_subwindows", "get_subwindows", 'routine in <a href="config/pds/Readpds_4.4/imagepds.html">imagepds.pro</a>', "imagepds.pro", "", "get_subwindows", "", "start_indend_indwobjects", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/imagepds.html#obtain_current_window_params", "obtain_current_window_params", 'routine in <a href="config/pds/Readpds_4.4/imagepds.html">imagepds.pro</a>', "imagepds.pro", "", "obtain_current_window_params", "", "start_indend_indlabelelement", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/imagepds.html#process_display_direction", "process_display_direction", 'routine in <a href="config/pds/Readpds_4.4/imagepds.html">imagepds.pro</a>', "imagepds.pro", "", "process_display_direction", "", "elementkeywds", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/imagepds.html#obtain_current_image_params", "obtain_current_image_params", 'routine in <a href="config/pds/Readpds_4.4/imagepds.html">imagepds.pro</a>', "imagepds.pro", "", "obtain_current_image_params", "", "start_indend_indlabelsilent", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/imagepds.html#obtain_image_architecture", "obtain_image_architecture", 'routine in <a href="config/pds/Readpds_4.4/imagepds.html">imagepds.pro</a>', "imagepds.pro", "", "obtain_image_architecture", "", "sample_type", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/imagepds.html#obtain_image_structure", "obtain_image_structure", 'routine in <a href="config/pds/Readpds_4.4/imagepds.html">imagepds.pro</a>', "imagepds.pro", "", "obtain_image_structure", "", "keywds", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/imagepds.html#read_image_data", "read_image_data", 'routine in <a href="config/pds/Readpds_4.4/imagepds.html">imagepds.pro</a>', "imagepds.pro", "", "read_image_data", "", "pointerstructarch", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/imagepds.html#convert_image_data", "convert_image_data", 'routine in <a href="config/pds/Readpds_4.4/imagepds.html">imagepds.pro</a>', "imagepds.pro", "", "convert_image_data", "", "currentlabelstart_indend_indkeywdsnoscale", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/imagepds.html#process_windows", "process_windows", 'routine in <a href="config/pds/Readpds_4.4/imagepds.html">imagepds.pro</a>', "imagepds.pro", "", "process_windows", "", "start_indend_indelementwobjectslabelimgkeywdssilent", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/imagepds.html#process_all_images", "process_all_images", 'routine in <a href="config/pds/Readpds_4.4/imagepds.html">imagepds.pro</a>', "imagepds.pro", "", "process_all_images", "", "filenamelabelobjectswobjectssilentnoscale", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/imagepds.html#imagepds", "imagepds", 'routine in <a href="config/pds/Readpds_4.4/imagepds.html">imagepds.pro</a>', "imagepds.pro", "", "imagepds", "", "SILENTNOSCALEfilenamelabel", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/impact_param.html", "impact_param.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "impact_param.pro", "", "", " NAME:        impact_param    PURPOSE: 	Computes the impact parameter of a vector originating at the 	given camera, relative to the given planet object.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        B = impact_param(cd, pd)    ARGUMENTS:   INPUT: 	cd:	Camera descriptor.  	pd:	Planet descriptor.    OUTPUT:  NONE    KEYOWRDS:   INPUT: 	p:	Image point specifying te ray to project.  If not given, 		the camera optic axis is used.    OUTPUT: NONE    RETURN:        Shifted image.     MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/impact_param.html#impact_param", "impact_param", 'routine in <a href="nv/obj/tools/impact_param.html">impact_param.pro</a>', "impact_param.pro", "", "impact_param", "", "pcdpd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/imscl.html", "imscl.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "imscl.pro", "", "", " imscl   PURPOSE : `   Scales the values of the given image similarly to tvscl.  '   CALLING SEQUENCE :    result=imscl(image, min, max)    ARGUMENTS   INPUT : image - Image to be scaled.            min, max - New min and max values for image.    OUTPUT : NONE     KEYWORDS   INPUT : NONE    OUTPUT : NONE     RETURN : Scaled image.      ORIGINAL AUTHOR : J. Spitale ; 8/95   UPDATE HISTORY :   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/imscl.html#imscl", "imscl", 'routine in <a href="util/imscl.html">imscl.pro</a>', "imscl.pro", "", "imscl", "", "imageminmax", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/in_image.html", "in_image.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "in_image.pro", "", "", " NAME:        in_image    PURPOSE: 	Determines which input points lie within an image described by the 	given camera descriptor.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        sub = in_image(cd, p)    ARGUMENTS:   INPUT: 	cd:	Camera descriptor.  	p:	Array (2,nv) of image points.    OUTPUT:  NONE    KEYOWRDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Subscripts of points that lie in the image.  -1 if there are none.     MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/in_image.html#in_image", "in_image", 'routine in <a href="nv/obj/tools/in_image.html">in_image.pro</a>', "in_image.pro", "", "in_image", "", "xminxmaxyminymaxslopcornerscd_image_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/composite/inertial_to_disk.html", "inertial_to_disk.pro", '.pro file in <a href="nv/obj/tools/composite/dir-overview.html">nv/obj/tools/composite/ directory</a>', "inertial_to_disk.pro", "", "", " NAME:        inertial_to_disk    PURPOSE:        Transforms vectors in inertial coordinates to disk coordinates.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = inertial_to_image(dkx, v)    ARGUMENTS:   INPUT: 	dkx:	Array of nt descriptors, subclass of DISK.  	v:	Array (nv x 3 x nt) of inertial vectors.    OUTPUT:        NONE   KEYWORDS:    INPUT: NONE     OUTPUT: NONE    RETURN:        Array (nv x 3 x nt) of disk points.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale, 2/2004   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/composite/inertial_to_disk.html#inertial_to_disk", "inertial_to_disk", 'routine in <a href="nv/obj/tools/composite/inertial_to_disk.html">inertial_to_disk.pro</a>', "inertial_to_disk.pro", "", "inertial_to_disk", "", "dkxv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/composite/inertial_to_disk_pos.html", "inertial_to_disk_pos.pro", '.pro file in <a href="nv/obj/tools/composite/dir-overview.html">nv/obj/tools/composite/ directory</a>', "inertial_to_disk_pos.pro", "", "", " NAME:        inertial_to_disk_pos    PURPOSE:        Transforms position vectors in inertial coordinates to disk 	coordinates.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = inertial_to_disk_pos(dkx, v)    ARGUMENTS:   INPUT: 	dkx:	Array of nt descritors, subclass of DISK.  	v:	Array (nv x 3 x nt) of inertial vectors    OUTPUT:        NONE   KEYWORDS:    INPUT: NONE     OUTPUT: NONE    RETURN:        Array (nv x 3 x nt) of disk points.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale, 3/2004   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/composite/inertial_to_disk_pos.html#inertial_to_disk_pos", "inertial_to_disk_pos", 'routine in <a href="nv/obj/tools/composite/inertial_to_disk_pos.html">inertial_to_disk_pos.pro</a>', "inertial_to_disk_pos.pro", "", "inertial_to_disk_pos", "", "dkxv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/composite/inertial_to_globe.html", "inertial_to_globe.pro", '.pro file in <a href="nv/obj/tools/composite/dir-overview.html">nv/obj/tools/composite/ directory</a>', "inertial_to_globe.pro", "", "", " NAME:        inertial_to_globe    PURPOSE:        Transforms vectors in inertial coordinates to globe coordinates.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = inertial_to_image(gbx, v)    ARGUMENTS:   INPUT: 	gbx:	Array of nt descriptors, subclass of globe.  	v:	Array (nv x 3 x nt) of inertial vectors.    OUTPUT:        NONE   KEYWORDS:    INPUT: NONE     OUTPUT: NONE    RETURN:        Array (nv x 3 x nt) of globe points.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale, 9/2012   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/composite/inertial_to_globe.html#inertial_to_globe", "inertial_to_globe", 'routine in <a href="nv/obj/tools/composite/inertial_to_globe.html">inertial_to_globe.pro</a>', "inertial_to_globe.pro", "", "inertial_to_globe", "", "gbxv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/composite/inertial_to_globe_pos.html", "inertial_to_globe_pos.pro", '.pro file in <a href="nv/obj/tools/composite/dir-overview.html">nv/obj/tools/composite/ directory</a>', "inertial_to_globe_pos.pro", "", "", " NAME:        inertial_to_globe_pos    PURPOSE:        Transforms position vectors in inertial coordinates to globe 	coordinates.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = inertial_to_globe_pos(gbx, v)    ARGUMENTS:   INPUT: 	gbx:	Array of nt descritors, subclass of globe.  	v:	Array (nv x 3 x nt) of inertial vectors    OUTPUT:        NONE   KEYWORDS:    INPUT: NONE     OUTPUT: NONE    RETURN:        Array (nv x 3 x nt) of globe points.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale, 9/2012   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/composite/inertial_to_globe_pos.html#inertial_to_globe_pos", "inertial_to_globe_pos", 'routine in <a href="nv/obj/tools/composite/inertial_to_globe_pos.html">inertial_to_globe_pos.pro</a>', "inertial_to_globe_pos.pro", "", "inertial_to_globe_pos", "", "gbxv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/composite/inertial_to_image.html", "inertial_to_image.pro", '.pro file in <a href="nv/obj/tools/composite/dir-overview.html">nv/obj/tools/composite/ directory</a>', "inertial_to_image.pro", "", "", " NAME:        inertial_to_image    PURPOSE:        Transforms vectors in inertial coordinates to image coordinates    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = inertial_to_image(cd, v)    ARGUMENTS:   INPUT: 	cd:	Array of nt camera descriptors.  	v:	Array (nv x 3 x nt) of inertial vectors    OUTPUT:        NONE   RETURN:        Array (2 x nv x nt) of image points.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/composite/inertial_to_image.html#inertial_to_image", "inertial_to_image", 'routine in <a href="nv/obj/tools/composite/inertial_to_image.html">inertial_to_image.pro</a>', "inertial_to_image.pro", "", "inertial_to_image", "", "cdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/composite/inertial_to_image_pos.html", "inertial_to_image_pos.pro", '.pro file in <a href="nv/obj/tools/composite/dir-overview.html">nv/obj/tools/composite/ directory</a>', "inertial_to_image_pos.pro", "", "", " NAME:        inertial_to_image_pos    PURPOSE:        Transforms vectors in inertial coordinates to image coordinates    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = inertial_to_image_pos(cd, v)    ARGUMENTS:   INPUT: 	cd:	Array of nt camera descriptors.  	v:	Array (nv x 3 x nt) of inertial vectors    OUTPUT:        NONE   RETURN:        Array (2 x nv x nt) of image points.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/composite/inertial_to_image_pos.html#inertial_to_image_pos", "inertial_to_image_pos", 'routine in <a href="nv/obj/tools/composite/inertial_to_image_pos.html">inertial_to_image_pos.pro</a>', "inertial_to_image_pos.pro", "", "inertial_to_image_pos", "", "cdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/grim/interface/ingrid.html", "ingrid.pro", '.pro file in <a href="nv/grim/interface/dir-overview.html">nv/grim/interface/ directory</a>', "ingrid.pro", "", "", " NAME: 	INGRID    PURPOSE: 	INterface to GRIm Data -- command-line access to GRIM data. 	The returned descriptors allow direct access to the memory images of 	GRIM's descriptor set.  Therefore changes made from the command line 	affect the descriptors that GRIM is using.  GRIM monitors those 	descriptors and updates itself whenever a change occurs.    CATEGORY: 	NV/GR    CALLING SEQUENCE: 	ingrid, arg, <xd>=<xd>    ARGUMENTS:   INPUT: 	arg:	GRIM window number or GRIM data struture.  If not given, the 		most recently accessed grim instance is used.    OUTPUT: NONE    KEYWORDS:   INPUT: 	plane:	Grim plane structure(s) instead of giving pn.  Note all planes 		must belong to the same grim instance.  	pn:	Plane numer(s) to access.  If not given, then current plane 		is used.  	all:	If set, all planes are used.    OUTPUT: 	dd:	GRIM's data descriptor.  	cd:	GRIM's camera descriptor.  	od:	GRIM's observer descriptor.  	sund:	GRIM's sun descriptor.  	pd:	GRIM's planet descriptors.  	rd:	GRIM's ring descriptors.  	sd:	GRIM's star descriptors.  	std:	GRIM's station descriptors.  	ard:	GRIM's array descriptors.  	gd:	Generic descriptor containing all of the above descriptors.  	center_ptd: 		POINT object giving the planet centers.  	limb_ptd: 		POINT object giving the limb points.  	ring_ptd: 		POINT object giving the ring points.  	star_ptd: 		POINT object giving the star points.  	term_ptd: 		POINT object giving the terminator points.  	station_ptd: 		POINT object giving the station points.  	array_ptd: 		POINT object giving the array points.  	plgrid_ptd: 		POINT object giving the planet grid points.  	shadow_ptd: 		POINT object giving the shadow points.  	object_ptd: 		POINT object giving all overlay points.  	tie_ptd: 		POINT object giving the tie points.  	curve_ptd: 		POINT object giving the curve points.  	active_*_ptd: 		Returns same as above ptd outputs, except ony active arrays 		are returned.    EXAMPLE: 	(1) Open a GRIM window, load an image, and compute limb points.  	(2) At the command line, type:  		IDL> ingrid, cd=cd 		IDL> pg_repoint, [50,50], 0d, cd=cd  	GRIM should detect the change to the camera descriptor and update 	itself by recomputing the limb points and refreshing the display.    KNOWN ISSUES: 	This procedure has unresolved issues, is unreliable, behaves 	irrationally, is overly complicated, and has periodic breakdowns for 	no externally apparent reason.    STATUS: 	Has unresolved issues that need to be confronted and addressed.    SEE ALSO: 	grim, gr_draw    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/grim/interface/ingrid.html#ingrid", "ingrid", 'routine in <a href="nv/grim/interface/ingrid.html">ingrid.pro</a>', "ingrid.pro", "", "ingrid", "", "planegdddcdpdrdsdstdardsundodlimb_ptdring_ptdstar_ptdstation_ptdarray_ptdterm_ptdplgrid_ptdcenter_ptdobject_ptdtie_ptdcurve_ptdshadow_ptdreflection_ptdpnallgrnumactive_pdactive_rdactive_sdactive_stdactive_ardactive_xdactive_limb_ptdactive_ring_ptdactive_star_ptdactive_term_ptdactive_plgrid_ptdactive_center_ptdactive_shadow_ptdactive_reflection_ptdactive_station_ptdactive_array_ptdarg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/insert_array.html", "insert_array.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "insert_array.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/insert_array.html#insert_array", "insert_array", 'routine in <a href="util/insert_array.html">insert_array.pro</a>', "insert_array.pro", "", "insert_array", "", "diminsertoffset", "          -1", "");
  
  

libdata[libdataItem++] = new Array("demo/install_guide.html", "install_guide.pro", '.pro file in <a href="demo/dir-overview.html">demo/ directory</a>', "install_guide.pro", "", "", "	User Installation Guide  	This guide will cover the installation of OMINAS and common issues with 	configuration, as well as present some common errors and possible 	solutions. Please see the section entitled Troubleshooting for more 	information regarding installation issues with OMINAS.  	Requirements  	Currently OMINAS requires IDL 8.2.3 or above, and a bash shell, on Linux or 	Mac OS.  	To process images from a particular mission, that mission's kernels will 	need to be available. The OMINAS installer can automatically download sets of 	kernels for several missions (Cassini, Galileo, Voyager, Dawn).  	OMINAS makes use of the NAIF Icy Toolkit to process SPICE kernels. The Icy 	toolkit may optionally be obtained manually from 	NAIF. However, the 	installer utility provided with OMINAS can download and compile Icy 	automatically. Installation of Icy is somewhat platform-dependent, so 	troubleshooting information can be found in Troubleshooting.  	Procedure  	1. Please ensure that OMINAS has been properly downloaded from the 	Github repository by entering 	the following command at the terminal: <span class= code-output > git clone https://github.com/ppenteado/ominas</span> 	A local copy of the OMINAS source will be cloned automatically.  	2. Configuration of OMINAS should be performed using the configuration 	script, configure.sh, which is located in the top-level ominas directory. 	This script can be run from the command line with: <span class= code-output > source configure.sh</span> 	3. A prompt will appear asking which packages should be installed. The 	user should type the numbers of the desired packages separated by spaces. 	We recomend, at a minimum, setting up packages 1, 2 and 3 (OMINAS Core, Demo and Icy). 	To automatically download and setup all the packages, use the all option.  	4. When setting up an individual kernel or data package (selections 4-13), 	one can either provide a path for an existing directory containing the required files, 	or tell the installer to download them.  	5. Test the install of OMINAS has been completed correctly by running the 	the following example scripts: <span class= code-output > ominas saturn_example.pro</span> <span class= code-output > ominas jupiter_example.pro</span> 	6. A successful Icy installation can be tested with the following IDL 	command from within an OMINAS IDL session: <span class= code-output > help, 'icy', /dlm</span> 	Some text on the installed version of Icy should be displayed. Additionally, 	use the following command: <span class= code-output > print, cspice_tkvrsn('TOOLKIT')</span> 	The version of Icy should be printed. If both of these functions return 	successfully, then Icy has been installed correctly.   Example installation walkthrough   From a fresh account (that never had OMINAS, Icy or any IDL libraries setup  before), for the 3 main packages (Core, Demo and Icy): <span class= code-output > ;[ominas_test_8@cmp ~]$ git clone https://github.com/ppenteado/ominas.git</span> <span class= code-output > ;Cloning into 'ominas'...</span> <span class= code-output > ;Username for 'https://github.com': ppenteado</span> <span class= code-output > ;Password for 'https://ppenteado@github.com':</span> <span class= code-output > ;remote: Counting objects: 13377, done.</span> <span class= code-output > ;remote: Compressing objects: 100% (85/85), done.</span> <span class= code-output > ;remote: Total 13377 (delta 51), reused 71 (delta 34), pack-reused 13258</span> <span class= code-output > ;Receiving objects: 100% (13377/13377), 200.48 MiB | 8.10 MiB/s, done.</span> <span class= code-output > ;Resolving deltas: 100% (7628/7628), done.</span> <span class= code-output > ;Checking connectivity... done.</span> <span class= code-output > ;Checking out files: 100% (3479/3479), done.</span>  At this point, a copy of OMINAS will be in a newly-created directory called  ominas, under the current directory. Note that if a non-empty ominas directory  was already present, git would notice it and refuse to download OMINAS into that  directory.    Now, getting into the ominas directory and running the installer: <span class= code-output >;[ominas_test_8@cmp ~]$ cd ominas/</span> <span class= code-output >;[ominas_test_8@cmp ominas]$ source configure.sh</span> <span class= code-output >;Detecting .bash_profile...</span> <span class= code-output >;.bash_profile detected!</span> <span class= code-output >;Detecting .bashrc...</span> <span class= code-output >;.bashrc detected!</span> <span class= code-output >;Using IDL at /usr/local/bin/idl</span> <span class= code-output >;IDL Version 8.5.1 (linux x86_64 m64). (c) 2015, Exelis Visual Information Solutions, Inc., a subsidiary of Harris Corporation.</span> <span class= code-output >;Installation number: XXXXXX.</span> <span class= code-output >;Licensed for use by: XXXXXX</span> <span class= code-output >;</span> <span class= code-output >;Creating ~/.ominas directory</span> <span class= code-output >;Creating ~/ominas_data directory</span> <span class= code-output >;The setup will guide you through the installation of OMINAS</span> <span class= code-output >;OMINAS files located in /home/ominas_test_8/ominas</span> <span class= code-output >;</span> <span class= code-output >;IDL Version 8.5.1 (linux x86_64 m64). (c) 2015, Exelis Visual Information Solutions, Inc., a subsidiary of Harris Corporation.</span> <span class= code-output >;Installation number: XXXXX.</span> <span class= code-output >;Licensed for use by: XXXXX</span> <span class= code-output >;</span> <span class= code-output >;% Compiled module: OMINAS_ICY_TEST.</span> <span class= code-output >;Icy: Icy not found</span> <span class= code-output >;Current OMINAS configuration settings</span> <span class= code-output >;Required:</span> <span class= code-output >;1) OMINAS Core  . . . . . . . . . . . . .  NOT CONFIGURED</span> <span class= code-output >;Contains the OMINAS code. If you select only one</span> <span class= code-output >;of the other packages, this will be included.</span> <span class= code-output >;Optional packages:</span> <span class= code-output >;2) Demo package . . . . . . . . . . . . .  NOT CONFIGURED</span> <span class= code-output >;Contains the demo scripts and the data required</span> <span class= code-output >;to run then.</span> <span class= code-output >;These files are always present (in ominas/demo),</span> <span class= code-output >;this option is to set up the environment so that</span> <span class= code-output >;the demos can be run.</span> <span class= code-output >;3) SPICE Icy  . . . . . . . . . . . . . .  NOT CONFIGURED</span> <span class= code-output >;Library maintained by JPL's NAIF (Navigation and Ancillary</span> <span class= code-output >;Information Facility, https://naif.jpl.nasa.gov/naif/toolkit.html,</span> <span class= code-output >;required to use spacecraft / planetary kernel files.</span> <span class= code-output >;</span> <span class= code-output >;Mission Packages:</span> <span class= code-output >;Kernels used for each mission's position and</span> <span class= code-output >;pointing data. If you do not already have them,</span> <span class= code-output >;an option to download them from PDS will be provided.</span> <span class= code-output >;If you already have them, you will need to provide</span> <span class= code-output >;the path to your kernel files.</span> <span class= code-output >;Note: the NAIF Generic Kernels (one of the optional</span> <span class= code-output >;data packages) are not required for the missions, they</span> <span class= code-output >;already contain a copy the subset of the generic kernel</span> <span class= code-output >;files they need.</span> <span class= code-output >;4) Cassini . . . . . . . . . . . . . . . . NOT CONFIGURED</span> <span class= code-output >;Subsetted, about 16 GB as of Dec/2016</span> <span class= code-output >;5) Galileo (GLL) . . . . . . . . . . . . . NOT CONFIGURED</span> <span class= code-output >;About 833 MB as of Dec/2016</span> <span class= code-output >;6) Voyager . . . . . . . . . . . . . . . . NOT CONFIGURED</span> <span class= code-output >;About 163 MB as of Dec/2016</span> <span class= code-output >;7) Dawn  . . . . . . . . . . . . . . . . . NOT CONFIGURED</span> <span class= code-output >;Subsetted, about 8 GB as of Jan/2017</span> <span class= code-output >;Data:</span> <span class= code-output >;8) NAIF Generic Kernels . . . . . . . . .  NOT CONFIGURED</span> <span class= code-output >;About 22 GB as of Dec/2016</span> <span class= code-output >;9) SEDR image data . . . . . . . . . . . . NOT CONFIGURED</span> <span class= code-output >;10) TYCHO2 star catalog . . . . . . . . . . NOT CONFIGURED</span> <span class= code-output >;About 161 MB download, 665 MB unpacked</span> <span class= code-output >;11) SAO star catalog . . . . . . . . . . . NOT CONFIGURED</span> <span class= code-output >;About 19 MB download, 70 MB unpacked</span> <span class= code-output >;12) GSC star catalog . . . . . . . . . . . NOT CONFIGURED</span> <span class= code-output >;13) UCAC4 star catalog . . . . . . . . . . NOT CONFIGURED</span> <span class= code-output >;About 8.5 GB download</span> <span class= code-output >;For more information, see</span> <span class= code-output >;https://ppenteado.github.io/ominas_doc/demo/install_guide.html</span> <span class= code-output >;Modify Current OMINAS configuration (Exit/Auto/Uninstall 1 2 ...)?  1 2 3</span> <span class= code-output >;Settiing OMINAS Core...</span> <span class= code-output >;OMINAS requires the NAIF Icy toolkit to process SPICE kernels.</span> <span class= code-output >;Would you like to install Icy from the internet now? [y]</span> <span class= code-output >;http://naif.jpl.nasa.gov/pub/naif/toolkit//IDL/PC_Linux_GCC_IDL8.x_64bit/packages/icy.tar.Z ~/ominas_data/icy.tar.Z</span> <span class= code-output >;http://naif.jpl.nasa.gov/pub/naif/toolkit//IDL/PC_Linux_GCC_IDL8.x_64bit/packages/icy.tar.Z --localdir=/home/ominas_test_8/ominas_data/</span> <span class= code-output >;</span> <span class= code-output >;IDL Version 8.5.1 (linux x86_64 m64). (c) 2015, Exelis Visual Information Solutions, Inc., a subsidiary of Harris Corporation.</span> <span class= code-output >;Installation number: XXXXXX.</span> <span class= code-output >;Licensed for use by: XXXXXX</span> <span class= code-output >;</span> <span class= code-output >;% Compiled module: PP_WGETCL.</span> <span class= code-output >;% Compiled module: PP_COMMAND_LINE_ARGS_PARSE.</span> <span class= code-output >;% Loaded DLM: URL.</span> <span class= code-output >;% Compiled module: PP_WGET__DEFINE.</span> <span class= code-output >;util/downloader/ca-bundle.crt</span> <span class= code-output >;% Compiled module: PARSE_URL.</span> <span class= code-output >;downloading http://naif.jpl.nasa.gov/pub/naif/toolkit//IDL/PC_Linux_GCC_IDL8.x_64bit/packages/icy.tar.Z</span> <span class= code-output >;% Compiled module: PP_READABLESIZE.</span> <span class= code-output >;Content Length:  276.00000 B</span> <span class= code-output >;% Compiled module: PP_PARSE_DATE.</span> <span class= code-output >;% Compiled module: JULDAY.</span> <span class= code-output >;Content Length:  43.669736 MB</span> <span class= code-output >;% Compiled module: CALDAT.</span> <span class= code-output >;Extracting Icy source files...</span> <span class= code-output >;Compiling Icy...</span> <span class= code-output >;Icy compiled. Log is at ~/.ominas/icy_make.log</span> <span class= code-output >;writing /home/ominas_test_8/.ominas/ominas_setup.sh</span> <span class= code-output >;/home/ominas_test_8/.ominas/ominas_setup.sh -&gt; /home/ominas_test_8/.ominas/ominas_setup_old.sh</span> <span class= code-output >;</span> <span class= code-output >;</span> <span class= code-output >;</span> <span class= code-output >;</span> <span class= code-output >;</span> <span class= code-output >;</span> <span class= code-output >;done with writing /home/ominas_test_8/.ominas/ominas_setup.sh</span> <span class= code-output >;IDL Version 8.5.1 (linux x86_64 m64). (c) 2015, Exelis Visual Information Solutions, Inc., a subsidiary of Harris Corporation.</span> <span class= code-output >;Installation number: XXXXXX.</span> <span class= code-output >;Licensed for use by: XXXXXX</span> <span class= code-output >;</span> <span class= code-output >;% Compiled module: OMINAS_PATHS_ADD.</span> <span class= code-output >;Checking to see if IDL paths need to be changed...</span> <span class= code-output >;% Compiled module: IDLASTRO_DOWNLOAD.</span> <span class= code-output >;% Compiled module: ROUTINE_EXISTS.</span> <span class= code-output >;There are missing IDLAstro routines.</span> <span class= code-output >;Auto installing</span> <span class= code-output >;git clone https://github.com/wlandsman/IDLAstro.git /home/ominas_test_8/ominas_data/idlastro</span> <span class= code-output >;Cloning into '/home/ominas_test_8/ominas_data/idlastro'...</span> <span class= code-output >;remote: Counting objects: 1400, done.</span> <span class= code-output >;remote: Compressing objects: 100% (7/7), done.</span> <span class= code-output >;remote: Total 1400 (delta 1), reused 3 (delta 1), pack-reused 1392</span> <span class= code-output >;Receiving objects: 100% (1400/1400), 11.63 MiB | 4.85 MiB/s, done.</span> <span class= code-output >;Resolving deltas: 100% (556/556), done.</span> <span class= code-output >;Checking connectivity... done.</span> <span class= code-output >;IDLAstro path set in preferences:  &lt;IDL_DEFAULT&gt;:+/home/ominas_test_8/ominas_data/idlastro/pro</span> <span class= code-output >;OMINAS paths set in IDL preferences</span> <span class= code-output >;Icy path set in IDL preferences</span> <span class= code-output >;OMINAS aliase set in /home/ominas_test_8/.bashrc.</span> <span class= code-output >;OMINAS aliase set in /home/ominas_test_8/.bash_profile.</span> <span class= code-output >;IDL Version 8.5.1 (linux x86_64 m64). (c) 2015, Exelis Visual Information Solutions, Inc., a subsidiary of Harris Corporation.</span> <span class= code-output >;Installation number: 5502667.</span> <span class= code-output >;Licensed for use by: NASA - Jet Propulsion Laboratory</span> <span class= code-output >;</span> <span class= code-output >;% Compiled module: OMINAS_ICY_TEST.</span> <span class= code-output >;% Loaded DLM: ICY.</span> <span class= code-output >;Icy: /home/ominas_test_8/ominas_data/icy/lib/icy.so</span> <span class= code-output >;Current OMINAS configuration settings</span> <span class= code-output >;Required:</span> <span class= code-output >;1) OMINAS Core  . . . . . . . . . . . . .  CONFIGURED</span> <span class= code-output >;Contains the OMINAS code. If you select only one</span> <span class= code-output >;of the other packages, this will be included.</span> <span class= code-output >;Optional packages:</span> <span class= code-output >;2) Demo package . . . . . . . . . . . . .  CONFIGURED</span> <span class= code-output >;Contains the demo scripts and the data required</span> <span class= code-output >;to run then.</span> <span class= code-output >;These files are always present (in ominas/demo),</span> <span class= code-output >;this option is to set up the environment so that</span> <span class= code-output >;the demos can be run.</span> <span class= code-output >;3) SPICE Icy  . . . . . . . . . . . . . .  CONFIGURED</span> <span class= code-output >;Library maintained by JPL's NAIF (Navigation and Ancillary</span> <span class= code-output >;Information Facility, https://naif.jpl.nasa.gov/naif/toolkit.html,</span> <span class= code-output >;required to use spacecraft / planetary kernel files.</span> <span class= code-output >;</span> <span class= code-output >;Mission Packages:</span> <span class= code-output >;Kernels used for each mission's position and</span> <span class= code-output >;pointing data. If you do not already have them,</span> <span class= code-output >;an option to download them from PDS will be provided.</span> <span class= code-output >;If you already have them, you will need to provide</span> <span class= code-output >;the path to your kernel files.</span> <span class= code-output >;Note: the NAIF Generic Kernels (one of the optional</span> <span class= code-output >;data packages) are not required for the missions, they</span> <span class= code-output >;already contain a copy the subset of the generic kernel</span> <span class= code-output >;files they need.</span> <span class= code-output >;4) Cassini . . . . . . . . . . . . . . . . NOT CONFIGURED</span> <span class= code-output >;Subsetted, about 16 GB as of Dec/2016</span> <span class= code-output >;5) Galileo (GLL) . . . . . . . . . . . . . NOT CONFIGURED</span> <span class= code-output >;About 833 MB as of Dec/2016</span> <span class= code-output >;6) Voyager . . . . . . . . . . . . . . . . NOT CONFIGURED</span> <span class= code-output >;About 163 MB as of Dec/2016</span> <span class= code-output >;7) Dawn  . . . . . . . . . . . . . . . . . NOT CONFIGURED</span> <span class= code-output >;Subsetted, about 8 GB as of Jan/2017</span> <span class= code-output >;Data:</span> <span class= code-output >;8) NAIF Generic Kernels . . . . . . . . .  NOT CONFIGURED</span> <span class= code-output >;About 22 GB as of Dec/2016</span> <span class= code-output >;9) SEDR image data . . . . . . . . . . . . NOT CONFIGURED</span> <span class= code-output >;10) TYCHO2 star catalog . . . . . . . . . . NOT CONFIGURED</span> <span class= code-output >;About 161 MB download, 665 MB unpacked</span> <span class= code-output >;11) SAO star catalog . . . . . . . . . . . NOT CONFIGURED</span> <span class= code-output >;About 19 MB download, 70 MB unpacked</span> <span class= code-output >;12) GSC star catalog . . . . . . . . . . . NOT CONFIGURED</span> <span class= code-output >;13) UCAC4 star catalog . . . . . . . . . . NOT CONFIGURED</span> <span class= code-output >;About 8.5 GB download</span> <span class= code-output >;For more information, see</span> <span class= code-output >;https://ppenteado.github.io/ominas_doc/demo/install_guide.html</span> <span class= code-output >;Modify Current OMINAS configuration (Exit/Auto/Uninstall 1 2 ...)?  e</span> <span class= code-output >;Setup has completed. It is recommended to restart your terminal session before using OMINAS.</span> <span class= code-output >;You may want to try some of the tutorials at https://ppenteado.github.io/ominas_doc/demo/</span>   At this point, one can run a few tests of the enviroment: <span class= code-output > ;[ominas_test_8@cmp ominas]$ which ominas</span> <span class= code-output > ;alias ominas='/home/ominas_test_8/.ominas/ominas'</span> <span class= code-output > ;~/.ominas/ominas</span> <span class= code-output > ;[ominas_test_8@cmp ominas]$ which ominasde</span> <span class= code-output > ;alias ominasde='/home/ominas_test_8/.ominas/ominasde'</span> <span class= code-output > ;~/.ominas/ominasde</span>  Which shows both ominas and ominasde are defined. Use ominas to start and IDL  session in which to use OMINAS, and ominasde to start an IDL DE session in  which to use OMINAS.   Now, to check on the ominas_setup file, which sets the environment for the OMINAS  core and all currently set packages (in this example, only Core, Demo and Icy are set): <span class= code-output > ;[ominas_test_8@cmp ominas]$ cat ~/.ominas/ominas_setup.sh</span> <span class= code-output > ;#!/usr/bin/env bash</span> <span class= code-output > ;alias ominas=~/.ominas/ominas</span> <span class= code-output > ;alias ominasde=~/.ominas/ominasde</span> <span class= code-output > ;export OMINAS_DIR=/home/ominas_test_8/ominas</span> <span class= code-output > ;export DFLAG=true</span> <span class= code-output > ;source /home/ominas_test_8/ominas/config/ominas_env_def.sh</span> <span class= code-output > ;unset NV_Generic_kernels_DATA</span> <span class= code-output > ;unset NV_SEDR_DATA</span> <span class= code-output > ;unset NV_TYCHO2_DATA</span> <span class= code-output > ;unset NV_SAO_DATA</span> <span class= code-output > ;unset NV_GSC_DATA</span> <span class= code-output > ;unset NV_UCAC4_DATA</span>  Now, to check that the right environment is see from an OMINAS session: <span class= code-output > ;[ominas_test_8@cmp ominas]$ ominas -e 'spawn, env | grep NV '</span> <span class= code-output > ;IDL Version 8.5.1 (linux x86_64 m64). (c) 2015, Exelis Visual Information Solutions, Inc., a subsidiary of Harris Corporation.</span> <span class= code-output > ;Installation number: XXXXX.</span> <span class= code-output > ;Licensed for use by: XXXXX</span> <span class= code-output > ;</span> <span class= code-output > ;NV_TRANSLATORS=/home/ominas_test_8/ominas/config/tab/translators.tab:/home/ominas_test_8/ominas/demo/data/translators.tab</span> <span class= code-output > ;NV_CONFIG=/home/ominas_test_8/ominas/config</span> <span class= code-output > ;NV_IO=/home/ominas_test_8/ominas/config/tab/io.tab</span> <span class= code-output > ;NV_SPICE=/home/ominas_test_8/ominas/config/spice</span> <span class= code-output > ;NV_ORBIT_DATA=/home/ominas_test_8/ominas/config/orb/</span> <span class= code-output > ;NV_ARRAY_DATA=/home/ominas_test_8/ominas/config/arr/dat/</span> <span class= code-output > ;NV_TRANSFORMS=/home/ominas_test_8/ominas/config/tab/transforms.tab:/home/ominas_test_8/ominas/demo/data/transforms.tab</span> <span class= code-output > ;NV_STATION_DATA=/home/ominas_test_8/ominas/config/stn/</span> <span class= code-output > ;NV_RING_DATA=/home/ominas_test_8/ominas/config/rings/</span> <span class= code-output > ;NV_FTP_DETECT=/home/ominas_test_8/ominas/config/tab/filetype_detectors.tab</span> <span class= code-output > ;NV_SPICE_KER=::/home/ominas_test_8/ominas/demo/data</span> <span class= code-output > ;NV_INS_DETECT=/home/ominas_test_8/ominas/config/tab/instrument_detectors.tab:/home/ominas_test_8/ominas/demo/data/instrument_detectors.tab</span>  Now, to check that the OMINAS paths show up inside an OMINAS IDL session: <span class= code-output > ;[ominas_test_8@cmp ominas]$ ominas -e 'print,pref_get( IDL_PATH )'</span> <span class= code-output > ;IDL Version 8.5.1 (linux x86_64 m64). (c) 2015, Exelis Visual Information Solutions, Inc., a subsidiary of Harris Corporation.</span> <span class= code-output > ;Installation number: XXXXX.</span> <span class= code-output > ;Licensed for use by: XXXXX</span> <span class= code-output > ;</span> <span class= code-output > ;&lt;IDL_DEFAULT&gt;:+/home/ominas_test_8/ominas_data/idlastro/pro:+/home/ominas_test_8/ominas_data/icy/lib:+/home/ominas_test_8/ominas:+/home/ominas_test_8/ominas/util/xidl</span> <span class= code-output > ;[ominas_test_8@cmp ominas]$ ominas -e 'print,pref_get( IDL_DLM_PATH )'</span> <span class= code-output > ;IDL Version 8.5.1 (linux x86_64 m64). (c) 2015, Exelis Visual Information Solutions, Inc., a subsidiary of Harris Corporation.</span> <span class= code-output > ;Installation number: XXXXX.</span> <span class= code-output > ;Licensed for use by: XXXXX</span> <span class= code-output > ;</span> <span class= code-output > ;&lt;IDL_DEFAULT&gt;:+/home/ominas_test_8/ominas_data/icy/lib</span>  With this environment, one can run some demo scripts, such as: <span class= code-output > ;ominas saturn_example</span> <span class= code-output > ;ominas jupiter_example</span>     Testing the environment with ominas_env_info         OMINAS includes a utilty script that prints out the most commonly relevant about your OMINAS environment, which can be useful for debugging        (both for yourself, and when you send us questions). It can be run by calling ominas_env_info, from an ominas/ominasde session. If an argument        is provided, it will be the filename where the output will be saved into (as opposed to printing it to the console). One example: <span class= code-output > ;[user@cmp ~]$ ominas</span> <span class= code-output > ;IDL Version 8.5.1 (linux x86_64 m64). (c) 2015, Exelis Visual Information Solutions, Inc., a subsidiary of Harris Corporation.</span> <span class= code-output > ;Installation number: XXXXXX.</span> <span class= code-output > ;Licensed for use by: XXXXXX</span> <span class= code-output > ;</span> <span class= code-output > ;IDL&gt; ominas_env_info,'~/ominas_env_info.txt'</span>        Which produces: <span class= code-output > ;OMINAS variables:</span> <span class= code-output > ;OMINAS_RC=/home/user/.ominas</span> <span class= code-output > ;OMINAS_DEMO=/home/user/ominas/demo</span> <span class= code-output > ;OMINAS_DIR=/home/user/ominas</span> <span class= code-output > ;OMINAS_DATA=/home/user/ominas_data</span> <span class= code-output > ;--------------------------------------------------------------------------------</span> <span class= code-output > ;NV variables:</span> <span class= code-output > ;NV_TRANSLATORS=/home/user/ominas/config/tab/translators.tab:/home/user/ominas/demo/data/translators.tab</span> <span class= code-output > ;NV_CONFIG=/home/user/ominas/config</span> <span class= code-output > ;NV_IO=/home/user/ominas/config/tab/io.tab</span> <span class= code-output > ;NV_SPICE=/home/user/ominas/config/spice</span> <span class= code-output > ;NV_ORBIT_DATA=/home/user/ominas/config/orb/</span> <span class= code-output > ;NV_ARRAY_DATA=/home/user/ominas/config/arr/dat/</span> <span class= code-output > ;NV_TRANSFORMS=/home/user/ominas/config/tab/transforms.tab:/home/user/ominas/demo/data/transforms.tab</span> <span class= code-output > ;NV_STATION_DATA=/home/user/ominas/config/stn/</span> <span class= code-output > ;NV_RING_DATA=/home/user/ominas/config/rings/</span> <span class= code-output > ;NV_FTP_DETECT=/home/user/ominas/config/tab/filetype_detectors.tab</span> <span class= code-output > ;NV_SPICE_KER=::/home/user/ominas/demo/data</span> <span class= code-output > ;NV_INS_DETECT=/home/user/ominas/config/tab/instrument_detectors.tab:/home/user/ominas/demo/data/instrument_detectors.tab</span> <span class= code-output > ;--------------------------------------------------------------------------------</span> <span class= code-output > ;ominas_setup.sh:</span> <span class= code-output > ;#!/usr/bin/env bash</span> <span class= code-output > ;alias ominas=~/.ominas/ominas</span> <span class= code-output > ;alias ominasde=~/.ominas/ominasde</span> <span class= code-output > ;export OMINAS_DIR=/home/user/ominas</span> <span class= code-output > ;export OMINAS_DATA=/home/user/ominas_data</span> <span class= code-output > ;export OMINAS_RC=/home/user/.ominas</span> <span class= code-output > ;export DFLAG=true</span> <span class= code-output > ;source /home/user/ominas/config/ominas_env_def.sh</span> <span class= code-output > ;unset NV_Generic_kernels_DATA</span> <span class= code-output > ;unset NV_SEDR_DATA</span> <span class= code-output > ;unset NV_TYCHO2_DATA</span> <span class= code-output > ;unset NV_SAO_DATA</span> <span class= code-output > ;unset NV_GSC_DATA</span> <span class= code-output > ;unset NV_UCAC4_DATA</span> <span class= code-output > ;--------------------------------------------------------------------------------</span> <span class= code-output > ;</span> <span class= code-output > ;IDL:</span> <span class= code-output > ;** Structure !VERSION, 8 tags, length=104, data length=100:</span> <span class= code-output > ;   ARCH            STRING    'x86_64'</span> <span class= code-output > ;   OS              STRING    'linux'</span> <span class= code-output > ;   OS_FAMILY       STRING    'unix'</span> <span class= code-output > ;   OS_NAME         STRING    'linux'</span> <span class= code-output > ;   RELEASE         STRING    '8.5.1'</span> <span class= code-output > ;   BUILD_DATE      STRING    'Nov 14 2015'</span> <span class= code-output > ;   MEMORY_BITS     INT             64</span> <span class= code-output > ;   FILE_OFFSET_BITS</span> <span class= code-output > ;                   INT             64</span> <span class= code-output > ;--------------------------------------------------------------------------------</span> <span class= code-output > ;environment IDL_PATH</span> <span class= code-output > ;</span> <span class= code-output > ;--------------------------------------------------------------------------------</span> <span class= code-output > ;environment IDL_DLM_PATH</span> <span class= code-output > ;</span> <span class= code-output > ;--------------------------------------------------------------------------------</span> <span class= code-output > ;preferences IDL_PATH</span> <span class= code-output > ;&lt;IDL_DEFAULT&gt;:+/home/user/ominas_data/idlastro/pro:+/home/user/ominas:+/home/user/ominas/util/xidl:+/home/user/ominas_data/icy/lib</span> <span class= code-output > ;--------------------------------------------------------------------------------</span> <span class= code-output > ;preferences IDL_DLM_PATH</span> <span class= code-output > ;&lt;IDL_DEFAULT&gt;:+/home/user/ominas_data/icy/lib</span> <span class= code-output > ;--------------------------------------------------------------------------------</span> <span class= code-output > ;</span> <span class= code-output > ;Icy:</span> <span class= code-output > ;--------------------------------------------------------------------------------</span> <span class= code-output > ;** ICY - IDL/CSPICE interface from JPL/NAIF (not loaded)</span> <span class= code-output > ;    Version: 1.8.0, Build Date: 05-JAN-2017, Source: ed.wright@jpl.nasa.gov</span> <span class= code-output > ;    Path: /home/user/ominas_data/icy/lib/icy.so</span> <span class= code-output > ;--------------------------------------------------------------------------------</span> <span class= code-output > ;CSPICE_N0066</span> <span class= code-output > ;--------------------------------------------------------------------------------</span> <span class= code-output > ;0 loaded kernels:</span> <span class= code-output > ;--------------------------------------------------------------------------------</span> <span class= code-output > ;</span> <span class= code-output > ;OMINAS repository:</span> <span class= code-output > ;On branch master</span> <span class= code-output > ;Your branch is up-to-date with 'origin/master'.</span> <span class= code-output > ;Last commit:</span> <span class= code-output > ;b373f70 Paulo Penteado Wed Jun 14 14:03:42 2017 -0700</span>   	Troubleshooting  	This section outlines several common sources of error which are due to 	OMINAS not being configured correctly.  	One of the most common configuration problems manifests as this error: <span class= code-output > % CSPICE_STR2ET: SPICE(NOLEAPSECONDS): [str2et_c-&gt;STR2ET-&gt;TTRANS] The variable that points to the leapseconds (DELTET/DELTA_AT)</span> <span class= code-output >                 could not be located in the kernel pool.  It is likely that the leapseconds kernel has not been loaded via</span> <span class= code-output >                 the routine FURNSH.</span> 	This error comes from the Icy toolkit. It specifically refers to the Leap 	Second Kernel file, however, as the lsk is usually the first kernel which 	is loaded, this error generally means that no kernels are being loaded.  	You can check which kernels have been loaded by entering the following 	IDL commands: <span class= code-output > cspice_ktotal, 'ALL', count</span> <span class= code-output > for i=0,count-1 do begin & cspice_kdata,i,'ALL',file,type,source,handle,found & print,i,file & endfor</span> 	A list will be populated with the currently loaded SPICE kernels, and 	their load order. If no kernels are loaded, then it is likely that a bad 	path was supplied to the kernel pools. Ensure that the kernel pool was 	successfully entered into the environemnt by using the  env  command at 	the terminal prompt. The kernel pool variable names follow a convention 	like so: &lt;MIS&gt;_SPICE_&lt;*K&gt;, where &lt;MIS&gt; is the abbreviated mission name, 	and &lt;*K&gt; is the type of kernel. Therefore, for Cassini, the IDL command: <span class= code-output > spawn, env | grep CAS_SPICE </span> 	will list the path to directories containing each type of Cassini kernel. 	If the variables are not present, the easiest fix might be to run the OMINAS 	installer again  	 source configure.sh  	From the ominas directory. Then, if the Cassini package shows as installed, 	select that option at the menu (4), to uninstall it. You will be presented with 	the possibility of preserving files the OMINAS installer previously downloaded, 	or deleting them. After the uninstallation is complete, you will be returned to 	the installer menu, and Cassini should show as not configured. Then select the Cassini 	option to set it up again.  	In some cases, a demo script will run and no error will appear to occur, 	but no pointing will be overlayed on the image. This error generally occurs 	due to the PCK kernels not being loaded or the CK kernels not being loaded 	in the correct order.  	When the frame kernel (FK) is not being loaded correctly for an image, 	Icy will return the following error: <span class= code-output > % CSPICE_PXFORM: SPICE(EMPTYSTRING): [pxform_c] String  from  has length zero.</span> 	If Icy is not installed, and a script is run, something similar to the 	following error may occur: <span class= code-output > % Attempt to call undefined procedure: 'CSPICE_STR2ET'.</span> 	In general, the undefined procudure may have any cspice prefix. Icy is 	either not configured correctly, or not installed. In IDL, check that 	the Icy path has been added to the IDL path as follows: <span class= code-output > path = pref_get('IDL_PATH')</span> <span class= code-output > print, path</span> <span class= code-output > dlm_path = pref_get('IDL_DLM_PATH')</span> <span class= code-output > print, dlm_path</span> 	The path variable should appear as a colon-separated list with 	&lt;IDL_DEFAULT&gt; as the first entry. Check that both Icy and OMINAS 	directories are added to the IDL_PATH, and that Icy is added to the 	IDL_DLM_PATH. If either Icy or OMINAS are not present, the best way to fix 	it probably is to get back into the OMINAS directory and run the configure.sh 	script to uninstall/install the Core, Demo or Icy packages again.   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("demo/install_guide.html#install_guide", "install_guide", 'routine in <a href="demo/install_guide.html">install_guide.pro</a>', "install_guide.pro", "", "install_guide", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/internal_points.html", "internal_points.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "internal_points.pro", "", "", " NAME:        internal_points    PURPOSE:        Output subscripts of points inside the given bounds.    CATEGORY:        UTIL    CALLING SEQUENCE:        result = internal_points(points, x0, x1, y0, y1)    ARGUMENTS:   INPUT:        points:         An array of image point.             x0:         Lower x bound.             x1:         Upper x bound.             y0:         Lower y bound.             y1:         Upper y bound.    OUTPUT:        NONE   RETURN:        Subscripts of points in array that fall inside the rectangle        whose corners are (x0,y0) and (x1,y1).   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/internal_points.html#internal_points", "internal_points", 'routine in <a href="util/internal_points.html">internal_points.pro</a>', "internal_points.pro", "", "internal_points", "", "pointsx0x1y0y1", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/intersect_planes.html", "intersect_planes.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "intersect_planes.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/intersect_planes.html#intersect_planes", "intersect_planes", 'routine in <a href="util/intersect_planes.html">intersect_planes.pro</a>', "intersect_planes.pro", "", "intersect_planes", "", "vnv1n1v2n2", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/ipt/ipt_chisq.html", "ipt_chisq.pro", '.pro file in <a href="nv/obj/tools/ipt/dir-overview.html">nv/obj/tools/ipt/ directory</a>', "ipt_chisq.pro", "", "", " NAME: 	ipt_chisq    PURPOSE: 	Computes chi-squared value for given point fit parameters.    CATEGORY: 	UTIL/NV/LIB/TOOLS/IPT    CALLING SEQUENCE: 	result = ipt_chisq(dxy, dtheta, fix, pts_dx, pts_dy, pts)    ARGUMENTS:   INPUT: 	dxy:		Array (2) giving x- and y-offset solution.  	dtheta:		Scalar giving theta-offset solution.  	fix:		Array specifying which parameters to fix as 			[dx,dy,dtheta].         pts_dx:         Array (n_points) containing offset of actual                        point from predicted point in x.         pts_dy:         Array (n_points) containing offset of actual                        point from predicted point in y.         pts:            Array (2,n_points) of image coordinates corresponding                        to actual point.  	axis:		Array (2) giving image coordinates of rotation axis 			in the case of a 3-parameter fit.    OUTPUT: NONE    KEYWORDS:   INPUT: 	norm:		If set, the returned value is normalized by dividing 			it by the number of degrees of freedom.    OUTPUT: NONE    RETURN: 	The chi-squared value is returned.    STATUS: 	Completed.    MODIFICATION HISTORY:  	Written by:	Haemmerle, 12/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/ipt/ipt_chisq.html#ipt_chisq", "ipt_chisq", 'routine in <a href="nv/obj/tools/ipt/ipt_chisq.html">ipt_chisq.pro</a>', "ipt_chisq.pro", "", "ipt_chisq", "", "normdxydthetafixpts_dxpts_dyptsaxis", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/ipt/ipt_coeff.html", "ipt_coeff.pro", '.pro file in <a href="nv/obj/tools/ipt/dir-overview.html">nv/obj/tools/ipt/ directory</a>', "ipt_coeff.pro", "", "", " NAME: 	ipt_coeff    PURPOSE: 	Computes coefficients for the 2- or 3-parameter linear least-square fit.    CATEGORY: 	UTIL/NV/LIB/TOOLS/IPT    CALLING SEQUENCE: 	ipt_coeff, pts_x, pts_y, pts, axis, M=M, b=b    ARGUMENTS:   INPUT:  	pts_x:	        Value containing offset of actual 			point from predicted point in x.         pts_y:          Value containing offset of actual                        point from predicted point in y.  	pts:	        Array (2) of image coordinates corresponding 			to actual point.  	axis:		Array (2) giving image coordinates of rotation axis 			in the case of a 3-parameter fit.    OUTPUT: NONE    KEYWORDS:   INPUT: 	sigma:	Uncertainty in each point position.    OUTPUT: 	M:	3x3 matrix of coefficients for the linear fit.  	b:	3-element column vector rhs of the linear fit.    PROCEDURE: 	Since the fit has been linearized, it can be written as a matrix 	equation:  				Mx = b,  	where x is the 3-element column vector [dx, dy, dtheta] of the 	independent variables. 	This routine computes the matrix M and the 	vector b.  Once these are known, mbfit can be used to solve the 	linear system.  Furthermore, since the fit is linear, a simultaneous 	fit can be performed by simply adding together any number of 	coefficient matrices and vectors, which can also be done using 	mbfit.    RESTRICTIONS: 	The fit associated with these coefficients has been linearized 	and is only valid for small corrections.  For larger corrections, 	this procedure can be iterated.    STATUS: 	Complete.    MODIFICATION HISTORY:  	Written by:	Haemmerle, 5/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/ipt/ipt_coeff.html#ipt_coeff", "ipt_coeff", 'routine in <a href="nv/obj/tools/ipt/ipt_coeff.html">ipt_coeff.pro</a>', "ipt_coeff.pro", "", "ipt_coeff", "", "Mbsigmapts_xpts_yptsaxis", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/is_member.html", "is_member.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "is_member.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/is_member.html#is_member", "is_member", 'routine in <a href="util/is_member.html">is_member.pro</a>', "is_member.pro", "", "is_member", "", "xv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/is_planet.html", "is_planet.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "is_planet.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/is_planet.html#is_planet", "is_planet", 'routine in <a href="util/is_planet.html">is_planet.pro</a>', "is_planet.pro", "", "is_planet", "", "_names", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/jd2et.html", "jd2et.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "jd2et.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/jd2et.html#jd2et", "jd2et", 'routine in <a href="util/jd2et.html">jd2et.pro</a>', "jd2et.pro", "", "jd2et", "", "jd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/jd_to_yydoy.html", "jd_to_yydoy.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "jd_to_yydoy.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/jd_to_yydoy.html#jd_to_yydoy", "jd_to_yydoy", 'routine in <a href="util/jd_to_yydoy.html">jd_to_yydoy.pro</a>', "jd_to_yydoy.pro", "", "jd_to_yydoy", "", "jd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/jed_to_ret.html", "jed_to_ret.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "jed_to_ret.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/jed_to_ret.html#jed_to_ret", "jed_to_ret", 'routine in <a href="util/jed_to_ret.html">jed_to_ret.pro</a>', "jed_to_ret.pro", "", "jed_to_ret", "", "jed", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/jpeg_image.html", "jpeg_image.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "jpeg_image.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/jpeg_image.html#jpeg_image", "jpeg_image", 'routine in <a href="util/jpeg_image.html">jpeg_image.pro</a>', "jpeg_image.pro", "", "jpeg_image", "", "wnummonoorderfilename", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/jup_convert_longitude.html", "jup_convert_longitude.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "jup_convert_longitude.pro", "", "", " NAME: 	jup_convert_longitude    PURPOSE: 	Convert among Jupiter's I, II, and III longitude systems.    CATEGORY: 	UTIL    CALLING SEQUENCE: 	result = jup_convert_longitude(lon, jd, from=from, to=to)    ARGUMENTS:   INPUT: 	lon:	Longitude to be converted; radians.  	jd:	Julian date.    KEYWORDS:   INPUT: 	from:	String specifying the input longitude system 		-- 'I', 'II', or 'III'.  	to:	String specifying the output longitude system 		-- 'I', 'II', or 'III'.   RETURN: 	Converted longitude; radians.    PROCEDURE: 	Conversions are based on the physical ephemeris parameters 	given in table 7.44.1 of the explanatory supplement to the 	astronomical almanac.    MODIFICATION HISTORY:  	Written by:	Spitale, 9/17/2001   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/jup_convert_longitude.html#jup_convert_longitude", "jup_convert_longitude", 'routine in <a href="util/jup_convert_longitude.html">jup_convert_longitude.pro</a>', "jup_convert_longitude.pro", "", "jup_convert_longitude", "", "fromtolonjd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("demo/jupiter_example.html", "jupiter_example.pro", '.pro file in <a href="demo/dir-overview.html">demo/ directory</a>', "jupiter_example.pro", "", "", " JUPITER EXAMPLE     Edited by Mark Moretto     June 2016      This example file uses an image of Jupiter, its rings, and satellites to     demonstrate various capabilities of the OMINAS software.  This includes     fitting the limb and rings simultaneously, hiding the limb and/or rings wrt     other objects in the field of view, plotting radial and longitudinal     sectors on the ring and generating map projections.      This example file can be executed from the UNIX command line using: <span class= code-output >ominas jupiter_example.pro</span>     or from within an OMINAS IDL session using: <span class= code-output >@jupiter_example</span>     After the example stops, later code samples in this file may be executed by     pasting them onto the IDL command line.    Read and display image        This first section uses dat_read to read in the image and then displays    the image using tvim.     dat_read reads the image portion (im) and the label (label) and returns a    data descriptor (dd) containing the image and label and information obtained    through OMINAS' configuration tables.  If a file exists in the same directory    and with the same name as the image, except with the extension  .dh ,    then it is assumed to be a detached header and it is read as well.     The files w1352097259.1 and n1352037683.2 are Cassini wide- and narrow-    angle frames of Jupiter.  2000r.img and 2100r.img are Galileo SSI    images of Ganymede.     tvim is called to display the image (im) in a new window with the y    coordinate as top-down: <span class= code-output > file = getenv('OMINAS_DIR')+'/demo/data/N1350122987_2.IMG'     ; Cassini Image</span> <span class= code-output > dd = dat_read(file, im, label)</span>  <span class= code-output > tvim, im, zoom=0.75, /order, /new</span>   Obtain descriptors     This section obtains the camera descriptor (cd), planet descriptors    (pd), ring descriptors (rd), and the sun descriptor (sund) for    use with subsequent commands: <span class= code-output > cd = pg_get_cameras(dd)</span> <span class= code-output > pd = pg_get_planets(dd, od=cd)</span> <span class= code-output > rd = pg_get_rings(dd, pd=pd, od=cd)</span> <span class= code-output > sund = pg_get_stars(dd, od=cd, name='SUN')</span>   NOTES     Because the detached header translator dh_std_input appears before    the Cassini Spice input translator in the default translators table, the    descriptors are taken from the detached header if it exists.  If it doesn't    exist, then they are obtained through the SPICE kernels.     The commented lines show how translator keywords can be passed to    override the keywords given in the translators table.      The keyword 'name' could be used in pg_get_planets to select only Jupiter    and the Galilean satellites.  By default, every body that's relevant to    the mission and can be found in the kernel list is returned.  Also, the    SPICE translator organizes the pd array such that pd[0] gives the    primary target of the observation, if one exists.     The keyword 'name' is used in pg_get_stars to select only the Sun.    Otherwise, star catalog stars would also be returned.  Note, however,    that the star catalog is still searched because it does appear in the    translators table.   Create a generic descriptor     This line creates a  generic  descriptor.  This is a convenience    feature wherein several descriptors are grouped into a structure that    can be passed to functions in one piece.  The field names of a generic    descriptor must follow the convention described in pg_description.txt: <span class= code-output > gd = {cd:cd, gbx:pd, dkx:rd, sund:sund}</span>    cd - camera descriptor part     gbx - globe descriptor part     dkx - disk descriptor part     sund - sun descriptor part   Compute geometric features     These commands compute the limb of each planet, the edges of the Jovian ring    system, and terminators on each planet: <span class= code-output > limb_ptd = pg_limb(gd=gd) & pg_hide, limb_ptd, gd=gd, bx=rd, /rm</span> <span class= code-output >           pg_hide, limb_ptd, /assoc, gd=gd, bx=pd, od=sund</span> <span class= code-output > ring_ptd = pg_disk(gd=gd) & pg_hide, ring_ptd, gd=gd, bx=pd</span> <span class= code-output > term_ptd = pg_limb(gd=gd, od=gd.sund) & pg_hide, term_ptd, gd=gd, bx=pd, /assoc</span>  <span class= code-output > center_ptd = pg_center(gd=gd, bx=pd)</span> <span class= code-output > center_o=pnt_points(center_ptd[0])    ;get the center of Jupiter from the points object</span> <span class= code-output > print, center_o                       ;display the center of Jupiter</span> <span class= code-output > object_ptd = [center_ptd,limb_ptd,ring_ptd,term_ptd]</span>    Note that terminators are computed    using pg_limb by specifying the sun as the observer instead of the camera.   Set plot parameters     The colors, psyms, psizes and plables variables    are defined for the plot.  The center is drawn in the default color    (!p.color), the limb is in yellow (ctyellow) and the inner and outer ring    are in red (ctred).  Here you can see that each ring is treated as two    objects (inner and outer) when defining plot characteristics.  With an    8-bit display, these color routines return the values that were previously    reserved in the color table with ctmod; with a 24-bit display, these    routines return the true color values for these colors.  nlimb stores the    number of points in the limb_ptd structure, nring, the number of points in    the ring point structure.  In plabels, the limb and ring's name is not    plotted since it would be plotted at the center of the object: <span class= code-output > ncent=n_elements(center_ptd)</span> <span class= code-output > nlimb=n_elements(limb_ptd)</span> <span class= code-output > nring=n_elements(ring_ptd)</span> <span class= code-output > nterm=n_elements(term_ptd)</span> <span class= code-output > colors=[make_array(n_elements(pd),value=!p.color), $</span> <span class= code-output >         make_array(n_elements(pd),value=ctyellow()), $</span> <span class= code-output >         make_array(2*n_elements(rd),value=ctred()), $</span> <span class= code-output >         make_array(nterm,value=ctgreen())]</span> <span class= code-output > psyms=[make_array(n_elements(pd),value=1), $</span> <span class= code-output >         make_array(n_elements(pd),value=3), $</span> <span class= code-output >         make_array(2*n_elements(rd),value=3), $</span> <span class= code-output >         make_array(nterm,value=3)]</span> <span class= code-output > psizes=1.0</span> <span class= code-output > csizes=0.75</span> <span class= code-output > plabels=[cor_name(pd), $</span> <span class= code-output >         make_array(n_elements(pd),value=''), $</span> <span class= code-output >         make_array(2*n_elements(rd),value=''), $</span> <span class= code-output >         make_array(nterm,value='')]</span>   Draw the limb, ring and planet center      This section draws the objects in the object array (center, limb, ring,  and terminator) with the colors and plot symbols and labels defined earlier: <span class= code-output >   pg_draw, object_ptd, col=colors, psy=psyms, psi=psizes, csi=csizes, pl=plabels</span>   First-cut Automatic repointing     Refine the pointing of the spacecraft by using pg_farfit, which searches    the whole image for a pattern matching the edges calculated using the    descriptors: <span class= code-output > edge_ptd = pg_edges(dd, edge=10)                ; Scan image for edges.</span> <span class= code-output > pg_draw, edge_ptd</span>            dxy = pg_farfit(dd, edge_ptd, [limb_ptd[0]])    ; Try to correlate scanned edges with the computed limb.      pg_repoint, dxy, 0d, axis=center_ptd[0], gd=gd  ; Change the pointing.      tvim, im      pg_draw, object_ptd, colors=colors, psyms=psyms, psizes=psizes, plabel=plabels            center_ptd = pg_center(gd=gd, bx=pd)      print, 'after automatic repointing, the center was shifted by:', pnt_points(center_ptd[0])-center_o, 'pixels'    Manually repoint the geometry     This pasteable section first clears the screen of the plotted points    by redisplaying the image with tvim.  It then calls pg_drag to allow    the user to use the cursor to drag the pointing, and with it the limb,    ring and planet center.  To move the pointing with pg_drag, use the left    mouse button and translate the pointing in x,y.  Use the middle mouse    button to rotate the pointing about an axis (in this case, the axis of    rotation is set as the planet center (center_ptd[0]).  When the    desired pointing is set, the right mouse button accepts it.  pg_drag    returns the delta x,y amount dragged (dxy) as well as the rotation    angle (dtheta).  pg_repoint uses the dxy and dtheta to update the    camera descriptor (cd, passed by gd).  The limb and center is then    recalculated, the image redisplayed to clear the objects drawn, and    then pg_draw is called to replot: <span class= code-output > tvim, im</span> <span class= code-output > dxy = pg_drag(object_ptd, dtheta=dtheta, axis=center_ptd[0])    ;Do the reponting</span> <span class= code-output > pg_repoint, dxy, dtheta, axis=center_ptd[0], gd=gd              ;Modify the general descriptor</span>  <span class= code-output > ;Recalculate the geometry and redisplay the image with the new overlays</span>  <span class= code-output > limb_ptd = pg_limb(gd=gd) & pg_hide, limb_ptd, gd=gd, bx=rd, /rm</span> <span class= code-output >        pg_hide, limb_ptd, /assoc, gd=gd, bx=pd, od=sund</span> <span class= code-output > ring_ptd = pg_disk(gd=gd) & pg_hide, ring_ptd, gd=gd, bx=pd</span> <span class= code-output > center_ptd = pg_center(gd=gd, bx=pd)</span> <span class= code-output > term_ptd = pg_limb(gd=gd, od=gd.sund) & pg_hide, term_ptd, gd=gd, bx=pd, /assoc</span> <span class= code-output > object_ptd = [center_ptd,limb_ptd,ring_ptd,term_ptd]</span>  <span class= code-output > tvim, im</span> <span class= code-output > pg_draw, object_ptd, colors=colors, psyms=psyms, psizes=psizes, plabel=plabels</span>   Scan the edge to find the limb and use it to correct the pointing using least-squares.     This section calls pg_cvscan to scan the image around the predicted    limb position and the ring edge position (within width of 80 pixels) and    find the points of highest correlation with a given edge model for each    object (edge_model_nav_limb = limb model used in the VICAR program NAV    and edge_model_nav_ring = ring model from NAV) and zeropoint offset in    the given model (lzero).  These points are then plotted: <span class= code-output > cvscan_ptd=pg_cvscan(dd, gd=gd, [limb_ptd[0]], edge=30, width=80, $</span> <span class= code-output >     model=[make_array(nlimb,val=ptr_new(edge_model_nav_limb(zero=lzero)))], $</span> <span class= code-output >     mzero=[make_array(nlimb,val=lzero)] )</span>  <span class= code-output > tvim, im</span> <span class= code-output > pg_draw, cvscan_ptd</span>          The commented command might be more appropriate for images in which    the planet disk is quite small.  In that case, we use a different edge    model (because the nav model cannot be scaled) and we scan a much    narrower region.   Threshold on correlation coefficient     This section calls pg_threshold to remove points with    unacceptable correlation coefficients.  The /relative flag means that    the minimum and maximum thresholds are taken as a fraction of the maximum    correlation coefficient for each set of points. In this case we use a minimun    correlation coefficent of 0.81 and a maximum of 1.0: <span class= code-output > pg_threshold, cvscan_ptd, min=0.81, max=1.0, /rel</span> <span class= code-output > tvim, im</span> <span class= code-output > pg_draw, cvscan_ptd</span>   Removing regions of bad scan points     This pasteable section calls pg_select to remove points within a    polygonal region as defined by the cursor.  Click the left mouse    button to mark a point and move the mouse to the next point and    click.  Use the middle mouse button to erase a point and the right    mouse button to end the region.  pg_trim removes the points in the    just defined region.  The scan points are then replotted.    Repeat these statements for each region a user wants to remove: <span class= code-output > region = pg_select(dd)</span> <span class= code-output > pg_trim, dd, cvscan_ptd, region</span> <span class= code-output > tvim, im</span> <span class= code-output > pg_draw, cvscan_ptd</span>   Fit the pointing to the scanned points using least squares     This section calls pg_cvscan_coeff to determine the linear least-squares    coefficients for a fit to the image coordinate translation and rotation    that matches the computed curve to the scanned curve. It then calls    pg_fit to do the fit with the calculated coefficients to calculate the    correction in translation (dxy) and rotation (dtheta).  It calls    pg_cvchisq to get the chi square of the fit.  Then calls pg_repoint to    update the pointing. Recalculates the limb and center and replots.    The determination of the curves and their subsequent fit can be    iterated on.     Note that, as shown, dx, dy, and dtheta are fit.  To fix any of these    parameters use the 'fix' keyword to pg_cvscan_coeff.  For example    with 'fix=2', dtheta will be zero: <span class= code-output > fix = [2]</span> <span class= code-output > cvscan_cf = pg_cvscan_coeff(cvscan_ptd, axis=center_ptd[0], fix=fix)</span> <span class= code-output > dxy = pg_fit([cvscan_cf], dtheta=dtheta)</span> <span class= code-output > chisq = pg_chisq(dxy, dtheta, cvscan_ptd, axis=center_ptd[0], fix=fix)</span> <span class= code-output > covar = pg_covariance([cvscan_cf])</span> <span class= code-output > print, dxy, dtheta*180./!pi, chisq, covar</span> <span class= code-output > pg_repoint, dxy, dtheta, axis=center_ptd[0], gd=gd</span>  <span class= code-output > limb_ptd = pg_limb(gd=gd) & pg_hide, limb_ptd, gd=gd, bx=rd, /rm</span> <span class= code-output >         pg_hide, limb_ptd, bx=pd, /assoc, gd=gd, od=sund</span> <span class= code-output > ring_ptd = pg_disk(gd=gd) & pg_hide, ring_ptd, gd=gd, bx=pd</span> <span class= code-output > center_ptd = pg_center(gd=gd, bx=pd)</span> <span class= code-output > term_ptd = pg_limb(gd=gd, od=gd.sund) & pg_hide, term_ptd, gd=gd, bx=pd, /assoc</span> <span class= code-output > object_ptd = [center_ptd,limb_ptd,ring_ptd,term_ptd]</span>  <span class= code-output > tvim, im</span> <span class= code-output > pg_draw, object_ptd, colors=colors, psyms=psyms, psizes=psizes, plabel=plabels</span>         Draw planet and ring latitude/longitude grid        This section calculates a latitude/longitude grid for each planet and a    radius/longitude grid for the rings.  By default it draws 12 latitude    and 12 longitude grid lines.  The longitude grid lines circle the body    and so on a map they will appear as 24 grid lines.  The ring radius grid    uses four grid lines by default between the inner and outer ring radius.    It uses pg_hide to set as not visible the points on the grid behind the    planet and ring for both objects.  It then uses pg_draw to draw the    grid points in blue (ctblue): <span class= code-output > grid_ptd = pg_grid(gd=gd, lat=lat, lon=lon)</span> <span class= code-output > pg_hide, grid_ptd, cd=cd, bx=pd, /assoc</span> <span class= code-output > pg_hide, grid_ptd, cd=cd, bx=pd, od=sund, /assoc</span> <span class= code-output > pg_hide, grid_ptd, gd=gd, bx=rd</span> <span class= code-output > pg_draw, grid_ptd, color=ctblue()</span>  <span class= code-output > plat_ptd = pg_grid(gd=gd, slon=!dpi/2d, lat=lat, nlon=0)</span> <span class= code-output > pg_hide, plat_ptd[0], cd=cd, bx=pd[0], /, bx=pd</span> <span class= code-output > pg_draw, plat_ptd[0], psym=3, plabel=strtrim(round(lat*180d/!dpi),2), /label_p</span>  <span class= code-output > plon_ptd = pg_grid(gd=gd, slat=0d, lon=lon, nlat=0)</span> <span class= code-output > pg_hide, plon_ptd[0], cd=cd, bx=pd[0], /assoc</span> <span class= code-output > pg_draw, plon_ptd[0], psym=3, plabel=strtrim(round(lon*180d/!dpi),2), /label_p</span>  <span class= code-output > dgrid_ptd=pg_grid(gd=gd, bx=rd) & pg_hide, dgrid_ptd, gd=gd, bx=pd</span> <span class= code-output > pg_draw, dgrid_ptd, color=ctpurple()</span>   Generate map projections     This section defines a map descriptor for a simple cylindrical projection    using pg_get_maps.  It then calls pg_map to create a map projection and    uses tvim to display it in a new window.  Four different map descriptors    are demonstrated.     We also call pg_grid to calculate a latitude/longitude grid on the map and    then pg_draw to draw the grid in green. For convenience, define a new generic descriptor.    Note that the map descriptor is used for the cd field. Call pg_limb to calculate the limb    on the map and then pg_draw to draw the grid in purple.   Mercator     Map descriptor: <span class= code-output > md = pg_get_maps(/over, bx=pd[0], $</span> <span class= code-output >   type='MERCATOR', $</span> <span class= code-output >   fn_data=ptr_new(),size=[400,200])</span>       Stereographic     Map descriptor: <span class= code-output > md = pg_get_maps(/over, bx=pd[0], $</span> <span class= code-output >   type='STEREOGRAPHIC', $</span> <span class= code-output >   fn_data=ptr_new(),scale=0.5, $</span> <span class= code-output >   size=[400,400], center=[!dpi/2d,0d])</span>       Orthographic     Map descriptor: <span class= code-output > md = pg_get_maps(/over, bx=pd[0], $</span> <span class= code-output >   type='ORTHOGRAPHIC', $</span> <span class= code-output >   fn_data=ptr_new(), $</span> <span class= code-output >   size=[400,400], $</span> <span class= code-output >   center=[!dpi/6d,!dpi])</span>       Rectangular     Map descriptor: <span class= code-output > md = pg_get_maps(/over, bx=pd[0], $</span> <span class= code-output >   type='RECTANGULAR', $</span> <span class= code-output >   /map_graphic,fn_data=ptr_new(),scale=1.0, $</span> <span class= code-output >   size=[400,200])</span>        Projecting the maps     Use the pg_map and the map descriptor to project the image onto a map.    Certain regions, such as rings, could be excluded from the projection    and bounds on the map can be set, if desired: <span class= code-output > ;to set projection bounds...</span> <span class= code-output > ;bounds = [-30,30,-180,180]*!dpi/180d</span>  <span class= code-output > mmap = 0</span> <span class= code-output > dd_map = pg_map(dd, md=md, gd=gd, bx=pd[0], map=mmap, bounds=bounds)</span>  <span class= code-output > ; to exclude areas covered by rings...</span> <span class= code-output > ;dd_map = pg_map(dd, md=md, gd=gd, bx=pd[0], gbx=pd[0], $</span> <span class= code-output > ;          hide_fn='pm_hide_ring', hide_data_p=ptr_new(rd), map=map, bounds=bounds)</span>  <span class= code-output > tvim, /new, mmap</span>    Call pg_grid to calculate a latitude/longitude grid on the map and    then pg_draw to draw the grid in green.     For convenience, define a new generic descriptor.  Note that the map    descriptor is used for the cd field: <span class= code-output > gdm={cd:md, od:cd, gbx:cor_select(pd,'JUPITER'), dkx:rd}</span>  <span class= code-output > map_grid_ptd = pg_grid(gd=gdm, lat=lat, lon=lon)</span> <span class= code-output > plat_ptd = pg_grid(gd=gdm, slon=!dpi/2d, lat=lat, nlon=0)</span> <span class= code-output > plon_ptd = pg_grid(gd=gdm, slat=0d, lon=lon, nlat=0)</span>  <span class= code-output > pg_draw, map_grid_ptd, col=ctgreen()</span> <span class= code-output > pg_draw, plat_ptd, psym=7, plabel=strmid(strtrim(lat*180d/!dpi,2),0,3), /label_p</span> <span class= code-output > pg_draw, plon_ptd, psym=7, plabel=strmid(strtrim(lon*180d/!dpi,2),0,3), /label_p</span>    Call pg_limb to calculate the limb on the map and then pg_draw to    draw the grid in purple: <span class= code-output > map_limb_ptd = pg_limb(gd=gdm)</span> <span class= code-output > pg_draw, map_limb_ptd, col=ctred()</span>  <span class= code-output > map_term_ptd = pg_limb(gd=gdm, od=sund)</span> <span class= code-output > pg_draw, map_term_ptd, col=ctyellow()</span>   Reproject the previous map     A map can be reprojected using a second map descriptor    and the original map descriptor as the camera descriptor: <span class= code-output > md1 = pg_get_maps(/over, bx=pd[0], $</span> <span class= code-output >   type='ORTHOGRAPHIC', $</span> <span class= code-output >   fn_data=ptr_new(), $</span> <span class= code-output >   size=[400,400], $</span> <span class= code-output >   center=[!dpi/6d,!dpi])</span>  <span class= code-output > map=0</span> <span class= code-output > dd_map1 = pg_map(dd_map, md=md1, cd=md, map=map1, bounds=bounds)</span> <span class= code-output > tvim, /new, map1</span>       Output the new state     This section shows how you can save your output.   Output descriptors     These commands write the descriptor information out through the    translators.  The exact behavior is translator-dependent.  The detached    header translator just modifies the detached header (stored in the data    descriptor).  The SPICE output translator writes a C-kernel if a file    name is specified using the ck_out translator keyword (as in the commented    line): <span class= code-output > pg_put_rings, dd, od=gd.cd, rd=rd</span> <span class= code-output > pg_put_planets, dd, od=gd.cd, pd=pd</span> <span class= code-output > pg_put_cameras, dd, cd=cd</span> <span class= code-output > ; cor_set_udata, cd, 'CK_COMMENT', 'This is a comment.'</span> <span class= code-output > ; pg_put_cameras, dd, gd=gd, 'ck_out=./test.bc'</span> <span class= code-output > ; print, spice_daf_comment('./test.bc')</span> <span class= code-output > pg_put_stars, dd, sd=sund, od=gd.cd</span>    Write image file and header     dat_write writes the image file from the data descriptor.  The detached header    is also written into a file with the same name as the image file except with    the extension '.dh'.  If this file does not already exist, it is created: <span class= code-output > split_filename, file, dir, name</span> <span class= code-output > dat_write, getenv('OMINAS_DATA')+'/' + name, dd</span>   Write map file and header     pg_put_maps causes the detached header translator to generate a new detached    header and write the map descriptor into it.     As above, dat_write writes the map image file and the detached header. Notice    that the filetype is given explicitly because the data descriptor was not    created by dat_read, which would have detected the filetype: <span class= code-output > pg_put_maps, dd_map, md=md</span>  <span class= code-output > split_filename, file, dir, name</span> <span class= code-output > dat_write, getenv('OMINAS_DATA')+'/' + name + '.map', dd_map, filetype = 'VICAR'</span>    To read the new map file, use dat_read just as the image file was read at the    beginning of this example script.  To read the map descriptor from the    detached header, use: <span class= code-output > md = pg_get_maps(dd_map)</span>  ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("util/kb_cursor.html", "kb_cursor.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "kb_cursor.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/kb_cursor.html#kbc_event", "kbc_event", 'routine in <a href="util/kb_cursor.html">kb_cursor.pro</a>', "kb_cursor.pro", "", "kbc_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/kb_cursor.html#kb_cursor", "kb_cursor", 'routine in <a href="util/kb_cursor.html">kb_cursor.pro</a>', "kb_cursor.pro", "", "kb_cursor", "", "changedownnowaitupwaitdatadevicenormalx0y0drawxywait", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/kbwait.html", "kbwait.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "kbwait.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/kbwait.html#kbwait", "kbwait", 'routine in <a href="util/kbwait.html">kbwait.pro</a>', "kbwait.pro", "", "kbwait", "", "message", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/keyval_struct__define.html", "keyval_struct__define.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "keyval_struct__define.pro", "", "", " NAME: 	keyval_struct__define    PURPOSE: 	Structure defining a keyword/value pair.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	N/A    FIELDS: 	keywords_p:	Pointer to list of keywords.  	values_p:	Pointer to list of value strings.   STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/keyval_struct__define.html#keyval_struct__define", "keyval_struct__define", 'routine in <a href="nv/obj/dat/keyval_struct__define.html">keyval_struct__define.pro</a>', "keyval_struct__define.pro", "", "keyval_struct__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/keyword__set.html", "keyword__set.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "keyword__set.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/keyword__set.html#keyword__set", "keyword__set", 'routine in <a href="util/keyword__set.html">keyword__set.pro</a>', "keyword__set.pro", "", "keyword__set", "", "x", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/keyword_value.html", "keyword_value.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "keyword_value.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/keyword_value.html#keyword_value", "keyword_value", 'routine in <a href="util/keyword_value.html">keyword_value.pro</a>', "keyword_value.pro", "", "keyword_value", "", "delimlineskeyword", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/keyword_value.html#__keyword_value", "__keyword_value", 'routine in <a href="util/keyword_value.html">keyword_value.pro</a>', "keyword_value.pro", "", "__keyword_value", "", "lineskeyword", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/lagrange_interp.html", "lagrange_interp.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "lagrange_interp.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/lagrange_interp.html#lagrange_interp", "lagrange_interp", 'routine in <a href="util/lagrange_interp.html">lagrange_interp.pro</a>', "lagrange_interp.pro", "", "lagrange_interp", "", "_xk_ykx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/lambdecute.html", "lambdecute.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "lambdecute.pro", "", "", " NAME: 	lambdecute    PURPOSE: 	Executes a command string using either 'execute or 'lambda' depending 	on the IDL version.    CATEGORY: 	UTIL    CALLING SEQUENCE: 	lambdecute, command    ARGUMENTS:   INPUT: 	filespec:	String giving command to eecute.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE     OUTPUT: NONE    RETURN: NONE     STATUS: 	Complete    SEE ALSO: 	dat_read    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2017   ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("util/gen/linegen3x.html", "linegen3x.pro", '.pro file in <a href="util/gen/dir-overview.html">util/gen/ directory</a>', "linegen3x.pro", "", "", " NAME: 	linegen3x    PURPOSE: 	Constructs a 3d array of subscripts that looks like indgen(ny, nz) in 	the y and z directions and is replicated in the x direction.    CATEGORY: 	UTIL/GEN    CALLING SEQUENCE: 	sub = linegen3x(nx, ny, nz)    ARGUMENTS:   INPUT: 	nx:	 Number of elements in the x direction.  	ny:	 Number of elements in the y direction.  	nz:	 Number of elements in the z direction.     OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    EXAMPLE:  	For nx=6, ny=3, nz=2: 		0  0  0  0  0  0 		1  1  1  1  1  1 		2  2  2  2  2  2  		3  3  3  3  3  3 		4  4  4  4  4  4 		5  5  5  5  5  5    RETURN: 	Array (nx x ny x nz) of subscripts.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/gen/linegen3x.html#linegen3x", "linegen3x", 'routine in <a href="util/gen/linegen3x.html">linegen3x.pro</a>', "linegen3x.pro", "", "linegen3x", "", "nml", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/gen/linegen3y.html", "linegen3y.pro", '.pro file in <a href="util/gen/dir-overview.html">util/gen/ directory</a>', "linegen3y.pro", "", "", " NAME: 	linegen3y    PURPOSE: 	Constructs a 3d array of subscripts that looks like indgen(nx, nz) in 	the x and z directions and is replicated in the y direction.    CATEGORY: 	UTIL/GEN    CALLING SEQUENCE: 	sub = linegen3y(nx, ny, nz)    ARGUMENTS:   INPUT: 	nx:	 Number of elements in the x direction.  	ny:	 Number of elements in the y direction.  	nz:	 Number of elements in the z direction.     OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    EXAMPLE:  	For nx=6, ny=3, nz=2: 		0  1  2  3  4  5 		0  1  2  3  4  5 		0  1  2  3  4  5  		6  7  8  9  10 11 		6  7  8  9  10 11 		6  7  8  9  10 11    RETURN: 	Array (nx x ny x nz) of subscripts.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/gen/linegen3y.html#linegen3y", "linegen3y", 'routine in <a href="util/gen/linegen3y.html">linegen3y.pro</a>', "linegen3y.pro", "", "linegen3y", "", "nml", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/gen/linegen3z.html", "linegen3z.pro", '.pro file in <a href="util/gen/dir-overview.html">util/gen/ directory</a>', "linegen3z.pro", "", "", " NAME: 	linegen3y    PURPOSE: 	Constructs a 3d array of subscripts that looks like indgen(nx, ny) in 	the x and y directions and is replicated in the z direction.    CATEGORY: 	UTIL/GEN    CALLING SEQUENCE: 	sub = linegen3y(nx, ny, nz)    ARGUMENTS:   INPUT: 	nx:	 Number of elements in the x direction.  	ny:	 Number of elements in the y direction.  	nz:	 Number of elements in the z direction.     OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    EXAMPLE:  	For nx=6, ny=3, nz=2: 		0  1  2  3  4  5 		6  7  8  9  10 11 		12 13 14 15 16 17  		0  1  2  3  4  5 		6  7  8  9  10 11 		12 13 14 15 16 17    RETURN: 	Array (nx x ny x nz) of subscripts.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/gen/linegen3z.html#linegen3z", "linegen3z", 'routine in <a href="util/gen/linegen3z.html">linegen3z.pro</a>', "linegen3z.pro", "", "linegen3z", "", "nml", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/local_extrema.html", "local_extrema.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "local_extrema.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/local_extrema.html#local_extrema", "local_extrema", 'routine in <a href="util/local_extrema.html">local_extrema.pro</a>', "local_extrema.pro", "", "local_extrema", "", "maximumminimumwidthx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/local_spikes.html", "local_spikes.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "local_spikes.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/local_spikes.html#local_spikes", "local_spikes", 'routine in <a href="util/local_spikes.html">local_spikes.pro</a>', "local_spikes.pro", "", "local_spikes", "", "fimageppnsigscale", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/locmod.html", "locmod.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "locmod.pro", "", "", " NAME:        locmod    PURPOSE:        Finds points in the image at which the correlation with the        given model is high.    CATEGORY:        UTIL    CALLING SEQUENCE:        result = modloc(image, model, edge=edge, ccmin=ccmin, gdmax=gdmax)    ARGUMENTS:   INPUT:        image:  Input image.         model:  2-D array giving a model of the reseau image.     OUTPUT:        NONE   KEYWORDS:   INPUT:         edge:  Distance from edge within which points are ignored.         ccmin:  Minimum correlation coefficient to accept.  Default is 0.8 .         gdmax:  Maximum gradiant of correlation coefficient to accept. 		Default is 0.25  	dmax:	Maximum number of resultant points allowed within any region 		of the image of size dbin * (size of the model).  Default is 2.  	dbin:	Binning factor size for computing point density, default is 2.        double:  If set, image is converted to double in the function,                otherwise it is converted to float.     OUTPUT:        coeff:	Correlation coefficients of returned points.    RETURN:        The points (x,y) in the image that best fits the model.  Returns 0        if no points are found.   PROCEDURE: 	Modloc first computes computes maps of the correlation coefficient 	between the model and the image with the model centered at each point 	as well as the gradient of the correlation coefficient at each point. 	Points with high correlation and low gradient are selected as 	candidates.  To select the final points, the point density is computed 	using a bin size of twice the size of the model and points within 	regions containing more than dmax candidates are deselected.     STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/locmod.html#locmod", "locmod", 'routine in <a href="util/locmod.html">locmod.pro</a>', "locmod.pro", "", "locmod", "", "coeffedgeccmingdmaxdmaxdbindouble_imagemodel", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/ls_to_xy.html", "ls_to_xy.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "ls_to_xy.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/ls_to_xy.html#ls_to_xy", "ls_to_xy", 'routine in <a href="util/ls_to_xy.html">ls_to_xy.pro</a>', "ls_to_xy.pro", "", "ls_to_xy", "", "ordersizelsimage", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/ltcorr.html", "ltcorr.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "ltcorr.pro", "", "", " NAME:        ltcorr    PURPOSE: 	Performs a light-travel-time correction on objects for which the 	correction has not already been performed.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        ltcorr, obs_bx, targ_bx0, c=c    ARGUMENTS:   INPUT: 	obs_bx:  Any subclass of BODY describing the observer.  	targ_bx: Array(nt) of any subclass of BODY describing the targets.    OUTPUT:  NONE    KEYOWRDS:   INPUT: 	c:		Speed of light.  	iterate:	If set, then the routine will iterate to refine 			the solution.  	epsilon:	Stopping criterion: maximum allowable timing error. 			Default is 1d-7.  	invert:		If set, the inverse correction is performed.    OUTPUT: NONE    RETURN: NONE    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/ltcorr.html#ltcorr", "ltcorr", 'routine in <a href="nv/obj/tools/ltcorr.html">ltcorr.pro</a>', "ltcorr.pro", "", "ltcorr", "", "cepsiloniterateinvertobs_bx_targ_bx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/make_array1.html", "make_array1.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "make_array1.pro", "", "", " NAME:        make_array1    PURPOSE:        Same as IDL function, make_array, but if n=1 it returns a scalar.    CATEGORY:        UTIL    CALLING SEQUENCE:        result = make_array1(n, value=value)    ARGUMENTS:   INPUT:            n:  Number of elements in resultant array.    OUTPUT:        NONE    KEYWORDS:   INPUT:        value:  Values to fill array.    OUTPUT:        NONE    RETURN:        Array (n) filled with value.  If n=1 then a scalar is returned        instead of an array.    SEE ALSO: 	make_array   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/make_array1.html#make_array1", "make_array1", 'routine in <a href="util/make_array1.html">make_array1.pro</a>', "make_array1.pro", "", "make_array1", "", "valuen", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/make_error_number.html", "make_error_number.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "make_error_number.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/make_error_number.html#men_get_decimal", "men_get_decimal", 'routine in <a href="util/make_error_number.html">make_error_number.pro</a>', "make_error_number.pro", "", "men_get_decimal", "", "xs", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/make_error_number.html#make_error_number", "make_error_number", 'routine in <a href="util/make_error_number.html">make_error_number.pro</a>', "make_error_number.pro", "", "make_error_number", "", "x_sig", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/strcat/gsc2/make_star_files_gsc2.html", "make_star_files_gsc2.pro", '.pro file in <a href="config/strcat/gsc2/dir-overview.html">config/strcat/gsc2/ directory</a>', "make_star_files_gsc2.pro", "", "", " Used to create the GSC2 records for use by strcat_gsc2_input.   Purpose   The full catalog file for GSC 2.2 is not available for download by  researchers, but the data is accessible through a WWW query engine at  http://www-gsss.stsci.edu/support/data_access.htm .  I was able to  determine the sections of the sky that were needed for the sat search  project (see /raid/matt/pointing.sav and /raid/matt/pointing.pro), and  created 40 data files by cut-and-paste from the WWW query engine.  This  routine compiles those data files into a single structure that can be  accessed by OMINAS.   ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("demo/map-disk_example.html", "map-disk_example.pro", '.pro file in <a href="demo/dir-overview.html">demo/ directory</a>', "map-disk_example.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("demo/map-globe_example.html", "map-globe_example.pro", '.pro file in <a href="demo/dir-overview.html">demo/ directory</a>', "map-globe_example.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("nv/obj/map/map_assign.html", "map_assign.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_assign.pro", "", "", " NAME: 	map_assign    PURPOSE: 	Replaces fields in a MAP object.  This is a convenient way of 	setting multiple fields in one call, and only a single event is 	generated.    CATEGORY: 	NV/OBJ/MAP    CALLING SEQUENCE: 	map_assign, md, <keywords>=<values>    ARGUMENTS:   INPUT: 	md:		MAP object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	MAP fields to set.  	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	map_set_*     MODIFICATION HISTORY:  	Written by:	Spitale		2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_assign.html#map_assign", "map_assign", 'routine in <a href="nv/obj/map/map_assign.html">map_assign.pro</a>', "map_assign.pro", "", "map_assign", "", "noeventxd@map__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_center.html", "map_center.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_center.pro", "", "", " NAME: 	map_center    PURPOSE: 	Returns the center for each given map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	center = map_center(md)    ARGUMENTS:   INPUT: NONE 	md:	 Array (nt) of map descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Array (2,nt) of centers associated with each given map descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_center.html#map_center", "map_center", 'routine in <a href="nv/obj/map/map_center.html">map_center.pro</a>', "map_center.pro", "", "map_center", "", "noeventmd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_centric_to_graphic.html", "map_centric_to_graphic.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_centric_to_graphic.pro", "", "", " NAME: 	map_centric_to_graphic    PURPOSE: 	Converts latitudes from the planetocentric to the planetographic 	convention.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_pts_g = map_centric_to_graphic(md, map_pts_c)    ARGUMENTS:   INPUT: 	md:	Array (nt) of map descriptors.  	map_pts_c:	Array (2,nv,nt) of map points in which the 			latitudes are planetocentric.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (2,nv,nt) of map points in which the latitudes are 	planetographic.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_centric_to_graphic.html#map_centric_to_graphic", "map_centric_to_graphic", 'routine in <a href="nv/obj/map/map_centric_to_graphic.html">map_centric_to_graphic.pro</a>', "map_centric_to_graphic.pro", "", "map_centric_to_graphic", "", "mdmap_pts0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_condense.html", "map_condense.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_condense.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_condense.html#map_condense", "map_condense", 'routine in <a href="nv/obj/map/map_condense.html">map_condense.pro</a>', "map_condense.pro", "", "map_condense", "", "mdbounds", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_create_descriptors.html", "map_create_descriptors.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_create_descriptors.pro", "", "", " NAME: 	map_create_descriptors    PURPOSE: 	Init method for the MAP class.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	md = map_create_descriptors(n)    ARGUMENTS:   INPUT: 	n:	Number of descriptors to create.    OUTPUT: NONE    KEYWORDS (in addition to those accepted by all superclasses):   INPUT: 	md:	Map descriptor(s) to initialize, instead of creating a new one.  	crd:	Core descriptor(s) to pass to cor_create_descriptors.  	type:	Array (1 x n) of strings giving the map types.  	units:	Array (2 x n) giving the map units.  	size:	Array (2 x n) giving the map sizes.  	scale:	Array (1 x n) giving the map scales.  	center:	Array (2 x n) giving the map centers.  	range:	Array (2x2 x n) giving the map centers.  	origin:	Array (2 x n) giving the map origins.  	rotate:	Array (1 x n) giving the map rotate codes.  	graphic: Array (1 x n) giving the map graphic flags.  	radii:	Array (3 x n) giving the map ellipsoid radii.  	radii:	Array (1 x n) of pointers giving the map functon data.     OUTPUT: NONE    RETURN: 	Newly created or or freshly initialized disk descriptors, depending 	on the presence of the dkd keyword.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_create_descriptors.html#map_create_descriptors", "map_create_descriptors", 'routine in <a href="nv/obj/map/map_create_descriptors.html">map_create_descriptors.pro</a>', "map_create_descriptors.pro", "", "map_create_descriptors", "", "crdmdn@map__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_fn_data.html", "map_fn_data.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_fn_data.pro", "", "", " NAME: 	map_fn_data    PURPOSE: 	Returns the function data for a map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	data = map_fn_data(md)    ARGUMENTS:   INPUT: NONE 	md:	 Map descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Function data associated with the given map descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Adapted by:	Spitale, 7/2016; adapted from map_fn_data_p   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_fn_data.html#map_fn_data", "map_fn_data", 'routine in <a href="nv/obj/map/map_fn_data.html">map_fn_data.pro</a>', "map_fn_data.pro", "", "map_fn_data", "", "noeventmd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_fn_image_to_map.html", "map_fn_image_to_map.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_fn_image_to_map.pro", "", "", " NAME: 	map_fn_image_to_map    PURPOSE: 	Returns the name of the image->map function for each given map 	descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	fn_image_to_map = map_fn_image_to_map(md)    ARGUMENTS:   INPUT: NONE 	md:	 Array (nt) of map descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Array (nt) of image->map function names associated with each given 	map descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_fn_image_to_map.html#map_fn_image_to_map", "map_fn_image_to_map", 'routine in <a href="nv/obj/map/map_fn_image_to_map.html">map_fn_image_to_map.pro</a>', "map_fn_image_to_map.pro", "", "map_fn_image_to_map", "", "noeventmd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_fn_map_to_image.html", "map_fn_map_to_image.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_fn_map_to_image.pro", "", "", " NAME: 	map_fn_map_to_image    PURPOSE: 	Returns the name of the map->image function for each given map 	descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	fn_image_to_map = map_fn_image_to_map(md)    ARGUMENTS:   INPUT: NONE 	md:	 Array (nt) of map descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Array (nt) of map->image function names associated with each given 	map descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_fn_map_to_image.html#map_fn_map_to_image", "map_fn_map_to_image", 'routine in <a href="nv/obj/map/map_fn_map_to_image.html">map_fn_map_to_image.pro</a>', "map_fn_map_to_image.pro", "", "map_fn_map_to_image", "", "noeventmd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_fn_valid.html", "map_fn_valid.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_fn_valid.pro", "", "", " NAME: 	map_fn_valid    PURPOSE: 	Returns the name of the map->image validation function for each given 	map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	fn_valid = map_fn_image_to_map(md)    ARGUMENTS:   INPUT: NONE 	md:	 Array (nt) of map descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Array (nt) of map->image validation function names associated with each given 	map descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2012  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_fn_valid.html#map_fn_valid", "map_fn_valid", 'routine in <a href="nv/obj/map/map_fn_valid.html">map_fn_valid.pro</a>', "map_fn_valid.pro", "", "map_fn_valid", "", "noeventmd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_get_grid_points.html", "map_get_grid_points.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_get_grid_points.pro", "", "", " NAME: 	map_get_grid_points    PURPOSE: 	Generates a lat/lon grid of points.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_pts = map_get_grid_points(lat=lat, lon=lon)    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: 	lat:	Array giving the latitudes for each constant latitude line.  	lon:	Array giving the longitudes for each constant longitude line.  	nt:	Number of grids to produce.  	scan_lat:	Latitudes to scan for each constant longitude line.  	scan_lon:	Longitudes to scan for each constant latitude line.    OUTPUT: NONE    RETURN: 	Array (2,np,nt) of map coordinate points where np is the number of 	scan_lats times the number of scan_lons.    STATUS: 	Complete  	Adapted by:	Spitale, 5/2016    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_get_grid_points.html#map_get_grid_points", "map_get_grid_points", 'routine in <a href="nv/obj/map/map_get_grid_points.html">map_get_grid_points.pro</a>', "map_get_grid_points.pro", "", "map_get_grid_points", "", "latlonntscan_latscan_lon", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_get_ranges.html", "map_get_ranges.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_get_ranges.pro", "", "", " NAME: 	map_get_ranges    PURPOSE: 	Returns ranges of valid coordinates for the given MAP object.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	ranges = map_get_ranges(md)    ARGUMENTS:   INPUT: 	md:	 MAP descriptor.     OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Array (2 x 2) giving the ranges in latitude, longitude.    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_get_ranges.html#map_get_ranges", "map_get_ranges", 'routine in <a href="nv/obj/map/map_get_ranges.html">map_get_ranges.pro</a>', "map_get_ranges.pro", "", "map_get_ranges", "", "md", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_graphic.html", "map_graphic.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_graphic.pro", "", "", " NAME: 	map_graphic    PURPOSE: 	Returns the graphic flag for each given map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	graphic = map_graphic(md)    ARGUMENTS:   INPUT: NONE 	md:	 Array (nt) of map descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Array (nt) of graphic flags associated with each given map descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_graphic.html#map_graphic", "map_graphic", 'routine in <a href="nv/obj/map/map_graphic.html">map_graphic.pro</a>', "map_graphic.pro", "", "map_graphic", "", "noeventmd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_graphic_to_centric.html", "map_graphic_to_centric.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_graphic_to_centric.pro", "", "", " NAME: 	map_graphic_to_centric    PURPOSE: 	Converts latitudes from the planetographic to the planetocentric 	convention.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_pts_c = map_graphic_to_centric(md, map_pts_g)    ARGUMENTS:   INPUT: 	md:	Array (nt) of map descriptors.  	map_pts_g:	Array (2,nv,nt) of map points in which the 			latitudes are planetographic.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (2,nv,nt) of map points in which the latitudes are 	planetocentric.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_graphic_to_centric.html#map_graphic_to_centric", "map_graphic_to_centric", 'routine in <a href="nv/obj/map/map_graphic_to_centric.html">map_graphic_to_centric.pro</a>', "map_graphic_to_centric.pro", "", "map_graphic_to_centric", "", "mdmap_pts0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_image_to_map.html", "map_image_to_map.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_image_to_map.pro", "", "", " NAME: 	map_image_to_map    PURPOSE: 	Transforms the given image points to map coordinate points.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_pts = map_image_to_map(md, image_pts)    ARGUMENTS:   INPUT: 	md	 	Array (nt) of MAP descriptors.  	image_pts:	Array (2,nv,nt) of map image points.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	valid:	Indices of all input points that correspond to valid 		output map points.  If not set then all points are 		valid.    RETURN: 	Array (2,nv,nt) of map coordinate points.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_image_to_map.html#map_image_to_map", "map_image_to_map", 'routine in <a href="nv/obj/map/map_image_to_map.html">map_image_to_map.pro</a>', "map_image_to_map.pro", "", "map_image_to_map", "", "validmd_image_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_image_to_map_equatorial_ring.html", "map_image_to_map_equatorial_ring.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_image_to_map_equatorial_ring.pro", "", "", " NAME: 	map_image_to_map_rectangular    PURPOSE: 	Transforms the given image points to map coordinate points 	using a rectangular projection.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_pts = map_image_to_map_rectangular(md, image_pts)    ARGUMENTS:   INPUT: 	md	 	Array (nt) of MAP descriptors.  	image_pts:	Array (2,nv,nt) of map image points.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	valid:	Indices of all input points that correspond to valid 		output map points.  If not set then all points are 		valid.    RETURN: 	Array (2,nv,nt) of map coordinate points in a rectangular projection. 	In this projection, latitudes map linearly to the the y image 	direction, and longitudes map linearly to the x image direction.  	With:  		a = [size[1]/pi, size[0]/2pi] * scale * units,  	the transformation is:  		lat = (y - origin[1])/a[0] + center[0]  		lon = (x - origin[0])/a[1] + center[1]  	where the latitude equation is solved iteratively.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_image_to_map_equatorial_ring.html#map_image_to_map_equatorial_ring", "map_image_to_map_equatorial_ring", 'routine in <a href="nv/obj/map/map_image_to_map_equatorial_ring.html">map_image_to_map_equatorial_ring.pro</a>', "map_image_to_map_equatorial_ring.pro", "", "map_image_to_map_equatorial_ring", "", "validmdimage_pts", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_image_to_map_equatorial_ring.html#_map_image_to_map_rectangular", "_map_image_to_map_rectangular", 'routine in <a href="nv/obj/map/map_image_to_map_equatorial_ring.html">map_image_to_map_equatorial_ring.pro</a>', "map_image_to_map_equatorial_ring.pro", "", "_map_image_to_map_rectangular", "", "validmdimage_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_image_to_map_mercator.html", "map_image_to_map_mercator.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_image_to_map_mercator.pro", "", "", " NAME: 	map_image_to_map_mercator    PURPOSE: 	Transforms the given image points to map coordinate points 	using a mercator projection.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_pts = map_image_to_map_mercator(md, image_pts)    ARGUMENTS:   INPUT: 	md	 	Array (nt) of MAP descriptors.  	image_pts:	Array (2,nv,nt) of map image points.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	valid:	Indices of all input points that correspond to valid 		output map points.  If not set then all points are 		valid.    RETURN: 	Array (2,nv,nt) of map coordinate points in a mercator projection. 	This projection results from projecting a sphere onto a cylinder 	that is tangent at the equator.  The scale is true along the equator 	only.  Areas are distorted, especially near the poles.  	With:  		a = [size[1]/pi, size[0]/2pi] * scale * units,  	and:  		e = sqrt(1 - (A/(B+C)/2)^2),  	where A, B, and C are the triaxial ellipsoid radii, the 	transformation is:  		pi/2 - 2*atan(exp(-y/a[0]) * 		         ((1 - e*sin(lat))/(1 + e*sin(lat)))^(e/2))  		lon = x/a[1] + center[1]  	where the latitude equation is solved iteratively.  	See [1], p. 45 for the mathematical derivation.  	[1] Snyder (1987) 	    Map projections -- A working manual 	    USGS professional paper 1395    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_image_to_map_mercator.html#immc_fn", "immc_fn", 'routine in <a href="nv/obj/map/map_image_to_map_mercator.html">map_image_to_map_mercator.pro</a>', "map_image_to_map_mercator.pro", "", "immc_fn", "", "xdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_image_to_map_mercator.html#map_image_to_map_mercator", "map_image_to_map_mercator", 'routine in <a href="nv/obj/map/map_image_to_map_mercator.html">map_image_to_map_mercator.pro</a>', "map_image_to_map_mercator.pro", "", "map_image_to_map_mercator", "", "validmd_image_pts", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_image_to_map_mercator.html#_map_image_to_map_mercator", "_map_image_to_map_mercator", 'routine in <a href="nv/obj/map/map_image_to_map_mercator.html">map_image_to_map_mercator.pro</a>', "map_image_to_map_mercator.pro", "", "_map_image_to_map_mercator", "", "validmd_image_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_image_to_map_mollweide.html", "map_image_to_map_mollweide.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_image_to_map_mollweide.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_image_to_map_mollweide.html#map_image_to_map_mollweide", "map_image_to_map_mollweide", 'routine in <a href="nv/obj/map/map_image_to_map_mollweide.html">map_image_to_map_mollweide.pro</a>', "map_image_to_map_mollweide.pro", "", "map_image_to_map_mollweide", "", "validmd_image_pts", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_image_to_map_mollweide.html#_map_image_to_map_mollweide", "_map_image_to_map_mollweide", 'routine in <a href="nv/obj/map/map_image_to_map_mollweide.html">map_image_to_map_mollweide.pro</a>', "map_image_to_map_mollweide.pro", "", "_map_image_to_map_mollweide", "", "validmd_image_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_image_to_map_orthographic.html", "map_image_to_map_orthographic.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_image_to_map_orthographic.pro", "", "", " NAME: 	map_image_to_map_orthographic    PURPOSE: 	Transforms the given image points to map coordinate points 	using an orthographic projection.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_pts = map_image_to_map_orthographic(md, image_pts)    ARGUMENTS:   INPUT: 	md	 	Array (nt) of MAP descriptors.  	image_pts:	Array (2,nv,nt) of map image points.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	valid:	Indices of all input points that correspond to valid 		output map points.  If not set then all points are 		valid.    RETURN: 	Array (2,nv,nt) of map coordinate points in an orthographic 	projection.  This projection portrays a planet as seen from a 	great distance.  Scale is true only at the map center.  Areas 	are distorted, especially away from the map center.  	With:  	  R = min(size[0],size[1])/2 * scale,  	and:  	  rho = sqrt(x^2 + y^2),  	and:  	  c = asin(rho/R),  	the transformation is:  	  lat = asin( cos(c)*sin(center[0]) + 	                    y*sin(c)*cos(center[0])/rho ) / units[0]  	  lon = center[1] + 	          atan( x*sin(c)/(rho*cos(center[0])*cos(c) - 	                        y*sin(center[0])*sin(c)) ) + units[1]   	See [1], p. 150 for the mathematical derivation.  	[1] Snyder (1987) 	    Map projections -- A working manual 	    USGS professional paper 1395     STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_image_to_map_orthographic.html#map_image_to_map_orthographic", "map_image_to_map_orthographic", 'routine in <a href="nv/obj/map/map_image_to_map_orthographic.html">map_image_to_map_orthographic.pro</a>', "map_image_to_map_orthographic.pro", "", "map_image_to_map_orthographic", "", "validmd_image_pts", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_image_to_map_orthographic.html#_map_image_to_map_orthographic", "_map_image_to_map_orthographic", 'routine in <a href="nv/obj/map/map_image_to_map_orthographic.html">map_image_to_map_orthographic.pro</a>', "map_image_to_map_orthographic.pro", "", "_map_image_to_map_orthographic", "", "validmd_image_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_image_to_map_orthographic_disk.html", "map_image_to_map_orthographic_disk.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_image_to_map_orthographic_disk.pro", "", "", " NAME: 	map_image_to_map_orthographic_disk    PURPOSE: 	Transforms the given image points to map coordinate points 	using an orthographic projection for a disk.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_pts = map_image_to_map_orthographic_disk(md, image_pts)    ARGUMENTS:   INPUT: 	md	 	Array (nt) of MAP descriptors.  	image_pts:	Array (2,nv,nt) of map image points.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	valid:	Indices of all input points that correspond to valid 		output map points.  If not set then all points are 		valid.    RETURN: 	Array (2,nv,nt) of map coordinate points in an orthographic disk 	projection.  This projection portrays a disk as seen from a 	great distance.  Scale is uniform, but it is only true if the 	projection is polar.  Likewise, areas are distorted for non-polar 	projections.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_image_to_map_orthographic_disk.html#map_image_to_map_orthographic_disk", "map_image_to_map_orthographic_disk", 'routine in <a href="nv/obj/map/map_image_to_map_orthographic_disk.html">map_image_to_map_orthographic_disk.pro</a>', "map_image_to_map_orthographic_disk.pro", "", "map_image_to_map_orthographic_disk", "", "validmd_image_pts", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_image_to_map_orthographic_disk.html#_map_image_to_map_orthographic_disk", "_map_image_to_map_orthographic_disk", 'routine in <a href="nv/obj/map/map_image_to_map_orthographic_disk.html">map_image_to_map_orthographic_disk.pro</a>', "map_image_to_map_orthographic_disk.pro", "", "_map_image_to_map_orthographic_disk", "", "validmd_image_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_image_to_map_rectangular.html", "map_image_to_map_rectangular.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_image_to_map_rectangular.pro", "", "", " NAME: 	map_image_to_map_rectangular    PURPOSE: 	Transforms the given image points to map coordinate points 	using a rectangular projection.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_pts = map_image_to_map_rectangular(md, image_pts)    ARGUMENTS:   INPUT: 	md	 	Array (nt) of MAP descriptors.  	image_pts:	Array (2,nv,nt) of map image points.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	valid:	Indices of all input points that correspond to valid 		output map points.  If not set then all points are 		valid.    RETURN: 	Array (2,nv,nt) of map coordinate points in a rectangular projection. 	In this projection, latitudes map linearly to the the y image 	direction, and longitudes map linearly to the x image direction.  	With:  		a = [size[1]/pi, size[0]/2pi] * scale * units,  	the transformation is:  		lat = (y - origin[1])/a[0] + center[0]  		lon = (x - origin[0])/a[1] + center[1]  	where the latitude equation is solved iteratively.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_image_to_map_rectangular.html#map_image_to_map_rectangular", "map_image_to_map_rectangular", 'routine in <a href="nv/obj/map/map_image_to_map_rectangular.html">map_image_to_map_rectangular.pro</a>', "map_image_to_map_rectangular.pro", "", "map_image_to_map_rectangular", "", "validmdimage_pts", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_image_to_map_rectangular.html#_map_image_to_map_rectangular", "_map_image_to_map_rectangular", 'routine in <a href="nv/obj/map/map_image_to_map_rectangular.html">map_image_to_map_rectangular.pro</a>', "map_image_to_map_rectangular.pro", "", "_map_image_to_map_rectangular", "", "validmdimage_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_image_to_map_rectangular_disk.html", "map_image_to_map_rectangular_disk.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_image_to_map_rectangular_disk.pro", "", "", " NAME: 	map_image_to_map_rectangular_disk    PURPOSE: 	Transforms the given image points to map coordinate points 	using a rectangular projection on a disk.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_pts = map_image_to_map_rectangular_disk(md, image_pts)    ARGUMENTS:   INPUT: 	md	 	Array (nt) of MAP descriptors.  	image_pts:	Array (2,nv,nt) of map image points.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	valid:	Indices of all input points that correspond to valid 		output map points.  If not set then all points are 		valid.    RETURN: 	Array (2,nv,nt) of map coordinate points in a rectangular projection. 	In this projection, latitudes map linearly to the the y image 	direction, and longitudes map linearly to the x image direction.  	With:  		a = [size[1]/pi, size[0]/2pi] * scale * units,  	the transformation is:  		lat = (y - origin[1])/a[0] + center[0]  		lon = (x - origin[0])/a[1] + center[1]  	where the latitude equation is solved iteratively.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_image_to_map_rectangular_disk.html#map_image_to_map_rectangular_disk", "map_image_to_map_rectangular_disk", 'routine in <a href="nv/obj/map/map_image_to_map_rectangular_disk.html">map_image_to_map_rectangular_disk.pro</a>', "map_image_to_map_rectangular_disk.pro", "", "map_image_to_map_rectangular_disk", "", "validmdimage_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_image_to_map_ring.html", "map_image_to_map_ring.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_image_to_map_ring.pro", "", "", " NAME: 	map_image_to_map_ring    PURPOSE: 	Transforms the given image points to map coordinate points 	using a rectangular projection.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_pts = map_image_to_map_rectangular(md, image_pts)    ARGUMENTS:   INPUT: 	md	 	Array (nt) of MAP descriptors.  	image_pts:	Array (2,nv,nt) of map image points.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	valid:	Indices of all input points that correspond to valid 		output map points.  If not set then all points are 		valid.    RETURN: 	Array (2,nv,nt) of map coordinate points in a rectangular projection. 	In this projection, latitudes map linearly to the the y image 	direction, and longitudes map linearly to the x image direction.  	With:  		a = [size[1]/pi, size[0]/2pi] * scale * units,  	the transformation is:  		lat = (y - origin[1])/a[0] + center[0]  		lon = (x - origin[0])/a[1] + center[1]  	where the latitude equation is solved iteratively.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_image_to_map_ring.html#map_image_to_map_ring", "map_image_to_map_ring", 'routine in <a href="nv/obj/map/map_image_to_map_ring.html">map_image_to_map_ring.pro</a>', "map_image_to_map_ring.pro", "", "map_image_to_map_ring", "", "validmdimage_pts", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_image_to_map_ring.html#_map_image_to_map_rectangular", "_map_image_to_map_rectangular", 'routine in <a href="nv/obj/map/map_image_to_map_ring.html">map_image_to_map_ring.pro</a>', "map_image_to_map_ring.pro", "", "_map_image_to_map_rectangular", "", "validmdimage_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_image_to_map_sinusoidal.html", "map_image_to_map_sinusoidal.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_image_to_map_sinusoidal.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_image_to_map_sinusoidal.html#map_image_to_map_sinusoidal", "map_image_to_map_sinusoidal", 'routine in <a href="nv/obj/map/map_image_to_map_sinusoidal.html">map_image_to_map_sinusoidal.pro</a>', "map_image_to_map_sinusoidal.pro", "", "map_image_to_map_sinusoidal", "", "validmd_image_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_image_to_map_stereographic.html", "map_image_to_map_stereographic.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_image_to_map_stereographic.pro", "", "", " NAME: 	map_image_to_map_stereographic    PURPOSE: 	Transforms the given image points to map coordinate points 	using an stereographic projection.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_pts = map_image_to_map_stereographic(md, image_pts)    ARGUMENTS:   INPUT: 	md	 	Array (nt) of MAP descriptors.  	image_pts:	Array (2,nv,nt) of map image points.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	valid:	Indices of all input points that correspond to valid 		output map points.  If not set then all points are 		valid.    RETURN: 	Array (2,nv,nt) of map coordinate points in an stereographic 	projection.  This projection results from the projection through 	a sphere onto a plane, from a point on the surface of the sphere. 	Scale is true only at the map center.  Areas are distorted, 	especially away from the map center.  	With:  	  a = [size[0],size[1]]/4 * scale,  	and:  	  e = sqrt(1 - (A/(B+C)/2)^2),  	where A, B, and C are the triaxial ellipsoid radii, and:  	  m1 = cos(center[0]]) / sqrt(1 - e^2*sin(center[0])^2)  	  rho = sqrt(x^2 + y^2)  	  X1 = 2*atan(tan(pi/4 + center[0]/2) * 	       ((1 - e*sin(center[0]))/(1 + e*sin(center[0])))^(e/2)) - pi/2d  	  ce = 2*atan(rho*cos(X1), 2*a*scale*m1)  	  X = asin(cos(ce)*sin(X1) + y*sin(ce)*cos(X1)/rho)  	the transformation is:  	  2*atan(tan(pi/4 + X/2) * $ 	              ((1 + e*sin(lat))/(1 - e*sin(lat)))^(e/2) ) - pi/2  	  lon = center[1] + atan( x*sin(ce) / 	          rho*cos(X1)*cos(ce) - y*sin(X1)*sin(ce) ) / units[1]  	where the latitude equation is solved iteratively.  	See [1], p. 161 for the mathematical derivation.  	[1] Snyder (1987) 	    Map projections -- A working manual 	    USGS professional paper 1395    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_image_to_map_stereographic.html#imst_fn", "imst_fn", 'routine in <a href="nv/obj/map/map_image_to_map_stereographic.html">map_image_to_map_stereographic.pro</a>', "map_image_to_map_stereographic.pro", "", "imst_fn", "", "xdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_image_to_map_stereographic.html#map_image_to_map_stereographic", "map_image_to_map_stereographic", 'routine in <a href="nv/obj/map/map_image_to_map_stereographic.html">map_image_to_map_stereographic.pro</a>', "map_image_to_map_stereographic.pro", "", "map_image_to_map_stereographic", "", "validmd_image_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_lookup_defaults.html", "map_lookup_defaults.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_lookup_defaults.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_lookup_defaults.html#map_lookup_defaults", "map_lookup_defaults", 'routine in <a href="nv/obj/map/map_lookup_defaults.html">map_lookup_defaults.pro</a>', "map_lookup_defaults.pro", "", "map_lookup_defaults", "", "md0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_map_to_image.html", "map_map_to_image.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_map_to_image.pro", "", "", " NAME: 	map_map_to_image    PURPOSE: 	Transforms the given map points to map image points.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	image_pts = map_map_to_image(md, map_pts)    ARGUMENTS:   INPUT: 	md	 	Array (nt) of MAP descriptors.  	map_pts:	Array (2,nv,nt) of map points.    OUTPUT: NONE    KEYWORDS:   INPUT: 	nowrap:	If set, then points that lie outide the map will not be 		around to the other side.    OUTPUT: 	valid:	Indices of all input points that correspond to valid 		output image points.  If not se then all points are 		valid.    RETURN: 	Array (2,nv,nt) of map image points.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_map_to_image.html#map_map_to_image", "map_map_to_image", 'routine in <a href="nv/obj/map/map_map_to_image.html">map_map_to_image.pro</a>', "map_map_to_image.pro", "", "map_map_to_image", "", "validnowrapallmd_map_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_map_to_image_equatorial_ring.html", "map_map_to_image_equatorial_ring.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_map_to_image_equatorial_ring.pro", "", "", " NAME: 	map_map_to_image_rectangular    PURPOSE: 	Transforms the given map points to map image points using a 	rectangular projection.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	image_pts = map_map_to_image_rectangular(md, map_pts)    ARGUMENTS:   INPUT: 	md	 	Array (nt) of MAP descriptors.  	map_pts:	Array (2,nv,nt) of map points.    OUTPUT: NONE    KEYWORDS:   INPUT: 	nowrap:	If set, then points that lie outide the map will not be 		around to the other side.    OUTPUT: 	valid:	Indices of all input points that correspond to valid 		output image points.  If not se then all points are 		valid.    RETURN: 	Array (2,nv,nt) of map image points in a rectangular projection. 	In this projection, latitudes map linearly to the the y image 	direction, and longitudes map linearly to the x image direction.  	With:  		a = [size[1]/pi, size[0]/2pi] * scale * units,  	the transformation is:  		x = a[1] * (lon - center[1]) + origin[0]  		y = a[0] * (lat - center[0]) + origin[1]    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_map_to_image_equatorial_ring.html#map_map_to_image_equatorial_ring", "map_map_to_image_equatorial_ring", 'routine in <a href="nv/obj/map/map_map_to_image_equatorial_ring.html">map_map_to_image_equatorial_ring.pro</a>', "map_map_to_image_equatorial_ring.pro", "", "map_map_to_image_equatorial_ring", "", "mdmap_pts", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_map_to_image_equatorial_ring.html#_map_map_to_image_rectangular", "_map_map_to_image_rectangular", 'routine in <a href="nv/obj/map/map_map_to_image_equatorial_ring.html">map_map_to_image_equatorial_ring.pro</a>', "map_map_to_image_equatorial_ring.pro", "", "_map_map_to_image_rectangular", "", "validmdmap_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_map_to_image_mercator.html", "map_map_to_image_mercator.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_map_to_image_mercator.pro", "", "", " NAME: 	map_map_to_image_mercator    PURPOSE: 	Transforms the given map points to map image points using the 	mercator projection.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	image_pts = map_map_to_image_mercator(md, map_pts)    ARGUMENTS:   INPUT: 	md	 	Array (nt) of MAP descriptors.  	map_pts:	Array (2,nv,nt) of map points.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	valid:	Indices of all input points that correspond to valid 		output image points.  If not se then all points are 		valid.    RETURN: 	Array (2,nv,nt) of map coordinate points in a mercator projection. 	This projection results from projecting a sphere onto a cylinder 	that is tangent at the equator.  The scale is true along the equator 	only.  Areas are distorted, especially near the poles.  	With:  		a = [size[1]/pi, size[0]/2pi] * scale * units,  	and:  		e = sqrt(1 - (A/(B+C)/2)^2),  	where A, B, and C are the triaxial ellipsoid radii, the 	transformation is:  		x = a[1] * (lon - center[1]) + origin[0]  		y = a[0] * log( tan(pi/4 + lat/2) * 		  ( (1 - e*sin(lat))/(1 + e*sin(lat)) )^(e/2) ) + origin[1]   	See [1], p. 44 for the mathematical derivation.  	[1] Snyder (1987) 	    Map projections -- A working manual 	    USGS professional paper 1395    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_map_to_image_mercator.html#map_map_to_image_mercator", "map_map_to_image_mercator", 'routine in <a href="nv/obj/map/map_map_to_image_mercator.html">map_map_to_image_mercator.pro</a>', "map_map_to_image_mercator.pro", "", "map_map_to_image_mercator", "", "mdmap_pts", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_map_to_image_mercator.html#_map_map_to_image_mercator", "_map_map_to_image_mercator", 'routine in <a href="nv/obj/map/map_map_to_image_mercator.html">map_map_to_image_mercator.pro</a>', "map_map_to_image_mercator.pro", "", "_map_map_to_image_mercator", "", "validmdmap_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_map_to_image_mollweide.html", "map_map_to_image_mollweide.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_map_to_image_mollweide.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_map_to_image_mollweide.html#mimw_fn", "mimw_fn", 'routine in <a href="nv/obj/map/map_map_to_image_mollweide.html">map_map_to_image_mollweide.pro</a>', "map_map_to_image_mollweide.pro", "", "mimw_fn", "", "xdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_map_to_image_mollweide.html#map_map_to_image_mollweide", "map_map_to_image_mollweide", 'routine in <a href="nv/obj/map/map_map_to_image_mollweide.html">map_map_to_image_mollweide.pro</a>', "map_map_to_image_mollweide.pro", "", "map_map_to_image_mollweide", "", "mdmap_pts", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_map_to_image_mollweide.html#_map_map_to_image_mollweide", "_map_map_to_image_mollweide", 'routine in <a href="nv/obj/map/map_map_to_image_mollweide.html">map_map_to_image_mollweide.pro</a>', "map_map_to_image_mollweide.pro", "", "_map_map_to_image_mollweide", "", "validmdmap_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_map_to_image_orthographic.html", "map_map_to_image_orthographic.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_map_to_image_orthographic.pro", "", "", " NAME: 	map_map_to_image_orthographic    PURPOSE: 	Transforms the given map points to map image points using the 	orthographic projection.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	image_pts = map_map_to_image_orthographic(md, map_pts)    ARGUMENTS:   INPUT: 	md	 	Array (nt) of MAP descriptors.  	map_pts:	Array (2,nv,nt) of map points.    OUTPUT: NONE    KEYWORDS:   INPUT: 	nowrap:	If set, then points that lie outide the map will not be 		around to the other side.    OUTPUT: 	valid:	Indices of all input points that correspond to valid 		output image points.  If not se then all points are 		valid.    RETURN: 	Array (2,nv,nt) of map image points in an orthographic 	projection.  This projection portrays a planet as seen from a 	great distance.  Scale is true only at the map center.  Areas 	are distorted, especially away from the map center.  	With:  	  R = min(size[0],size[1])/2 * scale  	the transformation is:  	  x = R * cos(lat/units[0]) * sin(lon/units[1] 0 center[1]) + origin[0]  	  y = R * 	     ( cos(center[0])*sin(lat/units[0]) - 	        sin(center[0])*cos(lat/units[0])*cos(lon - center[1]) ) + 	                                                            origin[1]  	See [1], p. 149 for the mathematical derivation.  	[1] Snyder (1987) 	    Map projections -- A working manual 	    USGS professional paper 1395    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_map_to_image_orthographic.html#map_map_to_image_orthographic", "map_map_to_image_orthographic", 'routine in <a href="nv/obj/map/map_map_to_image_orthographic.html">map_map_to_image_orthographic.pro</a>', "map_map_to_image_orthographic.pro", "", "map_map_to_image_orthographic", "", "mdmap_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_map_to_image_orthographic_disk.html", "map_map_to_image_orthographic_disk.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_map_to_image_orthographic_disk.pro", "", "", " NAME: 	map_map_to_image_orthographic_disk    PURPOSE: 	Transforms the given map points to map image points using the 	orthographic projection on a disk.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	image_pts = map_map_to_image_orthographic_disk(md, map_pts)    ARGUMENTS:   INPUT: 	md	 	Array (nt) of MAP descriptors.  	map_pts:	Array (2,nv,nt) of map points.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	valid:	Indices of all input points that correspond to valid 		output image points.  If not se then all points are 		valid.    RETURN: 	Array (2,nv,nt) of map image points in an orthographic disk 	projection.  This projection portrays a disk as seen from a 	great distance.  Scale is uniform, but it is only true if the 	projection is polar.  Likewise, areas are distorted for non-polar 	projections.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_map_to_image_orthographic_disk.html#map_map_to_image_orthographic_disk", "map_map_to_image_orthographic_disk", 'routine in <a href="nv/obj/map/map_map_to_image_orthographic_disk.html">map_map_to_image_orthographic_disk.pro</a>', "map_map_to_image_orthographic_disk.pro", "", "map_map_to_image_orthographic_disk", "", "mdmap_pts", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_map_to_image_orthographic_disk.html#_map_map_to_image_orthographic_disk", "_map_map_to_image_orthographic_disk", 'routine in <a href="nv/obj/map/map_map_to_image_orthographic_disk.html">map_map_to_image_orthographic_disk.pro</a>', "map_map_to_image_orthographic_disk.pro", "", "_map_map_to_image_orthographic_disk", "", "validmdmap_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_map_to_image_rectangular.html", "map_map_to_image_rectangular.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_map_to_image_rectangular.pro", "", "", " NAME: 	map_map_to_image_rectangular    PURPOSE: 	Transforms the given map points to map image points using a 	rectangular projection.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	image_pts = map_map_to_image_rectangular(md, map_pts)    ARGUMENTS:   INPUT: 	md	 	Array (nt) of MAP descriptors.  	map_pts:	Array (2,nv,nt) of map points.    OUTPUT: NONE    KEYWORDS:   INPUT: 	nowrap:	If set, then points that lie outide the map will not be 		around to the other side.    OUTPUT: 	valid:	Indices of all input points that correspond to valid 		output image points.  If not se then all points are 		valid.    RETURN: 	Array (2,nv,nt) of map image points in a rectangular projection. 	In this projection, latitudes map linearly to the the y image 	direction, and longitudes map linearly to the x image direction.  	With:  		a = [size[1]/pi, size[0]/2pi] * scale * units,  	the transformation is:  		x = a[1] * (lon - center[1]) + origin[0]  		y = a[0] * (lat - center[0]) + origin[1]    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_map_to_image_rectangular.html#map_map_to_image_rectangular", "map_map_to_image_rectangular", 'routine in <a href="nv/obj/map/map_map_to_image_rectangular.html">map_map_to_image_rectangular.pro</a>', "map_map_to_image_rectangular.pro", "", "map_map_to_image_rectangular", "", "mdmap_pts", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_map_to_image_rectangular.html#_map_map_to_image_rectangular", "_map_map_to_image_rectangular", 'routine in <a href="nv/obj/map/map_map_to_image_rectangular.html">map_map_to_image_rectangular.pro</a>', "map_map_to_image_rectangular.pro", "", "_map_map_to_image_rectangular", "", "validmdmap_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_map_to_image_rectangular_disk.html", "map_map_to_image_rectangular_disk.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_map_to_image_rectangular_disk.pro", "", "", " NAME: 	map_map_to_image_rectangular_disk    PURPOSE: 	Transforms the given map points to map image points using a 	rectangular projection on a disk.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	image_pts = map_map_to_image_rectangular_disk(md, map_pts)    ARGUMENTS:   INPUT: 	md	 	Array (nt) of MAP descriptors.  	map_pts:	Array (2,nv,nt) of map points.    OUTPUT: NONE    KEYWORDS:   INPUT: 	nowrap:	If set, then points that lie outide the map will not be 		around to the other side.    OUTPUT: 	valid:	Indices of all input points that correspond to valid 		output image points.  If not se then all points are 		valid.    RETURN: 	Array (2,nv,nt) of map image points in a rectangular projection. 	In this projection, latitudes map linearly to the the y image 	direction, and longitudes map linearly to the x image direction.  	With:  		a = [size[1]/pi, size[0]/2pi] * scale * units,  	the transformation is:  		x = a[1] * (lon - center[1]) + origin[0]  		y = a[0] * (lat - center[0]) + origin[1]    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_map_to_image_rectangular_disk.html#map_map_to_image_rectangular_disk", "map_map_to_image_rectangular_disk", 'routine in <a href="nv/obj/map/map_map_to_image_rectangular_disk.html">map_map_to_image_rectangular_disk.pro</a>', "map_map_to_image_rectangular_disk.pro", "", "map_map_to_image_rectangular_disk", "", "mdmap_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_map_to_image_ring.html", "map_map_to_image_ring.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_map_to_image_ring.pro", "", "", " NAME: 	map_map_to_image_ring    PURPOSE: 	Transforms the given map points to map image points using a 	rectangular projection.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	image_pts = map_map_to_image_rectangular(md, map_pts)    ARGUMENTS:   INPUT: 	md	 	Array (nt) of MAP descriptors.  	map_pts:	Array (2,nv,nt) of map points.    OUTPUT: NONE    KEYWORDS:   INPUT: 	nowrap:	If set, then points that lie outide the map will not be 		around to the other side.    OUTPUT: 	valid:	Indices of all input points that correspond to valid 		output image points.  If not se then all points are 		valid.    RETURN: 	Array (2,nv,nt) of map image points in a rectangular projection. 	In this projection, latitudes map linearly to the the y image 	direction, and longitudes map linearly to the x image direction.  	With:  		a = [size[1]/pi, size[0]/2pi] * scale * units,  	the transformation is:  		x = a[1] * (lon - center[1]) + origin[0]  		y = a[0] * (lat - center[0]) + origin[1]    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_map_to_image_ring.html#map_map_to_image_ring", "map_map_to_image_ring", 'routine in <a href="nv/obj/map/map_map_to_image_ring.html">map_map_to_image_ring.pro</a>', "map_map_to_image_ring.pro", "", "map_map_to_image_ring", "", "mdmap_pts", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_map_to_image_ring.html#_map_map_to_image_rectangular", "_map_map_to_image_rectangular", 'routine in <a href="nv/obj/map/map_map_to_image_ring.html">map_map_to_image_ring.pro</a>', "map_map_to_image_ring.pro", "", "_map_map_to_image_rectangular", "", "validmdmap_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_map_to_image_sinusoidal.html", "map_map_to_image_sinusoidal.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_map_to_image_sinusoidal.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_map_to_image_sinusoidal.html#map_map_to_image_sinusoidal", "map_map_to_image_sinusoidal", 'routine in <a href="nv/obj/map/map_map_to_image_sinusoidal.html">map_map_to_image_sinusoidal.pro</a>', "map_map_to_image_sinusoidal.pro", "", "map_map_to_image_sinusoidal", "", "mdmap_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_map_to_image_stereographic.html", "map_map_to_image_stereographic.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_map_to_image_stereographic.pro", "", "", " NAME: 	map_map_to_image_stereographic    PURPOSE: 	Transforms the given map points to map image points using the 	stereographic projection.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	image_pts = map_map_to_image_stereographic(md, map_pts)    ARGUMENTS:   INPUT: 	md	 	Array (nt) of MAP descriptors.  	map_pts:	Array (2,nv,nt) of map points.    OUTPUT: NONE    KEYWORDS:   INPUT: 	nowrap:	If set, then points that lie outide the map will not be 		around to the other side.    OUTPUT: 	valid:	Indices of all input points that correspond to valid 		output image points.  If not se then all points are 		valid.    RETURN: 	Array (2,nv,nt) of map image points in an stereographic 	projection.  This projection results from the projection through 	a sphere onto a plane, from a point on the surface of the sphere. 	Scale is true only at the map center.  Areas are distorted, 	especially away from the map center.  	With:  	  a = [size[0],size[1]]/4 * scale,  	and:  	  e = sqrt(1 - (A/(B+C)/2)^2),  	where A, B, and C are the triaxial ellipsoid radii, and:  	  lat0 = lat / units[0]  	  lon0 = lon / units[1]  	  m1 = cos(center[0]]) / sqrt(1 - e^2*sin(center[0])^2)  	  X = 2*atan(tan(pi/4 + lat/2) * $ 	       ((1 - e*sin(lat0))/(1 + e*sin(lat0)))^(e/2)) - pi/2  	  X1 = 2*atan(tan(pi/4 + center[0]/2) * 	       ((1 - e*sin(center[0]))/(1 + e*sin(center[0])))^(e/2)) - pi/2d  	  A = 2*a*scale*m1 / 	   ( cos(X1)*(1 + sin(X1)*sin(X) + cos(X1)*cos(X)*cos(lon0 - center[1])) )  	the transformation is:  	  x = A * cos(X)*sin(lon0 - center[1]) + origin[0]  	  y = A * ( cos(X1)*sin(X) - sin(X1)*cos(X)*sin(lon0 - center[1]) ) + 	                                                              origin[1]  	See [1], p. 160 for the mathematical derivation.  	[1] Snyder (1987) 	    Map projections -- A working manual 	    USGS professional paper 1395    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_map_to_image_stereographic.html#map_map_to_image_stereographic", "map_map_to_image_stereographic", 'routine in <a href="nv/obj/map/map_map_to_image_stereographic.html">map_map_to_image_stereographic.pro</a>', "map_map_to_image_stereographic.pro", "", "map_map_to_image_stereographic", "", "mdmap_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_match_type.html", "map_match_type.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_match_type.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_match_type.html#map_match_type", "map_match_type", 'routine in <a href="nv/obj/map/map_match_type.html">map_match_type.pro</a>', "map_match_type.pro", "", "map_match_type", "", "_type", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_optimize.html", "map_optimize.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_optimize.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_optimize.html#map_optimize", "map_optimize", 'routine in <a href="nv/obj/map/map_optimize.html">map_optimize.pro</a>', "map_optimize.pro", "", "map_optimize", "", "mdtypesizeoriginlatminlonminradmin", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_origin.html", "map_origin.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_origin.pro", "", "", " NAME: 	map_origin    PURPOSE: 	Returns the origin for each given map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	origin = map_origin(md)    ARGUMENTS:   INPUT: NONE 	md:	 Array (nt) of map descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Array (2,nt) of origins associated with each given map descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_origin.html#map_origin", "map_origin", 'routine in <a href="nv/obj/map/map_origin.html">map_origin.pro</a>', "map_origin.pro", "", "map_origin", "", "noeventmd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_pole.html", "map_pole.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_pole.pro", "", "", " NAME: 	map_pole    PURPOSE: 	Returns the pole for each given map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	pole = map_pole(md)    ARGUMENTS:   INPUT: NONE 	md:	 Array (nt) of map descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Array (nt) of ominas_map_pole structs associated with each given map 	descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_pole.html#map_pole", "map_pole", 'routine in <a href="nv/obj/map/map_pole.html">map_pole.pro</a>', "map_pole.pro", "", "map_pole", "", "noeventmd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_query.html", "map_query.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_query.pro", "", "", " NAME: 	map_query    PURPOSE: 	Returns the fields associated with a MAP object.  This is a 	convenient way of getting multiple fields in one call, and only a 	single event is generated.    CATEGORY: 	NV/OBJ/MAP    CALLING SEQUENCE: 	map_query, md, <keywords>=<values>    ARGUMENTS:   INPUT: 	md:	MAP object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	MAP object fields to set.  	condition:	Structure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT object, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.  	cat:		If set, arrays from mulitple input objets are 			concatenated.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.  	noevent:	If set, no event is generated.    OUTPUT: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_query.html#map_query", "map_query", 'routine in <a href="nv/obj/map/map_query.html">map_query.pro</a>', "map_query.pro", "", "map_query", "", "conditioncatnoeventxd@map__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_radii.html", "map_radii.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_radii.pro", "", "", " NAME: 	map_radii    PURPOSE: 	Returns the rference radii for each given map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	radii = map_radii(md)    ARGUMENTS:   INPUT: NONE 	md:	 Array (nt) of map descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Array (3,nt) of refernce radii associated with each given map 	descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_radii.html#map_radii", "map_radii", 'routine in <a href="nv/obj/map/map_radii.html">map_radii.pro</a>', "map_radii.pro", "", "map_radii", "", "noeventmd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_radii_to_ecc.html", "map_radii_to_ecc.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_radii_to_ecc.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_radii_to_ecc.html#map_radii_to_ecc", "map_radii_to_ecc", 'routine in <a href="nv/obj/map/map_radii_to_ecc.html">map_radii_to_ecc.pro</a>', "map_radii_to_ecc.pro", "", "map_radii_to_ecc", "", "radradii", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_radii_to_ecc.html#___map_radii_to_ecc", "___map_radii_to_ecc", 'routine in <a href="nv/obj/map/map_radii_to_ecc.html">map_radii_to_ecc.pro</a>', "map_radii_to_ecc.pro", "", "___map_radii_to_ecc", "", "radii", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_range.html", "map_range.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_range.pro", "", "", " NAME: 	map_range    PURPOSE: 	Returns the range for each given map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	range = map_range(md)    ARGUMENTS:   INPUT: NONE 	md:	 Array (nt) of map descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Array (2,2,nt) of ranges associated with each given map descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_range.html#map_range", "map_range", 'routine in <a href="nv/obj/map/map_range.html">map_range.pro</a>', "map_range.pro", "", "map_range", "", "noeventmd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_replicate.html", "map_replicate.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_replicate.pro", "", "", " NAME: 	map_replicate    PURPOSE: 	Replicates the given descriptor, producing an array of the given 	dimensions containing cloned versions of the input descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	mds = map_replicate(md, dim)    ARGUMENTS:   INPUT: 	md:	 MAP descriptor.  	dim:	 Dimensions of the result.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Array of the given dimensions containing cloned versions of the input 	descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_replicate.html#map_replicate", "map_replicate", 'routine in <a href="nv/obj/map/map_replicate.html">map_replicate.pro</a>', "map_replicate.pro", "", "map_replicate", "", "mddim", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_rotate.html", "map_rotate.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_rotate.pro", "", "", " NAME: 	map_rotate    PURPOSE: 	Returns the rotate value for each given map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	rotate = map_rotate(md)    ARGUMENTS:   INPUT: NONE 	md:	 Array (nt) of map descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Array (nt) of rotate values associated with each given map descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_rotate.html#map_rotate", "map_rotate", 'routine in <a href="nv/obj/map/map_rotate.html">map_rotate.pro</a>', "map_rotate.pro", "", "map_rotate", "", "noeventmd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_scale.html", "map_scale.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_scale.pro", "", "", " NAME: 	map_scale    PURPOSE: 	Returns the scale factor for each given map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	scale = map_scale(md)    ARGUMENTS:   INPUT: NONE 	md:	 Array (nt) of map descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Array (nt) of scale factors associated with each given map descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_scale.html#map_scale", "map_scale", 'routine in <a href="nv/obj/map/map_scale.html">map_scale.pro</a>', "map_scale.pro", "", "map_scale", "", "noeventmd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/map_set_bounds.html", "map_set_bounds.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "map_set_bounds.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/map_set_bounds.html#map_set_bounds", "map_set_bounds", 'routine in <a href="nv/obj/tools/map_set_bounds.html">map_set_bounds.pro</a>', "map_set_bounds.pro", "", "map_set_bounds", "", "mdbounds", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_set_center.html", "map_set_center.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_set_center.pro", "", "", " NAME: 	map_set_center    PURPOSE: 	Replaces the center for each given map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_set_center, md, center    ARGUMENTS:   INPUT: 	md:	 Array (nt) of map descriptors.  	center:	 Array (2,nt) of new map centers.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_set_center.html#map_set_center", "map_set_center", 'routine in <a href="nv/obj/map/map_set_center.html">map_set_center.pro</a>', "map_set_center.pro", "", "map_set_center", "", "noeventmdcenter", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_set_fn_data.html", "map_set_fn_data.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_set_fn_data.pro", "", "", " NAME: 	map_set_fn_data    PURPOSE: 	Replaces the function data for a map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_set_fn_data, md, data    ARGUMENTS:   INPUT: 	md:	 Map descriptor.  	data:	 New function data.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Adapted by:	Spitale, 7/2016; adapted from map_set_fn_data_p   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_set_fn_data.html#map_set_fn_data", "map_set_fn_data", 'routine in <a href="nv/obj/map/map_set_fn_data.html">map_set_fn_data.pro</a>', "map_set_fn_data.pro", "", "map_set_fn_data", "", "noeventmddata", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_set_fn_image_to_map.html", "map_set_fn_image_to_map.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_set_fn_image_to_map.pro", "", "", " NAME: 	map_set_fn_image_to_map    PURPOSE: 	Replaces the name of the image->map function for each given map 	descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_set_fn_image_to_map, md, fn    ARGUMENTS:   INPUT: NONE 	md:	Array (nt) of map descriptors.  	fn:	Array (nt) of function names.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_set_fn_image_to_map.html#map_set_fn_image_to_map", "map_set_fn_image_to_map", 'routine in <a href="nv/obj/map/map_set_fn_image_to_map.html">map_set_fn_image_to_map.pro</a>', "map_set_fn_image_to_map.pro", "", "map_set_fn_image_to_map", "", "noeventmdfn", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_set_fn_map_to_image.html", "map_set_fn_map_to_image.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_set_fn_map_to_image.pro", "", "", " NAME: 	map_set_fn_map_to_image    PURPOSE: 	Replaces the name of the map->image function for each given map 	descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_set_fn_map_to_image, md, fn    ARGUMENTS:   INPUT: NONE 	md:	Array (nt) of map descriptors.  	fn:	Array (nt) of function names.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_set_fn_map_to_image.html#map_set_fn_map_to_image", "map_set_fn_map_to_image", 'routine in <a href="nv/obj/map/map_set_fn_map_to_image.html">map_set_fn_map_to_image.pro</a>', "map_set_fn_map_to_image.pro", "", "map_set_fn_map_to_image", "", "noeventmdfn", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_set_graphic.html", "map_set_graphic.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_set_graphic.pro", "", "", " NAME: 	map_set_graphic    PURPOSE: 	Replaces the graphic flag for each given map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_set_graphic, md, graphic    ARGUMENTS:   INPUT: 	md:	 Array (nt) of map descriptors.  	graphic:	 Array (nt) of new graphic flags.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_set_graphic.html#map_set_graphic", "map_set_graphic", 'routine in <a href="nv/obj/map/map_set_graphic.html">map_set_graphic.pro</a>', "map_set_graphic.pro", "", "map_set_graphic", "", "noeventmdgraphic", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_set_origin.html", "map_set_origin.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_set_origin.pro", "", "", " NAME: 	map_set_origin    PURPOSE: 	Replaces the origin for each given map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_set_origin, md, origin    ARGUMENTS:   INPUT: 	md:	 Array (nt) of map descriptors.  	origin:	 Array (2,nt) of new map origins.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_set_origin.html#map_set_origin", "map_set_origin", 'routine in <a href="nv/obj/map/map_set_origin.html">map_set_origin.pro</a>', "map_set_origin.pro", "", "map_set_origin", "", "noeventmdorigin", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_set_pole.html", "map_set_pole.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_set_pole.pro", "", "", " NAME: 	map_set_pole    PURPOSE: 	Replaces the pole for each given map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_set_pole, md, pole    ARGUMENTS:   INPUT: 	md:	 Array (nt) of map descriptors.  	pole:	 Array (nt) of new ominas_map_pole structs.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_set_pole.html#map_set_pole", "map_set_pole", 'routine in <a href="nv/obj/map/map_set_pole.html">map_set_pole.pro</a>', "map_set_pole.pro", "", "map_set_pole", "", "noeventmdpole", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_set_radii.html", "map_set_radii.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_set_radii.pro", "", "", " NAME: 	map_set_radii    PURPOSE: 	Replaces the reference radii for each given map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_set_radii, md, radii    ARGUMENTS:   INPUT: 	md:	 Array (nt) of map descriptors.  	radii:	 Array (3,nt) of new reference radii.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_set_radii.html#map_set_radii", "map_set_radii", 'routine in <a href="nv/obj/map/map_set_radii.html">map_set_radii.pro</a>', "map_set_radii.pro", "", "map_set_radii", "", "noeventmdradii", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_set_range.html", "map_set_range.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_set_range.pro", "", "", " NAME: 	map_set_range    PURPOSE: 	Replaces the range for each given map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_set_range, md, range    ARGUMENTS:   INPUT: 	md:	 Array (nt) of map descriptors.  	range:	 Array (2,2,nt) of new map ranges.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_set_range.html#map_set_range", "map_set_range", 'routine in <a href="nv/obj/map/map_set_range.html">map_set_range.pro</a>', "map_set_range.pro", "", "map_set_range", "", "noeventmdrange", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_set_rotate.html", "map_set_rotate.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_set_rotate.pro", "", "", " NAME: 	map_set_rotate    PURPOSE: 	Replaces the rotate value for each given map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_set_rotate, md, rotate    ARGUMENTS:   INPUT: 	md:	 Array (nt) of map descriptors.  	rotate:	 Array (nt) of new rotate values.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_set_rotate.html#map_set_rotate", "map_set_rotate", 'routine in <a href="nv/obj/map/map_set_rotate.html">map_set_rotate.pro</a>', "map_set_rotate.pro", "", "map_set_rotate", "", "noeventmdrotate", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_set_scale.html", "map_set_scale.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_set_scale.pro", "", "", " NAME: 	map_set_scale    PURPOSE: 	Replaces the scale factor for each given map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_set_scale, md, scale    ARGUMENTS:   INPUT: 	md:	 Array (nt) of map descriptors.  	scale:	 Array (2,nt) of new scale factors.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_set_scale.html#map_set_scale", "map_set_scale", 'routine in <a href="nv/obj/map/map_set_scale.html">map_set_scale.pro</a>', "map_set_scale.pro", "", "map_set_scale", "", "noeventmdscale", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_set_size.html", "map_set_size.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_set_size.pro", "", "", " NAME: 	map_set_size    PURPOSE: 	Replaces the size for each given map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_set_size, md, size    ARGUMENTS:   INPUT: 	md:	 Array (nt) of map descriptors.  	size:	 Array (2,nt) of new map sizes.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_set_size.html#map_set_size", "map_set_size", 'routine in <a href="nv/obj/map/map_set_size.html">map_set_size.pro</a>', "map_set_size.pro", "", "map_set_size", "", "noeventmdsize", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_set_type.html", "map_set_type.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_set_type.pro", "", "", " NAME: 	map_set_type    PURPOSE: 	Replaces the type name for each given map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_set_type, md, type    ARGUMENTS:   INPUT: 	md:	 Array (nt) of map descriptors.  	type:	 Array (nt) of new type names.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_set_type.html#map_set_type", "map_set_type", 'routine in <a href="nv/obj/map/map_set_type.html">map_set_type.pro</a>', "map_set_type.pro", "", "map_set_type", "", "noeventmdtype", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_set_units.html", "map_set_units.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_set_units.pro", "", "", " NAME: 	map_set_units    PURPOSE: 	Replaces the units for each given map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	map_set_units, md, units    ARGUMENTS:   INPUT: 	md:	 Array (nt) of map descriptors.  	units:	 Array (2,nt) of new map units.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_set_units.html#map_set_units", "map_set_units", 'routine in <a href="nv/obj/map/map_set_units.html">map_set_units.pro</a>', "map_set_units.pro", "", "map_set_units", "", "noeventmdunits", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_size.html", "map_size.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_size.pro", "", "", " NAME: 	map_size    PURPOSE: 	Returns the size for each given map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	size = map_size(md)    ARGUMENTS:   INPUT: NONE 	md:	 Array (nt) of map descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Array (2,nt) of sizes associated with each given map descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_size.html#map_size", "map_size", 'routine in <a href="nv/obj/map/map_size.html">map_size.pro</a>', "map_size.pro", "", "map_size", "", "noeventmd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/composite/map_to_disk.html", "map_to_disk.pro", '.pro file in <a href="nv/obj/tools/composite/dir-overview.html">nv/obj/tools/composite/ directory</a>', "map_to_disk.pro", "", "", " NAME:        map_to_disk    PURPOSE:        Transforms points in map coordinates to disk coordinates.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = map_to_disk(md, dkx, map_pts)    ARGUMENTS:   INPUT: 	md:	Array of nt map descriptors.  	dkx:	Array of nt disk descriptors.  	map_pts:       Array (2 x nv x nt) of map points    OUTPUT:        NONE   KEYWORDS:    INPUT: NONE     OUTPUT: NONE    RETURN:        Array (nv x 3 x nt) of disk coordinates, with the altitude coordinate set to 	zero.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/composite/map_to_disk.html#map_to_disk", "map_to_disk", 'routine in <a href="nv/obj/tools/composite/map_to_disk.html">map_to_disk.pro</a>', "map_to_disk.pro", "", "map_to_disk", "", "mddkdmap_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/composite/map_to_globe.html", "map_to_globe.pro", '.pro file in <a href="nv/obj/tools/composite/dir-overview.html">nv/obj/tools/composite/ directory</a>', "map_to_globe.pro", "", "", " NAME:        map_to_globe    PURPOSE:        Transforms points in map coordinates to surface coordinates.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = map_to_globe(md, gbx, map_pts)    ARGUMENTS:   INPUT: 	md:	Array of nt map descriptors.  	gbx:	Array of nt globe descriptors.  	map_pts:	Array (2 x nv x nt) of map points    OUTPUT:        NONE   KEYWORDS:    INPUT: NONE     OUTPUT: NONE    RETURN:        Array (nv x 3 x nt) of globe coordinates, with the altitude coordinate set to 	zero.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/composite/map_to_globe.html#map_to_globe", "map_to_globe", 'routine in <a href="nv/obj/tools/composite/map_to_globe.html">map_to_globe.pro</a>', "map_to_globe.pro", "", "map_to_globe", "", "mdgbxmap_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/composite/map_to_image.html", "map_to_image.pro", '.pro file in <a href="nv/obj/tools/composite/dir-overview.html">nv/obj/tools/composite/ directory</a>', "map_to_image.pro", "", "", " NAME:        map_to_image    PURPOSE:        Transforms points from map coordinates to image coordinates.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:         result = map_to_image(md, cd, bx, map_pts)    ARGUMENTS:   INPUT: 	md:	Array of nt map descriptors describing the initial coordinate system. 		If bx is given, then this descriptor is not needed, though 		it may still be used to select between graphic/centric 		latitudes.  	cd:	Array of nt camera or map descriptor describing the final 		coordinate system.  	bx:	Array of nt Object descriptors (subclass of BODY).  	map_pts:       Array (2 x nv x nt) of map points    OUTPUT:        NONE   KEYWORDS:    INPUT: 	valid:	Indices of valid output points.  	body_pts:	Body coordinates of output points.      OUTPUT: NONE    RETURN:        Array (2 x nv x nt) of image points.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/composite/map_to_image.html#map_to_image", "map_to_image", 'routine in <a href="nv/obj/tools/composite/map_to_image.html">map_to_image.pro</a>', "map_to_image.pro", "", "map_to_image", "", "body_ptsvalidmdcdbxmap_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/composite/map_to_surface.html", "map_to_surface.pro", '.pro file in <a href="nv/obj/tools/composite/dir-overview.html">nv/obj/tools/composite/ directory</a>', "map_to_surface.pro", "", "", " NAME:        map_to_surface    PURPOSE:        Transforms points in map coordinates to surface coordinates.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = map_to_surface(md, bx, map_pts)    ARGUMENTS:   INPUT: 	md:	Array of nt map descriptors.  	bx:	Array of nt object descriptors (subclass of BODY.  	map_pts:	Array (2 x nv x nt) of map points    OUTPUT:        NONE   KEYWORDS:    INPUT: NONE     OUTPUT: NONE    RETURN:        Array (nv x 3 x nt) of surface coordinates, with the altitude coordinate 	set to zero.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/composite/map_to_surface.html#map_to_surface", "map_to_surface", 'routine in <a href="nv/obj/tools/composite/map_to_surface.html">map_to_surface.pro</a>', "map_to_surface.pro", "", "map_to_surface", "", "mdbxmap_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_type.html", "map_type.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_type.pro", "", "", " NAME: 	map_type    PURPOSE: 	Returns the type name for each given map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	type = map_type(md)    ARGUMENTS:   INPUT: NONE 	md:	 Array (nt) of map descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Array (nt) of type names associated with each given map descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_type.html#map_type", "map_type", 'routine in <a href="nv/obj/map/map_type.html">map_type.pro</a>', "map_type.pro", "", "map_type", "", "noeventmd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/map_unfold.html", "map_unfold.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "map_unfold.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/map_unfold.html#map_unfold", "map_unfold", 'routine in <a href="nv/obj/tools/map_unfold.html">map_unfold.pro</a>', "map_unfold.pro", "", "map_unfold", "", "mdmd0map0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_units.html", "map_units.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_units.pro", "", "", " NAME: 	map_units    PURPOSE: 	Returns the units for each given map descriptor.    CATEGORY: 	NV/LIB/MAP    CALLING SEQUENCE: 	units = map_units(md)    ARGUMENTS:   INPUT: NONE 	md:	 Array (nt) of map descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Array (2,nt) of units associated with each given map descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_units.html#map_units", "map_units", 'routine in <a href="nv/obj/map/map_units.html">map_units.pro</a>', "map_units.pro", "", "map_units", "", "noeventmd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/map_units_disk.html", "map_units_disk.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "map_units_disk.pro", "", "", " NAME:        map_units_disk    PURPOSE: 	Computes units for a map descriptor given pixel scales for 	the map center.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        v = map_units_disk(md, resrad=resrad, reslon=reslon)    ARGUMENTS:   INPUT: 	md:	Map descriptor.    OUTPUT:  NONE    KEYWORDS:   INPUT: 	resrad:	Scale (length/pixel) in radial direction.  	reslon:	Scale (radians/pixel) in longitude direction.    OUTPUT: NONE    RETURN: 	Array (2) giving the map units.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/map_units_disk.html#map_units_disk", "map_units_disk", 'routine in <a href="nv/obj/tools/map_units_disk.html">map_units_disk.pro</a>', "map_units_disk.pro", "", "map_units_disk", "", "resradreslonmd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_valid_points_equatorial_ring.html", "map_valid_points_equatorial_ring.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_valid_points_equatorial_ring.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_valid_points_equatorial_ring.html#map_valid_points_equatorial_ring", "map_valid_points_equatorial_ring", 'routine in <a href="nv/obj/map/map_valid_points_equatorial_ring.html">map_valid_points_equatorial_ring.pro</a>', "map_valid_points_equatorial_ring.pro", "", "map_valid_points_equatorial_ring", "", "_mdmap_ptsimage_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/map_valid_points_ring.html", "map_valid_points_ring.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "map_valid_points_ring.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/map_valid_points_ring.html#map_valid_points_ring", "map_valid_points_ring", 'routine in <a href="nv/obj/map/map_valid_points_ring.html">map_valid_points_ring.pro</a>', "map_valid_points_ring.pro", "", "map_valid_points_ring", "", "_mdmap_ptsimage_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/mask_globe.html", "mask_globe.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "mask_globe.pro", "", "", " NAME:        mask_globe    PURPOSE: 	Computes an image mask for a globe.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        result = mask_globe(cd, gbx)    ARGUMENTS:   INPUT: 	cd:	Camera descriptor.  	gbx:	Any subclass of GLOBE.    OUTPUT:  NONE    KEYOWRDS:   INPUT: 	slop:	Fractional amount by which to increase the globe 		radii before computing the mask.  	oversample:	Factor by wich to oversample the grid to reduce 			aliasing.    OUTPUT: NONE    RETURN:        Angle in radians.     MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/mask_globe.html#mask_globe", "mask_globe", 'routine in <a href="nv/obj/tools/mask_globe.html">mask_globe.pro</a>', "mask_globe.pro", "", "mask_globe", "", "oversampleslopsubcd_gbx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/mask_points.html", "mask_points.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "mask_points.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/mask_points.html#mask_points", "mask_points", 'routine in <a href="util/mask_points.html">mask_points.pro</a>', "mask_points.pro", "", "mask_points", "", "mask", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/match_bitmask.html", "match_bitmask.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "match_bitmask.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/match_bitmask.html#match_bitmask", "match_bitmask", 'routine in <a href="util/match_bitmask.html">match_bitmask.pro</a>', "match_bitmask.pro", "", "match_bitmask", "", "flagsmask", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/maxdev.html", "maxdev.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "maxdev.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/maxdev.html#maxdev", "maxdev", 'routine in <a href="util/maxdev.html">maxdev.pro</a>', "maxdev.pro", "", "maxdev", "", "x", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/maximize_flux.html", "maximize_flux.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "maximize_flux.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/maximize_flux.html#mxfx_show", "mxfx_show", 'routine in <a href="util/maximize_flux.html">maximize_flux.pro</a>', "maximize_flux.pro", "", "mxfx_show", "", "imageoutline_ptstshow", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/maximize_flux.html#mxfx_compute_flux", "mxfx_compute_flux", 'routine in <a href="util/maximize_flux.html">maximize_flux.pro</a>', "maximize_flux.pro", "", "mxfx_compute_flux", "", "cornersnormfluxext_fluxext_indicesindicesimageoutline_ptst", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/maximize_flux.html#maximize_flux", "maximize_flux", 'routine in <a href="util/maximize_flux.html">maximize_flux.pro</a>', "maximize_flux.pro", "", "maximize_flux", "", "shownsamplesnohomecornerskill_charregiondatawxwyno_widthbiasfn_shownsigfluxext_fluxnofitverboseimageoutline_ptscorrelation", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/mbfit.html", "mbfit.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "mbfit.pro", "", "", " NAME: 	mbfit    PURPOSE: 	Performs a simultaneous least square fit using the given coefficients.    CATEGORY: 	UTIL    CALLING SEQUENCE: 	result = mbfit(M, b)    ARGUMENTS:   INPUT: 	M:	Array (3,3,n) of coefficient matrices as computed by 		icv_coeff or ipt_coeff.  Coefficients from the two sources 		may be mixed.  	b:	Array (n,3) of coefficient vectors as computed by 		icv_coeff or ipt_coeff.  Coefficients from the two sources 		may be mixed.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	3-element vector giving the offset as [dx,dy,dtheta].    PROCEDURE: 	The simultaneous fit is performed by solving the system of equations  				SM x = Sb,  	where SM and Sb represent the sums of the M and b arguments over the 	'n' dimension respectively, and x is the return vector, [dx,dy,dtheta].    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/mbfit.html#mbfit", "mbfit", 'routine in <a href="util/mbfit.html">mbfit.pro</a>', "mbfit.pro", "", "mbfit", "", "Mb", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/mfact.html", "mfact.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "mfact.pro", "", "", " NAME:        mfact    PURPOSE:        Computes the factorial of each element of x    CATEGORY:        UTIL    CALLING SEQUENCE:        result = mfact(x)    ARGUMENTS:   INPUT:            x:  Float or double matrix    OUTPUT:        NONE    RETURN:        Array of factorials for each element of x    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/mfact.html#mfact", "mfact", 'routine in <a href="util/mfact.html">mfact.pro</a>', "mfact.pro", "", "mfact", "", "_x", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/min_angle.html", "min_angle.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "min_angle.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/min_angle.html#min_angle", "min_angle", 'routine in <a href="util/min_angle.html">min_angle.pro</a>', "min_angle.pro", "", "min_angle", "", "theta1theta2", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/minmax_latlon.html", "minmax_latlon.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "minmax_latlon.pro", "", "", " NAME:        minmax_latlon    PURPOSE: 	Computes latitide/longitude ranges visible in a given camera.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        minmax_latlon, cd, gbx, dkx    ARGUMENTS:   INPUT: 	cd:	Camera descriptor.  	gbx:	Globe descriptor.  	dkx:	Disk descriptor, for hiding points.    OUTPUT:  NONE    KEYWORDS:   INPUT: 	slop:	Amount by which to expand image border for search.    OUTPUT: 	latmin:	Southernmost latitude visible.  	latmax:	Northernmost latitude visible.  	lonmin:	Westernmost longitude visible.  	lonmax:	Easternmost longitude visible.    RETURN: NONE    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/minmax_latlon.html#minmax_latlon", "minmax_latlon", 'routine in <a href="nv/obj/tools/minmax_latlon.html">minmax_latlon.pro</a>', "minmax_latlon.pro", "", "minmax_latlon", "", "sloplatminlatmaxlonminlonmaxstatuscdpdrd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/fits/mkhdr.html", "mkhdr.pro", '.pro file in <a href="config/fits/dir-overview.html">config/fits/ directory</a>', "mkhdr.pro", "", "", " NAME: 	mkhdr    PURPOSE: 	Make a minimal primary FITS image header or a minimal FITS IMAGE 	extension header.    CATEGORY: 	UTIL/FITS    CALLING SEQUENCE: 	mkhdr, header 	mkhdr, header, im, [ /IMAGE, /EXTEND ] 	mkhdr, header, type, naxisx, [/IMAGE, /EXTEND ]    ARGUMENTS:   INPUT: 	im:	If im is a vector or array then the header will be made 		appropiate to the size and type of im.  im does not have 		to be the actual data; it can be a dummy array of the same 		type and size as the data.    Set im = '' to create a dummy 		header with NAXIS = 0.  	type:	If more than 2 parameters are supplied, then the second 		parameter is intepreted as an integer giving the IDL datatype 		e.g. 1 - LOGICAL*1, 2 - INTEGER*2, 4 - REAL*4, 3 - INTEGER*4.  	naxisx:	Vector giving the size of each dimension (naxis1, naxis2, 		etc.).    OUTPUT: 	header:	Image header, (string array) with required keywords 		BITPIX, NAXIS, NAXIS1, ... Further keywords can be added 		to the header with SXADDPAR.   KEYWORDS:   INPUT: 	image:	If set, then a minimal header for a FITS IMAGE extension 		is created.    An IMAGE extension header is identical to 		a primary FITS header except the first keyword is 		'XTENSION' = 'IMAGE' instead of 'SIMPLE  ' = 'T'.  	extend:	If set, then the keyword EXTEND is inserted into the file, 		with the value of  T  (true).    OUTPUT: NONE    RETURN: NONE    RESTRICTIONS: 	(1)  MKHDR should not be used to make an STSDAS header or a FITS 		ASCII or Binary Table header.   Instead use  		SXHMAKE - to create a minimal STSDAS header 		FXHMAKE - to create a minimal FITS binary table header 		FTCREATE - to create a minimal FITS ASCII table header  	(2)  Any data already in the header before calling MKHDR 		will be destroyed.    EXAMPLE: 	Create a minimal FITS header, HDR, for a 30 x 40 x 50 INTEGER*2 array  	      IDL> MKHDR, HDR, 2, [30,40,50]  	Alternatively, if the array already exists as an IDL variable, ARRAY,  	       IDL> MKHDR, HDR, ARRAY    STATUS: 	Complete    SEE ALSO: 	sxaddpar, sxdelpar, sxpar    MODIFICATION HISTORY:     Written November, 1988               W. Landsman     May, 1990, Adapted for IDL Version 2.0, J. Isensee   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/fits/mkhdr.html#mkhdr", "mkhdr", 'routine in <a href="config/fits/mkhdr.html">mkhdr.pro</a>', "mkhdr.pro", "", "mkhdr", "", "IMAGEEXTENDheaderimnaxisx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/mmm_to_mm.html", "mmm_to_mm.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "mmm_to_mm.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/mmm_to_mm.html#mmm_to_mm", "mmm_to_mm", 'routine in <a href="util/mmm_to_mm.html">mmm_to_mm.pro</a>', "mmm_to_mm.pro", "", "mmm_to_mm", "", "_mmm", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/modfit.html", "modfit.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "modfit.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/modfit.html#modfit_eval", "modfit_eval", 'routine in <a href="util/modfit.html">modfit.pro</a>', "modfit.pro", "", "modfit_eval", "", "xafnpder", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/modfit.html#modfit", "modfit", 'routine in <a href="util/modfit.html">modfit.pro</a>', "modfit.pro", "", "modfit", "", "dxysamplescaleoffsetchisqsig_scalesig_offsetsig_dxy_image_model", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/modloc.html", "modloc.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "modloc.pro", "", "", " NAME:        modloc    PURPOSE:        Finds points in the image at which the correlation with the        given model is high.    CATEGORY:        UTIL    CALLING SEQUENCE:        result = modloc(image, model, edge=edge, ccmin=ccmin, gdmax=gdmax)    ARGUMENTS:   INPUT:        image:  Input image.         model:  2-D array giving a model of the reseau image.     OUTPUT:        NONE   KEYWORDS:   INPUT:         edge:  Distance from edge within which points are ignored.         ccmin:  Minimum correlation coefficient to accept.  Default is 0.8.         gdmax:  If given, the maximum gradiant of correlation coefficient 		to accept.  	dmax:	Maximum number of resultant points allowed within any region 		of the image of size dbin * (size of the model).  Default is 2.  	dbin:	Binning factor size for computing point density, default is 2.        double:  If set, image is converted to double in the function,                otherwise it is converted to float.     OUTPUT:        NONE    RETURN:        The points (x,y) in the image that best fits the model.  Returns 0        if no points are found.   PROCEDURE: 	Modloc first computes computes maps of the correlation coefficient 	between the model and the image with the model centered at each point 	as well as the gradient of the correlation coefficient at each point. 	Points with high correlation and low gradient are selected as 	candidates.  To select the final points, the point density is computed 	using a bin size of twice the size of the model and points within 	regions containing more than dmax candidates are deselected.     STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/modloc.html#modloc", "modloc", 'routine in <a href="util/modloc.html">modloc.pro</a>', "modloc.pro", "", "modloc", "", "edgeccmingdmaxdmaxdbindouble_imagemodel", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/mosaic.html", "mosaic.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "mosaic.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/mosaic.html#mosaic", "mosaic", 'routine in <a href="nv/obj/tools/mosaic.html">mosaic.pro</a>', "mosaic.pro", "", "mosaic", "", "combine_fnwt_fnsdatamosaicweightmaps", "          -1", "");
  
  

libdata[libdataItem++] = new Array("demo/mosaic_example.html", "mosaic_example.pro", '.pro file in <a href="demo/dir-overview.html">demo/ directory</a>', "mosaic_example.pro", "", "", " MOSAIC EXAMPLE     This example requires the following kernel files, which are    included in the demo's data directory: <span class= code-output > $CAS_SPICE_CK/001103_001105ra.bc</span> <span class= code-output > $CAS_SPICE_CK/001105_001108.bc</span> <span class= code-output > $CAS_SPICE_CK/001026_001029ra.bc</span> <span class= code-output > $CAS_SPICE_CK/001029_001031ra.bc</span>    This example file demonstrates how to construct a mosaic using OMINAS.    This example file can be executed from the UNIX command line using:   	  ominas mosaic_example     or from within an OMINAS IDL session using:   	  @mosaic_example     After the example stops, later code samples in this file may be executed by    pasting them onto the IDL command line.   Read and display image  ;    This first section uses dat_read to read in the image and then displays    the image using tvim.     dat_read reads the image portion (im) and the label (label) and returns a    data descriptor (dd) containing the image and label and information obtained    through OMINAS' configuration tables.  If a file exists in the same directory    and with the same name as the image, except with the extension  .dh ,    then it is assumed to be a detached header and it is read as well.     The files w1352097259.1 and n1352037683.2 are Cassini wide- and narrow-    angle frames of Jupiter.  2000r.img and 2100r.img are Galileo SSI    images of Ganymede.     ctmod is called to reserve several colors in the case of an 8-bit display.     tvim is called to display the image (im) in a new window with the y    coordinate as top-down: <span class= code-output > files = getenv('OMINAS_DIR')+'/demo/data/'+['n1350122987.2','/n1351469359.2']</span> <span class= code-output > n = n_elements(files)</span>  <span class= code-output > dd = dat_read(files, input_transform='cas_delut')</span>  <span class= code-output > zoom = 0.3</span> <span class= code-output > for i=0, n-1 do tvim, dat_data(dd[i]), zoom=zoom, /order, /new</span> <span class= code-output > tvim, /list, wnum=ww</span>              Get camera, planets, rings and sun objects: <span class= code-output > _gd = {cd:obj_new(), gbx:obj_new(), dkx:obj_new(), sund:obj_new()}</span> <span class= code-output > gd = replicate(_gd, n)</span>  <span class= code-output > for i=0, n-1 do gd[i].cd = pg_get_cameras(dd[i])</span> <span class= code-output > for i=0, n-1 do gd[i].gbx = pg_get_planets(dd[i], od=gd[i].cd, name='JUPITER')</span> <span class= code-output > for i=0, n-1 do gd[i].dkx = pg_get_rings(dd[i], pd=gd[i].gbx, od=gd[i].cd)</span> <span class= code-output > for i=0, n-1 do gd[i].sund = pg_get_stars(dd[i], od=gd[i].cd, name='SUN')</span>    Compute limb: <span class= code-output > limb_ptd = objarr(n)</span> <span class= code-output > for i=0, n-1 do limb_ptd[i] = pg_limb(gd=gd[i])</span>   Navigate on limbs automatically     pg_farfit finds the limb to within a few pixels.  In reality, you would    want to refine the pointing by scanning for the limb and performing a    least-squares fit, but for the purposes of clarity in this example, the    inital fit will do: <span class= code-output > edge_ptd = objarr(n)</span> <span class= code-output > for i=0, n-1 do edge_ptd[i] = pg_edges(dd[i], edge=10)</span>    Run pg_farfit to obtain the offsets between the computed points (limb_ptd)    and the image edges (edge_ptd) and apply the offsets with pg_repoint: <span class= code-output > dxy = dblarr(2,n)</span> <span class= code-output > for i=0, n-1 do dxy[*,i] = pg_farfit(dd[i], edge_ptd[i], [limb_ptd[i]], ns=[5,5])</span> <span class= code-output > for i=0, n-1 do pg_repoint, dxy[*,i], 0d, gd=gd[i]</span>    Recompute the geometry now that the pointing was corrected: <span class= code-output > for i=0, n-1 do limb_ptd[i] = pg_limb(gd=gd[i])</span> <span class= code-output > for i=0, n-1 do  pg_draw, limb_ptd[i], wnum=ww[i]</span>              See jup_cassini.example and dione.example for examples    of least-squares fits to image features    Correct photometry     Here, a crude photometric correction is performed for the purposes    of this example.     In addition to the corrected images, the output descriptors, dd_pht,    will contain the photometric angles in their user data arrays with    the names 'EMM', 'INC' and 'PHASE': <span class= code-output > dd_pht = objarr(n)</span> <span class= code-output > for i=0, n-1 do dd_pht[i] = pg_photom(dd[i], gd=gd[i], $</span> <span class= code-output >   refl_fn='pht_refl_minneart',refl_parm=[0.9d], outline=limb_ptd[i])</span>  <span class= code-output > for i=0, n-1 do tvim, dat_data(dd_pht[i]), ww[i]</span>             Project maps     Note that all map projections use the same map descriptor.     Also, aux=['EMM'] is used with pg_map to direct it to reproject    the emmision angle array that was produced and stored in the data descriptor    by pg_photom.  That array will be needed by pg_mosaic: <span class= code-output > map_xsize = 800</span> <span class= code-output > map_ysize = 400</span>    Create the map descriptor to use for the projections: <span class= code-output > md = pg_get_maps(/over, gbx = pd1, $</span> <span class= code-output >   name='JUPITER',$</span> <span class= code-output >   type='RECTANGULAR', $</span> <span class= code-output >   fn_data=ptr_new(), $</span> <span class= code-output >   size=[map_xsize,map_ysize], $</span> <span class= code-output >   origin=[map_xsize,map_ysize]/2 )</span>  <span class= code-output > Do the map projections, frmo objects dd_pht, using map descriptor md:</span>      dd_map = objarr(n)      for i=0, n-1 do dd_map[i] = pg_map(dd_pht[i], md=md, gd=gd[i], aux=['EMM'])     Display the results: <span class= code-output > for i=0, n-1 do tvim, dat_data(dd_map[i]), /new</span>             Introducing wind profiles   Use the commented commands instead to include a zonal wind profile in  the projection: <span class= code-output > for i=0, n-1 do $</span> <span class= code-output >   dd_map[i] = pg_map(dd_pht[i], md=md, gd=gd[i], aux=['EMM'], $</span> <span class= code-output >   wind_fn='pm_wind_zonal', $</span> <span class= code-output >   wind_data={vel:cos((dindgen(181)-90)*!dpi/180d) * 100d, $</span> <span class= code-output >   dt:bod_time(gd[i].cd)-bod_time(gd[0].cd)})</span>   Construct the mosaic     The combination function 'emm' combines the maps    using wighting proprtional to emm^x, where emm is the emmision    cosine.  It also imposes a minimum emmision cosine, emm0.  Note    that the emission angles were computed by pg_photom and    reprojected by pg_map, as directed by the 'aux' keyword: <span class= code-output > dd_mosaic = pg_mosaic(dd_map, mosaic=mosaic, $</span> <span class= code-output >   wt='emm', comb='sum', data={x:5, emm0:cos(85d*!dpi/180d)})</span> <span class= code-output > tvim, mosaic, /new</span>        Save the mosaic and map info     To read the mosaic and projection info: <span class= code-output > dd = dat_read('./data/test.msc', mosaic, label)</span> <span class= code-output > md = pg_get_maps(dd)</span>  ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("nv/obj/tools/move_points.html", "move_points.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "move_points.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/move_points.html#move_points", "move_points", 'routine in <a href="nv/obj/tools/move_points.html">move_points.pro</a>', "move_points.pro", "", "move_points", "", "axispointsdxydtheta", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/gen/movegen.html", "movegen.pro", '.pro file in <a href="util/gen/dir-overview.html">util/gen/ directory</a>', "movegen.pro", "", "", " NAME: 	movegen    PURPOSE: 	Generates an array of subscripts to move the desired column or row 	in an array with dimensions n x m.   CATEGORY: 	UTIL/GEN    CALLING SEQUENCE: 	sub = movegen(n, m, w1, w2)    ARGUMENTS:   INPUT: 	n,m:		Dimensions of array from which to select.  	w1:		Index of column or row to move.  	w2:		Index giving new position of column or row.    OUTPUT: NONE    KEYWORDS:   INPUT: 	column:		If set, a column is moved (default).  	row:		If set, a row is moved.    OUTPUT: NONE    RETURN: 	Array (n x m) of subscripts that will move the row or column.     STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/gen/movegen.html#movegen", "movegen", 'routine in <a href="util/gen/movegen.html">movegen.pro</a>', "movegen.pro", "", "movegen", "", "rowcolumnnmw1w2", "          -1", "");
  
  

libdata[libdataItem++] = new Array("demo/multiinstrument_example.html", "multiinstrument_example.pro", '.pro file in <a href="demo/dir-overview.html">demo/ directory</a>', "multiinstrument_example.pro", "", "", " MULTI-INSTRUMENT EXAMPLE     This script demonstrates reading Cassini RADAR SAR, VIMS and ISS images and    projecting them onto an orthographical map for display as a RGB composite.     The SAR data file used, BIFQI22N068_D045_T003S01_V02.IMG, is too large (202 MB)    to include with the OMINAS distribution. This script will look for the file    under ~/ominas_data/sar/, and if not found, will download it from    PDS&lt;http://pds-imaging.jpl.nasa.gov/data/cassini/cassini_orbiter/CORADR_0045/DATA/BIDR/BIFQI22N068_D045_T003S01_V02.ZIP&gt;,    then unzip it.     Setup: The instrument detectors, translators and transforms must contain the    RADAR, ISS and VIMS definitions, as is included in demo/data/instrument_detectors.tab,    demo/data/translators.tab, and demo/data/transforms.tab. The PDS detector    and io functions must also be set up    in the corresponding tables, as is in config/tab/filetype_detectors.tab    and config/tab/io.tab.     This example requires SPICE/Icy to have been setup. It can be run just by doing: <span class= code-output > .run multiinstrument_example</span>    From within an OMINAS IDL session.     Troubleshooting: This example uses ISS, VIMS and RADAR data, so each of these    3 might independently fail. If this example fails, it may be helpful to try first    running the 3 individual instrument's example scripts first: jupiter_example.pro (ISS),    vims_example.pro and radar_example.pro, to see which instruments work in your    setup and which do not.   Read and display SAR file     Download the Cassini RADAR SAR image and unzip it, if needed: <span class= code-output > ;Download the SAR file, if needed</span> <span class= code-output > ldir='~/ominas_data/sar'</span> <span class= code-output > spawn,'eval echo '+ldir,res</span> <span class= code-output > ldir=res</span> <span class= code-output > img=ldir+path_sep()+'BIFQI22N068_D045_T003S01_V02.IMG'</span> <span class= code-output > if ~file_test(img,/read) then begin</span> <span class= code-output >   print,'SAR file needed for the demo not found. Downloading it from PDS...'</span> <span class= code-output >   p=pp_wget('http://pds-imaging.jpl.nasa.gov/data/cassini/cassini_orbiter/CORADR_0045/DATA/BIDR/BIFQI22N068_D045_T003S01_V02.ZIP',localdir=ldir)</span> <span class= code-output >   p.geturl</span> <span class= code-output >   print,'ZIP file downloaded, decompressing it...'</span> <span class= code-output >   file_unzip,ldir+path_sep()+'CORADR_0045/DATA/BIDR/BIFQI22N068_D045_T003S01_V02.ZIP',/verbose</span> <span class= code-output > endif</span> <span class= code-output > ;Read the file</span> <span class= code-output > dd=dat_read(img)</span>    Saturate the data to make the image better looking, since this is just for display    purposes: <span class= code-output > da=dat_data(dd)</span> <span class= code-output > dat_set_data,dd,0&gt;da&lt;1d0</span>    Show it a 1/20 resolution: <span class= code-output > tvim,0d0&gt;da&lt;1d0,zoom=0.05,/order,/new</span>        ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("demo/multimission_example.html", "multimission_example.pro", '.pro file in <a href="demo/dir-overview.html">demo/ directory</a>', "multimission_example.pro", "", "", " MULTI-MISSION EXAMPLE     Created by Joe Spitale     Feb 2017      This example file loads images from various missions onto planes of a     GRIM window and computes the centers of all available planets for each     image to demonstrates OMINAS' multi-mission capabilities.      This example file can be executed from the UNIX command line using: <span class= code-output >ominas multimission_example.pro</span>     or from within an OMINAS IDL session using: <span class= code-output >@multimission_example.pro</span>    Load the 3 images into grim, with planet centers as overlays: <span class= code-output > grim, over='planet_center', dat_read(getenv('OMINAS_DIR')+'/demo/data/'+ $</span> <span class= code-output > ['N1350122987_2.IMG','2100r.img','c3440346.gem'])</span>    The Jupiter observation (from Cassini, the first one displayed in grim) looks like:          And the Ganymede observation (from Galileo) looks like:          (that image is in the second plane in grim: use the     Plane-&gt;next menu option, or click the black double right-arrow button on the left     side of the top toolbar to switch planes)     And the Saturn observation (from Voyager) looks like:          (that image is in the third plane in grim: use the     Plane-&gt;next menu option, or click the black double right-arrow button on the left     side of the top toolbar to switch planes)  ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("util/mvbits.html", "mvbits.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "mvbits.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/mvbits.html#mvbits", "mvbits", 'routine in <a href="util/mvbits.html">mvbits.pro</a>', "mvbits.pro", "", "mvbits", "", "fromfromposlentopos", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/gen/mxgen.html", "mxgen.pro", '.pro file in <a href="util/gen/dir-overview.html">util/gen/ directory</a>', "mxgen.pro", "", "", " NAME: 	mxgen    PURPOSE:  	Generates 1d subscripts for an array of nn m-element column vectors 	such that subscripting the array of vectors will produce an array of 	nn n x m matrices with the given vectors forming the columns of the 	resulting matrices.    CATEGORY: 	UTIL/GEN    CALLING SEQUENCE: 	sub = mxgen(n, m, nn)    ARGUMENTS:   INPUT: 	n:	 Number of matrix columns.  	m: 	 Number of matrix rows.  	nn:	 Number of matrices.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Array (n x m x nn) of subscripts.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/gen/mxgen.html#mxgen", "mxgen", 'routine in <a href="util/gen/mxgen.html">mxgen.pro</a>', "mxgen.pro", "", "mxgen", "", "nmnn", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/n_where.html", "n_where.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "n_where.pro", "", "", " NAME:        n_where    PURPOSE:        Finds subscripts where an element in the first array matches        elements in the second input array.  This routine differs 	from nwhere in that 1) it works as advertised, and 2) it uses 	array operations for a faster search.  Also, this routine 	works only for numeric types.    CATEGORY:        UTIL    CALLING SEQUENCE:        result = n_where(ref, list)    ARGUMENTS:   INPUT:         ref:  Reference array         list:  Comparison array.     OUTPUT:        NONE   KEYWORDS:        NONE    RETURN:        An array of subscripts in list that match something in ref.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/n_where.html#n_where", "n_where", 'routine in <a href="util/n_where.html">n_where.pro</a>', "n_where.pro", "", "n_where", "", "reflist", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/nd_to_w.html", "nd_to_w.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "nd_to_w.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/nd_to_w.html#nd_to_w", "nd_to_w", 'routine in <a href="util/nd_to_w.html">nd_to_w.pro</a>', "nd_to_w.pro", "", "nd_to_w", "", "dimp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/near_points.html", "near_points.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "near_points.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/near_points.html#near_points", "near_points", 'routine in <a href="util/near_points.html">near_points.pro</a>', "near_points.pro", "", "near_points", "", "ptsxptsxrad", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/new.readpds.html", "new.readpds.pro", '.pro file in <a href="config/pds/Readpds_4.4/dir-overview.html">config/pds/Readpds_4.4/ directory</a>', "new.readpds.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/new.readpds.html#get_all_objects", "get_all_objects", 'routine in <a href="config/pds/Readpds_4.4/new.readpds.html">new.readpds.pro</a>', "new.readpds.pro", "", "get_all_objects", "", "label", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/new.readpds.html#dotable", "dotable", 'routine in <a href="config/pds/Readpds_4.4/new.readpds.html">new.readpds.pro</a>', "new.readpds.pro", "", "dotable", "", "fnamelabelstobjindex", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/new.readpds.html#doarrcol", "doarrcol", 'routine in <a href="config/pds/Readpds_4.4/new.readpds.html">new.readpds.pro</a>', "new.readpds.pro", "", "doarrcol", "", "fnamelabelstobjindex", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/new.readpds.html#readpds", "readpds", 'routine in <a href="config/pds/Readpds_4.4/new.readpds.html">new.readpds.pro</a>', "new.readpds.pro", "", "readpds", "", "SILENTNOSCALEHISTOGRAMfilename", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/ngaussfit.html", "ngaussfit.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "ngaussfit.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/ngaussfit.html#ngf_gaussian", "ngf_gaussian", 'routine in <a href="util/ngaussfit.html">ngaussfit.pro</a>', "ngaussfit.pro", "", "ngf_gaussian", "", "xcoeff", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/ngaussfit.html#ngf_dgaussian", "ngf_dgaussian", 'routine in <a href="util/ngaussfit.html">ngaussfit.pro</a>', "ngaussfit.pro", "", "ngf_dgaussian", "", "a0a1a2xcoeff", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/ngaussfit.html#ngf_eval", "ngf_eval", 'routine in <a href="util/ngaussfit.html">ngaussfit.pro</a>', "ngaussfit.pro", "", "ngf_eval", "", "xcoeffresultpder", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/ngaussfit.html#ngaussfit", "ngaussfit", 'routine in <a href="util/ngaussfit.html">ngaussfit.pro</a>', "ngaussfit.pro", "", "ngaussfit", "", "chisqitmaxyyxycoeff", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/nlfit.html", "nlfit.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "nlfit.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/nlfit.html#nlf_print_free_params", "nlf_print_free_params", 'routine in <a href="util/nlfit.html">nlfit.pro</a>', "nlfit.pro", "", "nlf_print_free_params", "", "state", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/nlfit.html#nlf_print_covariance", "nlf_print_covariance", 'routine in <a href="util/nlfit.html">nlfit.pro</a>', "nlfit.pro", "", "nlf_print_covariance", "", "sigmanormstatecov", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/nlfit.html#nlf_print_results", "nlf_print_results", 'routine in <a href="util/nlfit.html">nlfit.pro</a>', "nlfit.pro", "", "nlf_print_results", "", "covnormsigresrms_sigrms_natstatechisqreduced_chisq", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/nlfit.html#nlf_compute_beta", "nlf_compute_beta", 'routine in <a href="util/nlfit.html">nlfit.pro</a>', "nlfit.pro", "", "nlf_compute_beta", "", "state", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/nlfit.html#nlf_compute_alpha", "nlf_compute_alpha", 'routine in <a href="util/nlfit.html">nlfit.pro</a>', "nlfit.pro", "", "nlf_compute_alpha", "", "state", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/nlfit.html#nlf_covariance", "nlf_covariance", 'routine in <a href="util/nlfit.html">nlfit.pro</a>', "nlfit.pro", "", "nlf_covariance", "", "sigmanormstate", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/nlfit.html#nlf_fit_statistics", "nlf_fit_statistics", 'routine in <a href="util/nlfit.html">nlfit.pro</a>', "nlfit.pro", "", "nlf_fit_statistics", "", "covnormsigrms_sigrms_natstatechisq", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/nlfit.html#nlf_show", "nlf_show", 'routine in <a href="util/nlfit.html">nlfit.pro</a>', "nlfit.pro", "", "nlf_show", "", "statechisq", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/nlfit.html#nint_newtfn", "nint_newtfn", 'routine in <a href="util/nlfit.html">nlfit.pro</a>', "nlfit.pro", "", "nint_newtfn", "", "x0", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/nlfit.html#nlf_interp", "nlf_interp", 'routine in <a href="util/nlfit.html">nlfit.pro</a>', "nlfit.pro", "", "nlf_interp", "", "statealphabeta", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/nlfit.html#nlf_step", "nlf_step", 'routine in <a href="util/nlfit.html">nlfit.pro</a>', "nlfit.pro", "", "nlf_step", "", "statedelta", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/nlfit.html#nlf_test_abort", "nlf_test_abort", 'routine in <a href="util/nlfit.html">nlfit.pro</a>', "nlfit.pro", "", "nlf_test_abort", "", "state", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/nlfit.html#nlf_compute_chisq", "nlf_compute_chisq", 'routine in <a href="util/nlfit.html">nlfit.pro</a>', "nlfit.pro", "", "nlf_compute_chisq", "", "state", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/nlfit.html#nlf_compute_state", "nlf_compute_state", 'routine in <a href="util/nlfit.html">nlfit.pro</a>', "nlfit.pro", "", "nlf_compute_state", "", "statusstate", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/nlfit.html#nlf_minimize", "nlf_minimize", 'routine in <a href="util/nlfit.html">nlfit.pro</a>', "nlfit.pro", "", "nlf_minimize", "", "epsilonntriessilentstate", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/nlfit.html#nlfit", "nlfit", 'routine in <a href="util/nlfit.html">nlfit.pro</a>', "nlfit.pro", "", "nlfit", "", "silentnokbchisqrmsepsilonntriesfnlabelsxysigyparmsigparm", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/nmax.html", "nmax.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "nmax.pro", "", "", " NAME:        nmax    PURPOSE:        Finds maximum values within many arrays.    CATEGORY:        UTIL    CALLING SEQUENCE:        result = nmax(array, direction, subscripts=subscripts)    ARGUMENTS:   INPUT:          array:  Array to search for maximum values.       direction:  Dimension to search.     OUTPUT:        NONE   KEYWORDS:     subscripts: Coordinate of each maximum value relative to the                 scanning dimension.    RETURN:        An array of maximum values.   EXAMPLE: 	If x is an array with dimensions (d0,d1,d2), then the command  		xm = nmax(x, 1, sub=sub)  	returns an array with dimensions (d0,1,d2), where each value is 	the maximum value along the scanned direction (direction 1).    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale; 1/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/nmax.html#nmax", "nmax", 'routine in <a href="util/nmax.html">nmax.pro</a>', "nmax.pro", "", "nmax", "", "subscripts__arraydir", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/nmin.html", "nmin.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "nmin.pro", "", "", " NAME:        nmin    PURPOSE:        Finds minimum values within many arrays.    CATEGORY:        UTIL    CALLING SEQUENCE:        result = nmin(array, direction, subscripts=subscripts)    ARGUMENTS:   INPUT:          array:  Array to search for minimum values.       direction:  Dimension to search.     OUTPUT:        NONE   KEYWORDS:     subscripts: Coordinate of each minimum value relative to the                 scanning dimension.    RETURN:        An array of minimum values.   EXAMPLE: 	If x is an array with dimensions (d0,d1,d2), then the command  		xm = nmin(x, 1, sub=sub)  	returns an array with dimensions (d0,1,d2), where each value is 	the minimum value along the scanned direction (direction 1).    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale; 1/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/nmin.html#nmin", "nmin", 'routine in <a href="util/nmin.html">nmin.pro</a>', "nmin.pro", "", "nmin", "", "subscriptspositive__arraydir", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/nnwhere.html", "nnwhere.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "nnwhere.pro", "", "", " NAME:        nnwhere    PURPOSE:        Finds subscripts where an element in the first array matches        elements in the second input array.    CATEGORY:        UTIL    CALLING SEQUENCE:        result = nnwhere(ref, list)    ARGUMENTS:   INPUT:         ref:  Reference array         list:  Comparison array.     OUTPUT:        NONE   KEYWORDS:        NONE    RETURN:        An array of subscripts in list that match something in ref.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/nnwhere.html#nnwhere", "nnwhere", 'routine in <a href="util/nnwhere.html">nnwhere.pro</a>', "nnwhere.pro", "", "nnwhere", "", "reflist", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/nround.html", "nround.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "nround.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/nround.html#nround", "nround", 'routine in <a href="util/nround.html">nround.pro</a>', "nround.pro", "", "nround", "", "figstringx_n", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/ntrace.html", "ntrace.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "ntrace.pro", "", "", " NAME:        ntrace    PURPOSE:        Computes the traces of square matrices    CATEGORY:        UTIL    CALLING SEQUENCE:        result = ntrace(matrix)    ARGUMENTS:   INPUT:        matrix:         Array (n,n,m) of nxn matrices.    OUTPUT:        NONE    RETURN:        Array (m) giving the traces of the matrices.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/ntrace.html#ntrace", "ntrace", 'routine in <a href="util/ntrace.html">ntrace.pro</a>', "ntrace.pro", "", "ntrace", "", "matrix", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/sys/util/nv_clone.html", "nv_clone.pro", '.pro file in <a href="nv/sys/util/dir-overview.html">nv/sys/util/ directory</a>', "nv_clone.pro", "", "", " NAME: 	nv_clone    PURPOSE:        Allocates a new object as a copy of the given (existing) 	object.  All pointers in the new object are newly allocated.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	new_xd = nv_clone(xd)    ARGUMENTS:   INPUT: 	xd:	 Object to clone.  May be any pointer or structure.    OUTPUT: NONE    KEYWORDS:   INPUT: 	protect: 		String array giving the names of fields to be copied rather 		than cloned.    OUTPUT: NONE    RETURN:        Newly created object with all fields identical to        the input object, and new pointers.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/sys/util/nv_clone.html#nv_clone_match", "nv_clone_match", 'routine in <a href="nv/sys/util/nv_clone.html">nv_clone.pro</a>', "nv_clone.pro", "", "nv_clone_match", "", "protecttag", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/sys/util/nv_clone.html#nv_clone_recurse", "nv_clone_recurse", 'routine in <a href="nv/sys/util/nv_clone.html">nv_clone.pro</a>', "nv_clone.pro", "", "nv_clone_recurse", "", "protectxd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/sys/util/nv_clone.html#nv_clone", "nv_clone", 'routine in <a href="nv/sys/util/nv_clone.html">nv_clone.pro</a>', "nv_clone.pro", "", "nv_clone", "", "noeventprotectxd0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/sys/event/nv_compress_events.html", "nv_compress_events.pro", '.pro file in <a href="nv/sys/event/dir-overview.html">nv/sys/event/ directory</a>', "nv_compress_events.pro", "", "", " NAME: 	nv_compress_events    PURPOSE: 	Returns only unique events from the given buffer.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	events = nv_compress_events(buf)    ARGUMENTS:   INPUT: 	buf:	Array of nv_event_struct.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	All events in buf that are unique.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/sys/event/nv_compress_events.html#nv_compress_events", "nv_compress_events", 'routine in <a href="nv/sys/event/nv_compress_events.html">nv_compress_events.pro</a>', "nv_compress_events.pro", "", "nv_compress_events", "", "buf", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/sys/util/nv_copy.html", "nv_copy.pro", '.pro file in <a href="nv/sys/util/dir-overview.html">nv/sys/util/ directory</a>', "nv_copy.pro", "", "", " NAME: 	nv_copy    PURPOSE: 	Copies all fields from one descriptor to another.  New pointers 	are allocated only when the destination field is null.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	nv_copy, dst_xd, src_xd    ARGUMENTS:   INPUT: 	dst_xd:	 Object to copy to.  	src_xd:	 Object to copy from.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN:  NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale		3/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/sys/util/nv_copy.html#nv_copy_is_scalar", "nv_copy_is_scalar", 'routine in <a href="nv/sys/util/nv_copy.html">nv_copy.pro</a>', "nv_copy.pro", "", "nv_copy_is_scalar", "", "x", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/sys/util/nv_copy.html#nv_copy_recurse", "nv_copy_recurse", 'routine in <a href="nv/sys/util/nv_copy.html">nv_copy.pro</a>', "nv_copy.pro", "", "nv_copy_recurse", "", "allocdst_xdsrc_xd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/sys/util/nv_copy.html#nv_copy", "nv_copy", 'routine in <a href="nv/sys/util/nv_copy.html">nv_copy.pro</a>', "nv_copy.pro", "", "nv_copy", "", "noeventdst_xdsrc_xd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/sys/util/nv_debug.html", "nv_debug.pro", '.pro file in <a href="nv/sys/util/dir-overview.html">nv/sys/util/ directory</a>', "nv_debug.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/sys/util/nv_debug.html#nv_debug", "nv_debug", 'routine in <a href="nv/sys/util/nv_debug.html">nv_debug.pro</a>', "nv_debug.pro", "", "nv_debug", "", "ptr_trackingptr_listptr_callsptr_call_level", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/sys/util/nv_directive_stop__define.html", "nv_directive_stop__define.pro", '.pro file in <a href="nv/sys/util/dir-overview.html">nv/sys/util/ directory</a>', "nv_directive_stop__define.pro", "", "", " NAME: 	nv_directive_stop__define    PURPOSE: 	Structure defining the NV_STOP directive.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	N/A    FIELDS: 	directive:	String giving the directive.     STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/sys/util/nv_directive_stop__define.html#nv_directive_stop__define", "nv_directive_stop__define", 'routine in <a href="nv/sys/util/nv_directive_stop__define.html">nv_directive_stop__define.pro</a>', "nv_directive_stop__define.pro", "", "nv_directive_stop__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/sys/event/nv_event_struct__define.html", "nv_event_struct__define.pro", '.pro file in <a href="nv/sys/event/dir-overview.html">nv/sys/event/ directory</a>', "nv_event_struct__define.pro", "", "", " NAME: 	nv_event_struct__define    PURPOSE: 	Structure defining the NV data event.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	N/A    FIELDS: 	xd:		Descriptor affected by this event.  	handler:	Name of event handler procedure, which should accept 			an array of events as its only argument.  	data_p:		Pointer to associated user data.  	data:		Scalar user data.  	desc:		String giving a description of the event.  	type:		Event type: 0 = set value, 1 = get_value.       STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/sys/event/nv_event_struct__define.html#nv_event_struct__define", "nv_event_struct__define", 'routine in <a href="nv/sys/event/nv_event_struct__define.html">nv_event_struct__define.pro</a>', "nv_event_struct__define.pro", "", "nv_event_struct__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/sys/event/nv_flush.html", "nv_flush.pro", '.pro file in <a href="nv/sys/event/dir-overview.html">nv/sys/event/ directory</a>', "nv_flush.pro", "", "", " NAME: 	nv_flush    PURPOSE: 	Flushes the nv event buffer.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	nv_flush    ARGUMENTS:   INPUT: 	events:	If specified, these events are processed instead of those in 		the event buffer.    KEYWORDS: NONE    RETURN: 	NONE    PROCEDURE: 	Events are compressed so that duplicate events are not reported.  Each 	unique handler is called once with all of the relevant events given.    COMMON BLOCKS: 	nv_notify_block    STATUS: 	Complete    SEE ALSO: 	nv_notify    MODIFICATION HISTORY:  	Written by:	Spitale, 11/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/sys/event/nv_flush.html#nv_flush", "nv_flush", 'routine in <a href="nv/sys/event/nv_flush.html">nv_flush.pro</a>', "nv_flush.pro", "", "nv_flush", "", "clearevents", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/sys/util/nv_free.html", "nv_free.pro", '.pro file in <a href="nv/sys/util/dir-overview.html">nv/sys/util/ directory</a>', "nv_free.pro", "", "", " NAME: 	nv_free    PURPOSE: 	Recursively frees a descriptor.  Pointers and structures are 	dereferenced and descended, freeing any pointers encountered.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	nv_free, p    ARGUMENTS:   INPUT: 	p:	Pointer or structure.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/sys/util/nv_free.html#nvf_recurse", "nvf_recurse", 'routine in <a href="nv/sys/util/nv_free.html">nv_free.pro</a>', "nv_free.pro", "", "nvf_recurse", "", "p", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/sys/util/nv_free.html#nv_free", "nv_free", 'routine in <a href="nv/sys/util/nv_free.html">nv_free.pro</a>', "nv_free.pro", "", "nv_free", "", "dp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/sys/util/nv_help.html", "nv_help.pro", '.pro file in <a href="nv/sys/util/dir-overview.html">nv/sys/util/ directory</a>', "nv_help.pro", "", "", " NAME: 	nv_help    PURPOSE: 	Prints information about various OMINAS objects.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	nv_help, p    ARGUMENTS:   INPUT: 	p:	Object to query.  Actions that depend on this input are 		as follows:  		 p		action 		 ---------------------------------------------------- 		 No value	Print the full paths of all NV tables. 		 Numeric	Call IDL finction 'help'. 		 Ptr or struct	Descend recursively, printing info on all 				fields. 		 String		Assumes p is the name of an OMINAS routine 				and prints the documentation page if 				available.     OUTPUT: NONE    KEYWORDS:   INPUT: 	event:		If set, the event tables are printed and p 			is ignored.    OUTPUT: 	capture:	If present, the output in returned in this 			keyword instead of being printed.    ENVIRONMENT VARIABLES: 	OMINAS_DIR:	OMINAS top directory; used to find documentation files.    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/sys/util/nv_help.html#nv_help_print", "nv_help_print", 'routine in <a href="nv/sys/util/nv_help.html">nv_help.pro</a>', "nv_help.pro", "", "nv_help_print", "", "captures", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/sys/util/nv_help.html#nv_help_sep", "nv_help_sep", 'routine in <a href="nv/sys/util/nv_help.html">nv_help.pro</a>', "nv_help.pro", "", "nv_help_sep", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/sys/util/nv_help.html#nv_help_state", "nv_help_state", 'routine in <a href="nv/sys/util/nv_help.html">nv_help.pro</a>', "nv_help.pro", "", "nv_help_state", "", "capture", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/sys/util/nv_help.html#nv_help_descend", "nv_help_descend", 'routine in <a href="nv/sys/util/nv_help.html">nv_help.pro</a>', "nv_help.pro", "", "nv_help_descend", "", "capturedp0indentstringindex", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/sys/util/nv_help.html#nv_help_dump_events", "nv_help_dump_events", 'routine in <a href="nv/sys/util/nv_help.html">nv_help.pro</a>', "nv_help.pro", "", "nv_help_dump_events", "", "captureitems", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/sys/util/nv_help.html#nv_help_event", "nv_help_event", 'routine in <a href="nv/sys/util/nv_help.html">nv_help.pro</a>', "nv_help.pro", "", "nv_help_event", "", "capture", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/sys/util/nv_help.html#nv_help_doc", "nv_help_doc", 'routine in <a href="nv/sys/util/nv_help.html">nv_help.pro</a>', "nv_help.pro", "", "nv_help_doc", "", "capturename", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/sys/util/nv_help.html#nv_help", "nv_help", 'routine in <a href="nv/sys/util/nv_help.html">nv_help.pro</a>', "nv_help.pro", "", "nv_help", "", "captureeventdp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/sys/state/nv_init_state.html", "nv_init_state.pro", '.pro file in <a href="nv/sys/state/dir-overview.html">nv/sys/state/ directory</a>', "nv_init_state.pro", "", "", " NAME: 	nv_init_state    PURPOSE: 	Initializes the NV state structure.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	state = nv_init_state()    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	New nv_state structure.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/sys/state/nv_init_state.html#nv_init_state", "nv_init_state", 'routine in <a href="nv/sys/state/nv_init_state.html">nv_init_state.pro</a>', "nv_init_state.pro", "", "nv_init_state", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/sys/util/nv_message.html", "nv_message.pro", '.pro file in <a href="nv/sys/util/dir-overview.html">nv/sys/util/ directory</a>', "nv_message.pro", "", "", " NAME: 	nv_message    PURPOSE: 	Prints an error message and halts execution.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	nv_message, string    ARGUMENTS:   INPUT: 	string:	Message to print.    OUTPUT: NONE    KEYWORDS:   INPUT: 	name:		Name to use for the calling routine instead of 			taking it from the traceback list.  	anonymous:	If set, the traaceback list is not used to infer the 			name of the calling routine.  In this case, a name 			is printed nly if explicitly specified using the 'name' 			keyword.  	continue:	If set, execution is not halted.  	stop:		If set, execution is halted in nv_message.  	get_message:	If set, the last message sent through nv_message 			is returned in the _string keyword and no other 			action is taken.  	clear:		If set, the last message is cleared and no other action 			is taken.  	cb_tag:		If set, the callback procedure below is added to 			the cllaback list under this tag name and no other 			action is taken.  	cb_data_p:	Pointer to data for the callback procedure.  	callback:	Name of a callback procedure to add to the callback 			list.  Callback procedures are sent two arguments: 			cb_data_p (see above), and the message string.  	disconnect:	If set, the callback identified by the given cb_tag 			is removed from the callback list and no other 			action is taken.  	explanation:	String giving an extended explanation for the message.  	verbose:	Floating value in the range 0 to 1 specifying the 			verbosity threshold.  If set, and no string is given, 			then the threshold is set to this value.  If a string 			is given, then it will only be printed if this 			value is greater than or equal to current verbosity 			level.  Setting this keyword implies /continue. 			Verbosity threshold rules of thumb are as follows:  			 0.1:	Useful messages that you don't always need to see; 				files being loaded, written, etc. 			 0.5:	Useful messages that you want to see even less; 				file-not-found warnings, etc. 			 0.9:	Debugging messages that don't produce huge 				outputs. 			 1.0:	Mega debugging messages that may create 				huge outputs.  Your short message will get lost 				in this output, so use 0.9 instead.    	silent:		Suppressed printing of messages.  	format:		Format string.     OUTPUT: 	message:	If /get_message, this keyword will return the last 			message sent through nv_message.    ENVIRONMENT VARIABLES: 	NV_VERBOSITY:	Initial verbosity setting.    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/sys/util/nv_message.html#nv_message", "nv_message", 'routine in <a href="nv/sys/util/nv_message.html">nv_message.pro</a>', "nv_message.pro", "", "nv_message", "", "nameanonymouscontinueclearget_messageformatmessageexplanationcallbackcb_data_pdisconnectcb_tagverbosesilentstopstring", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/sys/event/nv_notify.html", "nv_notify.pro", '.pro file in <a href="nv/sys/event/dir-overview.html">nv/sys/event/ directory</a>', "nv_notify.pro", "", "", " NAME: 	nv_notify    PURPOSE: 	Notify nv system of an event on some set of descriptors.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	nv_notify, xd, type=type    ARGUMENTS:   INPUT: 	xd:	Descriptor for which an event has occurred.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	type:	Type of event: 		 0 - set value 		 1 - get value 		This input can have only one element.  If not given, the 		event type is assumed to be 0.  	flush:	Flush the write event buffer -- call the handlers for each 		unique event only once and clear the buffer.  	noevent: If set, nothing is done.    OUTPUT: 	NONE    RETURN: 	NONE    PROCEDURE: 	By default, write events are buffered.  Handlers for write events are 	only called when /flush is specified.  For read events, all event 	handlers of the specified type are called as procedures with an  	nv_event_struct as the argument.    COMMON BLOCKS: 	nv_notify_block    STATUS: 	Complete    SEE ALSO: 	nv_notify_register, nv_notify_unregister    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/sys/event/nv_notify.html#nv_notify", "nv_notify", 'routine in <a href="nv/sys/event/nv_notify.html">nv_notify.pro</a>', "nv_notify.pro", "", "nv_notify", "", "typedescflushnoeventxd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/sys/event/nv_notify_list_struct__define.html", "nv_notify_list_struct__define.pro", '.pro file in <a href="nv/sys/event/dir-overview.html">nv/sys/event/ directory</a>', "nv_notify_list_struct__define.pro", "", "", " NAME: 	nv_notify_list_struct__define    PURPOSE: 	Structure defining an entry in the NV event registry.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	N/A    FIELDS: 	xd:		Descriptor affected by this event.  	handler:	Name of event handler procedure, which should accept 			an array of events as its only argument.  	data_p:		Pointer to associated user data.  	data:		Scalar user data.  	desc:		String giving a description of the event.  	type:		Event type: 0 = set value, 1 = get_value.  	compress:	If 1, compress events.  	dynamic:	1 if a pointer was allocated for the descriptor 			in this entry.       STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/sys/event/nv_notify_list_struct__define.html#nv_notify_list_struct__define", "nv_notify_list_struct__define", 'routine in <a href="nv/sys/event/nv_notify_list_struct__define.html">nv_notify_list_struct__define.pro</a>', "nv_notify_list_struct__define.pro", "", "nv_notify_list_struct__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/sys/event/nv_notify_register.html", "nv_notify_register.pro", '.pro file in <a href="nv/sys/event/dir-overview.html">nv/sys/event/ directory</a>', "nv_notify_register.pro", "", "", " NAME: 	nv_notify_register    PURPOSE: 	Register descriptor event handlers.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	nv_notify_register, xd, handler, type, data=data    ARGUMENTS:   INPUT: 	xd:		Array of descriptors.  	handler:	Name of event handler functions.  If only one element, 			then this function will be registered for every given 			descriptor.  Otherwise must have the same number of 			elements as xd.  	type:		Type of data event to respond to: 			 0 - set value 			 1 - get value 			0 is default.  If only one element, then this type 			will be registered for every given descriptor. 			Otherwise must have the same number of elements as xd.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	data:		Arbitrary user data to associate with events on these 			descriptors.  A pointer to this data is allocated and 			returned in the 'data_p' field of the event structure. 			Note that only one descriptor xd may be specified 			per call when using this argument.  	scalar_data:	Scalar user data to associate with events on these 			descriptors.  This data is returned in the 'data' 			field of the event structure.  	compress:	Event compression flag.    OUTPUT: 	NONE    RETURN: 	NONE    COMMON BLOCKS: 	nv_notify_block    STATUS: 	Complete    SEE ALSO: 	nv_notify_unregister    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/sys/event/nv_notify_register.html#nv_notify_register", "nv_notify_register", 'routine in <a href="nv/sys/event/nv_notify_register.html">nv_notify_register.pro</a>', "nv_notify_register.pro", "", "nv_notify_register", "", "datascalar_datacompress_xdhandlertype", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/sys/event/nv_notify_unregister.html", "nv_notify_unregister.pro", '.pro file in <a href="nv/sys/event/dir-overview.html">nv/sys/event/ directory</a>', "nv_notify_unregister.pro", "", "", " NAME: 	nv_notify_unregister    PURPOSE: 	Unregister a descriptor event handler.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	nv_notify_unregister, xd, handler    ARGUMENTS:   INPUT: 	xd:		Descriptors for which to discontinue notification.  	handler:	If given, names of event handler functions to remove 			for each given descriptor.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	all:		If set, all handlers are unregistered.    OUTPUT: 	NONE    RETURN: 	NONE    COMMON BLOCKS: 	nv_notify_block    STATUS: 	Complete    SEE ALSO: 	nv_notify_register    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/sys/event/nv_notify_unregister.html#nv_notify_unregister", "nv_notify_unregister", 'routine in <a href="nv/sys/event/nv_notify_unregister.html">nv_notify_unregister.pro</a>', "nv_notify_unregister.pro", "", "nv_notify_unregister", "", "allxdhandler", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/sys/event/nv_ping.html", "nv_ping.pro", '.pro file in <a href="nv/sys/event/dir-overview.html">nv/sys/event/ directory</a>', "nv_ping.pro", "", "", " NAME: 	nv_ping    PURPOSE: 	Generates a write event on a set of descriptors.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	nv_ping, xd    ARGUMENTS:   INPUT: 	xd:	Array of descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 5/2014   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/sys/event/nv_ping.html#nv_ping", "nv_ping", 'routine in <a href="nv/sys/event/nv_ping.html">nv_ping.pro</a>', "nv_ping.pro", "", "nv_ping", "", "noeventxdp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/sys/util/nv_protected.html", "nv_protected.pro", '.pro file in <a href="nv/sys/util/dir-overview.html">nv/sys/util/ directory</a>', "nv_protected.pro", "", "", " NAME: 	nv_protected    PURPOSE: 	Tests whether a structure or field is protected.  Protected fields 	are not freed by nv_free, nor are they descended by nv_free 	or nv_clone.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	test = nv_protected(tag)    ARGUMENTS:   INPUT: 	tag:		Structure tag to test.     OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	1 if protected, 0 if not.    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 7/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/sys/util/nv_protected.html#nv_protected", "nv_protected", 'routine in <a href="nv/sys/util/nv_protected.html">nv_protected.pro</a>', "nv_protected.pro", "", "nv_protected", "", "arg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/sys/util/nv_ptr_free.html", "nv_ptr_free.pro", '.pro file in <a href="nv/sys/util/dir-overview.html">nv/sys/util/ directory</a>', "nv_ptr_free.pro", "", "", " NAME: 	nv_ptr_free    PURPOSE: 	Wrapper to the IDL routine ptr_free.  In conjunction with nv_ptr_new, 	pointer allocations are tracked for debugging purposes.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	nv_ptr_free, p    ARGUMENTS:   INPUT: 	p:	Pointer to free.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/sys/util/nv_ptr_free.html#nv_ptr_free", "nv_ptr_free", 'routine in <a href="nv/sys/util/nv_ptr_free.html">nv_ptr_free.pro</a>', "nv_ptr_free.pro", "", "nv_ptr_free", "", "p", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/sys/util/nv_ptr_new.html", "nv_ptr_new.pro", '.pro file in <a href="nv/sys/util/dir-overview.html">nv/sys/util/ directory</a>', "nv_ptr_new.pro", "", "", " NAME: 	nv_ptr_new    PURPOSE: 	Wrapper for te IDL function ptr_new.  In conjunction with nv_ptr_free, 	pointer allocations are tracked for debugging purposes.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	p = nv_ptr_new(x)    ARGUMENTS:   INPUT: 	x:	Data to point to.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Newly allocated pointer    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/sys/util/nv_ptr_new.html#nv_ptr_new", "nv_ptr_new", 'routine in <a href="nv/sys/util/nv_ptr_new.html">nv_ptr_new.pro</a>', "nv_ptr_new.pro", "", "nv_ptr_new", "", "allocate_heapno_copyx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/sys/state/nv_reset.html", "nv_reset.pro", '.pro file in <a href="nv/sys/state/dir-overview.html">nv/sys/state/ directory</a>', "nv_reset.pro", "", "", " NAME: 	nv_reset    PURPOSE: 	Resets the NV state.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	nv_reset    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/sys/state/nv_reset.html#nv_reset", "nv_reset", 'routine in <a href="nv/sys/state/nv_reset.html">nv_reset.pro</a>', "nv_reset.pro", "", "nv_reset", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/sys/event/nv_resume_events.html", "nv_resume_events.pro", '.pro file in <a href="nv/sys/event/dir-overview.html">nv/sys/event/ directory</a>', "nv_resume_events.pro", "", "", " NAME: 	nv_resume_events    PURPOSE: 	Resumes data event tracking.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	nv_resume_events    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/sys/event/nv_resume_events.html#nv_resume_events", "nv_resume_events", 'routine in <a href="nv/sys/event/nv_resume_events.html">nv_resume_events.pro</a>', "nv_resume_events.pro", "", "nv_resume_events", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/sys/state/nv_state_struct__define.html", "nv_state_struct__define.pro", '.pro file in <a href="nv/sys/state/dir-overview.html">nv/sys/state/ directory</a>', "nv_state_struct__define.pro", "", "", " NAME: 	nv_state_struct__define    PURPOSE: 	Structure defining the NV state.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	N/A    FIELDS: 	ndd:	Maximum number of data descriptors with maintain == 1 to 		keep in memory at any given time.  	dds_p:	List of data descriptors kept in memory as a result of 		maintain == 1.  	translators_filenames_p:	Pointer to names of translators 					tables.  	tr_table_p:	Pointer to loaded translators table.  	transforms_filenames_p:	Pointer to names of transforms tables.  	trf_table_p:	Pointer to loaded transforms table.  	io_filenames_p:	Pointer to names of I/O tables.  	io_table_p:	Pointer to loaded I/O table.  	ftp_detectors_filenames_p:	Pointer to names of filetypes tables.  	ftp_table_p:	Pointer to loaded filetypes table.  	ins_detectors_filenames_p:	Pointer to names of instruments 					tables.  	ins_table_p:	Pointer to loaded instruments table.      STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/sys/state/nv_state_struct__define.html#nv_state_struct__define", "nv_state_struct__define", 'routine in <a href="nv/sys/state/nv_state_struct__define.html">nv_state_struct__define.pro</a>', "nv_state_struct__define.pro", "", "nv_state_struct__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/sys/event/nv_suspend_events.html", "nv_suspend_events.pro", '.pro file in <a href="nv/sys/event/dir-overview.html">nv/sys/event/ directory</a>', "nv_suspend_events.pro", "", "", " NAME: 	nv_suspend_events    PURPOSE: 	Suspends data event tracking.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	nv_suspend_events    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/sys/event/nv_suspend_events.html#nv_suspend_events", "nv_suspend_events", 'routine in <a href="nv/sys/event/nv_suspend_events.html">nv_suspend_events.pro</a>', "nv_suspend_events.pro", "", "nv_suspend_events", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/include/nv_trs_keywords1_include.html", "nv_trs_keywords1_include.pro", '.pro file in <a href="config/include/dir-overview.html">config/include/ directory</a>', "nv_trs_keywords1_include.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("config/include/nv_trs_keywords_include.html", "nv_trs_keywords_include.pro", '.pro file in <a href="config/include/dir-overview.html">config/include/ directory</a>', "nv_trs_keywords_include.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("util/nwhere.html", "nwhere.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "nwhere.pro", "", "", " NAME:        nwhere    PURPOSE:        Finds subscripts of elements in the first input array that match        elements in the second input array.    CATEGORY:        UTIL    CALLING SEQUENCE:        result = nwhere(ref, list)    ARGUMENTS:   INPUT:         ref:  Reference array         list:  Comparison array.     OUTPUT:        reverse_indices: 		Subscripts wrt the second input array.   KEYWORDS:        NONE    RETURN:        An array of subscripts in ref that match something in list.    STATUS:        Completed, but not as efficient as desired.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/nwhere.html#nwhere", "nwhere", 'routine in <a href="util/nwhere.html">nwhere.pro</a>', "nwhere.pro", "", "nwhere", "", "reverse_indicesreflist", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/nwhere.html#_nwhere", "_nwhere", 'routine in <a href="util/nwhere.html">nwhere.pro</a>', "nwhere.pro", "", "_nwhere", "", "reflist", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/nwhere.html#___nwhere", "___nwhere", 'routine in <a href="util/nwhere.html">nwhere.pro</a>', "nwhere.pro", "", "___nwhere", "", "reflist", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/objpds.html", "objpds.pro", '.pro file in <a href="config/pds/Readpds_4.4/dir-overview.html">config/pds/Readpds_4.4/ directory</a>', "objpds.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/objpds.html#obtain", "obtain", 'routine in <a href="config/pds/Readpds_4.4/objpds.html">objpds.pro</a>', "objpds.pro", "", "obtain", "", "paramobject", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/objpds.html#sort_structure", "sort_structure", 'routine in <a href="config/pds/Readpds_4.4/objpds.html">objpds.pro</a>', "objpds.pro", "", "sort_structure", "", "object", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/objpds.html#check_duplicate", "check_duplicate", 'routine in <a href="config/pds/Readpds_4.4/objpds.html">objpds.pro</a>', "objpds.pro", "", "check_duplicate", "", "paramobject", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/objpds.html#objpds", "objpds", 'routine in <a href="config/pds/Readpds_4.4/objpds.html">objpds.pro</a>', "objpds.pro", "", "objpds", "", "labelparam", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/arr/ominas_array__define.html", "ominas_array__define.pro", '.pro file in <a href="nv/obj/arr/dir-overview.html">nv/obj/arr/ directory</a>', "ominas_array__define.pro", "", "", " NAME: 	ominas_array__define    PURPOSE: 	Class structure for the ARRAY class.    CATEGORY: 	NV/LIB/arr    CALLING SEQUENCE: 	N/A    FIELDS: 	bd:	BODY class descriptor.  		Methods: arr_body, arr_set_body   	primary:	Primary descriptor.  			Methods: arr_primary, arr_set_primary  	surface_pts:	Vector giving the surface coordinates of the 			array points on the primary.  			Methods: arr_surface_pts, arr_set_surface_pts     STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 10/2012  	Adapted by:	Spitale, 5/2016  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/arr/ominas_array__define.html#ominas_array::init", "ominas_array::init", 'routine in <a href="nv/obj/arr/ominas_array__define.html">ominas_array__define.pro</a>', "ominas_array__define.pro", "", "ominas_array::init", "", "crdardii@arr__keywords.include", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/arr/ominas_array__define.html#ominas_array__define", "ominas_array__define", 'routine in <a href="nv/obj/arr/ominas_array__define.html">ominas_array__define.pro</a>', "ominas_array__define.pro", "", "ominas_array__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/bod/ominas_body__define.html", "ominas_body__define.pro", '.pro file in <a href="nv/obj/bod/dir-overview.html">nv/obj/bod/ directory</a>', "ominas_body__define.pro", "", "", " NAME: 	ominas_body__define    PURPOSE: 	Class structure for the BODY class.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	N/A    FIELDS: 	crd:	CORE class descriptor.  		Methods: bod_core   	opaque:	Flag describing whether a body is  easily visible .  		Methods: bod_opaque, bod_set_opaque   	time:	Time, at body position, at which this descriptor is valid.  		Methods: bod_time, bod_set_time   	orient:	Orientation matrix, transforms body to inertial.  		Methods: bod_orient, bod_set_orient   	avel:	Angular velocity vector.  Each higher-order vector is the 		angular velocity for the vector of the preceding order.  		Methods: bod_avel, bod_set_avel   	pos:	Position of body center in the inertial frame.  		Methods: bod_pos, bod_set_pos   	vel:	Velocity of body center in the inertial frame.  		Methods: bod_vel, bod_set_vel   	libv:	Libration vector.  Each higher-order vector is the libration 		for the vector of the preceding order.  The body librates about 		the direction v_unit(libv), with an amplitude given by 		v_mag(libv).  		Methods: bod_libv, bod_set_libv   	lib:	Phase of the libraton vectors at body time.  		Methods: bod_lib, bod_set_lib   	dlibdt:	Frequency for each libration vector.  		Methods: bod_dlibdt, bod_set_dlibdt  	aberration: 		Aberration flag mask: 1=correction performed.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/bod/ominas_body__define.html#ominas_body::init", "ominas_body::init", 'routine in <a href="nv/obj/bod/ominas_body__define.html">ominas_body__define.pro</a>', "ominas_body__define.pro", "", "ominas_body::init", "", "crdbdii@bod__keywords.include", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/bod/ominas_body__define.html#ominas_body__define", "ominas_body__define", 'routine in <a href="nv/obj/bod/ominas_body__define.html">ominas_body__define.pro</a>', "ominas_body__define.pro", "", "ominas_body__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cam/ominas_camera__define.html", "ominas_camera__define.pro", '.pro file in <a href="nv/obj/cam/dir-overview.html">nv/obj/cam/ directory</a>', "ominas_camera__define.pro", "", "", " NAME: 	ominas_camera__define    PURPOSE: 	Class structure fo the CAMERA class.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	N/A    FIELDS: 	bd:	BODY class descriptor.  		Methods: cam_body, cam_set_body   	scale:	2-element array giving the camera scale (radians/pixel) in 		each direction.  The meaning of this quantity depends on the 		distortion model.  		Methods: cam_scale, cam_set_scale   	oaxis:	2-element array giving the image coordinates corresponding 		to the camera optic axis.  		Methods: cam_oaxis, cam_set_oaxis   	exposure:	Exposure duration.  BODY time refers to the 			center of this interval.  			Methods: cam_exposure, cam_set_exposure   	size:	Image size in pixels.  		Methods: cam_size, cam_set_size  	filters:	String array giving the names of each filter.   	fn_focal_to_image:	String giving the name of a function 				that transforms points in the focal 				plane coordinate system to points in 				the image coordinate system.  Default is 				cam_image_to_focal_linear().  				Methods: cam_fn_focal_to_image, 				         cam_set_fn_focal_to_image   	fn_image_to_focal:	String giving the name of a function 				that transforms points in the image 				coordinate system to points in the focal- 				plane coordinate system.  Default is 				cam_image_to_focal_linear().  				Methods: cam_fn_image_to_focal 				         cam_set_fn_image_to_focal   	fn_psf:	String giving the name of a function to be defined as 		follows:  		function <name>, cd, x, y, default=default  		The function should return an array of PSF values at the given 		coordinates, subject to the following rules:  		1) If neither x nor y are given, then a PSF function is returned 		   on some default grid, which is application-specific.  		2) If only x is given, then PSF values are returned for each x, 		   with y values set to zero.  		3) If x and y are given, then PSF values are returned at all 		   points (x,y).   		Methods: cam_fn_psf, cam_set_fn_psf, cam_psf, cam_psf_attrib    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cam/ominas_camera__define.html#ominas_camera::init", "ominas_camera::init", 'routine in <a href="nv/obj/cam/ominas_camera__define.html">ominas_camera__define.pro</a>', "ominas_camera__define.pro", "", "ominas_camera::init", "", "crdbdcdii@cam__keywords.include", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/cam/ominas_camera__define.html#ominas_camera__define", "ominas_camera__define", 'routine in <a href="nv/obj/cam/ominas_camera__define.html">ominas_camera__define.pro</a>', "ominas_camera__define.pro", "", "ominas_camera__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/cor/ominas_core__define.html", "ominas_core__define.pro", '.pro file in <a href="nv/obj/cor/dir-overview.html">nv/obj/cor/ directory</a>', "ominas_core__define.pro", "", "", " NAME: 	ominas_core__define    PURPOSE: 	Class structure for the CORE class.    CATEGORY: 	NV/OBJ/COR    CALLING SEQUENCE: 	N/A    FIELDS: 	name:	Name of the object.  		Methods: cor_name, cor_set_name   	user:	Username.  		Methods: cor_user   	tasks_p: 		Pointer to tasks list.  		Methods: cor_tasks, cor_add_task   	udata_tlp: 		Tag list containing user data.  		Methods: cor_set_udata, cor_test_udata, cor_udata  	abbrev:	Abbreviation for this descriptor class, e.g., COR.  	tag:	Tag for this descriptor class, e.g., CRD.  	gdp:	Pointer to generic descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/cor/ominas_core__define.html#ominas_core::rereference", "ominas_core::rereference", 'routine in <a href="nv/obj/cor/ominas_core__define.html">ominas_core__define.pro</a>', "ominas_core__define.pro", "", "ominas_core::rereference", "", "struct", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/cor/ominas_core__define.html#ominas_core::dereference", "ominas_core::dereference", 'routine in <a href="nv/obj/cor/ominas_core__define.html">ominas_core__define.pro</a>', "ominas_core__define.pro", "", "ominas_core::dereference", "", "struct", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/cor/ominas_core__define.html#ominas_core::init", "ominas_core::init", 'routine in <a href="nv/obj/cor/ominas_core__define.html">ominas_core__define.pro</a>', "ominas_core__define.pro", "", "ominas_core::init", "", "crdii@cor__keywords.include", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/cor/ominas_core__define.html#ominas_core__define", "ominas_core__define", 'routine in <a href="nv/obj/cor/ominas_core__define.html">ominas_core__define.pro</a>', "ominas_core__define.pro", "", "ominas_core__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/ominas_data__define.html", "ominas_data__define.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "ominas_data__define.pro", "", "", " NAME: 	ominas_data__define    PURPOSE: 	Structure defining the data descriptor.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	N/A    FIELDS: 	data_dap:	Pointer to data archive containing the data 			and nhist past versions.  	abscissa_dap:	Pointer to data archive containing the abscissa 			and nhist past versions.  	header_dap:	Pointer to data archive containing the header 			and nhist past versions.  	dap_index:	Index of archived data to use.  	dhp:		Pointer to detached header.  	max:		Maximum data value.  	min:		Minimum data value.  	abmax:		Maximum abscissa value.  	abmin:		Minimum abscissa value.  	cache:		Max cache size data array.  Used to deterine whether 			to load / unload data samples.  -1 means infinite.  	dim:		Array giving data dimensions.  	slice_struct:	Structure containing array giving coordinates for a 			subarray.  If slice coordinates exist, the dat methods 			act as if the data descriptor contains only this slice of 			data.  Dimensions, min, and max are set accordingly. 			Dimensions of the subarray are the difference between 			the dimensions of the full array and the dimensionality 			of the slice coordinates.  	typecode:	Data type code.  	filename:	Name of data file.  	filetype:	Filetype string determined by dat_detect_filetype.  	input_transforms_p:	Pointer to list of input transform 				functions determined by dat_lookup_transforms.  	output_transforms_p:	Pointer to list of output transform 				functions determined by dat_lookup_transforms.  	input_fn:	Name of function to read data file.  	output_fn:	Name of function to write data file.  	keyword_fn:	Name of function to read/write header keywords.  	instrument:	Instrument string from dat_detect_instrument.  	input_translators_p:	Pointer to list of input translator 				functions determined by dat_lookup_translators.  	output_translators_p:	Pointer to list of output translator 				functions determined by dat_lookup_translators.  	input_keyvals_p:	Keyword/value pairs for input translators.  	output_keyvals_p:	Keyword/value pairs for output translators.  	transient_keyvals_p:	Transient keyword/value pairs found in the 				translator argument string.  	last_translator:	Description of last translator called.  	sampling_fn:		Optional function to perform a transformation 				on the samples given to dat_data():  				function sampling_fn, dd, samples, data  	dim_fn:			Optional function to cause dat_dim() to report 				dimensions other than those stored in the 				data descriptor:  				function dim_fn, dd, data  	compress:	Compression suffix.  The full name of the 			compression function is dat_compress_data_<suffix>.  	compress_data_p:	Data for compression function.  	maintain:	Data maintenance mode: 				  0: load initially 				  1: load when needed; retain 				     only ndd data descriptor 				     arrays in memory. 				  2: Load when needed, but  				     do not retain.  	update:		Data update mode: 				 -1: Locked; applies to data, header, 				     and udata. 				  0: Normal 				  1: Clone a new descriptor 				     and leave original dd 				     unchanged.  	sibling_dd_h:	Handle giving dd spawned as a result of writing to 			this descriptor while update = 1.  Handle is used 			to protect this dd from nv_free. ;   STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/ominas_data__define.html#ominas_data::init", "ominas_data::init", 'routine in <a href="nv/obj/dat/ominas_data__define.html">ominas_data__define.pro</a>', "ominas_data__define.pro", "", "ominas_data::init", "", "crdddii@dat__keywords.include", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/dat/ominas_data__define.html#dat_dd0_struct__define", "dat_dd0_struct__define", 'routine in <a href="nv/obj/dat/ominas_data__define.html">ominas_data__define.pro</a>', "ominas_data__define.pro", "", "dat_dd0_struct__define", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/dat/ominas_data__define.html#ominas_data__define", "ominas_data__define", 'routine in <a href="nv/obj/dat/ominas_data__define.html">ominas_data__define.pro</a>', "ominas_data__define.pro", "", "ominas_data__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dsk/ominas_disk__define.html", "ominas_disk__define.pro", '.pro file in <a href="nv/obj/dsk/dir-overview.html">nv/obj/dsk/ directory</a>', "ominas_disk__define.pro", "", "", " NAME: 	ominas_disk__define    PURPOSE: 	Class structure for the DISK class.    CATEGORY: 	NV/LIB/DSK    CALLING SEQUENCE: 	N/A    FIELDS: 	sld:	SOLID class descriptor.  		Methods: dsk_solid, dsk_set_solid   	sma:	Array ndv+1 x 2 giving the semimajor axes and derivatives 		for each edge.  		Methods: dsk_sma, dsk_set_sma   	ecc:	Array ndv+1 x 2 giving the eccentricities and derivatives 		for each edge.  		Methods: dsk_ecc, dsk_set_ecc   	dap:	Array ndv+1 giving the apsidal shift and derivatives.  		Methods: dsk_dap, dsk_set_dap   	scale:	2-elements array giving optional radial scale coefficients:  			 scaled_radii = scale[0] * radii*scale[1]  		Methods: dsk_scale, dsk_set_scale, dsk_apply_scale   	nm:	Integer giving the number of radial harmonics in the ring 		shape.  		Methods: dsk_nm, dsk_set_nm, dsk_get_nm   	m:	Array nm x 2 giving the m value for each harmonic, for 		each edge.  		Methods: dsk_m, dsk_set_m, dsk_get_nm   	em:	Array nm x 2 giving the eccentricity for each harmonic, for 		each edge.  		Methods: dsk_em, dsk_set_em   	tapm:	Array nm x 2 giving the true anmalies of periapse for each 		harmonic, for each edge.  		Methods: dsk_tapm, dsk_set_tapm   	dtapmdt:Array nm x 2 giving the tapm rate rate for each 		harmonic, for each edge.  		Methods: dsk_dtapmdt, dsk_set_dtapmdt   	libam:	Array nm x 2 giving the libration amplitude for each 		harmonic, for each edge.  		Methods: dsk_libam, dsk_set_libam   	libm:	Array nm x 2 giving the libration phase for each 		harmonic, for each edge.  		Methods: dsk_libm, dsk_set_libm   	dlibmdt:	Array nm x 2 giving the libration frequency for each 			harmonic, for each edge.  			Methods: dsk_dlibmdt, dsk_set_dlibmdt   	nl:	Integer giving the number of radial harmonics in the ring 		shape.  		Methods: dsk_nm, dsk_set_nm, dsk_get_nm   	l:	Array nl x 2 giving the l value for each harmonic, for 		each edge.  		Methods: dsk_m, dsk_set_m, dsk_get_nm   	il:	Array nl x 2 giving the inclination for each harmonic, for 		each edge.  		Methods: dsk_em, dsk_set_em   	taanl:	Array nl x 2 giving the true anomaly of periapse for each 		harmonic, for each edge.  		Methods: dsk_taanl, dsk_set_taanl   	dtaanldt:	Array nl x 2 giving the taanl rate for each 			harmonic, for each edge.  			Methods: dsk_dtaanldt, dsk_set_dtaanldt   	libal:	Array nl x 2 giving the libration amplitude for each 		harmonic, for each edge.  		Methods: dsk_libam, dsk_set_libam   	libl:	Array nl x 2 giving the libration phase for each 		harmonic, for each edge.  		Methods: dsk_libm, dsk_set_libm   	dlibldt:	Array nl x 2 giving the libration frequency for each 			harmonic, for each edge.  			Methods: dsk_dlibmdt, dsk_set_dlibmdt      STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/ominas_disk__define.html#ominas_disk::init", "ominas_disk::init", 'routine in <a href="nv/obj/dsk/ominas_disk__define.html">ominas_disk__define.pro</a>', "ominas_disk__define.pro", "", "ominas_disk::init", "", "crdbdslddkdii@dsk__keywords.include", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/dsk/ominas_disk__define.html#ominas_disk__define", "ominas_disk__define", 'routine in <a href="nv/obj/dsk/ominas_disk__define.html">ominas_disk__define.pro</a>', "ominas_disk__define.pro", "", "ominas_disk__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/ominas_env_info.html", "ominas_env_info.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "ominas_env_info.pro", "Paulo Penteado (Paulo.Penteado@jpl.nasa.gov),  ", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/ominas_env_info.html#ominas_env_info", "ominas_env_info", 'routine in <a href="util/ominas_env_info.html">ominas_env_info.pro</a>', "ominas_env_info.pro", "Paulo Penteado (http://www.ppenteado.net),  ", "ominas_env_info", "    Prints out the most commonly useful information about the OMINAS environment     for debugging.   ", "outfile      If provided, output is written to that file, instead of to the terminal.   ", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/glb/ominas_globe__define.html", "ominas_globe__define.pro", '.pro file in <a href="nv/obj/glb/dir-overview.html">nv/obj/glb/ directory</a>', "ominas_globe__define.pro", "", "", " NAME: 	ominas_globe__define    PURPOSE: 	Class structure fo the GLOBE class.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	N/A    FIELDS: 	sld:	SOLID class descriptor.  		Methods: glb_solid, glb_set_solid   	type:	String giving the type.  ELLIPSOID, FACET, or HARMONIC. 		Currently only ellipsoids are supported.   		Methods: glb_type, glb_set_type  	lref:	Longitude reference note.  Used to describe the longitude 		reference system.  		Methods: glb_lref, glb_set_lref   	radii:	3-element array giving the ellipsoid radii.  		Methods: glb_radii, glb_set_radii   	lora:	Longitude of first ellipsoid radius.  		Methods: glb_lora, glb_set_lora   	rref:	Reference radius.  		Methods: glb_rref, glb_set_rref   	J:	Array (nj) giving the zonal harmonics.  Indices in the 		array correspond to the standard harmonic orders, i.e., 		J[2] is J2.  		Methods: glb_j, glb_set_j    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/glb/ominas_globe__define.html#ominas_globe::init", "ominas_globe::init", 'routine in <a href="nv/obj/glb/ominas_globe__define.html">ominas_globe__define.pro</a>', "ominas_globe__define.pro", "", "ominas_globe::init", "", "crdbdsldgbdii@glb__keywords.include", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/glb/ominas_globe__define.html#ominas_globe__define", "ominas_globe__define", 'routine in <a href="nv/obj/glb/ominas_globe__define.html">ominas_globe__define.pro</a>', "ominas_globe__define.pro", "", "ominas_globe__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/downloader/ominas_icy_remove.html", "ominas_icy_remove.pro", '.pro file in <a href="util/downloader/dir-overview.html">util/downloader/ directory</a>', "ominas_icy_remove.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/downloader/ominas_icy_remove.html#ominas_icy_remove", "ominas_icy_remove", 'routine in <a href="util/downloader/ominas_icy_remove.html">ominas_icy_remove.pro</a>', "ominas_icy_remove.pro", "", "ominas_icy_remove", "", "allorc", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/downloader/ominas_icy_test.html", "ominas_icy_test.pro", '.pro file in <a href="util/downloader/dir-overview.html">util/downloader/ directory</a>', "ominas_icy_test.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/downloader/ominas_icy_test.html#ominas_icy_test", "ominas_icy_test", 'routine in <a href="util/downloader/ominas_icy_test.html">ominas_icy_test.pro</a>', "ominas_icy_test.pro", "", "ominas_icy_test", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/map/ominas_map__define.html", "ominas_map__define.pro", '.pro file in <a href="nv/obj/map/dir-overview.html">nv/obj/map/ directory</a>', "ominas_map__define.pro", "", "", " NAME: 	ominas_map__define    PURPOSE: 	Class structure fo the MAP class.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	N/A    FIELDS: 	crd:	CORE class descriptor.  		Methods: map_core   	type:	String giving the map type, e.g., RECTANGULAR, 		ORTHOGRAPHIC.  Map transformation functions are named 		map_image_to_map_<type> and map_map_to_image_<type>.  		Methods: map_type, map_set_type   	units:	2-element array (lat,lon) to converts map radians to other   		units (map radians/unit).  		Methods: map_units, map_set_units   	size:	2-element array giving the map size in pixels.  		Methods: map_size, map_set_size   	scale:	Map scale (units/angle) at the center of the map.  		Methods: map_scale, map_set_scale   	center:	2-element array giving the map coordinates of the 		center of the map.  		Methods: map_center, map_set_center   	range:	2-element array giving the map coordinates of the 		lat/lon ranges of the map.  		Methods: map_range, map_set_range   	origin:	2-element array giving the image coordinates corresponding 		to the center of the map.  		Methods: map_origin, map_set_origin   	rotate:	Code specifying a rotation to be applied to the map, as in the 		IDL 'rotate' function.   	graphic:	Flag indicating whether latitudes are represented 			using the planetocrntric or planetographic convention.  	radii:	3-element array giving ellipsoid radii to use in projections. 		Only the relative ratios are important.  All elements are 		set to 1 by default.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/map/ominas_map__define.html#ominas_map::init", "ominas_map::init", 'routine in <a href="nv/obj/map/ominas_map__define.html">ominas_map__define.pro</a>', "ominas_map__define.pro", "", "ominas_map::init", "", "crdmdii@map__keywords.include", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/map/ominas_map__define.html#ominas_map__define", "ominas_map__define", 'routine in <a href="nv/obj/map/ominas_map__define.html">ominas_map__define.pro</a>', "ominas_map__define.pro", "", "ominas_map__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/downloader/ominas_paths_add.html", "ominas_paths_add.pro", '.pro file in <a href="util/downloader/dir-overview.html">util/downloader/ directory</a>', "ominas_paths_add.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/downloader/ominas_paths_add.html#ominas_paths_add", "ominas_paths_add", 'routine in <a href="util/downloader/ominas_paths_add.html">ominas_paths_add.pro</a>', "ominas_paths_add.pro", "", "ominas_paths_add", "", "orcicydirominasdir", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/downloader/ominas_paths_remove.html", "ominas_paths_remove.pro", '.pro file in <a href="util/downloader/dir-overview.html">util/downloader/ directory</a>', "ominas_paths_remove.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/downloader/ominas_paths_remove.html#ominas_paths_remove", "ominas_paths_remove", 'routine in <a href="util/downloader/ominas_paths_remove.html">ominas_paths_remove.pro</a>', "ominas_paths_remove.pro", "", "ominas_paths_remove", "", "orc", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/plt/ominas_planet__define.html", "ominas_planet__define.pro", '.pro file in <a href="nv/obj/plt/dir-overview.html">nv/obj/plt/ directory</a>', "ominas_planet__define.pro", "", "", " NAME: 	ominas_planet__define    PURPOSE: 	Class structure for the PLANET class.    CATEGORY: 	NV/LIB/PLT    CALLING SEQUENCE: 	N/A    FIELDS: 	gbd:	GLOBE class descriptor.  		Methods: str_globe, str_set_globe    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/plt/ominas_planet__define.html#ominas_planet::init", "ominas_planet::init", 'routine in <a href="nv/obj/plt/ominas_planet__define.html">ominas_planet__define.pro</a>', "ominas_planet__define.pro", "", "ominas_planet::init", "", "crdbdsldgbdpdii@plt__keywords.include", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/plt/ominas_planet__define.html#ominas_planet__define", "ominas_planet__define", 'routine in <a href="nv/obj/plt/ominas_planet__define.html">ominas_planet__define.pro</a>', "ominas_planet__define.pro", "", "ominas_planet__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/pnt/ominas_point__define.html", "ominas_point__define.pro", '.pro file in <a href="nv/obj/pnt/dir-overview.html">nv/obj/pnt/ directory</a>', "ominas_point__define.pro", "", "", " NAME: 	ominas_point__define    PURPOSE: 	Structure for managing points.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	N/A    FIELDS: 	desc:		Data set description.  	points_p:	Pointer to image points.  	vectors_p:	Pointer to inertial vectors.  	data_p:		Pointer to a point-by-point user data array.  	tags_p:		Tags for point-by-point user data.  	flags_p:	Pointer to point-by-point flag array.  	nv:		Number of elements in the nv direction.  	nt:		Number of elements in the nt direction.  	assoc_xd:	Associated descriptor.     STATUS: 	Complete    MODIFICATION HISTORY:   Spitale, 11/2015; 	Adapted from pg_points_struct__define   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/pnt/ominas_point__define.html#ominas_point::init", "ominas_point::init", 'routine in <a href="nv/obj/pnt/ominas_point__define.html">ominas_point__define.pro</a>', "ominas_point__define.pro", "", "ominas_point::init", "", "crdptdii@pnt__keywords.include", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/pnt/ominas_point__define.html#ominas_point__define", "ominas_point__define", 'routine in <a href="nv/obj/pnt/ominas_point__define.html">ominas_point__define.pro</a>', "ominas_point__define.pro", "", "ominas_point__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/rng/ominas_ring__define.html", "ominas_ring__define.pro", '.pro file in <a href="nv/obj/rng/dir-overview.html">nv/obj/rng/ directory</a>', "ominas_ring__define.pro", "", "", " NAME: 	ominas_ring__define    PURPOSE: 	Class structure for the RING class.    CATEGORY: 	NV/LIB/RNG    CALLING SEQUENCE: 	N/A    FIELDS: 	dkd:	DISK class descriptor.  		Methods: rng_disk, rng_set_disk   	primary:	Primary body descriptor.  			Methods: rng_primary, rng_set_primary  	desc:	String giving the description of the ring.  Valid values 		are 'EDGE', 'PEAK', 'TROUGH'.  		Methods: rng_desc, rng_set_desc    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/rng/ominas_ring__define.html#ominas_ring::init", "ominas_ring::init", 'routine in <a href="nv/obj/rng/ominas_ring__define.html">ominas_ring__define.pro</a>', "ominas_ring__define.pro", "", "ominas_ring::init", "", "crdbdslddkdrdii@rng__keywords.include", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/rng/ominas_ring__define.html#ominas_ring__define", "ominas_ring__define", 'routine in <a href="nv/obj/rng/ominas_ring__define.html">ominas_ring__define.pro</a>', "ominas_ring__define.pro", "", "ominas_ring__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/sld/ominas_solid__define.html", "ominas_solid__define.pro", '.pro file in <a href="nv/obj/sld/dir-overview.html">nv/obj/sld/ directory</a>', "ominas_solid__define.pro", "", "", " NAME: 	ominas_solid__define    PURPOSE: 	Class structure fo the SOLID class.    CATEGORY: 	NV/LIB/SLD    CALLING SEQUENCE: 	N/A    FIELDS: 	bd:	BODY class descriptor.  		Methods: sld_body, sld_set_body   	opacity: Normalized opacity for ray tracing.  		Methods: sld_opacity, sld_set_opacity   	GM:	Mass x gravitational constant.  		Methods: sld_gm, sld_set_gm   	mass:	Body mass.  This field and GM are kept in sync unless 		/nosync is used in sld_set_mass or sld_set_gm.  		Methods: sld_mass, sld_set_mass   	phase_fn: String giving the name of a phase function to be defined as 		  follows:  		  function <name>, mu, mu0, parm  		  The function should return a value corresponding to the 		  phase function with emission cosine mu and incidence 		  cosine mu0.  		  Methods: sld_phase_fn, sld_set_phase_fn   	phase_parm:	Array (npht) of parameters to pass to the phase 			function.  		  Methods: sld_phase_parm, sld_set_phase_parm   	refl_fn:  String giving the name of a reflection function to be defined as 		  follows:  		  function <name>, mu, mu0, parm  		  The function should return a value corresponding to the 		  reflection function with emission cosine mu and incidence 		  cosine mu0.  		  Methods: sld_refl_fn, sld_set_refl_fn   	refl_parm:	Array (npht) of parameters to pass to the reflection 			function.  		  Methods: sld_refl_parm, sld_set_refl_parm   	albedo:	Bond albedo.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/sld/ominas_solid__define.html#ominas_solid::init", "ominas_solid::init", 'routine in <a href="nv/obj/sld/ominas_solid__define.html">ominas_solid__define.pro</a>', "ominas_solid__define.pro", "", "ominas_solid::init", "", "crdbdsldii@sld__keywords.include", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/sld/ominas_solid__define.html#ominas_solid__define", "ominas_solid__define", 'routine in <a href="nv/obj/sld/ominas_solid__define.html">ominas_solid__define.pro</a>', "ominas_solid__define.pro", "", "ominas_solid__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/str/ominas_star__define.html", "ominas_star__define.pro", '.pro file in <a href="nv/obj/str/dir-overview.html">nv/obj/str/ directory</a>', "ominas_star__define.pro", "", "", " NAME: 	ominas_star__define    PURPOSE: 	Class structure for the STAR class.    CATEGORY: 	NV/LIB/STR    CALLING SEQUENCE: 	N/A    FIELDS: 	gbd:	GLOBE class descriptor.  		Methods: str_globe, str_set_globe   	lum:	Luminosity value.  		Methods: str_lum, str_set_lum   	sp:	Spectral class string.  		Methods: str_sp, str_set_sp    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/str/ominas_star__define.html#ominas_star::init", "ominas_star::init", 'routine in <a href="nv/obj/str/ominas_star__define.html">ominas_star__define.pro</a>', "ominas_star__define.pro", "", "ominas_star::init", "", "crdbdsldgbdsdii@str__keywords.include", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/str/ominas_star__define.html#ominas_star__define", "ominas_star__define", 'routine in <a href="nv/obj/str/ominas_star__define.html">ominas_star__define.pro</a>', "ominas_star__define.pro", "", "ominas_star__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/stn/ominas_station__define.html", "ominas_station__define.pro", '.pro file in <a href="nv/obj/stn/dir-overview.html">nv/obj/stn/ directory</a>', "ominas_station__define.pro", "", "", " NAME: 	ominas_station__define    PURPOSE: 	Class structure for the STATION class.    CATEGORY: 	NV/LIB/STN    CALLING SEQUENCE: 	N/A    FIELDS: 	bd:	BODY class descriptor.  		Methods: stn_body, stn_set_body   	primary:	Primary body descriptor.  			Methods: stn_primary, stn_set_primary  	surface_pt:	Vector giving the surface coordinates of the 			stations location on the primary.  This 			is redundant with the location of bd, but it 			allows one to compute map coordinates without 			a body descriptor present.  			Methods: stn_surface_pt, stn_set_surface_pt     STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/stn/ominas_station__define.html#ominas_station::init", "ominas_station::init", 'routine in <a href="nv/obj/stn/ominas_station__define.html">ominas_station__define.pro</a>', "ominas_station__define.pro", "", "ominas_station::init", "", "crdbdstdii@stn__keywords.include", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/stn/ominas_station__define.html#ominas_station__define", "ominas_station__define", 'routine in <a href="nv/obj/stn/ominas_station__define.html">ominas_station__define.pro</a>', "ominas_station__define.pro", "", "ominas_station__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/on_off.html", "on_off.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "on_off.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/on_off.html#on_off", "on_off", 'routine in <a href="util/on_off.html">on_off.pro</a>', "on_off.pro", "", "on_off", "", "tf", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/oplotc.html", "oplotc.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "oplotc.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/oplotc.html#oplotc", "oplotc", 'routine in <a href="util/oplotc.html">oplotc.pro</a>', "oplotc.pro", "", "oplotc", "", "colorspolarpsymssolidsymsizepixmapxy", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_anom_to_arg.html", "orb_anom_to_arg.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_anom_to_arg.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_anom_to_arg.html#orb_anom_to_arg", "orb_anom_to_arg", 'routine in <a href="nv/obj/tools/orb/orb_anom_to_arg.html">orb_anom_to_arg.pro</a>', "orb_anom_to_arg.pro", "", "orb_anom_to_arg", "", "apxdanomframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_anom_to_arg_rate.html", "orb_anom_to_arg_rate.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_anom_to_arg_rate.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_anom_to_arg_rate.html#orb_anom_to_arg_rate", "orb_anom_to_arg_rate", 'routine in <a href="nv/obj/tools/orb/orb_anom_to_arg_rate.html">orb_anom_to_arg_rate.pro</a>', "orb_anom_to_arg_rate.pro", "", "orb_anom_to_arg_rate", "", "dapdtxddanomdtframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_anom_to_lon.html", "orb_anom_to_lon.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_anom_to_lon.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_anom_to_lon.html#orb_anom_to_lon", "orb_anom_to_lon", 'routine in <a href="nv/obj/tools/orb/orb_anom_to_lon.html">orb_anom_to_lon.pro</a>', "orb_anom_to_lon.pro", "", "orb_anom_to_lon", "", "aplanxdanomframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_anom_to_lon_rate.html", "orb_anom_to_lon_rate.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_anom_to_lon_rate.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_anom_to_lon_rate.html#orb_anom_to_lon_rate", "orb_anom_to_lon_rate", 'routine in <a href="nv/obj/tools/orb/orb_anom_to_lon_rate.html">orb_anom_to_lon_rate.pro</a>', "orb_anom_to_lon_rate.pro", "", "orb_anom_to_lon_rate", "", "dapdtdlandtxddanomdtframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_arg_to_anom.html", "orb_arg_to_anom.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_arg_to_anom.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_arg_to_anom.html#orb_arg_to_anom", "orb_arg_to_anom", 'routine in <a href="nv/obj/tools/orb/orb_arg_to_anom.html">orb_arg_to_anom.pro</a>', "orb_arg_to_anom.pro", "", "orb_arg_to_anom", "", "apxdargframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_arg_to_anom_rate.html", "orb_arg_to_anom_rate.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_arg_to_anom_rate.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_arg_to_anom_rate.html#orb_arg_to_anom_rate", "orb_arg_to_anom_rate", 'routine in <a href="nv/obj/tools/orb/orb_arg_to_anom_rate.html">orb_arg_to_anom_rate.pro</a>', "orb_arg_to_anom_rate.pro", "", "orb_arg_to_anom_rate", "", "dapdtxddargdtframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_arg_to_lon.html", "orb_arg_to_lon.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_arg_to_lon.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_arg_to_lon.html#orb_arg_to_lon", "orb_arg_to_lon", 'routine in <a href="nv/obj/tools/orb/orb_arg_to_lon.html">orb_arg_to_lon.pro</a>', "orb_arg_to_lon.pro", "", "orb_arg_to_lon", "", "lanxdargframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_arg_to_lon_rate.html", "orb_arg_to_lon_rate.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_arg_to_lon_rate.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_arg_to_lon_rate.html#orb_arg_to_lon_rate", "orb_arg_to_lon_rate", 'routine in <a href="nv/obj/tools/orb/orb_arg_to_lon_rate.html">orb_arg_to_lon_rate.pro</a>', "orb_arg_to_lon_rate.pro", "", "orb_arg_to_lon_rate", "", "dlandtxddargdtframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_cartesian_to_orbit.html", "orb_cartesian_to_orbit.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_cartesian_to_orbit.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_cartesian_to_orbit.html#orb_cartesian_to_orbit", "orb_cartesian_to_orbit", 'routine in <a href="nv/obj/tools/orb/orb_cartesian_to_orbit.html">orb_cartesian_to_orbit.pro</a>', "orb_cartesian_to_orbit.pro", "", "orb_cartesian_to_orbit", "", "GGcirculargbx_r_v", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_compute_dapdt.html", "orb_compute_dapdt.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_compute_dapdt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_compute_dapdt.html#orb_compute_dapdt", "orb_compute_dapdt", 'routine in <a href="nv/obj/tools/orb/orb_compute_dapdt.html">orb_compute_dapdt.pro</a>', "orb_compute_dapdt.pro", "", "orb_compute_dapdt", "", "GGsmaxdgbx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_compute_dlandt.html", "orb_compute_dlandt.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_compute_dlandt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_compute_dlandt.html#orb_compute_dlandt", "orb_compute_dlandt", 'routine in <a href="nv/obj/tools/orb/orb_compute_dlandt.html">orb_compute_dlandt.pro</a>', "orb_compute_dlandt.pro", "", "orb_compute_dlandt", "", "GGsmaxdgbx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_compute_dlpdt.html", "orb_compute_dlpdt.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_compute_dlpdt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_compute_dlpdt.html#orb_compute_dlpdt", "orb_compute_dlpdt", 'routine in <a href="nv/obj/tools/orb/orb_compute_dlpdt.html">orb_compute_dlpdt.pro</a>', "orb_compute_dlpdt.pro", "", "orb_compute_dlpdt", "", "GGsmaxdgbx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_compute_dmadt.html", "orb_compute_dmadt.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_compute_dmadt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_compute_dmadt.html#orb_compute_dmadt", "orb_compute_dmadt", 'routine in <a href="nv/obj/tools/orb/orb_compute_dmadt.html">orb_compute_dmadt.pro</a>', "orb_compute_dmadt.pro", "", "orb_compute_dmadt", "", "GGsmaxdgbx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_compute_dmldt.html", "orb_compute_dmldt.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_compute_dmldt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_compute_dmldt.html#orb_compute_dmldt", "orb_compute_dmldt", 'routine in <a href="nv/obj/tools/orb/orb_compute_dmldt.html">orb_compute_dmldt.pro</a>', "orb_compute_dmldt.pro", "", "orb_compute_dmldt", "", "GGsmaxdgbx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_compute_dtapdt.html", "orb_compute_dtapdt.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_compute_dtapdt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_compute_dtapdt.html#orb_compute_dtapdt", "orb_compute_dtapdt", 'routine in <a href="nv/obj/tools/orb/orb_compute_dtapdt.html">orb_compute_dtapdt.pro</a>', "orb_compute_dtapdt.pro", "", "orb_compute_dtapdt", "", "GGsmaxdgbx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_compute_ea.html", "orb_compute_ea.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_compute_ea.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_compute_ea.html#osk_eval", "osk_eval", 'routine in <a href="nv/obj/tools/orb/orb_compute_ea.html">orb_compute_ea.pro</a>', "orb_compute_ea.pro", "", "osk_eval", "", "ea", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_compute_ea.html#orb_compute_ea", "orb_compute_ea", 'routine in <a href="nv/obj/tools/orb/orb_compute_ea.html">orb_compute_ea.pro</a>', "orb_compute_ea.pro", "", "orb_compute_ea", "", "eccrx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_compute_elements.html", "orb_compute_elements.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_compute_elements.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_compute_elements.html#orb_compute_elements", "orb_compute_elements", 'routine in <a href="nv/obj/tools/orb/orb_compute_elements.html">orb_compute_elements.pro</a>', "orb_compute_elements.pro", "", "orb_compute_elements", "", "smaeccincaplandmldtdmadtdapdtliba_apdlibdt_aplib_apdlandtliba_landlibdt_lanlib_lanmamllptatlraddlpdttimerdtgbxtrdgbx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_compute_ma.html", "orb_compute_ma.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_compute_ma.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_compute_ma.html#orb_compute_ma", "orb_compute_ma", 'routine in <a href="nv/obj/tools/orb/orb_compute_ma.html">orb_compute_ma.pro</a>', "orb_compute_ma.pro", "", "orb_compute_ma", "", "eccfearx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_compute_r.html", "orb_compute_r.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_compute_r.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_compute_r.html#orb_compute_r", "orb_compute_r", 'routine in <a href="nv/obj/tools/orb/orb_compute_r.html">orb_compute_r.pro</a>', "orb_compute_r.pro", "", "orb_compute_r", "", "rx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/old/orb_compute_sma-old.html", "orb_compute_sma-old.pro", '.pro file in <a href="nv/obj/tools/orb/old/dir-overview.html">nv/obj/tools/orb/old/ directory</a>', "orb_compute_sma-old.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/old/orb_compute_sma-old.html#ocsma_fn", "ocsma_fn", 'routine in <a href="nv/obj/tools/orb/old/orb_compute_sma-old.html">orb_compute_sma-old.pro</a>', "orb_compute_sma-old.pro", "", "ocsma_fn", "", "a", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/old/orb_compute_sma-old.html#orb_compute_sma", "orb_compute_sma", 'routine in <a href="nv/obj/tools/orb/old/orb_compute_sma-old.html">orb_compute_sma-old.pro</a>', "orb_compute_sma-old.pro", "", "orb_compute_sma", "", "GGdmldtxdgbx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_compute_sma.html", "orb_compute_sma.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_compute_sma.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_compute_sma.html#ocsma_fn", "ocsma_fn", 'routine in <a href="nv/obj/tools/orb/orb_compute_sma.html">orb_compute_sma.pro</a>', "orb_compute_sma.pro", "", "ocsma_fn", "", "a", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_compute_sma.html#orb_compute_sma", "orb_compute_sma", 'routine in <a href="nv/obj/tools/orb/orb_compute_sma.html">orb_compute_sma.pro</a>', "orb_compute_sma.pro", "", "orb_compute_sma", "", "GGJdmldtdlpdtdapdtdlandtxdgbx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_compute_ta.html", "orb_compute_ta.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_compute_ta.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_compute_ta.html#orb_compute_ta", "orb_compute_ta", 'routine in <a href="nv/obj/tools/orb/orb_compute_ta.html">orb_compute_ta.pro</a>', "orb_compute_ta.pro", "", "orb_compute_ta", "", "rx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_construct_descriptor.html", "orb_construct_descriptor.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_construct_descriptor.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_construct_descriptor.html#orb_construct_descriptor", "orb_construct_descriptor", 'routine in <a href="nv/obj/tools/orb/orb_construct_descriptor.html">orb_construct_descriptor.pro</a>', "orb_construct_descriptor.pro", "", "orb_construct_descriptor", "", "namesmaeccinclanaplpmamltatldmldtdmadtdlandtliba_landlibdt_lanlib_landapdtliba_apdlibdt_aplib_apdlpdtmmem_lpmdlpmdtlibamlibmdlibmdtllil_lanldlanldtliballibldlibldttimepptrd0ringGGnoevolvenocomputerdoutgbx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_evolve.html", "orb_evolve.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_evolve.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_evolve.html#orb_evolve", "orb_evolve", 'routine in <a href="nv/obj/tools/orb/orb_evolve.html">orb_evolve.pro</a>', "orb_evolve.pro", "", "orb_evolve", "", "rxdt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_evolve_ma.html", "orb_evolve_ma.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_evolve_ma.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_evolve_ma.html#orb_evolve_ma", "orb_evolve_ma", 'routine in <a href="nv/obj/tools/orb/orb_evolve_ma.html">orb_evolve_ma.pro</a>', "orb_evolve_ma.pro", "", "orb_evolve_ma", "", "rxdt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_get_ap.html", "orb_get_ap.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_get_ap.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_get_ap.html#_orb_get_ap", "_orb_get_ap", 'routine in <a href="nv/obj/tools/orb/orb_get_ap.html">orb_get_ap.pro</a>', "orb_get_ap.pro", "", "_orb_get_ap", "", "xdframe_bd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_get_ap.html#orb_get_ap", "orb_get_ap", 'routine in <a href="nv/obj/tools/orb/orb_get_ap.html">orb_get_ap.pro</a>', "orb_get_ap.pro", "", "orb_get_ap", "", "xdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_get_ascending_node.html", "orb_get_ascending_node.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_get_ascending_node.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_get_ascending_node.html#orb_get_ascending_node", "orb_get_ascending_node", 'routine in <a href="nv/obj/tools/orb/orb_get_ascending_node.html">orb_get_ascending_node.pro</a>', "orb_get_ascending_node.pro", "", "orb_get_ascending_node", "", "arbitraryrefsafexdframe_bd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_get_ascending_node.html#_orb_get_ascending_node", "_orb_get_ascending_node", 'routine in <a href="nv/obj/tools/orb/orb_get_ascending_node.html">orb_get_ascending_node.pro</a>', "orb_get_ascending_node.pro", "", "_orb_get_ascending_node", "", "arbitraryrefxdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_get_dapdt.html", "orb_get_dapdt.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_get_dapdt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_get_dapdt.html#orb_get_dapdt", "orb_get_dapdt", 'routine in <a href="nv/obj/tools/orb/orb_get_dapdt.html">orb_get_dapdt.pro</a>', "orb_get_dapdt.pro", "", "orb_get_dapdt", "", "xdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_get_dlandt.html", "orb_get_dlandt.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_get_dlandt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_get_dlandt.html#orb_get_dlandt", "orb_get_dlandt", 'routine in <a href="nv/obj/tools/orb/orb_get_dlandt.html">orb_get_dlandt.pro</a>', "orb_get_dlandt.pro", "", "orb_get_dlandt", "", "xdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_get_dlibdt_ap.html", "orb_get_dlibdt_ap.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_get_dlibdt_ap.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_get_dlibdt_ap.html#orb_get_dlibdt_ap", "orb_get_dlibdt_ap", 'routine in <a href="nv/obj/tools/orb/orb_get_dlibdt_ap.html">orb_get_dlibdt_ap.pro</a>', "orb_get_dlibdt_ap.pro", "", "orb_get_dlibdt_ap", "", "xdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_get_dlibdt_lan.html", "orb_get_dlibdt_lan.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_get_dlibdt_lan.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_get_dlibdt_lan.html#orb_get_dlibdt_lan", "orb_get_dlibdt_lan", 'routine in <a href="nv/obj/tools/orb/orb_get_dlibdt_lan.html">orb_get_dlibdt_lan.pro</a>', "orb_get_dlibdt_lan.pro", "", "orb_get_dlibdt_lan", "", "xdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_get_dlpmdt.html", "orb_get_dlpmdt.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_get_dlpmdt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_get_dlpmdt.html#orb_get_dlpmdt", "orb_get_dlpmdt", 'routine in <a href="nv/obj/tools/orb/orb_get_dlpmdt.html">orb_get_dlpmdt.pro</a>', "orb_get_dlpmdt.pro", "", "orb_get_dlpmdt", "", "rdpd0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_get_dmadt.html", "orb_get_dmadt.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_get_dmadt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_get_dmadt.html#orb_get_dmadt", "orb_get_dmadt", 'routine in <a href="nv/obj/tools/orb/orb_get_dmadt.html">orb_get_dmadt.pro</a>', "orb_get_dmadt.pro", "", "orb_get_dmadt", "", "xdjunk", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_get_dmldt.html", "orb_get_dmldt.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_get_dmldt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_get_dmldt.html#orb_get_dmldt", "orb_get_dmldt", 'routine in <a href="nv/obj/tools/orb/orb_get_dmldt.html">orb_get_dmldt.pro</a>', "orb_get_dmldt.pro", "", "orb_get_dmldt", "", "xdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_get_ecc.html", "orb_get_ecc.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_get_ecc.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_get_ecc.html#orb_get_ecc", "orb_get_ecc", 'routine in <a href="nv/obj/tools/orb/orb_get_ecc.html">orb_get_ecc.pro</a>', "orb_get_ecc.pro", "", "orb_get_ecc", "", "xdjunk", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_get_inc.html", "orb_get_inc.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_get_inc.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_get_inc.html#orb_get_inc", "orb_get_inc", 'routine in <a href="nv/obj/tools/orb/orb_get_inc.html">orb_get_inc.pro</a>', "orb_get_inc.pro", "", "orb_get_inc", "", "xdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_get_lan.html", "orb_get_lan.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_get_lan.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_get_lan.html#orb_get_lan", "orb_get_lan", 'routine in <a href="nv/obj/tools/orb/orb_get_lan.html">orb_get_lan.pro</a>', "orb_get_lan.pro", "", "orb_get_lan", "", "refxdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_get_lib_ap.html", "orb_get_lib_ap.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_get_lib_ap.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_get_lib_ap.html#orb_get_lib_ap", "orb_get_lib_ap", 'routine in <a href="nv/obj/tools/orb/orb_get_lib_ap.html">orb_get_lib_ap.pro</a>', "orb_get_lib_ap.pro", "", "orb_get_lib_ap", "", "xdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_get_lib_lan.html", "orb_get_lib_lan.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_get_lib_lan.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_get_lib_lan.html#orb_get_lib_lan", "orb_get_lib_lan", 'routine in <a href="nv/obj/tools/orb/orb_get_lib_lan.html">orb_get_lib_lan.pro</a>', "orb_get_lib_lan.pro", "", "orb_get_lib_lan", "", "xdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_get_liba_ap.html", "orb_get_liba_ap.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_get_liba_ap.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_get_liba_ap.html#orb_get_liba_ap", "orb_get_liba_ap", 'routine in <a href="nv/obj/tools/orb/orb_get_liba_ap.html">orb_get_liba_ap.pro</a>', "orb_get_liba_ap.pro", "", "orb_get_liba_ap", "", "xdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_get_liba_lan.html", "orb_get_liba_lan.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_get_liba_lan.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_get_liba_lan.html#orb_get_liba_lan", "orb_get_liba_lan", 'routine in <a href="nv/obj/tools/orb/orb_get_liba_lan.html">orb_get_liba_lan.pro</a>', "orb_get_liba_lan.pro", "", "orb_get_liba_lan", "", "xdframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_get_lpm.html", "orb_get_lpm.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_get_lpm.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_get_lpm.html#orb_get_lpm", "orb_get_lpm", 'routine in <a href="nv/obj/tools/orb/orb_get_lpm.html">orb_get_lpm.pro</a>', "orb_get_lpm.pro", "", "orb_get_lpm", "", "rdpd0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_get_ma.html", "orb_get_ma.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_get_ma.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_get_ma.html#orb_get_ma", "orb_get_ma", 'routine in <a href="nv/obj/tools/orb/orb_get_ma.html">orb_get_ma.pro</a>', "orb_get_ma.pro", "", "orb_get_ma", "", "xdjunk", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_get_sma.html", "orb_get_sma.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_get_sma.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_get_sma.html#orb_get_sma", "orb_get_sma", 'routine in <a href="nv/obj/tools/orb/orb_get_sma.html">orb_get_sma.pro</a>', "orb_get_sma.pro", "", "orb_get_sma", "", "xdjunk", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_inertialize.html", "orb_inertialize.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_inertialize.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_inertialize.html#orb_inertialize", "orb_inertialize", 'routine in <a href="nv/obj/tools/orb/orb_inertialize.html">orb_inertialize.pro</a>', "orb_inertialize.pro", "", "orb_inertialize", "", "frame_bx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_init_descriptors.html", "orb_init_descriptors.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_init_descriptors.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_init_descriptors.html#orb_create_descriptors", "orb_create_descriptors", 'routine in <a href="nv/obj/tools/orb/orb_init_descriptors.html">orb_init_descriptors.pro</a>', "orb_init_descriptors.pro", "", "orb_create_descriptors", "", "namesmaeccinclanapmadmadtdlandtdapdttngbx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/orb/orb_input.html", "orb_input.pro", '.pro file in <a href="config/orb/dir-overview.html">config/orb/ directory</a>', "orb_input.pro", "", "", " NAME: 	orb_input    PURPOSE: 	Input translator for planetary orbits.    CATEGORY: 	NV/CONFIG    CALLING SEQUENCE(only to be called by dat_get_value): 	result = orb_input(dd, keyword)    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	keyword:	String giving the name of the translator quantity.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	key1:		Camera descriptor    OUTPUT: 	status:		Zero if valid data is returned    ENVIRONMENT VARIABLES: 	NV_ORBIT_DATA:	Sets the directory in which to look for data files.    RETURN: 	Data associated with the requested keyword.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale; 9/2007   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/orb/orb_input.html#oi_clone", "oi_clone", 'routine in <a href="config/orb/orb_input.html">orb_input.pro</a>', "orb_input.pro", "", "oi_clone", "", "_rd", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/orb/orb_input.html#oi_get_element", "oi_get_element", 'routine in <a href="config/orb/orb_input.html">orb_input.pro</a>', "orb_input.pro", "", "oi_get_element", "", "dattagvar", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/orb/orb_input.html#orb_input", "orb_input", 'routine in <a href="config/orb/orb_input.html">orb_input.pro</a>', "orb_input.pro", "", "orb_input", "", "valuesstatusddkeywordprefix@nv_trs_keywords_include.pro", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_lon_to_anom.html", "orb_lon_to_anom.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_lon_to_anom.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_lon_to_anom.html#orb_lon_to_anom", "orb_lon_to_anom", 'routine in <a href="nv/obj/tools/orb/orb_lon_to_anom.html">orb_lon_to_anom.pro</a>', "orb_lon_to_anom.pro", "", "orb_lon_to_anom", "", "aplanxdlonframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_lon_to_anom_rate.html", "orb_lon_to_anom_rate.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_lon_to_anom_rate.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_lon_to_anom_rate.html#orb_lon_to_anom_rate", "orb_lon_to_anom_rate", 'routine in <a href="nv/obj/tools/orb/orb_lon_to_anom_rate.html">orb_lon_to_anom_rate.pro</a>', "orb_lon_to_anom_rate.pro", "", "orb_lon_to_anom_rate", "", "dapdtdlandtxddlondtframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_lon_to_arg.html", "orb_lon_to_arg.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_lon_to_arg.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_lon_to_arg.html#orb_lon_to_arg", "orb_lon_to_arg", 'routine in <a href="nv/obj/tools/orb/orb_lon_to_arg.html">orb_lon_to_arg.pro</a>', "orb_lon_to_arg.pro", "", "orb_lon_to_arg", "", "lanxdlonframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_lon_to_arg_rate.html", "orb_lon_to_arg_rate.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_lon_to_arg_rate.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_lon_to_arg_rate.html#orb_lon_to_arg_rate", "orb_lon_to_arg_rate", 'routine in <a href="nv/obj/tools/orb/orb_lon_to_arg_rate.html">orb_lon_to_arg_rate.pro</a>', "orb_lon_to_arg_rate.pro", "", "orb_lon_to_arg_rate", "", "dlandtxddlondtframe_bd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_lon_to_body.html", "orb_lon_to_body.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_lon_to_body.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_lon_to_body.html#orb_lon_to_body", "orb_lon_to_body", 'routine in <a href="nv/obj/tools/orb/orb_lon_to_body.html">orb_lon_to_body.pro</a>', "orb_lon_to_body.pro", "", "orb_lon_to_body", "", "frame_bdxdlon", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_min_distance.html", "orb_min_distance.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_min_distance.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_min_distance.html#_eval_omd", "_eval_omd", 'routine in <a href="nv/obj/tools/orb/orb_min_distance.html">orb_min_distance.pro</a>', "orb_min_distance.pro", "", "_eval_omd", "", "p", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_min_distance.html#orb_min_distance", "orb_min_distance", 'routine in <a href="nv/obj/tools/orb/orb_min_distance.html">orb_min_distance.pro</a>', "orb_min_distance.pro", "", "orb_min_distance", "", "frame_bdlon1lon2distanceslons_xd1_xd2", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_plot.html", "orb_plot.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_plot.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_plot.html#orb_plot", "orb_plot", 'routine in <a href="nv/obj/tools/orb/orb_plot.html">orb_plot.pro</a>', "orb_plot.pro", "", "orb_plot", "", "cd_rdframe_bx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_precess.html", "orb_precess.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_precess.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_precess.html#orb_precess", "orb_precess", 'routine in <a href="nv/obj/tools/orb/orb_precess.html">orb_precess.pro</a>', "orb_precess.pro", "", "orb_precess", "", "_pd_rdpd_precessrd_precessobs_bx_pd0pd_rd0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_print_descriptor.html", "orb_print_descriptor.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_print_descriptor.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_print_descriptor.html#orb_get_elements", "orb_get_elements", 'routine in <a href="nv/obj/tools/orb/orb_print_descriptor.html">orb_print_descriptor.pro</a>', "orb_print_descriptor.pro", "", "orb_get_elements", "", "trdgbx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_set_ap.html", "orb_set_ap.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_set_ap.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_set_ap.html#orb_set_ap", "orb_set_ap", 'routine in <a href="nv/obj/tools/orb/orb_set_ap.html">orb_set_ap.pro</a>', "orb_set_ap.pro", "", "orb_set_ap", "", "xdframe_bdap", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_set_dapdt.html", "orb_set_dapdt.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_set_dapdt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_set_dapdt.html#orb_set_dapdt", "orb_set_dapdt", 'routine in <a href="nv/obj/tools/orb/orb_set_dapdt.html">orb_set_dapdt.pro</a>', "orb_set_dapdt.pro", "", "orb_set_dapdt", "", "xdframe_bddapdt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_set_dlandt.html", "orb_set_dlandt.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_set_dlandt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_set_dlandt.html#orb_set_dlandt", "orb_set_dlandt", 'routine in <a href="nv/obj/tools/orb/orb_set_dlandt.html">orb_set_dlandt.pro</a>', "orb_set_dlandt.pro", "", "orb_set_dlandt", "", "xdframe_bddlandt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_set_dlibdt_ap.html", "orb_set_dlibdt_ap.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_set_dlibdt_ap.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_set_dlibdt_ap.html#orb_set_dlibdt_ap", "orb_set_dlibdt_ap", 'routine in <a href="nv/obj/tools/orb/orb_set_dlibdt_ap.html">orb_set_dlibdt_ap.pro</a>', "orb_set_dlibdt_ap.pro", "", "orb_set_dlibdt_ap", "", "xdframe_bddlibdt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_set_dlibdt_lan.html", "orb_set_dlibdt_lan.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_set_dlibdt_lan.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_set_dlibdt_lan.html#orb_set_dlibdt_lan", "orb_set_dlibdt_lan", 'routine in <a href="nv/obj/tools/orb/orb_set_dlibdt_lan.html">orb_set_dlibdt_lan.pro</a>', "orb_set_dlibdt_lan.pro", "", "orb_set_dlibdt_lan", "", "xdframe_bddlibdt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_set_dlpmdt.html", "orb_set_dlpmdt.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_set_dlpmdt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_set_dlpmdt.html#orb_set_dlpmdt", "orb_set_dlpmdt", 'routine in <a href="nv/obj/tools/orb/orb_set_dlpmdt.html">orb_set_dlpmdt.pro</a>', "orb_set_dlpmdt.pro", "", "orb_set_dlpmdt", "", "rddlpmdtpd0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_set_dmadt.html", "orb_set_dmadt.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_set_dmadt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_set_dmadt.html#orb_set_dmadt", "orb_set_dmadt", 'routine in <a href="nv/obj/tools/orb/orb_set_dmadt.html">orb_set_dmadt.pro</a>', "orb_set_dmadt.pro", "", "orb_set_dmadt", "", "xddmadtjunk", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_set_ecc.html", "orb_set_ecc.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_set_ecc.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_set_ecc.html#orb_set_ecc", "orb_set_ecc", 'routine in <a href="nv/obj/tools/orb/orb_set_ecc.html">orb_set_ecc.pro</a>', "orb_set_ecc.pro", "", "orb_set_ecc", "", "xd_eccjunk", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_set_inc.html", "orb_set_inc.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_set_inc.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_set_inc.html#orb_set_inc", "orb_set_inc", 'routine in <a href="nv/obj/tools/orb/orb_set_inc.html">orb_set_inc.pro</a>', "orb_set_inc.pro", "", "orb_set_inc", "", "xdframe_bdinc", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_set_lan.html", "orb_set_lan.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_set_lan.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_set_lan.html#orb_set_lan", "orb_set_lan", 'routine in <a href="nv/obj/tools/orb/orb_set_lan.html">orb_set_lan.pro</a>', "orb_set_lan.pro", "", "orb_set_lan", "", "xdframe_bdlan", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_set_lib_ap.html", "orb_set_lib_ap.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_set_lib_ap.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_set_lib_ap.html#orb_set_lib_ap", "orb_set_lib_ap", 'routine in <a href="nv/obj/tools/orb/orb_set_lib_ap.html">orb_set_lib_ap.pro</a>', "orb_set_lib_ap.pro", "", "orb_set_lib_ap", "", "xdframe_bdlib", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_set_lib_lan.html", "orb_set_lib_lan.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_set_lib_lan.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_set_lib_lan.html#orb_set_lib_lan", "orb_set_lib_lan", 'routine in <a href="nv/obj/tools/orb/orb_set_lib_lan.html">orb_set_lib_lan.pro</a>', "orb_set_lib_lan.pro", "", "orb_set_lib_lan", "", "xdframe_bdlib_lan", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_set_liba_ap.html", "orb_set_liba_ap.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_set_liba_ap.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_set_liba_ap.html#orb_set_liba_ap", "orb_set_liba_ap", 'routine in <a href="nv/obj/tools/orb/orb_set_liba_ap.html">orb_set_liba_ap.pro</a>', "orb_set_liba_ap.pro", "", "orb_set_liba_ap", "", "xdframe_bdliba_ap", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_set_liba_lan.html", "orb_set_liba_lan.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_set_liba_lan.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_set_liba_lan.html#orb_set_liba_lan", "orb_set_liba_lan", 'routine in <a href="nv/obj/tools/orb/orb_set_liba_lan.html">orb_set_liba_lan.pro</a>', "orb_set_liba_lan.pro", "", "orb_set_liba_lan", "", "xdframe_bdliba_lan", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_set_lpm.html", "orb_set_lpm.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_set_lpm.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_set_lpm.html#orb_set_lpm", "orb_set_lpm", 'routine in <a href="nv/obj/tools/orb/orb_set_lpm.html">orb_set_lpm.pro</a>', "orb_set_lpm.pro", "", "orb_set_lpm", "", "rdlpmpd0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_set_ma.html", "orb_set_ma.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_set_ma.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_set_ma.html#orb_set_ma", "orb_set_ma", 'routine in <a href="nv/obj/tools/orb/orb_set_ma.html">orb_set_ma.pro</a>', "orb_set_ma.pro", "", "orb_set_ma", "", "xdmajunk", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_set_sma.html", "orb_set_sma.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_set_sma.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_set_sma.html#orb_set_sma", "orb_set_sma", 'routine in <a href="nv/obj/tools/orb/orb_set_sma.html">orb_set_sma.pro</a>', "orb_set_sma.pro", "", "orb_set_sma", "", "xd_smajunk", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/old/orb_solve_kepler.html", "orb_solve_kepler.pro", '.pro file in <a href="nv/obj/tools/orb/old/dir-overview.html">nv/obj/tools/orb/old/ directory</a>', "orb_solve_kepler.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/old/orb_solve_kepler.html#osk_eval", "osk_eval", 'routine in <a href="nv/obj/tools/orb/old/orb_solve_kepler.html">orb_solve_kepler.pro</a>', "orb_solve_kepler.pro", "", "osk_eval", "", "EE", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/old/orb_solve_kepler.html#orb_solve_kepler", "orb_solve_kepler", 'routine in <a href="nv/obj/tools/orb/old/orb_solve_kepler.html">orb_solve_kepler.pro</a>', "orb_solve_kepler.pro", "", "orb_solve_kepler", "", "rx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_span_errors.html", "orb_span_errors.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_span_errors.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_span_errors.html#ope_span_mc", "ope_span_mc", 'routine in <a href="nv/obj/tools/orb/orb_span_errors.html">orb_span_errors.pro</a>', "orb_span_errors.pro", "", "ope_span_mc", "", "x0_sig_xnsignseed", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_span_errors.html#ope_span", "ope_span", 'routine in <a href="nv/obj/tools/orb/orb_span_errors.html">orb_span_errors.pro</a>', "orb_span_errors.pro", "", "ope_span", "", "x0_sig_xnsignscanndim", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_span_errors.html#orb_span_errors", "orb_span_errors", 'routine in <a href="nv/obj/tools/orb/orb_span_errors.html">orb_span_errors.pro</a>', "orb_span_errors.pro", "", "orb_span_errors", "", "nsignscannsamplesdkxgbxsig_dkx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_test.html", "orb_test.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_test.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_test.html#orb_test", "orb_test", 'routine in <a href="nv/obj/tools/orb/orb_test.html">orb_test.pro</a>', "orb_test.pro", "", "orb_test", "", "xd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_to_cartesian.html", "orb_to_cartesian.pro", '.pro file in <a href="nv/obj/tools/orb/dir-overview.html">nv/obj/tools/orb/ directory</a>', "orb_to_cartesian.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/orb/orb_to_cartesian.html#orb_to_cartesian", "orb_to_cartesian", 'routine in <a href="nv/obj/tools/orb/orb_to_cartesian.html">orb_to_cartesian.pro</a>', "orb_to_cartesian.pro", "", "orb_to_cartesian", "", "velf_rx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/orb/orbcat_read.html", "orbcat_read.pro", '.pro file in <a href="config/orb/dir-overview.html">config/orb/ directory</a>', "orbcat_read.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/orb/orbcat_read.html#ocr_get_value", "ocr_get_value", 'routine in <a href="config/orb/orbcat_read.html">orbcat_read.pro</a>', "orbcat_read.pro", "", "ocr_get_value", "", "datkeysvalskey", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/orb/orbcat_read.html#orbcat_read", "orbcat_read", 'routine in <a href="config/orb/orbcat_read.html">orbcat_read.pro</a>', "orbcat_read.pro", "", "orbcat_read", "", "filename", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/orb/orbcat_record__define.html", "orbcat_record__define.pro", '.pro file in <a href="config/orb/dir-overview.html">config/orb/ directory</a>', "orbcat_record__define.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/orb/orbcat_record__define.html#orbcat_record__define", "orbcat_record__define", 'routine in <a href="config/orb/orbcat_record__define.html">orbcat_record__define.pro</a>', "orbcat_record__define.pro", "", "orbcat_record__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/util/orient_to_cmat.html", "orient_to_cmat.pro", '.pro file in <a href="config/util/dir-overview.html">config/util/ directory</a>', "orient_to_cmat.pro", "", "", " NAME: 	orient_to_cmat    PURPOSE: 	xx    CATEGORY: 	UTIL    CALLING SEQUENCE: 	result = xx(xx, xx) 	xx, xx, xx    ARGUMENTS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    KEYWORDS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    RETURN: 	xx    PROCEDURE: 	The appropriate conversion routine is called based on the instrument 	field in the data desciptor.    EXAMPLE: 	xx    STATUS: 	xx    SEE ALSO: 	cmat_to_orient    MODIFICATION HISTORY:  	Written by:	Spitale, 1/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/util/orient_to_cmat.html#orient_to_cmat", "orient_to_cmat", 'routine in <a href="config/util/orient_to_cmat.html">orient_to_cmat.pro</a>', "orient_to_cmat.pro", "", "orient_to_cmat", "", "ddorient", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/p.html", "p.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "p.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/p.html#p", "p", 'routine in <a href="util/p.html">p.pro</a>', "p.pro", "", "p", "", "arg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/abbrev/p.html", "p.pro", '.pro file in <a href="util/abbrev/dir-overview.html">util/abbrev/ directory</a>', "p.pro", "", "", " NAME: 	p   PURPOSE: 	Abbreviation for the print command   CATEGORY:        UTIL/ABBREV  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/abbrev/p.html#p", "p", 'routine in <a href="util/abbrev/p.html">p.pro</a>', "p.pro", "", "p", "", "x", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/p/p_angle.html", "p_angle.pro", '.pro file in <a href="util/p/dir-overview.html">util/p/ directory</a>', "p_angle.pro", "", "", " NAME:        p_angle    PURPOSE:        Computes the angles between the given arrays of image vectors.   CATEGORY:        UTIL/V    CALLING SEQUENCE:        result = p_angle(p1, p2)    ARGUMENTS:   INPUT: 	p1:	An array of np x nt image vectors (i.e., 2 x np x nt).  	p2:	Another array of np x nt image vectors.     OUTPUT:        NONE   RETURN:        Array of np x nt angles in radians.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale	6/2005   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/p/p_angle.html#p_angle", "p_angle", 'routine in <a href="util/p/p_angle.html">p_angle.pro</a>', "p_angle.pro", "", "p_angle", "", "p1p2", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/p/p_cross.html", "p_cross.pro", '.pro file in <a href="util/p/dir-overview.html">util/p/ directory</a>', "p_cross.pro", "", "", " NAME:        p_cross    PURPOSE:        Computes the cross products between the given arrays image vectors.   CATEGORY:        UTIL/V    CALLING SEQUENCE:        result = p_cross(p1, p2)    ARGUMENTS:   INPUT: 	p1:	An array of np x nt image vectors (i.e., 2 x np x nt).  	p2:	Another array of np x nt image vectors.     OUTPUT:        NONE   RETURN:        Array of np x nt out-of-image components of the cross products. 	The in-plane components will always be zero.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale	6/2005   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/p/p_cross.html#p_cross", "p_cross", 'routine in <a href="util/p/p_cross.html">p_cross.pro</a>', "p_cross.pro", "", "p_cross", "", "p1p2", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/p/p_inner.html", "p_inner.pro", '.pro file in <a href="util/p/dir-overview.html">util/p/ directory</a>', "p_inner.pro", "", "", " NAME:        p_inner    PURPOSE:        Computes inner products between the given arrays of image vectors.   CATEGORY:        UTIL/V    CALLING SEQUENCE:        result = p_inner(p1, p2)    ARGUMENTS:   INPUT: 	p1:	An array of np x nt image vectors (i.e., 2 x np x nt).  	p2:	Another array of np x nt image vectors.     OUTPUT:        NONE   RETURN:        Array of np x nt inner products.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale	6/2005   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/p/p_inner.html#p_inner", "p_inner", 'routine in <a href="util/p/p_inner.html">p_inner.pro</a>', "p_inner.pro", "", "p_inner", "", "p1p2", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/p/p_interior_convex.html", "p_interior_convex.pro", '.pro file in <a href="util/p/dir-overview.html">util/p/ directory</a>', "p_interior_convex.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/p/p_interior_convex.html#pic_test", "pic_test", 'routine in <a href="util/p/p_interior_convex.html">p_interior_convex.pro</a>', "p_interior_convex.pro", "", "pic_test", "", "ppp", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/p/p_interior_convex.html#p_interior_convex", "p_interior_convex", 'routine in <a href="util/p/p_interior_convex.html">p_interior_convex.pro</a>', "p_interior_convex.pro", "", "p_interior_convex", "", "p_vertp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/p/p_mag.html", "p_mag.pro", '.pro file in <a href="util/p/dir-overview.html">util/p/ directory</a>', "p_mag.pro", "", "", " NAME:        p_mag    PURPOSE:        Computes the magnitudes of the given array of image vectors.   CATEGORY:        UTIL/V    CALLING SEQUENCE:        result = p_mag(p)    ARGUMENTS:   INPUT: 	p:	An array of np x nt image vectors (i.e., 2 x np x nt).     OUTPUT:        NONE   RETURN:        Array of np x nt magnitudes.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale	6/2005   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/p/p_mag.html#p_mag", "p_mag", 'routine in <a href="util/p/p_mag.html">p_mag.pro</a>', "p_mag.pro", "", "p_mag", "", "p", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/p/p_mean.html", "p_mean.pro", '.pro file in <a href="util/p/dir-overview.html">util/p/ directory</a>', "p_mean.pro", "", "", " NAME:        p_mean    PURPOSE:        Computes the mean values of the given array of points 	in the y direction.   CATEGORY:        UTIL/V    CALLING SEQUENCE:        result = p_mean(v)    ARGUMENTS:   INPUT:        v:     An array of np x nt points (i.e. 2 x np x nt).     OUTPUT:        NONE   RETURN:        Array of 1 x nt points (i.e., 2 x 1 x nt).    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/p/p_mean.html#p_mean", "p_mean", 'routine in <a href="util/p/p_mean.html">p_mean.pro</a>', "p_mean.pro", "", "p_mean", "", "wtp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/p/p_mxp.html", "p_mxp.pro", '.pro file in <a href="util/p/dir-overview.html">util/p/ directory</a>', "p_mxp.pro", "", "", " NAME:        p_mxp    PURPOSE:        Computes matrix product between square matrices and points.   CATEGORY:        UTIL/V    CALLING SEQUENCE:        result = p_mxp(m, p)    ARGUMENTS:   INPUT: 	m:	An array of 2 x 2 matrices (i.e., 2 x 2 x nt).  	p:	An array of np x nt image points (i.e., 2 x np x nt).    OUTPUT:        NONE   RETURN:        Array 2 x np x nt of matrix products.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale	6/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/p/p_mxp.html#p_mxp", "p_mxp", 'routine in <a href="util/p/p_mxp.html">p_mxp.pro</a>', "p_mxp.pro", "", "p_mxp", "", "mp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/p/p_rotate.html", "p_rotate.pro", '.pro file in <a href="util/p/dir-overview.html">util/p/ directory</a>', "p_rotate.pro", "", "", " NAME:        p_rotate    PURPOSE:        Rotates the given image vectors about an axis projecting out of the 	image plane.   CATEGORY:        UTIL/V    CALLING SEQUENCE:        result = p_rotate(p, sin_theta, cos_theta)    ARGUMENTS:   INPUT: 	p:	An array of np x nt image vectors (i.e., 2 x np x nt).  	sin_theta:	Sines of np x nt rotation angles in radians.  	cos_theta:	Cosines of np x nt rotation angles in radians.     OUTPUT:        NONE   RETURN:        Array of np x nt image vectors.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale	6/2005   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/p/p_rotate.html#p_rotate", "p_rotate", 'routine in <a href="util/p/p_rotate.html">p_rotate.pro</a>', "p_rotate.pro", "", "p_rotate", "", "psin_thetacos_theta", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/p/p_sample.html", "p_sample.pro", '.pro file in <a href="util/p/dir-overview.html">util/p/ directory</a>', "p_sample.pro", "", "", " NAME:        p_sample    PURPOSE:        Resamples the given points such that their spacing is 	uniform.    CATEGORY:        UTIL/V    CALLING SEQUENCE:        result = p_sample(p, spacing=spacing)    ARGUMENTS:   INPUT:                p:      An array of np points (i.e., 2 x np array) 			to resample.  Note that the reason there is no 			nt direction is that unifrom spacing would impose 			differing numbers of elements in that direction, which 			is not permissible.    OUTPUT:        NONE   RETURN:        Array of np uniformly-spaced points.     STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  10/2012   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/p/p_sample.html#p_sample", "p_sample", 'routine in <a href="util/p/p_sample.html">p_sample.pro</a>', "p_sample.pro", "", "p_sample", "", "splinelsquadraticquadraticpdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/p/p_sqmag.html", "p_sqmag.pro", '.pro file in <a href="util/p/dir-overview.html">util/p/ directory</a>', "p_sqmag.pro", "", "", " NAME:        p_mag    PURPOSE:        Computes the squared magnitudes of the given array of image vectors.   CATEGORY:        UTIL/V    CALLING SEQUENCE:        result = p_sqmag(p)    ARGUMENTS:   INPUT: 	p:	An array of np x nt image vectors (i.e., 2 x np x nt).     OUTPUT:        NONE   RETURN:        Array of np x nt squared magnitudes.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale	6/2005   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/p/p_sqmag.html#p_sqmag", "p_sqmag", 'routine in <a href="util/p/p_sqmag.html">p_sqmag.pro</a>', "p_sqmag.pro", "", "p_sqmag", "", "p", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/p/p_stdev.html", "p_stdev.pro", '.pro file in <a href="util/p/dir-overview.html">util/p/ directory</a>', "p_stdev.pro", "", "", " NAME:        p_stdev    PURPOSE:        Computes the standard deviations of the given array of column vectors 	in the x direction.   CATEGORY:        UTIL/V    CALLING SEQUENCE:        result = p_stdev(v)    ARGUMENTS:   INPUT:        v:     An array of np x nt points (i.e. 2 x np x nt).     OUTPUT:        NONE   RETURN:        Array of 1 x nt points (i.e., 2 x 1 x nt).    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/p/p_stdev.html#p_stdev", "p_stdev", 'routine in <a href="util/p/p_stdev.html">p_stdev.pro</a>', "p_stdev.pro", "", "p_stdev", "", "meanmean2wtp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/p/p_unit.html", "p_unit.pro", '.pro file in <a href="util/p/dir-overview.html">util/p/ directory</a>', "p_unit.pro", "", "", " NAME:        p_unit    PURPOSE:        Converts image vectors to unit image vectors.    CATEGORY:        UTIL/V    CALLING SEQUENCE:        result = p_unit(p)    ARGUMENTS:   INPUT: 	p:	An array of np x nt image vectors (i.e., 2 x np x nt).    OUTPUT:        mag:	Array of np x nt magnitudes.   RETURN:        An array of np x nt unit image vectors (i.e., 2 x np x nt).    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale	6/2005   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/p/p_unit.html#p_unit", "p_unit", 'routine in <a href="util/p/p_unit.html">p_unit.pro</a>', "p_unit.pro", "", "p_unit", "", "magp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/pad_array.html", "pad_array.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "pad_array.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/pad_array.html#pad_array", "pad_array", 'routine in <a href="util/pad_array.html">pad_array.pro</a>', "pad_array.pro", "", "pad_array", "", "padarrayn", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/parallelogram.html", "parallelogram.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "parallelogram.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/parallelogram.html#parallelogram", "parallelogram", 'routine in <a href="util/parallelogram.html">parallelogram.pro</a>', "parallelogram.pro", "", "parallelogram", "", "npcenter_p0v1v2", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/parm_scan.html", "parm_scan.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "parm_scan.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/parm_scan.html#parm_scan", "parm_scan", 'routine in <a href="util/parm_scan.html">parm_scan.pro</a>', "parm_scan.pro", "", "parm_scan", "", "scalexrangeaty", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/parse_comma_list.html", "parse_comma_list.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "parse_comma_list.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/parse_comma_list.html#parse_comma_list", "parse_comma_list", 'routine in <a href="util/parse_comma_list.html">parse_comma_list.pro</a>', "parse_comma_list.pro", "", "parse_comma_list", "", "delim_s", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/parse_comma_list.html#_parse_comma_list", "_parse_comma_list", 'routine in <a href="util/parse_comma_list.html">parse_comma_list.pro</a>', "parse_comma_list.pro", "", "_parse_comma_list", "", "delim_s", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/parse_numeric_list.html", "parse_numeric_list.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "parse_numeric_list.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/parse_numeric_list.html#parse_numeric_list", "parse_numeric_list", 'routine in <a href="util/parse_numeric_list.html">parse_numeric_list.pro</a>', "parse_numeric_list.pro", "", "parse_numeric_list", "", "s", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/pdspar.html", "pdspar.pro", '.pro file in <a href="config/pds/Readpds_4.4/dir-overview.html">config/pds/Readpds_4.4/ directory</a>', "pdspar.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/pdspar.html#get_matching_char", "get_matching_char", 'routine in <a href="config/pds/Readpds_4.4/pdspar.html">pdspar.pro</a>', "pdspar.pro", "", "get_matching_char", "", "ipchar", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/pdspar.html#PDSPAR", "PDSPAR", 'routine in <a href="config/pds/Readpds_4.4/pdspar.html">pdspar.pro</a>', "pdspar.pro", "", "PDSPAR", "", "MVALCOUNTINDEXlblnameabort", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/peak_interp.html", "peak_interp.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "peak_interp.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/peak_interp.html#peak_interp", "peak_interp", 'routine in <a href="util/peak_interp.html">peak_interp.pro</a>', "peak_interp.pro", "", "peak_interp", "", "minymaxwidthalphastatusnsig_x_y", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/peak_interp_2d.html", "peak_interp_2d.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "peak_interp_2d.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/peak_interp_2d.html#peak_interp_2d", "peak_interp_2d", 'routine in <a href="util/peak_interp_2d.html">peak_interp_2d.pro</a>', "peak_interp_2d.pro", "", "peak_interp_2d", "", "corr", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/perim_interp.html", "perim_interp.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "perim_interp.pro", "", "", " NAME: 	perim_interp    PURPOSE: 	Interpolates within given ellipses in an image.    CATEGORY: 	UTIL    CALLING SEQUENCE: 	result = perim_interp(image, center_pts, a, b, h)    ARGUMENTS:   INPUT: 	image:		Input image.  	center_pts:	Array (2,n) giving ellipse centers.  	a:		Scalar giving the semimajor axis of the ellipses.  	b:		Scalar giving the semiminor axis of the ellipses.  	h:		Scalar giving the rotation of the ellipse semimajor axes 			from horizontal.  (radians)    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	show:		If set, the outlines of the ellipses are plotted on 			the current graphics window.    OUTPUT: 	NONE    RETURN: 	Image array in which the pixels contained in the specified ellipses 	havwe been interpolated from the pixels along the perimeters of the 	ellipses.    PROCEDURE: 	Each point in each ellipse is replaced by an average of the points on 	the perimeter, weighted by the inverse square of the point's distance 	from each perimeter point.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 5/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/perim_interp.html#perim_interp", "perim_interp", 'routine in <a href="util/perim_interp.html">perim_interp.pro</a>', "perim_interp.pro", "", "perim_interp", "", "showimagecenter_ptsabh", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_add_selections.html", "pg_add_selections.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_add_selections.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_add_selections.html#pg_add_selections", "pg_add_selections", 'routine in <a href="nv/com/pg/pg_add_selections.html">pg_add_selections.pro</a>', "pg_add_selections.pro", "", "pg_add_selections", "", "trsselect", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_array.html", "pg_array.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_array.pro", "", "", " NAME: 	pg_array    PURPOSE: 	Computes image points for given array descriptors.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	array_ptd = pg_array(gd=gd)    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd:	Array (n_timesteps) of camera descriptors.  	ard:	Array (n_objects, n_timesteps) of descriptors of objects 		that must be a subclass of array.  	gbx:	Array (n_xd, n_timesteps) of descriptors of objects 		that must be a subclass of GLOBE.  	dkx:	Array (n_xd, n_timesteps) of descriptors of objects 		that must be a subclass of DISK.  	bx:	Array (n_xd, n_timesteps) of descriptors of objects 		that must be a subclass of BODY, instead of gbx or dkx.  	gd:	Generic descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.  	dd:	Data descriptor containing a generic descriptor to use 		if gd not given.  	clip:	 If set points are computed only within this many camera 		 fields of view.  	cull:	 If set, POINT objects excluded by the clip keyword 		 are not returned.  Normally, empty POINT objects 		 are returned as placeholders.     OUTPUT: NONE    RETURN: 	Array (n_objects) of objects containing image points and 	the corresponding inertial vectors.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 10/2012   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_array.html#pg_array", "pg_array", 'routine in <a href="nv/com/pg/pg_array.html">pg_array.pro</a>', "pg_array.pro", "", "pg_array", "", "cdardgbxdkxbxddgdclipcull", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_bad_data.html", "pg_bad_data.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_bad_data.pro", "", "", " NAME: 	pg_bad_data    PURPOSE: 	Locates areas of bad data values like saturation and dropouts.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_bad_data(dd)    ARGUMENTS:   INPUT: 	dd:		Data descriptor containing the image to be despiked.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	dropout:	Value to use for dropouts.  Default is 0  	sat:		If given, value above which to flag as saturated, 			inclusive.  	mask:		Byte image of the same size as the input image 			in which nonzero pixel values indicate locations 			where problems should not be flagged.  	extend:		Number of pixels away from masked pixels before 			locations may be flagged as spikes.  	edge:		Regions closer than this to the edge of the image 			will be ignored.  Default is 0.    OUTPUT: 	subscripts:	Subscript of each bad point.    RETURN: 	POINT objects containing the detected bad points.    STATUS: 	Complete    SEE ALSO: 	pg_spikes    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2013   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_bad_data.html#pg_bad_data", "pg_bad_data", 'routine in <a href="nv/com/pg/pg_bad_data.html">pg_bad_data.pro</a>', "pg_bad_data.pro", "", "pg_bad_data", "", "dropoutsatmaskextendedgesubscriptsdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_blemish.html", "pg_blemish.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_blemish.pro", "", "", " NAME: 	pg_blemish    PURPOSE: 	Removes blemishes from an image using interpolation.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_blemish(dd, blem_ptd)    ARGUMENTS:   INPUT: 	dd:		Data descriptor containing the image to be corrected.  	blem_ptd:	POINT object containing the known image 			coordinates of the blemishes.  If an array of 			objects is given, then the operation is 			performed repeatedly using each set of blemish 			coordinates.  			This argument can also be specified directly as an 			array of image points.    OUTPUT: 	NONE    KEYWORDS:   INPUT:         a:		Semimajor axis of elliptical blemish model.  Default is 			5 pixels.          b:		Semiminor axis of elliptical blemish model.  Default is 			5 pixels.          h:		Angle of rotation (in radians) of smimajor axis from 			horizontal.  Default is 0.  	 show:		If set, the outlines of the blemishes are plotted on 			the current graphics window.    OUTPUT: 	image:		The corrected image.    RETURN: 	Data descriptor containing the corrected image.    PROCEDURE: 	Blemishes are modeled as ellipses.  Pixels interior to the ellipse 	are interpolated from those on the boundary.    STATUS: 	Complete    SEE ALSO: 	pg_resloc, pg_linearize_image, pg_resfit    MODIFICATION HISTORY:  	Written by:	Spitale, 5/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_blemish.html#pg_blemish", "pg_blemish", 'routine in <a href="nv/com/pg/pg_blemish.html">pg_blemish.pro</a>', "pg_blemish.pro", "", "pg_blemish", "", "abhimageshowddblem_ptdnom_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_center.html", "pg_center.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_center.pro", "", "", " NAME: 	pg_center    PURPOSE: 	Computes image coordinates of the center of each object.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	center_ptd = pg_center(cd=cd, bx=bx) 	center_ptd = pg_center(gd=gd)    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd:	Array (nt) of camera descriptors.  	bx:	Array (n_objects, nt) of descriptors of objects 		which must be a subclass of BODY.  	gd:	Generic descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.  	dd:	Data descriptor containing a generic descriptor to use 		if gd not given.  	clip:	 If set points are computed only within this many camera 		 fields of view.  	cull:	 If set, POINT objects excluded by the clip keyword 		 are not returned.  Normally, empty POINT objects 		 are returned as placeholders.    OUTPUT: NONE    RETURN: 	Array (n_objects) of POINT objets containing image points and 	the corresponding inertial vectors.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_center.html#pg_center", "pg_center", 'routine in <a href="nv/com/pg/pg_center.html">pg_center.pro</a>', "pg_center.pro", "", "pg_center", "", "cdbxddgdclipcull", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_chisq.html", "pg_chisq.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_chisq.pro", "", "", " NAME: 	pg_chisq    PURPOSE: 	Computes chi-squared value for given curve- or point-fit parameters.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	chisq = pg_chisq(dxy, dtheta, scan_ptd, axis_ptd=axis_ptd)    ARGUMENTS:   INPUT: 	dxy:		2-element vector giving the translation as [dx,dy].  	dtheta:		Rotation in radians.  	scan_ptd:	Array (n_curves) of POINT objects output from 			pg_cvscan or pg_ptscan containing scan data.    OUTPUT: NONE    KEYWORDS:   INPUT: 	axis_ptd:	POINT object containing a single image point 			to be used as the axis of rotation.  	fix:		Array specifying which parameters to fix as 			[dx,dy,dtheta].    OUTPUT: NONE    RETURN: 	Normalized chi-square value.    STATUS: 	Complete    SEE ALSO: 	pg_cvscan, pg_cvscan_coeff, pg_cvchisq, pg_ptscan, pg_ptscan_coeff, 	pg_ptchisq, pg_fit, pg_threshold    MODIFICATION HISTORY:  	Written by:	Spitale, 10/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_chisq.html#pg_chisq", "pg_chisq", 'routine in <a href="nv/com/pg/pg_chisq.html">pg_chisq.pro</a>', "pg_chisq.pro", "", "pg_chisq", "", "axis_ptdfixdxydthetascan_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_cntrd.html", "pg_cntrd.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_cntrd.pro", "", "", " NAME: 	pg_cntrd    PURPOSE: 	Calculates the centroids centered near given features in 	an image.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_cntrd(dd, object_ptd)    ARGUMENTS:   INPUT: 	dd:		Data descriptor  	object_ptd: 	Array (n_pts) of POINT objects giving the points. 			Only the image coordinates of the points need to be 			specified.    OUTPUT:        NONE   KEYWORDS:   INPUT:         fwhm:           Full-Width Half-maximum to use around expected point                        location.  If not given, a default fwhm of 2 pixels                        is used.         edge:           Distance from edge from which to ignore points.  If                        not given, an edge distance of 0 is used.       sigmin:           If given, points are discarded if the sigma above                        the mean for the centroid pixel is below this value.     OUTPUT: NONE    RETURN: 	An array of type POINT objects giving the detected position for        each object.  The max values for each detection is        saved in the data portion of object with tag 'scan_cc'.        The x and y offset from the given position is also saved.    RESTRICTIONS: 	Currently does not work for multiple time steps.    PROCEDURE: 	For each visible object, a centroid is calcualted using the 	astronlib cntrd routine.    SEE ALSO: 	ptscan, pg_ptscan, pg_ptcntrd   STATUS: 	Complete.    MODIFICATION HISTORY:  	Written by:	Haemmerle, 2/1999   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_cntrd.html#pg_cntrd", "pg_cntrd", 'routine in <a href="nv/com/pg/pg_cntrd.html">pg_cntrd.pro</a>', "pg_cntrd.pro", "", "pg_cntrd", "", "fwhmedgesigminddobject_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_coadd.html", "pg_coadd.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_coadd.pro", "", "", " NAME: 	pg_coadd    PURPOSE: 	Averages the given images and geometries.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	dd0 = pg_coadd(dd, bx0, cd=cd, bx=bx)    ARGUMENTS:   INPUT: 	dd:	Array of data descriptors giving images to average.    OUTPUT: 	bx0:	Averaged bx body descriptors.    KEYWORDS:   INPUT: 	bx:	Array [ndd] or [ndd,n] of descriptors of any superclass of BODY, 		one for each input image, to be averaged.  Times, positions, and 		orientations are average.  In addition, for any camera 		descriptors, the optical axes are also averaged.  	gd:	Generic descriptor containing the body descriptors or an 		array [ndd] of generic descriptors.  	median: If set, the median is used instead of the average.  	minimum: If set, the minimum is used instead of the average.  	maximum: If set, the maximum is used instead of the average.  	algorithm: String giving the alogrithm to use instead of specifying 		   One of the above keyowrds.  Default is 'average .    OUTPUT: NONE     STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 4/2014   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_coadd.html#pgc_compute_average", "pgc_compute_average", 'routine in <a href="nv/com/pg/pg_coadd.html">pg_coadd.pro</a>', "pg_coadd.pro", "", "pgc_compute_average", "", "dd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_coadd.html#pgc_compute_median", "pgc_compute_median", 'routine in <a href="nv/com/pg/pg_coadd.html">pg_coadd.pro</a>', "pg_coadd.pro", "", "pgc_compute_median", "", "dd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_coadd.html#pgc_compute_minimum", "pgc_compute_minimum", 'routine in <a href="nv/com/pg/pg_coadd.html">pg_coadd.pro</a>', "pg_coadd.pro", "", "pgc_compute_minimum", "", "dd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_coadd.html#pgc_compute_maximum", "pgc_compute_maximum", 'routine in <a href="nv/com/pg/pg_coadd.html">pg_coadd.pro</a>', "pg_coadd.pro", "", "pgc_compute_maximum", "", "dd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_coadd.html#pg_coadd", "pg_coadd", 'routine in <a href="nv/com/pg/pg_coadd.html">pg_coadd.pro</a>', "pg_coadd.pro", "", "pg_coadd", "", "cdbxgdmedianminimummaximumalgorithmddbx0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_core.html", "pg_core.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_core.pro", "", "", " NAME: 	pg_core    PURPOSE: 	Generates a dn profile through a cube, or stack of images.   CATEGORY: 	NV/PG    CALLING SEQUENCE:     result = pg_core(dd, cd=cd, outline_ptd)    ARGUMENTS:   INPUT: 	  dd:	 Data descriptor(s).   outline_ptd:   POINT descriptor giving the outline of the region to plot,                 as produced by the pg_select_region.    OUTPUT:         NONE   KEYWORDS:   INPUT: 	  cd:	Camera descriptor.  Needed for sinc interpolation. (to get PSF)           gd:   Optional generic descriptor containing cd.       interp:   Type of interpolation to use.  Options are:                'nearest', 'mean', 'bilinear', 'cubic', 'sinc'.           bg:	Uniform value to subtract from profile.   arg_interp:   Arguments to pass to the interpolation function.     OUTPUT:     profile:   The profile.        sigma:   Array giving the standard deviation at each point in the 		profile.      distance:  Array giving the distance, in pixels, along the profile.     image_pts:  Image point for each point along the profile.    RETURN: 	Two data descriptors: the first contains the profile; the second contains 	the profile sigma.    MODIFICATION HISTORY:        Written by:     Spitale, 7/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_core.html#pg_core", "pg_core", 'routine in <a href="nv/com/pg/pg_core.html">pg_core.pro</a>', "pg_core.pro", "", "pg_core", "", "cdgddistanceinterparg_interpsigmaprofileimage_ptsbgddoutline_ptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_core.html#test", "test", 'routine in <a href="nv/com/pg/pg_core.html">pg_core.pro</a>', "pg_core.pro", "", "test", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_coregister.html", "pg_coregister.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_coregister.pro", "", "", " NAME: 	pg_coregister    PURPOSE: 	Using the given geometry information, shifts the given images so as 	to center the given bodies at the same pixel in each image, or aligns 	images based on pointing.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_coregister, dd, cd=cd, bx=bx    ARGUMENTS:   INPUT: 	dd:	Array of data descriptors giving images to shift.    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd:	Array of camera descripors, one for each input image.  	bx:	Array of descriptors of any superclass of BODY, one for each 		input image.  	gd:	Generic descriptor containing the camera and body 		descriptors or an array of generic descriptors, one for each 		input image.  	center: Image coordinates at which to center each body.  By default, 		the average center among all the bodies is used.  If this input 		contains a single element, it is taken as the index of the 		input image to use as the reference.  	p:	Array (1,3) giving surface coordinates at which to center 		each body.  	xshift:	Additional image offset by which to shift each image.  	wrap:	If set shifted pixels are wrapped to the opposite side 		of the image.  	subpixel: By default, each image is shifted by an integer number of 		  pixels in each direction. If this keyword is set, the 		  image is interpolated onto a new pixel grid such that the 		  sub-pixel shift is obtained.  (Not currently implemented)    OUTPUT: 	shift:	Offset applied to each image.    SIDE EFFECTS: 	The given data and camera descriptors are modified: the images are 	shifted and the camera descriptor optic axes are changed accordingly.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 11/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_coregister.html#pg_coregister", "pg_coregister", 'routine in <a href="nv/com/pg/pg_coregister.html">pg_coregister.pro</a>', "pg_coregister.pro", "", "pg_coregister", "", "cdbxgdshiftcenterpxshiftwrapsubpixelno_shiftdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_covariance.html", "pg_covariance.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_covariance.pro", "", "", " NAME: 	pg_covariance    PURPOSE: 	Computes a covariance matrix for the least-square fit specified by the 	input scan coefficients.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	dxy = pg_covariance(cf)    ARGUMENTS:   INPUT: 	cf:	Array of pg_fit_coeff_struct as produced by pg_cvscan_coeff or 		pg_ptscan_coeff.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	status:	0 if successful, -1 otherwise.    RETURN: 	Covariance matrix.  The diagonal elements are the variances in each fit 	parameter, the off-diagonal elements are the covariances.    RESTRICTIONS: 	It is the caller's responsibility to ensure that all of the input 	coefficients were computed using with the same set of fixed parameters.    STATUS: 	Complete    SEE ALSO: 	pg_cvscan, pg_cvscan_coeff, pg_ptscan, pg_ptscan_coeff, 	pg_cvchisq, pg_ptchisq, pg_threshold    MODIFICATION HISTORY:  	Written by:	Spitale, 9/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_covariance.html#pg_covariance", "pg_covariance", 'routine in <a href="nv/com/pg/pg_covariance.html">pg_covariance.pro</a>', "pg_covariance.pro", "", "pg_covariance", "", "statuscf", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_crop.html", "pg_crop.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_crop.pro", "", "", " NAME:        pg_crop    PURPOSE:        Crops an image and modifies that camera descriptor accordingly.    CATEGORY:        NV/PG    CALLING SEQUENCE:        pg_crop, dd, corner_ptd, cd=cd, image=image    ARGUMENTS:   INPUT:        dd:        Data descriptor containing the image to be cropped.  	corner_ptd: POINT object containing 2 points, giving the corners 		    for cropping.  May also be an array of 2 image points.    OUTPUT:        dd:	The image contained in the input data descriptor is cropped.    KEYWORDS:   INPUT:        cd:     Camera descriptor.         gd:     Generic descriptor to use instead of cd.    OUTPUT: 	cd:	The optic axis of the camera descriptor is modified to 		correspond to the corrected image.         image:	The cropped image    RETURN:        NONE    EXAMPLE: 	pg_crop, dd, cd=cd, [[100,200], [800,900]], im=im    STATUS:        Complete.    NOTES: 	This routine should be modified to work with map descriptors as well.    MODIFICATION HISTORY:        Written by:     Spitale; 6/2005   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_crop.html#pg_crop", "pg_crop", 'routine in <a href="nv/com/pg/pg_crop.html">pg_crop.pro</a>', "pg_crop.pro", "", "pg_crop", "", "cdgdimagecropddcorner_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_crop_points.html", "pg_crop_points.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_crop_points.pro", "", "", " NAME: 	pg_crop_points    PURPOSE: 	Hides image points that lie outside the field of view.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_crop_points, cd, ptd    ARGUMENTS:   INPUT: 	ptd:	POINT object containing points to be cropped.    OUTPUT: 	ptd:	The input POINT object is modified.    KEYWORDS:   INPUT: 	cd:	Camera descriptor, used to determine image dimenesions.  	slop:	Number of pixels outside image to include.  Defautl is 1.    OUTPUT: 	indices: Indices of retained points.    RETURN: 	NONE    RESTRICTIONS: 	The given POINT object is modified.    STATUS: 	xx    MODIFICATION HISTORY:  	Written by:	Spitale; 5/2005   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_crop_points.html#pg_crop_points", "pg_crop_points", 'routine in <a href="nv/com/pg/pg_crop_points.html">pg_crop_points.pro</a>', "pg_crop_points.pro", "", "pg_crop_points", "", "cdslopindicesptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_cursor.html", "pg_cursor.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_cursor.pro", "", "", " NAME: 	pg_cursor    PURPOSE: 	Allows the user to obtain information about image pixels selected 	using the mouse in the current graphics window.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_cursor, dd    ARGUMENTS:   INPUT: 	dd:	Data descriptor containing the image.  Multiple data 		descriptors may be given and the pixel values for each will 		be displayed.  However, descriptors for only one of the data 		descriptors may be given.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	cd:	Camera descriptor.  Must be included for planet and ring 		coordinate, RA/DEC, and photometric output.  A map descriptor 		may be substitued for this argument, in which case ring 		coordinates, RA/DEC, and photometric data are not output.  	gbx:	Object descriptors, subclass of 'GLOBE'.  Must be included for 		planet coordinate output.  	dkx:	Object descriptors, subclass of 'DISK'.  Must be included for 		ring coordinate output.  	sund:	Star descriptor specifying the state of the sun.  	sd:	Star descriptors.  Must be included for star otput.  	gd:	Generic descriptor.  If given, the above object descriptors are 		taken from this structure.  	radec:	If set, right ascension and declination with respect to the 		inertial coordinate system are output for each selected pixel.  	photom:	If set, photometric angles are output for each pixel that 		intersects a planet or ring.  (Ring photometry is not yet 		implememented)  	fn:	Names of functions to be called whenever a point is selected. 		Each function is called as follows:  		value = call_function(fn, p, image, gd=gd, $                                                format=_format, label=label)  		p is the image coords of the selected point, image is the 		input image and gd is a generic descriptor containing the 		object descriptors.  format and label are outputs used to label 		the returned value.  These functions are apended to the set of 		default functions.  	silent:	If set, no string is printed, although the 'string' output 		keyword remains valid.  	xy:	If present, this image point is used and the user is not 		prompted to select a point.     OUTPUT: 	string:	The string that's printed.  If /silent is specified, this 		string is valid, but not printed.  	values: Array (nfn,2,npoints) giving the numerical results in the order 		that they appear in the output.    RETURN: 	NONE    STATUS: 	Ring photometry is not yet implemented.    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_cursor.html#_pgc_xy", "_pgc_xy", 'routine in <a href="nv/com/pg/pg_cursor.html">pg_cursor.pro</a>', "pg_cursor.pro", "", "_pgc_xy", "", "gdformatlabelnamepdd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_cursor.html#__pgc_dn", "__pgc_dn", 'routine in <a href="nv/com/pg/pg_cursor.html">pg_cursor.pro</a>', "pg_cursor.pro", "", "__pgc_dn", "", "gdformatlabelnamepdd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_cursor.html#_pgc_dn", "_pgc_dn", 'routine in <a href="nv/com/pg/pg_cursor.html">pg_cursor.pro</a>', "pg_cursor.pro", "", "_pgc_dn", "", "gdformatlabelnamepdd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_cursor.html#_pgc_star", "_pgc_star", 'routine in <a href="nv/com/pg/pg_cursor.html">pg_cursor.pro</a>', "pg_cursor.pro", "", "_pgc_star", "", "gdformatlabelnamepdd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_cursor.html#_pgc_radec", "_pgc_radec", 'routine in <a href="nv/com/pg/pg_cursor.html">pg_cursor.pro</a>', "pg_cursor.pro", "", "_pgc_radec", "", "gdformatlabelnamepdd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_cursor.html#_pgc_globe", "_pgc_globe", 'routine in <a href="nv/com/pg/pg_cursor.html">pg_cursor.pro</a>', "pg_cursor.pro", "", "_pgc_globe", "", "gdformatlabelnamepdd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_cursor.html#_pgc_map", "_pgc_map", 'routine in <a href="nv/com/pg/pg_cursor.html">pg_cursor.pro</a>', "pg_cursor.pro", "", "_pgc_map", "", "gdformatlabelnamepdd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_cursor.html#_pgc_disk", "_pgc_disk", 'routine in <a href="nv/com/pg/pg_cursor.html">pg_cursor.pro</a>', "pg_cursor.pro", "", "_pgc_disk", "", "gdformatlabelnamepdd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_cursor.html#_pgc_disk_scale", "_pgc_disk_scale", 'routine in <a href="nv/com/pg/pg_cursor.html">pg_cursor.pro</a>', "pg_cursor.pro", "", "_pgc_disk_scale", "", "gdformatlabelnamepdd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_cursor.html#_pgc_eqplane", "_pgc_eqplane", 'routine in <a href="nv/com/pg/pg_cursor.html">pg_cursor.pro</a>', "pg_cursor.pro", "", "_pgc_eqplane", "", "gdformatlabelnamepdd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_cursor.html#_pgc_eqplane_scale", "_pgc_eqplane_scale", 'routine in <a href="nv/com/pg/pg_cursor.html">pg_cursor.pro</a>', "pg_cursor.pro", "", "_pgc_eqplane_scale", "", "gdformatlabelnamepdd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_cursor.html#_pgc_photom_globe", "_pgc_photom_globe", 'routine in <a href="nv/com/pg/pg_cursor.html">pg_cursor.pro</a>', "pg_cursor.pro", "", "_pgc_photom_globe", "", "gdformatlabelnamepdd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_cursor.html#_pgc_photom_disk", "_pgc_photom_disk", 'routine in <a href="nv/com/pg/pg_cursor.html">pg_cursor.pro</a>', "pg_cursor.pro", "", "_pgc_photom_disk", "", "gdformatlabelnamepdd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_cursor.html#_pgc_photom_eqplane", "_pgc_photom_eqplane", 'routine in <a href="nv/com/pg/pg_cursor.html">pg_cursor.pro</a>', "pg_cursor.pro", "", "_pgc_photom_eqplane", "", "gdformatlabelnamepdd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_cursor.html#pgc_table", "pgc_table", 'routine in <a href="nv/com/pg/pg_cursor.html">pg_cursor.pro</a>', "pg_cursor.pro", "", "pgc_table", "", "label_padvalue_padnamename_pvalue_plabel_pformat_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_cursor.html#pg_cursor", "pg_cursor", 'routine in <a href="nv/com/pg/pg_cursor.html">pg_cursor.pro</a>', "pg_cursor.pro", "", "pg_cursor", "", "cdgbxdkxsundsdgdfnradecphotomxystringsilentvaluesddptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_cusps.html", "pg_cusps.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_cusps.pro", "", "", " NAME: 	pg_cusps    PURPOSE: 	Computes image points at the limb/terminator cusps for each given 	globe object.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	cusp_ptd = pg_cusps(cd=cd, od=od, gbx=gbx) 	cusp_ptd = pg_cusps(gd=gd)    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd:	 Array (n_timesteps) of camera descriptors.  	od:	 Array (n_timesteps) of descriptors for the observer, 		 default is the sun is gd given.  	gbx:	 Array (n_objects, n_timesteps) of descriptors of objects 		 which must be a subclass of GLOBE.  	gd:	Generic descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.  	dd:	Data descriptor containing a generic descriptor to use 		if gd not given.  	epsilon: Maximum angular error in the result.  Default is 1e-3.  	reveal:	 Normally, points computed for objects whose opaque flag 		 is set are made invisible.  /reveal suppresses this behavior.     OUTPUT: NONE    RETURN: 	Array (n_objects) of POINT objects containing image 	points and the corresponding inertial vectors.    PROCEDURE: 	This program uses an iterative scheme to find the two points on 	the surface of the globe where the surface normal is simultaneously 	perpendicular to the vectors from the camera and the Sun.     STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 12/2010   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_cusps.html#pg_cusps", "pg_cusps", 'routine in <a href="nv/com/pg/pg_cusps.html">pg_cusps.pro</a>', "pg_cusps.pro", "", "pg_cusps", "", "cdodgbxddgdepsilonreveal", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_cvchisq.html", "pg_cvchisq.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_cvchisq.pro", "", "", " NAME: 	pg_cvchisq    PURPOSE: 	Computes chi-squared value for given curve fit parameters.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	chisq = pg_cvchisq(dxy, dtheta, scan_ptd, axis_ptd=axis_ptd)    ARGUMENTS:   INPUT: 	dxy:		2-element vector giving the translation as [dx,dy].  	dtheta:		Rotation in radians.  	scan_ptd:	Array (n_curves) of POINT output from 			pg_cvscan containing scanned image points as well as 			other necessary scan data.    OUTPUT: NONE    KEYWORDS:   INPUT: 	axis_ptd:	POINT containing a single image  point 			to be used as the axis of rotation.  	fix:		Array specifying which parameters to fix as 			[dx,dy,dtheta].    OUTPUT: NONE    RETURN: 	Chi-square value.    RESTRICTIONS: 	The caller is responsible for ensuring that the input parameters are 	consistent with those used with other programs like pg_fit.    STATUS: 	Complete    SEE ALSO: 	pg_cvscan, pg_cvscan_coeff, pg_cvchisq, pg_ptscan, pg_ptscan_coeff, 	pg_ptchisq, pg_fit, pg_threshold    MODIFICATION HISTORY:  	Written by:	Spitale, 6/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_cvchisq.html#pg_cvchisq", "pg_cvchisq", 'routine in <a href="nv/com/pg/pg_cvchisq.html">pg_cvchisq.pro</a>', "pg_cvchisq.pro", "", "pg_cvchisq", "", "axis_ptdfixdxydthetascan_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_cvscan.html", "pg_cvscan.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_cvscan.pro", "", "", " NAME: 	pg_cvscan    PURPOSE: 	Attempts to find points of highest correlation with a given model along 	curves in an image.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	scan_ptd = pg_cvscan(dd, curve_ptd)    ARGUMENTS:   INPUT: 	dd:		Data descriptor  	cd:		Camera descriptor.  not required, but some 			interpolation schemes will not work without it.  	bx:		Descriptor specifying the body associated with 			each POINT object.  Not required, but some algorithms 			will not work properly without it.  	gd:		Generic descriptor.  	curve_ptd:	Array (n_curves) of POINT objects giving the curves. 			Only the image coordinates of the curves need to be 			specified in the POINT object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	model_p:	Array (n_curves) of pointers to model arrays.  Each 			model array has dimensions (n_points,nm), where n_points 			is the number of points in the curve and nm is the 			number of points in the model.  Thus, a model may be 			specified for each point on the curve.  Default 			model is edge_model_atan().  	mzero:		Array (n_curves) or (n_curves,n_points) of zero-point 			offsets for each model in model_p.  mzero must be 			specified if model_p is given.  	width:		Number of pixels to scan on either side of the curve. 			Default is 20.  	edge:		Distance from the edge of the image within which 			curve points will not be scanned.  Default is 0.  	algorithm:	Name of alrogithm to use to detect the edge. 			Choices are 'MODEL', 'GRAD', and 'HALF'. 			Default is 'MODEL'.  	arg:		Argument passed to the edge detection routine. 			For the GRAD algorithm, this argument specifies 			whether each edge is interior (arg=1) or 			exterior (arg=0).  	scan_ptd:	If given, these previously scanned points are updated 			to be consistent with the given data points.  The image 			is not scanned.  	dir:		If given the scan will be performed in this direction 			instead of normal to the curve.  Must be a 2-element 			unit vector.    OUTPUT: NONE    RETURN: 	Array (n_curves) of POINT objects containing resulting image points, 	as well as additional scan data to be used by pg_cvscan_coeff and 	possibly other programs.  The scan data is as follows:  		 tag			 description 	 	-----			------------- 		scan_cos		Cosine of normal at each point. 		scan_sin		Sine of normal at each point. 		scan_offsets		Raw offsets from computed curve. 		scan_cc			Correlation coefficient for each scanned 					point. 		scan_sigma		Scan offset uncertainties. 		scan_model_xpts		Model points corresponding to each 		scan_model_ypts		 scanned point    RESTRICTIONS: 	Currently does not work for multiple time steps.    PROCEDURE: 	Normal sines and cosines are computed using icv_compute_directions. 	These directions are input to icv_strip_curve along with the image 	in order to extract an image strip to be scanned.  icv_scan_strip is 	then used to find the optimum scan offsets and icv_convert_scan_offsets 	is used to obtain image coordinates corresponding to each scan offset. 	See the documentation for each of those routines for more details.    EXAMPLE: 	The following command scans for a limb in the image contained in the 	given data descriptor, dd:  	scan_ptd = pg_cvscan(dd, limb_ptd, width=40, edge=20)  	In this call, limb_ptd is a POINT containing computed limb 	points.    STATUS: 	Complete    SEE ALSO: 	pg_cvscan_coeff, pg_cvchisq, pg_ptscan, pg_ptscan_coeff, pg_ptchisq, 	pg_fit, pg_threshold    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_cvscan.html#pg_cvscan", "pg_cvscan", 'routine in <a href="nv/com/pg/pg_cvscan.html">pg_cvscan.pro</a>', "pg_cvscan.pro", "", "pg_cvscan", "", "algorithmcdbxgdmodel_pmzerodirwidthedgeargscan_ptdddobject_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_cvscan_coeff.html", "pg_cvscan_coeff.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_cvscan_coeff.pro", "", "", " NAME: 	pg_cvscan_coeff    PURPOSE: 	Computes linear least-squares coefficients for a fit to the image 	coordinate translation and rotation that matches a computed curve to 	a scanned curve in an image.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	scan_cf = pg_cvscan_coeff(scan_ptd, axis_ptd=axis_ptd)    ARGUMENTS:   INPUT: 	scan_ptd:	Array (n_curves) of POINT output from 			pg_cvscan containing scanned image points as well as 			other necessary scan data.    OUTPUT: NONE    KEYWORDS:   INPUT: 	axis_ptd:	POINT containing a single image  point 			to be used as the axis of rotation in the fit for 			every curve.  	fix:		Array specifying which parameters to fix in the 			fit as [dx,dy,dtheta].    OUTPUT: NONE    RETURN: 	Array (n_curves) of pg_fit_coeff_struct containing coefficients for 	the least-square fit to be input to pg_fit.    RESTRICTIONS: 	Currently does not work for multiple time steps.    PROCEDURE: 	pg_cvscan_coeff extracts the scan data from the given 	scan_ptd structure and uses icv_coeff to compute the coefficients. 	See the documentation for that routine for details.    EXAMPLE: 	The following command uses scan data from pg_cvscan to compute 	least square coefficients for a fit such that only dx and dtheta 	will be allowed to vary:  	cvscan_cf = pg_cvscan_coeff(scan_ptd, axis=center_ptd, fix=[1])  	In this call, scan_ptd is a POINT containing the scan data 	from pg_cvscan and center_ptd is a POINT giving the center 	of the planet as computed by pg_center.    STATUS: 	Complete    SEE ALSO: 	pg_cvscan, pg_cvchisq, pg_ptscan, pg_ptscan_coeff, pg_ptchisq, 	pg_fit, pg_threshold    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_cvscan_coeff.html#pg_cvscan_coeff", "pg_cvscan_coeff", 'routine in <a href="nv/com/pg/pg_cvscan_coeff.html">pg_cvscan_coeff.pro</a>', "pg_cvscan_coeff.pro", "", "pg_cvscan_coeff", "", "axis_ptdfixscan_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_data_adjust.html", "pg_data_adjust.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_data_adjust.pro", "", "", " NAME: 	pg_data_adjust   PURPOSE: 	Allows the user to adjust data values using the mouse.  A rectangle 	is selected height (positve or negative) gives the data value adjustment. 	Works for 1-D or 2_d data sets.   CATEGORY:        NV/PG   CALLING SEQUENCE:      pg_data_adjust, dd    ARGUMENTS:   INPUT:       dd:	Data descriptor.    OUTPUT: 	NONE     KEYWORDS:   INPUT:          NONE      OUTPUT:          NONE    RETURN:       NONE    ORIGINAL AUTHOR : J. Spitale ; 2/2014   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_data_adjust.html#pg_data_adjust", "pg_data_adjust", 'routine in <a href="nv/com/pg/pg_data_adjust.html">pg_data_adjust.pro</a>', "pg_data_adjust.pro", "", "pg_data_adjust", "", "dd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_despike.html", "pg_despike.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_despike.pro", "", "", " NAME: 	pg_despike    PURPOSE: 	Removes previously-located spurious features like cosmic-ray hits.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_despike(dd)    ARGUMENTS:   INPUT: 	dd:		Data descriptor containing the image to be despiked.  	spike_ptd:	POINT specifying the points to replace; 			typically computed by pg_spikes.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	scale:		Typical size of features to be removed.  Default 			is 10.  	n=n:		Number of timers to repeat the box filter.  Default 			is 5.  	kernel:		If set, this kernel is used to weight the replacement 			of all pixels in a box of size scale around each 			spike point, instead of replacing only the spike 			point.  If this is a scalar, then this is taken as the 			width of a Gaussian kernel.    OUTPUT: 	image:		The corrected image.    RETURN: 	Data descriptor containing the corrected image.  If /noclone 	is not set, set input data descriptor is modified.    PROCEDURE: 	pg_despike replaces the values of the desired pixels with those 	computed by smoothing the input image using a box filter of size 	'scale' repeatedly, 'n' times.    STATUS: 	Complete.    SEE ALSO: 	pg_spikes    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2004   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_despike.html#pg_despike", "pg_despike", 'routine in <a href="nv/com/pg/pg_despike.html">pg_despike.pro</a>', "pg_despike.pro", "", "pg_despike", "", "imagescalenkernelnocloneddspike_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_disk.html", "pg_disk.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_disk.pro", "", "", " NAME: 	pg_disk    PURPOSE: 	Computes image points on the inner and outer edges of each given disk 	object at all given time steps.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_disk(cd=cd, dkx=dkx) 	result = pg_disk(gd=gd)    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd:	 Array (n_timesteps) of camera descriptors.  	dkx:	 Array (n_objects, n_timesteps) of descriptors of objects 		 which must be a subclass of DISK.  	gd:	Generic descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.  	dd:	Data descriptor containing a generic descriptor to use 		if gd not given.  	inner/outer: If either of these keywords are set, then only 	             that edge is computed.  	npoints: Number of points to compute around each edge.  Default is 		 1000.  	reveal:	 Normally, points computed for objects whose opaque flag 		 is set are made invisible.  /reveal suppresses this behavior.  	clip:	 If set points are computed only within this many camera 		 fields of view.  	cull:	 If set, POINT objects excluded by the clip keyword 		 are not returned.  Normally, empty POINT objects 		 are returned as placeholders.    OUTPUT: NONE    RETURN: 	Array (2*n_objects) of POINT containing image points and 	the corresponding inertial vectors.  The output array is arranged as 	[inner, outer, inner, outer, ...] in the order that the disk 	descriptors are given in the dkx argument.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_disk.html#pg_disk", "pg_disk", 'routine in <a href="nv/com/pg/pg_disk.html">pg_disk.pro</a>', "pg_disk.pro", "", "pg_disk", "", "cddkxddgdclipcullinnerouternpointsreveal", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_drag.html", "pg_drag.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_drag.pro", "", "", " NAME: 	pg_drag    PURPOSE: 	Allows the user to graphically translate and rotate an array of points 	using the mouse.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	dxy = pg_drag(object_ptd, dtheta=dtheta, axis_ptd=axis_ptd)    ARGUMENTS:   INPUT: 	object_ptd:	Array (n_objects) of POINT containing the 			image points to be dragged.    OUTPUT: 	object_ptd:	If /move, the input points will be modified by the 			offsets resulting from the drag.    KEYWORDS:   INPUT: 	axis_ptd:	POINT containing a single image point 			to be used as the axis of rotation.  	sample:		Sampling interval for drag graphics.  The input 			points are subsampled at this interval so that the 			dragging can be done smoothly.  Default is 10.  	move:		If set, object_ptd will be modified on return using 			pg_move.  	symbol:		If set, the symbol number will be passed to cursor_move 			so something other than a period can be used to mark 			points.  	silent:		If set, turns off the notification that cursor                        movement is required.  	xor_graphics:	If set, grahics are drawn using the XOR function.  	color:		Drawing color.  Default is ctyellow.    OUTPUT: 	dtheta:		Dragged rotation in radians.    RETURN: 	2-element array giving the drag translation as [dx,dy].    PROCEDURE: 	cursor_move is used to perfform the drag.  See that routine for more 	detail.    STATUS: 	Complete    SEE ALSO: 	pg_move    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998       Modified by:     Dyer Lytle, Vance Haemmerle 11/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_drag.html#pg_drag", "pg_drag", 'routine in <a href="nv/com/pg/pg_drag.html">pg_drag.pro</a>', "pg_drag.pro", "", "pg_drag", "", "drawxor_graphicsdthetaaxis_ptdsamplemovesymbolsilentcolorfndataobject_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_drag_shadow_plane.html", "pg_drag_shadow_plane.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_drag_shadow_plane.pro", "", "", " NAME: 	pg_drag_shadow_plane    PURPOSE: 	Allows the user to graphically rotate a plane passing through the 	center of a planet by dragging the shadow cast by the planet on the 	plane using the mouse.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	dxy = pg_drag_shadow_plane(cd=cd, gbx=gbx, sund=sund)    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd:	 Camera descriptor.  	gbx:	 Subclass of GLOBE.  	sund:	 Star descriptor for the Sun.  	gd:	Generic descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.  	dd:	Data descriptor containing a generic descriptor to use 		if gd not given.  	p0:	 Initial point to use instead  of prompting the user.  	n0:	 Initial plane orientation.  Default is the planet y-axis.  	gain:	 Radians / pixel offset from the initial point.  	axis:	 Rotation axis; default is the planet pole.  	silent:	 If set, turns off notifications.  	xor_graphics:	If set, grahics are drawn using the XOR function.  	color:		Drawing color.    OUTPUT: NONE    RETURN: 	Column vector giving the final plane orientation.     STATUS: 	Complete    SEE ALSO:     MODIFICATION HISTORY:  	Written by:	Spitale, 2/2012   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_drag_shadow_plane.html#pgdsp_compute", "pgdsp_compute", 'routine in <a href="nv/com/pg/pg_drag_shadow_plane.html">pg_drag_shadow_plane.pro</a>', "pg_drag_shadow_plane.pro", "", "pgdsp_compute", "", "ncdpdsundn0term_ptdaxistheta", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_drag_shadow_plane.html#pg_drag_shadow_plane", "pg_drag_shadow_plane", 'routine in <a href="nv/com/pg/pg_drag_shadow_plane.html">pg_drag_shadow_plane.pro</a>', "pg_drag_shadow_plane.pro", "", "pg_drag_shadow_plane", "", "cdgbxsundddgdxor_graphicsp0n0silentcolorgainaxisshadow_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_draw.html", "pg_draw.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_draw.pro", "", "", " NAME: 	pg_draw    PURPOSE: 	Calls pg_draw_point or pg_draw_vector depending on the input arrays. 	pg_draw_point is called is only one argument is given.  Otherwise, 	it assumed that a source and target are given and pg_draw_vector is 	called.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_draw, object_ptd, target_ptd    ARGUMENTS:   INPUT: 	object_ptd:	Array of POINT containing image points 			to be plotted in the current data coordinate system. 			Or inertial vectors to be used as vector sources. 			May also be an array of image points or inertial 			vectors.  	target_ptd:	Array of POINTs giving the inertial 			positions of vector targets.  May also be an 			array of inertial vectors.  If this argument is 			present, then vectors are drawn instead of points.    OUTPUT: NONE    KEYWORDS: 	graphics:	Logical operation to use for drawing.  	See pg_draw or pg_draw_vector for more keywords.    RETURN: 	NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 9/2005   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_draw.html#pg_draw", "pg_draw", 'routine in <a href="nv/com/pg/pg_draw.html">pg_draw.pro</a>', "pg_draw.pro", "", "pg_draw", "", "literalcolorsshadespsymspsizesplabelsxormodecsizescthickswnumlabel_shadelabel_pointsthicklineprintcdgdcorientlengthsalignnoshortensolidfixedheadswinglengthgraphicslabel_colorshade_thresholdobject_ptdtarget_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_draw_point.html", "pg_draw_point.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_draw_point.pro", "", "", " NAME: 	pg_draw_point    PURPOSE: 	Draws points from the given POINT on the current graphics 	window using the current data coordinate system.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_draw_point, object_ptd    ARGUMENTS:   INPUT: 	object_ptd:	Array of POINT containing image points 			to be plotted in the current data coordinate system.    OUTPUT: NONE    KEYWORDS:   INPUT: 	literal:	All of the following input keywords accept an array 			where each element corresponds to an element in the 			object_ptd array.  By default, if the keyword array is 			shorter than the object_ptd array, then the last element 	  		is used to fill out the array.  /literal suppresses 			this behavior and causes unspecified elements to 			take their default values.  	colors:		Array of plotting colors.  Default is !color.  String 			names will be converted using the ct<string>() 			functions.  Labels are also plotted in this color. 			If one element, then all points are plotted in this 			color; if multiple elements, and object_ptd also 			has multiple elements, each color will be assigned to 			all elements in the corresponding array (see /literal); 			if mulitple elements, and object_ptd has only one 			element, then each color will be assigned to each 			element of th object_ptd array.  	shades:		Array of plotting shades.  Default is 1.0.  	label_shade:	Array of plotting shades for labels.  Default is 1.0.  	shades:		Array of plotting shades.  Default is 1.0.  	psyms:		Array of plotting symbols.  Default is 3.  	thick:		Array of plotting thicknesses.  Default is 1.  	line:		Array of linestyles.  Default is 0.  	psizes:		Array of plotting symbol sizes.  Default is 1.0.  	csizes:		Array of character sizes.  Default is 1.0.  	cthicks:	Array of character thicknesses.  Default is 1.0.  	corient:	Array of character orientations.  Default is 1.0.  	plabels:	Array of object labels.  Default is ''.  	label_points:	If set, plabels will be applied element-by-element to 			each point in each points array instead of once 			to each object.  	align:		Label alignment.  See XYOUTS.  	wnum:		Window number in which to draw.  	xormode:	If set, XOR graphics mode is used for drawing.  	print:		Message to print before plotting.    OUTPUT: NONE    RETURN: 	NONE    EXAMPLE: 	The following command draws and labels a lavender 'limb' and a red 	'ring' (assuming that the points have already been computed):  	pg_draw_point, [limb_ptd, ring_ptd], color=[ctpurple(), ctred()], $ 	         plabels=['LIMB','RING']    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998 (pg_draw) 	Renamed pg_draw_point: Spitale, 9/2005   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_draw_point.html#pgdp_draw", "pgdp_draw", 'routine in <a href="nv/com/pg/pg_draw_point.html">pg_draw_point.pro</a>', "pg_draw_point.pro", "", "pgdp_draw", "", "label_pointsplabelspointscolorspsymspsizesthicklinecsizescthickscorientalignplabel_offsetlabel_colors", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_draw_point.html#pgdp_fill", "pgdp_fill", 'routine in <a href="nv/com/pg/pg_draw_point.html">pg_draw_point.pro</a>', "pg_draw_point.pro", "", "pgdp_fill", "", "defall_valn_objects", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_draw_point.html#pg_draw_point", "pg_draw_point", 'routine in <a href="nv/com/pg/pg_draw_point.html">pg_draw_point.pro</a>', "pg_draw_point.pro", "", "pg_draw_point", "", "literalcolorspsymspsizesplabelsxormodecsizescthickswnumshadeslabel_pointsthicklineprintlabel_shadealigncorientlabel_colorshade_threshold_pp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_draw_vector.html", "pg_draw_vector.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_draw_vector.pro", "", "", " NAME: 	pg_draw_vector     PURPOSE:          Draws vectors on an image from a source towards a          target. Very useful for locating off-image objects          (planets, say) in an image for referencing.  By default,          vectors are foreshortened to their projections onto the image          plane so that vectors with large  out-of-plane components          will be shorter.  (This can be deactivated with the          /noshorten keyword.)  Also by default, vectors that point          away from the camera will be drawn as dotted lines while          vectors which point towards the camera will be drawn solid.          (This can be controlled with the /solid keyword.)     CATEGORY:          NV/PG    CALLING SEQUENCE:                  pg_draw_vector, sources, targets,                  (cd=cd| gd=gd)[, /literal, thick=thick, lengths=lengths,                   colors=colors, plabels=plabels, csizes=csizes]     INPUTS:         sources:         Inertial positions of sources.  Either an array                          of column vectors (nv x 3 x nt) or an array of                          POINT objects containing the inertial vectors.          targets:         Inertial positions of targets, or inertial unit                          vectors giving directions to targets.  Either an                          array of column vectors (nv x 3 xnt) or an array                          of POINT objects.  There must either be a single                          target point or a one-to-one match between source                          and target points.     OPTIONAL INPUTS:     KEYWORD PARAMETERS:         cd or gd        A camera descriptor or a generic descriptor                        containing a camera descriptor.  Required unless 			source and target given as image points.  	literal:	All of the following input keywords accept an array 			where each element corresponds to an element in the 			object_ptd array.  By default, if the keyword array is 			shorter than the object_ptd array, then the last element 	  		is used to fill out the array.  /literal suppresses 			this behavior and causes unspecified elements to 			take their default values         lengths:        Lengths of the vectors.  (Default: 50 pixels)         thick:         Line thicknesses.  (Default: 1)         colors:         Colors to use in drawing.  (Default: current                        default color)         plabels:         Text with which to label vectors.  (Default:                        no label)         csizes:      Character sizes for plabels.  (Default: 1)         solid:         All lines are to be drawn solid (linestyle=0)                        rather than allow vectors pointing into the                        image plane to be dotted.         noshorten:     If set, vectors will not be foreshortened                        depending on how much they point into/out                        of the image plane.         fixedheads:     If set, arrowheads will not be scaled to                         match the foreshortening of the vector.   OUTPUTS:         None    EXAMPLE:        Say moon_points is a POINT object containing the center        data for the four Galilean satellites and jupiter_points has        Jupiter's center data.  Then         IDL> pg_draw_vector, moon_points, jupiter_points, colors=[100, $              150, 200, 250], thick=1.25, length=70, plabels= Jupiter , $              csizes=1.5         will draw vectors from each towards the planet.  Conversely,         IDL> pg_draw_vector, jupiter_points, moon_points, colors=[100, $              150, 200, 250], thick=1.25, length=70, plabels=[ Io ,  Europa , $               Ganymede ,  Callisto ], csizes=1.5         will draw vectors from Jupiter's center towards each moon,        labelling each by the moon's name.    MODIFICATION HISTORY:       Written: John W. Weiss, 5/05      Consolidated some functionality into plot_arrow; Spitale 9/2005    ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_draw_vector.html#pg_draw_vector", "pg_draw_vector", 'routine in <a href="nv/com/pg/pg_draw_vector.html">pg_draw_vector.pro</a>', "pg_draw_vector.pro", "", "pg_draw_vector", "", "cdddgdliterallengthsplabelscolorsthickcsizeswnumnoshortensolidfixedheadswinglengthdraw_wnumshadeslabel_shadelabel_colorshade_thresholdsourcetarget", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_edges.html", "pg_edges.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_edges.pro", "", "", " NAME: 	pg_edges    PURPOSE: 	Scans an image for candidate edge points.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	edge_ptd = pg_edges(dd)    ARGUMENTS:   INPUT: 	dd:		Data descriptor    OUTPUT: NONE    KEYWORDS:   INPUT: 	threshold:	Minimum activity to accept as an edge point.  	edge:		Distance from the edge of the image within which 			curve points will not be scanned.  Default is 0.  	npoints:	Maximum number of points to return.  	lowpass:	If given, the image is smoothed with a kernel of 			this size.     OUTPUT: NONE    RETURN: 	POINT giving the resulting edge points.    PROCEDURE: 	At each pixel in the image, an activity is computed (see activity.pro). 	Points with activity greater than the threshold value are accepted.    STATUS: 	Complete    SEE ALSO: 	pg_cvscan_coeff, pg_cvchisq, pg_ptscan, pg_ptscan_coeff, pg_ptchisq, 	pg_fit, pg_threshold    MODIFICATION HISTORY:  	Written by:	Spitale, 4/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_edges.html#pg_edges", "pg_edges", 'routine in <a href="nv/com/pg/pg_edges.html">pg_edges.pro</a>', "pg_edges.pro", "", "pg_edges", "", "thresholdedgenpointsgatelowpassdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_exclude_points.html", "pg_exclude_points.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_exclude_points.pro", "", "", " NAME: 	pg_exclude_points    PURPOSE: 	xx    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = xx(xx, xx) 	xx, xx, xx    ARGUMENTS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    KEYWORDS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    ENVIRONMENT VARIABLES: 	xx:	xx  	xx:	xx    RETURN: 	xx    COMMON BLOCKS: 	xx:	xx  	xx:	xx    SIDE EFFECTS: 	xx    RESTRICTIONS: 	xx    PROCEDURE: 	xx    EXAMPLE: 	xx    STATUS: 	xx    SEE ALSO: 	xx, xx, xx    MODIFICATION HISTORY:  	Written by:	xx, xx/xx/xxxx   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_exclude_points.html#pg_exclude_points", "pg_exclude_points", 'routine in <a href="nv/com/pg/pg_exclude_points.html">pg_exclude_points.pro</a>', "pg_exclude_points.pro", "", "pg_exclude_points", "", "radiusptdxptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_farfit.html", "pg_farfit.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_farfit.pro", "", "", " NAME: 	pg_farfit    PURPOSE: 	Searches for the offset (dx,dy) that gives the best agreement between 	two uncorrelated sets of image points.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	dxy = pg_farfit(dd, base_ptd, model_ptd)    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	base_ptd:	POINT giving a set of points to fit to. 			This input may be produced by pg_edges, for example.  	model_ptd:	Array of POINT giving model points (computed 			limb points for example).    OUTPUT: NONE    KEYWORDS:   INPUT: 	show:		If specified, the search is displayed in the current 			graphics window.  This value can be specified as a 			2-element array giving the size of the displayed image.  	bin:		Initial bin size for point densities.  Default is 50 			pixels.  	max_density:	Maximum model point density.  Default = 5.  	nsamples:	Number of samples in each direction in the grid search. 			See image_correlate.  	region:		Size of region to scan, centered at offset [0,0].  If not 			specified, the entire image is scanned.  	sigma:		2-element array giving the width of the correlation 			peak in each direction.  	cc:		Cross correlation of final result.  	mcc:		Corss correlation at the model points.  	bias:		If given, solutions are biased toward the initial 			guess using a weighting function of the form:  				exp(-r^2/2*bias),  			where r is the distance between from the initial 			guess.  	nosearch:	If set, no search is performed.  An offset of [0,0] 			is returned.     OUTPUT: NONE    RETURN: 	2-element array giving the fit offset as [dx,dy].    PROCEDURE: 	pg_farfit is a wrapper for the routine correlate_points.  See the 	documentation for that routine for details on the fitting procedure    STATUS: 	Complete.    SEE ALSO: 	pg_edges correlate_points    MODIFICATION HISTORY:  	Written by:	Spitale, 4/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_farfit.html#pg_farfit", "pg_farfit", 'routine in <a href="nv/com/pg/pg_farfit.html">pg_farfit.pro</a>', "pg_farfit.pro", "", "pg_farfit", "", "nsamplesshowbinmax_densityregionsigmaccmccbiasnosearchddbase_ptdmodel_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_fit.html", "pg_fit.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_fit.pro", "", "", " NAME: 	pg_fit    PURPOSE: 	Performs a simultaneous 1-,2-, or 3-parameter linear least-squares fit 	using the given coefficients.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	dxy = pg_fit(cf, dtheta=dtheta)    ARGUMENTS:   INPUT: 	cf:	Array of pg_fit_coeff_struct as produced by pg_cvscan_coeff or 		pg_ptscan_coeff.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	dtheta:	Fit offset in theta.    RETURN: 	2-element array giving the fit offset as [dx,dy].    RESTRICTIONS: 	It is the caller's responsibility to ensure that all of the input 	coefficients were computed using with the same set of fixed parameters.    PROCEDURE: 	pg_fit extracts the fit coefficients from cf and inputs them to mbfit 	to perform a simultatneous least square fit using all of the 	coefficients.  See the documentation for that routine for more detail.    EXAMPLE: 	The following commands perform a simultaneous least square fit to 	a limb, ring and star field with all parameters free:  	cvscan_ptd = pg_cvscan(dd, [limb_ptd,ring_ptd], width=40, edge=20) 	ptscan_ptd = pg_ptscan(dd, [star_ptd], width=40, edge=20)  	cvscan_cf = pg_cvscan_coeff(cvscan_ptd, axis=center_ptd) 	ptscan_cf = pg_ptscan_coeff(ptscan_ptd, axis=center_ptd)  	dxy = pg_fit([cvscan_cf,ptscan_cf], dtheta=dtheta)  	In this example, center_ptd, limb_ptd, ring_ptd, and star_ptd are assumed 	to have been previously computed using the appropriate routines.  	Note that since this is a linear fit, the input systems may have been 	linearized and it may be necessary to iterate this procedure.     STATUS: 	Complete    SEE ALSO: 	pg_cvscan, pg_cvscan_coeff, pg_ptscan, pg_ptscan_coeff, 	pg_cvchisq, pg_ptchisq, pg_threshold    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_fit.html#pg_fit", "pg_fit", 'routine in <a href="nv/com/pg/pg_fit.html">pg_fit.pro</a>', "pg_fit.pro", "", "pg_fit", "", "dthetacf", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_fit_coeff_struct__define.html", "pg_fit_coeff_struct__define.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_fit_coeff_struct__define.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_fit_coeff_struct__define.html#pg_fit_coeff_struct__define", "pg_fit_coeff_struct__define", 'routine in <a href="nv/com/pg/pg_fit_coeff_struct__define.html">pg_fit_coeff_struct__define.pro</a>', "pg_fit_coeff_struct__define.pro", "", "pg_fit_coeff_struct__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_footprint.html", "pg_footprint.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_footprint.pro", "", "", " NAME: 	pg_footprint    PURPOSE: 	Computes the footprint of a camera on a given body.    CATEGORY: 	NV/PG    CALLING SEQUENCE:        footprint_ptd = footprint(cd=cd, bx=bx)    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd:	Array (n_timesteps) of camera descriptors.  	bx:	Array (n_objects, n_timesteps) of descriptors of objects 		which must be a subclass of BODY.  	gd:	Generic descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.  	dd:	Data descriptor containing a generic descriptor to use 		if gd not given.  	clip:	 If set, points are computed only within this many camera 		 fields of view.  	sample:	 Sampling rate; default is 1 pixel.    OUTPUT: NONE    RETURN: 	Array (n_objects) of POINT containing image points and 	the corresponding inertial vectors.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 5/2014   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_footprint.html#pg_footprint", "pg_footprint", 'routine in <a href="nv/com/pg/pg_footprint.html">pg_footprint.pro</a>', "pg_footprint.pro", "", "pg_footprint", "", "cdbxddgdclipsample", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_get_arrays.html", "pg_get_arrays.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_get_arrays.pro", "", "", " NAME: 	pg_get_arrays    PURPOSE: 	Obtains a array descriptor for the given data descriptor.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_get_arrays(dd) 	result = pg_get_arrays(dd, trs)    ARGUMENTS:   INPUT: 	dd:	data descriptor  	trs:	String containing keywords and values to be passed directly 		to the translators as if they appeared as arguments in the 		translators table.  These arguments are passed to every 		translator called, so the user should be aware of possible 		conflicts.  Keywords passed using this mechanism take 		precedence over keywords appearing in the translators table.    OUTPUT: NONE    KEYWORDS:   INPUT: 	ard:		Input array descriptors; used by some translators.  	override:	Create a data descriptor and initilaize with the 			given values.  Translators will not be called.  	arr_*:		All array override keywords are accepted.  See 			array_keywords.include.  			If name is specified, then only descriptors with 			those names are returned.  	verbatim:	If set, the descriptors requested using name 			are returned in the order requested.  Otherwise, the 			order is determined by the translators.  	tr_override:	String giving a comma-separated list of translators 			to use instead of those in the translators table.  If 			this keyword is specified, no translators from the 			table are called, but the translators keywords 			from the table are still used.    RETURN: 	Array of array descriptors, 0 if an error occurs.    PROCEDURE: 	If /override, then a array descriptor is created and initialized 	using the specified values.  Otherwise, the descriptor is obtained 	through the translators.  Note that if /override is not used, 	values (except name) can still be overridden by specifying 	them as keyword parameters.  If name is specified, then 	only descriptors corresponding to those names will be returned.     MODIFICATION HISTORY:  	Written by:	Spitale, 10/2012   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_get_arrays.html#pg_get_arrays", "pg_get_arrays", 'routine in <a href="nv/com/pg/pg_get_arrays.html">pg_get_arrays.pro</a>', "pg_get_arrays.pro", "", "pg_get_arrays", "", "odbxard_extraoverrideverbatimddtrs@arr__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_get_cameras.html", "pg_get_cameras.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_get_cameras.pro", "", "", " NAME: 	pg_get_cameras    PURPOSE: 	Obtains a camera descriptor for the given data descriptor.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_get_cameras(dd) 	result = pg_get_cameras(dd, trs)    ARGUMENTS:   INPUT: 	dd:	data descriptor  	trs:	String containing keywords and values to be passed directly 		to the translators as if they appeared as arguments in the 		translators table.  These arguments are passed to every 		translator called, so the user should be aware of possible 		conflicts.  Keywords passed using this mechanism take 		precedence over keywords appearing in the translators table.    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd:		Input camera descriptors; used by some translators.  	gd:		Generic descriptor containing the above descriptors. 			Note this keyword is inherited from the CORE keywords 			list.  	override:	Create a data descriptor and initilaize with the 			given values.  Translators will not be called.  	cam_*:		All camera override keywords are accepted.  See 			camera_keywords.include.  			If cam_name is specified, then only descriptors with 			those names are returned.  	verbatim:	If set, the descriptors requested using cam_name 			are returned in the order requested.  Otherwise, the 			order is determined by the translators.  	tr_override:	String giving a comma-separated list of translators 			to use instead of those in the translators table.  If 			this keyword is specified, no translators from the 			table are called, but the translators keywords 			from the table are still used.  	default_orient:		Default orientation matrix to use if camera 				orientation is not available.  If not specified, 				the identity matrix is used.    RETURN: 	Array of camera descriptors, 0 if an error occurs.    PROCEDURE: 	If /override, then a camera descriptor is created and initialized 	using the specified values.  Otherwise, the descriptor is obtained 	through the translators.  Note that if /override is not used, 	values (except cam_name) can still be overridden by specifying 	them as keyword parameters.  If cam_name is specified, then 	only descriptors corresponding to those names will be returned.     MODIFICATION HISTORY:  	Written by:	Spitale, 1998 	Modified:	Spitale, 8/2001   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_get_cameras.html#pg_get_cameras", "pg_get_cameras", 'routine in <a href="nv/com/pg/pg_get_cameras.html">pg_get_cameras.pro</a>', "pg_get_cameras.pro", "", "pg_get_cameras", "", "cdodpd_extraoverrideverbatimdefault_orientno_defaultddtrs@cam__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_get_celestial_sphere.html", "pg_get_celestial_sphere.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_get_celestial_sphere.pro", "", "", " NAME: 	pg_get_celestial_sphere    PURPOSE: 	Obtains a globe descriptor describing the celestial sphere.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_get_celestial_sphere()    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: 	radius:	 Radius to use for the globe.  Default is 1d30.    OUTPUT: NONE    RETURN: 	Globe descriptor with inertial body descriptor and very large radii.     MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_get_celestial_sphere.html#pg_get_celestial_sphere", "pg_get_celestial_sphere", 'routine in <a href="nv/com/pg/pg_get_celestial_sphere.html">pg_get_celestial_sphere.pro</a>', "pg_get_celestial_sphere.pro", "", "pg_get_celestial_sphere", "", "radius", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_get_maps.html", "pg_get_maps.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_get_maps.pro", "", "", " NAME: 	pg_get_maps    PURPOSE: 	Obtains a map descriptor for the given data descriptor.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_get_maps(dd) 	result = pg_get_maps(dd, trs)    ARGUMENTS:   INPUT: 	dd:	data descriptor  	trs:	String containing keywords and values to be passed directly 		to the translators as if they appeared as arguments in the 		translators table.  These arguments are passed to every 		translator called, so the user should be aware of possible 		conflicts.  Keywords passed using this mechanism take 		precedence over keywords appearing in the translators table.    OUTPUT: NONE    KEYWORDS:   INPUT: 	md:		Input map descriptors; used by some translators.  	override:	Create a data descriptor and initilaize with the 			given values.  Translators will not be called.  	map_*:		All map override keywords are accepted.  See 			map_keywords.include.  			If name is specified, then only descriptors with 			those names are returned.  			If /override and name is not specified, then 			the name is taken from the core descriptor.  	verbatim:	If set, the descriptors requested using name 			are returned in the order requested.  Otherwise, the 			order is determined by the translators.  	tr_override:	String giving a comma-separated list of translators 			to use instead of those in the translators table.  If 			this keyword is specified, no translators from the 			table are called, but the translators keywords 			from the table are still used.    RETURN: 	Array of map descriptors, 0 if an error occurs.    PROCEDURE: 	If /override, then a map descriptor is created and initialized 	using the specified values.  Otherwise, the descriptor is obtained 	through the translators.  Note that if /override is not used, 	values (except name) can still be overridden by specifying 	them as keyword parameters.  If name is specified, then 	only descriptors corresponding to those names will be returned.     MODIFICATION HISTORY:  	Written by:	Spitale, 1998 	Modified:	Spitale, 8/2001   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_get_maps.html#pg_get_maps", "pg_get_maps", 'routine in <a href="nv/com/pg/pg_get_maps.html">pg_get_maps.pro</a>', "pg_get_maps.pro", "", "pg_get_maps", "", "mdgbxdkxbx_extraoverrideverbatimddtrs@map__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_get_planets.html", "pg_get_planets.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_get_planets.pro", "", "", " NAME: 	pg_get_planets    PURPOSE: 	Obtains planet descriptors for the given data descriptor.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_get_planets(dd, od=od) 	result = pg_get_planets(dd, od=od, trs)    ARGUMENTS:   INPUT: 	dd:	data descriptor  	trs:	String containing keywords and values to be passed directly 		to the translators as if they appeared as arguments in the 		translators table.  These arguments are passed to every 		translator called, so the user should be aware of possible 		conflicts.  Keywords passed using this mechanism take 		precedence over keywords appearing in the translators table.    OUTPUT: NONE    KEYWORDS:   INPUT: 	pd:		Input planet descriptors; used by some translators.  	od:		Observer descriptor, typically a camera descriptor. 			If given, then planet positions will be corrected 			for light travel time and stellar aberration relative 			to this observer unless /raw is set.  	sd:		Primary star descriptor; needed by some translators.  	gd:		Generic descriptors.  Can be used in place of od and sd.  	raw:		If set, no aberration corrections are performed.  	override:	Create a data descriptor and initilaize with the 			given values.  Translators will not be called.  	plt_*:		All planet override keywords are accepted.  See 			planet_keywords.include.  			If name is specified, then only descriptors with 			those names are returned.  	verbatim:	If set, the descriptors requested using name 			are returned in the order requested.  Otherwise, the 			order is determined by the translators.  	tr_override:	String giving a comma-separated list of translators 			to use instead of those in the translators table.  If 			this keyword is specified, no translators from the 			table are called, but the translators keywords 			from the table are still used.       Descriptor Select Keywords     --------------------------     Descriptor select keywords are combined with OR logic.  They are implemented     in this routine as described below after the translators have been called,     but they are also added to the translator keywords.  The purpose of sending     then to the translators as well is to give the translators an opportunity     to filter their outputs before potentially generating a huge array of     descriptors that would mostly be filtered out by this routine.  	fov/cov:	Select all planets that fall within this many fields of 			view (fov) (+/- 10%) from the center of view (cov). 			Default cov is the camera optic axis.  	pix:		Select all planets whose apparent size (in pixels) is 			greater than or equal to this value.  	radmax:		Select all planets whose radius is greater than or 			equal to this value.  	radmin:		Select all planets whose radius is less than or 			equal to this value.  	distmax:	Select all planets whose distance is greater than or 			equal to this value.  	distmin:	Select all planets whose distance is less than or 			equal to this value.  	nlarge:		Select n largest planets.  	nsmall:		Select n smallest planets.  	nclose:		Select n closst planets.  	nfar:		Select n farthest planets.    RETURN: 	Array of planet descriptors, 0 if an error occurs.    PROCEDURE: 	If /override, then a planet descriptor is created and initialized 	using the specified values.  Otherwise, the descriptor is obtained 	through the translators.  Note that if /override is not used, 	values (except name) can still be overridden by specifying 	them as keyword parameters.  If name is specified, then 	only descriptors corresponding to those names will be returned.     MODIFICATION HISTORY:  	Written by:	Spitale, 1998 	Modified:	Spitale, 8/2001   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_get_planets.html#pggp_select_planets", "pggp_select_planets", 'routine in <a href="nv/com/pg/pg_get_planets.html">pg_get_planets.pro</a>', "pg_get_planets.pro", "", "pggp_select_planets", "", "odddpdselect", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_get_planets.html#pg_get_planets", "pg_get_planets", 'routine in <a href="nv/com/pg/pg_get_planets.html">pg_get_planets.pro</a>', "pg_get_planets.pro", "", "pg_get_planets", "", "pdodsd_extraoverrideverbatimrawddtrs@plt__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_get_rings.html", "pg_get_rings.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_get_rings.pro", "", "", " NAME: 	pg_get_rings    PURPOSE: 	Obtains ring descriptors for the given data descriptor.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_get_rings(dd, od=od) 	result = pg_get_rings(dd, od=od, trs)    ARGUMENTS:   INPUT: 	dd:	data descriptor  	trs:	String containing keywords and values to be passed directly 		to the translators as if they appeared as arguments in the 		translators table.  These arguments are passed to every 		translator called, so the user should be aware of possible 		conflicts.  Keywords passed using this mechanism take 		precedence over keywords appearing in the translators table.    OUTPUT: NONE    KEYWORDS:   INPUT: 	rd:		Input ring descriptors; used by some translators.  	pd:		Planet descriptors for primary objects.  	od:		Observer descriptors.  	gd:		Generic descriptors.  Can be used in place of od.  	override:	Create a data descriptor and initilaize with the 			given values.  Translators will not be called.  	rng_*:		All ring override keywords are accepted.  See 			ring_keywords.include.  			If name is specified, then only descriptors with 			those names are returned.  	verbatim:	If set, the descriptors requested using name 			are returned in the order requested.  Otherwise, the 			order is determined by the translators.  	tr_override:	String giving a comma-separated list of translators 			to use instead of those in the translators table.  If 			this keyword is specified, no translators from the 			table are called, but the translators keywords 			from the table are still used.    RETURN: 	Ring descriptors obtained from the translators, 0 if an error occurs.    PROCEDURE: 	If /override, then a ring descriptor is created and initialized 	using the specified values.  Otherwise, the descriptor is obtained 	through the translators.  Note that if /override is not used, 	values (except name) can still be overridden by specifying 	them as keyword parameters.  If name is specified, then 	only descriptors corresponding to those names will be returned.     SEE ALSO: 	xx, xx, xx    MODIFICATION HISTORY:  	Written by:	Spitale, 1998 	Modified:	Spitale, 8/2001   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_get_rings.html#pggr_select_rings", "pggr_select_rings", 'routine in <a href="nv/com/pg/pg_get_rings.html">pg_get_rings.pro</a>', "pg_get_rings.pro", "", "pggr_select_rings", "", "odddrdselect", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_get_rings.html#pg_get_rings", "pg_get_rings", 'routine in <a href="nv/com/pg/pg_get_rings.html">pg_get_rings.pro</a>', "pg_get_rings.pro", "", "pg_get_rings", "", "rdpdod_extraoverrideverbatimddtrs@rng__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_get_stars.html", "pg_get_stars.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_get_stars.pro", "", "", " NAME: 	pg_get_stars    PURPOSE: 	Obtain star descriptors for the given data descriptor.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_get_stars(dd, od=od) 	result = pg_get_stars(dd, od=od, trs)    ARGUMENTS:   INPUT: 	dd:	data descriptor  	trs:	String containing keywords and values to be passed directly 		to the translators as if they appeared as arguments in the 		translators table.  These arguments are passed to every 		translator called, so the user should be aware of possible 		conflicts.  Keywords passed using this mechanism take 		precedence over keywords appearing in the translators table.    OUTPUT: NONE    KEYWORDS:   INPUT: 	sd:		Input star descriptors; used by some translators.  	od:		Observer descriptor, typically a camera descriptor. 			If given, then star positions will be corrected 			for stellar aberration (but not light-travel time, 			which is inherently accounted for in star catalogs) 			relative to this observer, unless /raw is set.  	gd:		Generic descriptors.  Can be used in place of od.  	raw:		If set, no aberration corrections are performed.  	override:	Create a data descriptor and initilaize with the 			given values.  Translators will not be called.  	str_*:		All star override keywords are accepted.  See 			star_keywords.include.  			If name is specified, then only descriptors with 			those names are returned.  	verbatim:	If set, the descriptors requested using name 			are returned in the order requested.  Otherwise, the 			order is determined by the translators.  	tr_override:	String giving a comma-separated list of translators 			to use instead of those in the translators table.  If 			this keyword is specified, no translators from the 			table are called, but the translators keywords 			from the table are still used.      Descriptor Select Keywords     --------------------------     Descriptor select keywords are combined with OR logic.  They are implemented     in this routine as described below after the translators have been called,     but they are also added to the translator keywords.  The purpose of sending     then to the translators as well is to give the translators an opportunity     to filter their outputs before potentially generating a huge array of     descriptors that would mostly be filtered out by this routine.  	fov/cov:	Select all stars that fall within this many fields of 			view (fov) (+/- 10%) from the center of view (cov). 			Default cov is the camera optic axis.  	pix:		Select all stars whose apparent size (in pixels) is 			greater than or equal to this value.  	radmax:		Select all stars whose radius is greater than or 			equal to this value.  	radmin:		Select all stars whose radius is less than or 			equal to this value.  	distmax:	Select all stars whose distance is greater than or 			equal to this value.  	distmin:	Select all stars whose distance is less than or 			equal to this value.  	nlarge:		Select n largest stars.  	nsmall:		Select n smallest stars.  	nclose:		Select n closst stars.  	nfar:		Select n farthest stars.  	faint:		Select stars with magnitudes less than or equal to 			this value.  	bright:		Select stars with magnitudes greater than or equal to 			this value.  	nbright:	Select this many brightest stars.    RETURN: 	Star descriptors obtained from the translators, 0 if an error occurs.    PROCEDURE: 	If /override, then a star descriptor is created and initialized 	using the specified values.  Otherwise, the descriptor is obtained 	through the translators.  Note that if /override is not used, 	values (except name) can still be overridden by specifying 	them as keyword parameters.  If name is specified, then 	only descriptors corresponding to those names will be returned.     SEE ALSO: 	xx, xx, xx    MODIFICATION HISTORY:  	Written by:	Spitale, 1998 	Modified:	Spitale, 8/2001   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_get_stars.html#pggs_select_stars", "pggs_select_stars", 'routine in <a href="nv/com/pg/pg_get_stars.html">pg_get_stars.pro</a>', "pg_get_stars.pro", "", "pggs_select_stars", "", "odddsdselect", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_get_stars.html#pg_get_stars", "pg_get_stars", 'routine in <a href="nv/com/pg/pg_get_stars.html">pg_get_stars.pro</a>', "pg_get_stars.pro", "", "pg_get_stars", "", "sdod_extraoverrideverbatimrawddtrs@str__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_get_stations.html", "pg_get_stations.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_get_stations.pro", "", "", " NAME: 	pg_get_stations    PURPOSE: 	Obtains a station descriptor for the given data descriptor.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_get_stations(dd) 	result = pg_get_stations(dd, trs)    ARGUMENTS:   INPUT: 	dd:	data descriptor  	trs:	String containing keywords and values to be passed directly 		to the translators as if they appeared as arguments in the 		translators table.  These arguments are passed to every 		translator called, so the user should be aware of possible 		conflicts.  Keywords passed using this mechanism take 		precedence over keywords appearing in the translators table.    OUTPUT: NONE    KEYWORDS:   INPUT: 	std:		Input station descriptors; used by some translators.  	override:	Create a data descriptor and initilaize with the 			given values.  Translators will not be called.  	stn_*:		All station override keywords are accepted.  See 			station_keywords.include.  			If name is specified, then only descriptors with 			those names are returned.  	verbatim:	If set, the descriptors requested using name 			are returned in the order requested.  Otherwise, the 			order is determined by the translators.  	tr_override:	String giving a comma-separated list of translators 			to use instead of those in the translators table.  If 			this keyword is specified, no translators from the 			table are called, but the translators keywords 			from the table are still used.    RETURN: 	Array of station descriptors, 0 if an error occurs.    PROCEDURE: 	If /override, then a station descriptor is created and initialized 	using the specified values.  Otherwise, the descriptor is obtained 	through the translators.  Note that if /override is not used, 	values (except name) can still be overridden by specifying 	them as keyword parameters.  If name is specified, then 	only descriptors corresponding to those names will be returned.     MODIFICATION HISTORY:  	Written by:	Spitale, 2/2009   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_get_stations.html#pg_get_stations", "pg_get_stations", 'routine in <a href="nv/com/pg/pg_get_stations.html">pg_get_stations.pro</a>', "pg_get_stations.pro", "", "pg_get_stations", "", "odbxstd_extraoverrideverbatimddtrs@stn__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_grid.html", "pg_grid.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_grid.pro", "", "", " NAME: 	pg_grid    PURPOSE: 	Computes image points on a surface coordinate grid.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	grid_ptd = pg_grid(cd=cd, gbx=gbx) 	grid_ptd = pg_grid(gd=gd)    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd:	Array (n_timesteps) of camera descriptors.  	gbx:	Array (n_objects, n_timesteps) of descriptors of objects 		that must be a subclass of GLOBE.  	dkx:	Array (n_objects, n_timesteps) of descriptors of objects 		that must be a subclass of DISK.  	bx:	Array (n_objects, n_timesteps) of descriptors of objects 		that must be a subclass of BODY.  	gd:	Generic descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.  	dd:	Data descriptor containing a generic descriptor to use 		if gd not given.  	lat:	Array giving grid-line latitudes in radians.  	lon:	Array giving grid-line longitudes in radians.  	nlat:	Number of equally-spaced latitude lines to generate if keyword 		lat not given.  Default is 12.  	flat:	This reference latitude line will be one of the latitude lines generated 		if nlat is specified.  Default is zero.  	nlon:	Number of equally-spaced longitude lines to generate if keyword 		lon not given.  Default is 12.  	flon:	This reference longitude line will be one of the longitude lines generated 		if nlon is specified.  Default is zero.  	clip:	 If set points are computed only within this many camera 		 fields of view.  	cull:	 If set, POINT objects excluded by the clip keyword 		 are not returned.  Normally, empty POINT objects 		 are returned as placeholders.  	npoints: Number of points to compute in each latitude or longitude line, 		 per 2*pi radians; default is 360.  	slat:	Latitudes to compute on each longitude circle.  	slon:	Longitudes to compute on each latitude circle.     OUTPUT: 	lat:	Array giving grid-line latitudes in radians.  	lon:	Array giving grid-line longitudes in radians.    RETURN: 	Array of POINT containing image points and the corresponding inertial 	vectors.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_grid.html#pg_grid", "pg_grid", 'routine in <a href="nv/com/pg/pg_grid.html">pg_grid.pro</a>', "pg_grid.pro", "", "pg_grid", "", "cdgbxdkxbxddgdlatlonnlatnlonflatflonnpointsclipcullslatslon", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_hide.html", "pg_hide.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_hide.pro", "", "", " NAME: 	pg_hide    PURPOSE: 	Hides the given points with respect to each given object and observer 	using the hide methods of the given bodies.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_hide, point_ptd, cd=cd, od=od, bx=bx    ARGUMENTS:   INPUT: 	point_ptd:	Array of POINT containing inertial vectors.    OUTPUT: 	hide_ptd:	Array (n_disks, n_timesteps) of POINT 			containing the hidden points.     KEYWORDS:   INPUT: 	cd:	Array (n_timesteps) of camera descriptors.  	gbx:	Array (n_objects, n_timesteps) of descriptors of objects 		that must be a subclass of GLOBE.  	dkx:	Array (n_objects, n_timesteps) of descriptors of objects 		that must be a subclass of DISK.  	bx:	Array (n_bodies, n_timesteps) of descriptors of objects 		which must be a subclass of BODY.  	od:	Array (n_timesteps) of descriptors of objects 		which must be a subclass of BODY.  These objects are used 		as the observer from which points are hidden.  If no observer 		descriptor is given, the camera descriptor is used.  	gd:	Generic descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.  	dd:	Data descriptor containing a generic descriptor to use 		if gd not given.  	reveal:	 Normally, objects whose opaque flag is set are ignored. 		 /reveal suppresses this behavior.  	cat:	If set, the hide_ptd points are concatentated into a single 		POINT object.  	rm:	If set, points are flagged for being in front of or behind 		the body, rather then just behind it.  	assoc:	If set, points are only hidden wrt their associated body. 		This is typically much faster because the calcuations for 		each points array are carried out for a single body instead 		of all given bodies.  This is useful, for example, for hiding 		points that lie on the surface of a planet wrt to only that 		planet.    OUTPUT: NONE    RETURN: NONE    SIDE EFFECTS: 	The flags arrays in point_ptd are modified.    PROCEDURE: 	For each object in point_ptd, hidden points are computed and 	PTD_MASK_INVISIBLE in the POINT is set.  No points are 	removed from the array.    EXAMPLE: 	The following command hides all points which are behind a planet as 	seen by the camera:  	pg_hide, point_ptd, cd=cd, bx=pd  	In this call, pd is a planet descriptor, and cd is a camera descriptor.    STATUS: 	Complete    SEE ALSO: 	pg_hide_limb    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2017, generalized pg_hide_globe and pg_hide_disk   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_hide.html#pgh_select_by_assoc", "pgh_select_by_assoc", 'routine in <a href="nv/com/pg/pg_hide.html">pg_hide.pro</a>', "pg_hide.pro", "", "pgh_select_by_assoc", "", "bxpoint_ptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_hide.html#pgh_select_by_bounding_box", "pgh_select_by_bounding_box", 'routine in <a href="nv/com/pg/pg_hide.html">pg_hide.pro</a>', "pg_hide.pro", "", "pgh_select_by_bounding_box", "", "_cdbxpoint_ptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_hide.html#pg_hide", "pg_hide", 'routine in <a href="nv/com/pg/pg_hide.html">pg_hide.pro</a>', "pg_hide.pro", "", "pg_hide", "", "cdodbxgbxdkxddgdrevealcompresscatrmassoc_point_ptdhide_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_image_sector.html", "pg_image_sector.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_image_sector.pro", "", "", " NAME: 	pg_image_sector   PURPOSE: 	Allows the user to select a rectangular image region, with an 	arbitrary tilt, by clicking and dragging.  A rectangle is selected 	using the left mouse button and a line of zero width is selected 	using the right moise button.   CATEGORY:        NV/PG   CALLING SEQUENCE:      outline_ptd = pg_image_sector()    ARGUMENTS:   INPUT:       NONE    OUTPUT: 	NONE     KEYWORDS:   INPUT:       win_num:     Window number of IDL graphics window in which to select                    box, default is current window.        restore:     Do not leave the box in the image.             p0:     First corner of box.  If set, then the routine immediately                    begins to drag from that point until a button is released.             p1:     Endpoint.  If given, p0 must also be given and is taken                    as the starting point for a line along which to scan.                    In this case, the user does not select the box manually.                    Scan width is one pixel unless 'width' is specified,                    and is centered on the line from p0 to p1.          width:     Width of box instead of letting the user select.          color:     Color to use for rectangle, default is !color.   xor_graphics:     If set, the sector outline is drawn and erased using xor                    graphics instead of a pixmap.         sample:	    Pixel grid sampling to use instead of 1.        corners:     If set, then p0 and p1 are taken as the corners of                    the box, and the user is not prompted to select one.         silent:     If set, messages are suppressed.     OUTPUT:          NONE   KNOWN BUGS: 	The sector flips when it hits zero azimuth rather than retaining a 	consistent sense.    RETURN:       POINT containing points on the sector outline.  The point       spacing is determined by the sample keyword.   ORIGINAL AUTHOR : J. Spitale ; 6/2005   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_image_sector.html#pg_image_sector", "pg_image_sector", 'routine in <a href="nv/com/pg/pg_image_sector.html">pg_image_sector.pro</a>', "pg_image_sector.pro", "", "pg_image_sector", "", "samplewin_numwidthrestorep0p1xor_graphicscolorsilentcorners", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_image_sector.html#test", "test", 'routine in <a href="nv/com/pg/pg_image_sector.html">pg_image_sector.pro</a>', "pg_image_sector.pro", "", "test", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_limb.html", "pg_limb.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_limb.pro", "", "", " NAME: 	pg_limb    PURPOSE: 	Computes image points on the limb of each given globe object.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	limb_ptd = pg_limb(cd=cd, gbx=gbx, ods=ods) 	limb_ptd = pg_limb(gd=gd, od=od)    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd:	 Array (n_timesteps) of camera descriptors.  	gbx:	 Array (n_objects, n_timesteps) of descriptors of objects 		 which must be a subclass of GLOBE.  	od:	 Array (n_timesteps) of descriptors of objects 		 which must be a subclass of BODY.  These objects are used 		 as the observer from which limb is computed.  If no observer 		 descriptor is given, the camera descriptor is used.  	gd:	Generic descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.  	dd:	Data descriptor containing a generic descriptor to use 		if gd not given.  	npoints: Number of points to compute.  Default is 1000.  	epsilon: Maximum angular error in the result.  Default is 1e-3.  	reveal:	 Normally, points computed for objects whose opaque flag 		 is set are made invisible.  /reveal suppresses this behavior.  	clip:	 If set points are computed only within this many camera 		 fields of view.  	cull:	 If set, POINT objects excluded by the clip keyword 		 are not returned.  Normally, empty POINT objects 		 are returned as placeholders.    OUTPUT: NONE    RETURN: 	Array (n_objects) of POINT containing image 	points and the corresponding inertial vectors.    PROCEDURE: 	By definition, the surface normal at a point on the limb of a body is 	perpendicular to a vector from the observer to that same point, so the 	dot product of the two vectors is zero.  This program uses an iterative 	scheme to find points onthe surface at which this dot product is less 	than epsilon.    EXAMPLE: 	The following command computes points on the planet which lie on the 	terminator:  	term_ptd = pg_limb,(cd=cd, gbx=pd, od=sd)  	In this call, pd is a planet descriptor, cd is a camera descriptor, 	and sd is a star descriptor (i.e., the sun).    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_limb.html#pg_limb", "pg_limb", 'routine in <a href="nv/com/pg/pg_limb.html">pg_limb.pro</a>', "pg_limb.pro", "", "pg_limb", "", "cdodgbxddgdclipcullnpointsepsilonreveal", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_limb_sector.html", "pg_limb_sector.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_limb_sector.pro", "", "", " NAME: 	pg_limb_sector   PURPOSE: 	Allows the user to select an image sector along lines of constant  	azimuth and altitude above a planet by clicking and dragging.   CATEGORY:        NV/PG   CALLING SEQUENCE:      outline_ptd=pg_limb_sector(cd=cd, gbx=gbx, dkd=dkd)    ARGUMENTS:   INPUT:       NONE    OUTPUT: 	NONE     KEYWORDS:   INPUT:            cd:     Camera descriptor.            gbx:     Globe descriptor for the planet whose limb is to be                    scanned.             gd:     Generic descriptor containnig the above descriptors.        win_num:     Window number of IDL graphics window in which to select                    box, default is current window.        restore:     Do not leave the box in the image.             p0:     First corner of box.  If set, then the routine immediately                    begins to drag from that point until a button is released.          color:     Color to use for rectangle, default is !color.         sample:     Sets the grid sampling in pixels.  Default is one.   xor_graphics:     If set, the sector outline is drawn and erased using xor                    graphics instead of a pixmap.          nodsk:     If set, skyplane disk image points will not be included                    in the output POINT.             cw:     If set, azimuths are assumed to increase in the clockwise                    direction.         silent:     If set, messages are suppressed.     OUTPUT:          dkd:      Disk desriptor in the skyplane, centered on the planet                    with 0 axis along the skyplane projection of the north                    pole.  For use with pg_profile_ring.           azimuths: Array giving azimuth at each sample.          altitudes: Array giving altitude at each sample.      limb_pts_body: Body coordinates of each limb points on planet surface.    RETURN:       POINT containing points on the sector outline.  The point       spacing is determined by the sample keyword.  The POINT object       also contains the disk coordinate for each point, relative to the       returned disk descriptor, and the user fields 'nrad' and 'nlon'       giving the number of points in altitude and azimuth.   KNOWN BUGS: 	The sector flips when it hits zero azimuth rather than retaining a 	consistent sense.    MODIFICATION HISTORY : 	Spitale; 8/2006		original version   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_limb_sector.html#pg_limb_sector", "pg_limb_sector", 'routine in <a href="nv/com/pg/pg_limb_sector.html">pg_limb_sector.pro</a>', "pg_limb_sector.pro", "", "pg_limb_sector", "", "cdgbxgdlonsamplewin_numrestorep0xor_graphicscolorsilentnodskdkdaltitudesazimuthslimb_pts_bodycw", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_limb_sector_altaz.html", "pg_limb_sector_altaz.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_limb_sector_altaz.pro", "", "", " NAME: 	pg_limb_sector_altaz   PURPOSE: 	Constructs a limb sector outline for use with pg_profile_ring given 	altitude and azimuth bounds.   CATEGORY:        NV/PG   CALLING SEQUENCE:      outline_ptd=pg_limb_sector_altaz(cd=cd, gbx=gbx, alt, az, dkd=dkd)    ARGUMENTS:   INPUT:       alt:	2-elements array giving the lower and upper altitude bounds 		for the sector.        az:	2-elements array giving the lower and upper azimuth bounds 		for the sector in radians, reliative to the skyplane 		projection of the planet's north pole.    OUTPUT: 	NONE     KEYWORDS:   INPUT:            cd:     Camera descriptor.            gbx:     Globe descriptor giving the planet about whose limb                    the scan will be extracted.             gd:     Generic descriptor containing the above descriptors.         sample:     Sets the grid sampling in pixels.  Default is one.            naz:     Total number of samples in the azimuthal direction.                    Determined by the 'sample' keyword by default.           nalt:     Total number of samples in the altitude direction.                    Determined by the 'sample' keyword by default.            alt:     Array giving the altitude of each point in the sector.             az:     Array giving the azimuth of each point in the sector.             cw:     If set, azimuths are assumed to increase in the clockwise                    direction.          nodsk:     If set, skyplane disk image points will not be included                    in the output POINT.        graphic:     If set, the sector is computed in the planetographic                    sense, i.e., lines of constant azimuth extend along                    the local surface normal direction instead of the radial                    direction.     OUTPUT:           dkd:     Disk descriptor in the skyplane, centered on the planet                    with 0 axis along the skyplane projection of the north                    pole.  For use with pg_profile_ring.           azimuths: Array giving azimuth at each sample.          altitudes: Array giving altitude at each sample.      limb_pts_body: Body coordinates of each limb points on planet surface.     RETURN:       POINT containing points on the sector outline.  The point       spacing is determined by the sample keyword.  The POINT objects       also contains the disk coordinate for each point, relative to the       returned disk descriptor, and the user fields 'nrad' and 'nlon'       giving the number of points in altitude and azimuth.   KNOWN BUGS: 	The sector flips when it hits zero azimuth rather than retaining a 	consistent sense.    ORIGINAL AUTHOR : 	Spitale; 8/2006   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_limb_sector_altaz.html#pg_limb_sector_altaz", "pg_limb_sector_altaz", 'routine in <a href="nv/com/pg/pg_limb_sector_altaz.html">pg_limb_sector_altaz.pro</a>', "pg_limb_sector_altaz.pro", "", "pg_limb_sector_altaz", "", "cdgbxgddkdsamplenodskaltitudesazimuthslimb_pts_bodycwnaznaltgraphicalt_az", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_limb_sector_linear.html", "pg_limb_sector_linear.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_limb_sector_linear.pro", "", "", " NAME: 	pg_limb_sector_linear   PURPOSE: 	Constructs a limb sector outline for use with pg_profile_image, given 	altitude and length bounds.  The sector is rectangular, being tangent 	to the limb at a given azimuth.   CATEGORY:        NV/PG   CALLING SEQUENCE:      outline_ptd = pg_limb_sector_line(cd=cd, gbx=gbx, alt, rim, az0)    ARGUMENTS:   INPUT:       alt:	2-elements array giving the lower and upper altitude bounds 		for the sector.        rim:	2-element array giving the image-coordinate cylidrical coordinates 		of the the ends of the sector.        az0:	Azimuth of the sector tangent point.    OUTPUT: 	NONE     KEYWORDS:   INPUT:            cd:     Camera descriptor.            gbx:     Globe descriptor giving the planet about whose limb                    the scan will be extracted.             gd:     Generic descriptor containig the above descriptors.         sample:     Sets the grid sampling in pixels.  Default is one.           nrim:     Total number of samples in the scan direction.                    Determined by the 'sample' keyword by default.           nalt:     Total number of samples in the altitude direction.                    Determined by the 'sample' keyword by default.        graphic:     If set, the sector is computed in the planetographic                    sense, i.e., lines of constant azimuth extend along                    the local surface normal direction instead of the radial                    direction.     OUTPUT:              rims: Array giving azimuth at each sample.          altitudes: Array giving altitude at each sample.    RETURN:       POINT object containing points on the sector outline.  The point       spacing is determined by the sample keyword.  The POINT object       also contains the user fields 'nl' and 'nw' giving the number of points       in altitude and r.   KNOWN BUGS: 	The sector flips when it hits zero azimuth rather than retaining a 	consistent sense.    ORIGINAL AUTHOR : 	Spitale; 1/2009   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_limb_sector_linear.html#pg_limb_sector_linear", "pg_limb_sector_linear", 'routine in <a href="nv/com/pg/pg_limb_sector_linear.html">pg_limb_sector_linear.pro</a>', "pg_limb_sector_linear.pro", "", "pg_limb_sector_linear", "", "cdgbxgdsamplealtitudesrimsnrimnaltgraphicalt_rimaz0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_limb_sector_oblique.html", "pg_limb_sector_oblique.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_limb_sector_oblique.pro", "", "", " NAME:			***incomplete*** 	pg_limb_sector_oblique   PURPOSE: 	Allows the user to select an image sector along lines of constant  	azimuth and altitude above a planet by clicking and dragging.   CATEGORY:        NV/PG   CALLING SEQUENCE:      outline_ptd=pg_limb_sector(cd=cd, gbx=gbx, dkd=dkd)    ARGUMENTS:   INPUT:       NONE    OUTPUT: 	NONE     KEYWORDS:   INPUT:            cd:     Camera descriptor.            gbx:     Globe descriptor for the planet whose limb is to be                    scanned.             gd:     Generic descriptor containnig the above descriptors.        win_num:     Window number of IDL graphics window in which to select                    box, default is current window.        restore:     Do not leave the box in the image.             p0:     First corner of box.  If set, then the routine immediately                    begins to drag from that point until a button is released.          color:     Color to use for rectangle, default is !color.         sample:     Sets the grid sampling in pixels.  Default is one.   xor_graphics:     If set, the sector outline is drawn and erased using xor                    graphics instead of a pixmap.     OUTPUT:          dkd:      Disk desriptor in the skyplane, centered on the planet                    with 0 axis along the skyplane projection of the north                    pole.  For use with pg_profile_ring.           azimuths: Array giving azimuth at each sample.          altitudes: Array giving altitude at each sample.      limb_pts_body: Body coordinates of each limb points on planet surface.    RETURN:       POINT containing points on the sector outline.  The point       spacing is determined by the sample keyword.  The POINT object       also contains the disk coordinate for each point, relative to the       returned disk descriptor, and the user fields 'nrad' and 'nlon'       giving the number of points in altitude and azimuth.   KNOWN BUGS: 	The sector flips when it hits zero azimuth rather than retaining a 	consistent sense.    MODIFICATION HISTORY : 	Spitale; 1/2007		original version   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_limb_sector_oblique.html#pg_limb_sector_oblique", "pg_limb_sector_oblique", 'routine in <a href="nv/com/pg/pg_limb_sector_oblique.html">pg_limb_sector_oblique.pro</a>', "pg_limb_sector_oblique.pro", "", "pg_limb_sector_oblique", "", "cdgbxgdlonsamplewin_numrestorep0p1widthxor_graphicscolorsilentnodskdkdaltitudesazimuthslimb_pts_bodycw", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_linearize_image.html", "pg_linearize_image.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_linearize_image.pro", "", "", " NAME: 	pg_linearize_image    PURPOSE: 	Reprojects an image onto a linear scale.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_linearize_image(dd, new_cd, cd=cd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor containing image to be reprojected.    OUTPUT: 	new_cd:	Camera descriptor corresponding to the reprojected image.    KEYWORDS:   INPUT: 	cd:	Camera descriptor describing the image to be reprojected.  	gd:	Generic descriptor containing the above descriptor.  	scale:	2-element array giving the camera scale (radians/pixel) 		in each direction for the reprojected image.  If not given, the 		scale of the input image is used.  	oaxis:	2-element array giving the image coordinates of the optic axis 		in the reprojected image.  If not given, the center of 		the reprojected image is used.  	size:	2-element array giving the size of the reprojected image.  If 		not given, the size of the input image is used.  	pc_xsize: X-Size of each image piece.  Default is 200 pixels.  	pc_xsize: Y-Size of each image piece.  Default is 200 pixels.  	fcp:	Focal coordinates of known reseau locations.  	scp:	Image coordinates in input image of detected reseau marks 		corresponding to those given by nmp.  	interp:	Type of interpolation to use.  Options are: 		'nearest', 'mean', 'bilinear', 'cubic', 'sinc'.    OUTPUT: 	image:	The output image, which is also placed in the data descriptor.    RETURN: 	Data descriptor containing the reprojected image.    PROCEDURE: 	The input image is divided into pieces and tranformed one piece at 	a time.  There are two modes of operation: If nmp and scp are 	given, then the image is transformed using them as control points. 	Otherwise, the image is transformed using whatever camera transformation 	is specified in the camera descriptor.    STATUS: 	Control-point scheme not yet implemented.    SEE ALSO: 	pg_resfit, pg_resloc    MODIFICATION HISTORY:  	Written by:	Spitale, 5/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_linearize_image.html#pg_linearize_image", "pg_linearize_image", 'routine in <a href="nv/com/pg/pg_linearize_image.html">pg_linearize_image.pro</a>', "pg_linearize_image.pro", "", "pg_linearize_image", "", "cdgdfcpscpscaleoaxissizepc_xsizepc_ysizeimageinterpddnew_cd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_load_maps.html", "pg_load_maps.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_load_maps.pro", "", "", " NAME: 	pg_load_maps    PURPOSE: 	Loads maps and descriptors from a map directory.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	ddmap = pg_load_maps(md=md)    ARGUMENTS:   INPUT: 	dir :   Top directory for map library.  If not set, the directory 		is obtained from the PG_MAPS environment varable.    OUTPUT: NONE    KEYWORDS:   INPUT: 	bx:	Body descriptors indicating which maps to load.     OUTPUT: 	md:	Map descriptor for each map.    ENVIRONMENT VARIABLES: 	PG_MAPS: 		Sets the map directory; overrides the dir keyword.  Maps are 		organized into subdirectories named for each body.    RETURN: 	Data descriptor containing the rendered image.    PROCEDURE:     EXAMPLE:    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  7/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_load_maps.html#pg_load_maps", "pg_load_maps", 'routine in <a href="nv/com/pg/pg_load_maps.html">pg_load_maps.pro</a>', "pg_load_maps.pro", "", "pg_load_maps", "", "mdbxdddir", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_map.html", "pg_map.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_map.pro", "", "", " NAME: 	pg_map    PURPOSE: 	Generates map projections.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_map(dd, md=md, cd=cd, gbx=gbx, sund=sund) 	result = pg_map(dd, gd=gd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor containing image to be projected.   KEYWORDS:   INPUT: 	md:	Map descriptor describing the projection.  	cd:	Camera descriptor describing the image to be projected.  	bx:	Subclass of BODY giving the body to be projected.  Can be 		GLOBE or RING.  Only bodies whose names match that in the 		map descriptor are mapped.  	gbx:	Globe descriptor describing the body to be projected. 		This argument is kept for compatibility with earlier 		code.  It is recommended that you use the 'bx' argument 		instead.  	dkx:	Disk descriptor describing the body to be projected. 		This argument is kept for compatibility with earlier 		code.  It is recommended that you use the 'bx' argument 		instead.  	sund:	Star descriptor for the sun.  If given, points behind the 		terminator are excluded.  	gd:	Generic descriptor.  If given, the above descriptor inputs 		are taken from the corresponding fields of this structure 		instead of from those keywords.  	hide_fn:	String giving the name of a function whose purpose 			is to exclude hidden points from the map.  The only 			function currently packaged is 'pm_hide_ring', which 			takes a ring descriptor as data (see next keyword).  	hide_data_p:	Pointer to data for the hide function.  	aux_names:	Array (naux) giving udata names for additional data 			descriptor planes to reproject.  The dimensions of these 			planes must be the same as the image.  	pc_xsize, pc_ysize:	The map is generated in pieces of size pc_xsize 				x pc_ysize.   Default is 100 x 100 pixels.  	bounds:		Projection bounds specified as [lat0, lat1, lon0, lon1].  	edge:	Minimum proximity to image edge.  Default is 0.  	roi:	Subscripts in the output map specifying the map region 		to project, instead of the whole thing.  	interp:	Type of interpolation, see image_interp_cam.  	arg_interp:	Interpolation argument, see image_interp_cam.  	offset:	Offset in [lat,lon] to apply to map coordinates before 		projecting.  	smooth:	If set, the input image is smoothed before reprojection.  	test_factor:	If set, a test map, reduced in size by this factor, 			is projected to determine the roi.  For maps with 			large blank areas, this may speed up the projection 			greatly.     OUTPUT: 	map:	For convenience, the generated map is returned here as 		well as in the returned data descriptor.    RETURN: 	Data descriptor containing the output map.  The instrument field is set 	to 'MAP'.  User data arrays are created for the reprojected aux_names 	arrays.    STATUS: 	Complete    SEE ALSO: 	pg_mosaic    MODIFICATION HISTORY:  	Written by:	Spitale, 1998 	Modified:	Daiana DiNino; 7, 2011 : test_factor   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_map.html#pg_map", "pg_map", 'routine in <a href="nv/com/pg/pg_map.html">pg_map.pro</a>', "pg_map.pro", "", "pg_map", "", "mdcdbxgbxdkxsundgdhide_fnhide_data_pmapaux_namespc_xsizepc_ysizeboundsinterparg_interpoffsetedgewind_fnwind_datasmoothroitest_factordd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_mask.html", "pg_mask.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_mask.pro", "", "", " NAME: 	pg_mask    PURPOSE: 	Uses the given geometry to compute an image mask for all objects 	in a scene.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	mask = pg_mask(cd=cd, gbx=gbx, dkx=dkx, bx=bx, sund=sund) 	mask = pg_mask(gd=gd)    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd:	Camera descriptor.  	gbx:	Globe descriptors.  	dkx:	Disk descriptors.  	bx:	Body descriptors (i.e. point sources).  	sund:	Star descriptor giving the sun.  	gd:	Generic descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.  	dd:	Data descriptor containing a generic descriptor to use 		if gd not given.  	fgbx,fdkx,fbx:	Fractonal amount to increase the radii of each 			descriptor type.  	dgbx,ddkx,dbx:	Absolute amount, in physical units (e.g. meters), to 			increase the radii of each descriptor type.  	pgbx,pdkx,pbx:	Absolute amount, in mask pixels, to increase the radii 			of each descriptor type.  	nodd;    If set, no data descriptor is created.  	np:      Number of points to use in computing curves.  Default is 1000.    OUTPUT: 	limb_ptd:	POINT giving the computed limb points.  	term_ptd:	POINT giving the computed terminator points.  	disk_ptd:	POINT giving the computed disk points.  	body_ptd:	POINT giving the computed body points.    RETURN: 	Data descriptor containing a byte image in which pixels corresponding 	to objects are set to 1.    STATUS: 	Complete.    SEE ALSO: 	pg_spikes    MODIFICATION HISTORY:  	Written by:	Spitale, 4/2004   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_mask.html#pgmsk_grow", "pgmsk_grow", 'routine in <a href="nv/com/pg/pg_mask.html">pg_mask.pro</a>', "pg_mask.pro", "", "pgmsk_grow", "", "maskdr", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_mask.html#pg_mask", "pg_mask", 'routine in <a href="nv/com/pg/pg_mask.html">pg_mask.pro</a>', "pg_mask.pro", "", "pg_mask", "", "maskddgdcdgbxdkxbxsundfgbxfdkxfbxdgbxddkxdbxpgbxpdkxpbxlimb_ptdterm_ptdbody_ptddisk_ptdnoddnp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_mask_points.html", "pg_mask_points.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_mask_points.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_mask_points.html#pg_mask_points", "pg_mask_points", 'routine in <a href="nv/com/pg/pg_mask_points.html">pg_mask_points.pro</a>', "pg_mask_points.pro", "", "pg_mask_points", "", "mask", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_measure.html", "pg_measure.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_measure.pro", "", "", " NAME: 	pg_measure    PURPOSE: 	Allows the user to measure quantities between two points in an 	image using the mouse in the current graphics window.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_measure, dd    ARGUMENTS:   INPUT: 	dd:	Data descriptor containing the image.  Multiple data 		descriptors may be given and the pixel values for each will 		be displayed.  However, descriptors for only one of the data 		descriptors may be given.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	cd:	Camera descriptor.  Must be included for planet and ring 		coordinate, RA/DEC, and photometric output.  A map descriptor 		may be substitued for this argument, in which case ring 		coordinates, RA/DEC, and photometric data are not output.  	gbx:	Object descriptors, subclass of 'GLOBE'.  Must be included for 		planet coordinate output.  	dkx:	Object descriptors, subclass of 'DISK'.  Must be included for 		ring coordinate output.  	sund:	Star descriptor specifying the state of the sun.  	gd:	Generic descriptor.  If given, the above object descriptors are 		taken from this structure.  	radec:	If set, right ascension and declination differences with 		respect to the inertial coordinate system are output for 		each selected pair.  	xy:	If set, this is taken as the first point, and the user selects 		only the second point.  	fn:	Names of functions to be called whenever a point is selected. 		Each function is called as follows:  		value = call_function(fn, p, image, gd=gd, $                                                format=_format, label=label)  		p is the image coords of the selected point, image is the 		input image and gd is a generic descriptor containing the 		object descriptors.  format and label are outputs used to label 		the returned value.  These functions are apended to the set of 		default functions.  	silent:	If set, no string is printed, although the 'string' output 		keyword remains valid.     OUTPUT: 	string:	The string that's printed.  If /silent is specified, this 		string is valid, but not printed.  	values: Array (nfn,2,npoints) giving the numerical results in the order 		that they appear in the output.  	p:	Array (2,2) giving the selected points.    RETURN: 	NONE    STATUS: 	Ring photometry is not yet implemented.    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_measure.html#_pgm_xy_test", "_pgm_xy_test", 'routine in <a href="nv/com/pg/pg_measure.html">pg_measure.pro</a>', "pg_measure.pro", "", "_pgm_xy_test", "", "gdinertial_ptsurface_ptpdd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_measure.html#_pgm_xy", "_pgm_xy", 'routine in <a href="nv/com/pg/pg_measure.html">pg_measure.pro</a>', "pg_measure.pro", "", "_pgm_xy", "", "gdformatlabelinertial_ptsurface_ptpddxd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_measure.html#_pgm_dn_test", "_pgm_dn_test", 'routine in <a href="nv/com/pg/pg_measure.html">pg_measure.pro</a>', "pg_measure.pro", "", "_pgm_dn_test", "", "gdinertial_ptsurface_ptpdd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_measure.html#_pgm__dn", "_pgm__dn", 'routine in <a href="nv/com/pg/pg_measure.html">pg_measure.pro</a>', "pg_measure.pro", "", "_pgm__dn", "", "gdformatlabelinertial_ptsurface_ptpddxd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_measure.html#_pgm_dn", "_pgm_dn", 'routine in <a href="nv/com/pg/pg_measure.html">pg_measure.pro</a>', "pg_measure.pro", "", "_pgm_dn", "", "gdformatlabelinertial_ptsurface_ptpddxd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_measure.html#_pgm_radec_test", "_pgm_radec_test", 'routine in <a href="nv/com/pg/pg_measure.html">pg_measure.pro</a>', "pg_measure.pro", "", "_pgm_radec_test", "", "gdinertial_ptsurface_ptpdd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_measure.html#_pgm_radec", "_pgm_radec", 'routine in <a href="nv/com/pg/pg_measure.html">pg_measure.pro</a>', "pg_measure.pro", "", "_pgm_radec", "", "gdformatlabelinertial_ptsurface_ptpddxd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_measure.html#_pgm_globe_test", "_pgm_globe_test", 'routine in <a href="nv/com/pg/pg_measure.html">pg_measure.pro</a>', "pg_measure.pro", "", "_pgm_globe_test", "", "gdinertial_ptsurface_ptpdd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_measure.html#_pgm_globe", "_pgm_globe", 'routine in <a href="nv/com/pg/pg_measure.html">pg_measure.pro</a>', "pg_measure.pro", "", "_pgm_globe", "", "gdformatlabelinertial_ptsurface_ptpddxd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_measure.html#_pgm_disk_test", "_pgm_disk_test", 'routine in <a href="nv/com/pg/pg_measure.html">pg_measure.pro</a>', "pg_measure.pro", "", "_pgm_disk_test", "", "gdinertial_ptsurface_ptpdd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_measure.html#_pgm_disk", "_pgm_disk", 'routine in <a href="nv/com/pg/pg_measure.html">pg_measure.pro</a>', "pg_measure.pro", "", "_pgm_disk", "", "gdformatlabelinertial_ptsurface_ptpddxd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_measure.html#_pgm_eqplane_test", "_pgm_eqplane_test", 'routine in <a href="nv/com/pg/pg_measure.html">pg_measure.pro</a>', "pg_measure.pro", "", "_pgm_eqplane_test", "", "gdinertial_ptsurface_ptpdd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_measure.html#_pgm_eqplane", "_pgm_eqplane", 'routine in <a href="nv/com/pg/pg_measure.html">pg_measure.pro</a>', "pg_measure.pro", "", "_pgm_eqplane", "", "gdformatlabelinertial_ptsurface_ptpddxd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_measure.html#____pgm_eqplane", "____pgm_eqplane", 'routine in <a href="nv/com/pg/pg_measure.html">pg_measure.pro</a>', "pg_measure.pro", "", "____pgm_eqplane", "", "gdformatlabelinertial_ptsurface_ptpddxd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_measure.html#_pgm_map_test", "_pgm_map_test", 'routine in <a href="nv/com/pg/pg_measure.html">pg_measure.pro</a>', "pg_measure.pro", "", "_pgm_map_test", "", "gdinertial_ptsurface_ptpdd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_measure.html#_pgm_map", "_pgm_map", 'routine in <a href="nv/com/pg/pg_measure.html">pg_measure.pro</a>', "pg_measure.pro", "", "_pgm_map", "", "gdformatlabelinertial_ptsurface_ptpddxd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_measure.html#pgm_table", "pgm_table", 'routine in <a href="nv/com/pg/pg_measure.html">pg_measure.pro</a>', "pg_measure.pro", "", "pgm_table", "", "label_padvalue_padnamename_pvalue_plabel_pformat_p", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_measure.html#pg_measure", "pg_measure", 'routine in <a href="nv/com/pg/pg_measure.html">pg_measure.pro</a>', "pg_measure.pro", "", "pg_measure", "", "cdgbxdkxsundsdgdfnradecxystringsilentvaluespdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_mosaic.html", "pg_mosaic.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_mosaic.pro", "", "", " NAME: 	pg_mosaic    PURPOSE: 	Combines two or more maps into one.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_mosaic(dds)    ARGUMENTS:   INPUT: 	dds:	Array of data descriptors containing the maps to be combined. 		Maps must all be of the same size and data type.    OUTPUT: 	mosaic:	The mosaic image array.    KEYWORDS:   INPUT: 	combine_fn:	Name of function to be called to combine the maps. 			Default is 'median'.  	wt_fns:		Names of functions to be called to weight the maps.  	data:		Data to be passed to combine_fn.  	weight:		Array of weights, one for each input dd.         pc_xsize:	x size of mosaic work pieces.  Smaller pieces save 			memory, but increase run time.         pc_ysize:	y size of mosaic work pieces.     OUTPUT: 	mosaic:		Image array giving the output mosiac.    RETURN: 	Data descriptor containing the mosaic.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale 1/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_mosaic.html#pg_mosaic", "pg_mosaic", 'routine in <a href="nv/com/pg/pg_mosaic.html">pg_mosaic.pro</a>', "pg_mosaic.pro", "", "pg_mosaic", "", "combine_fnwt_fnsdatamosaicweightpc_xsizepc_ysizescalesdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_move.html", "pg_move.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_move.pro", "", "", " NAME: 	pg_move    PURPOSE: 	Translates and rotates the given points.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_move, object_ptd, dxy, dtheta, axis_ptd=axis_ptd    ARGUMENTS:   INPUT: 	object_ptd:	Array (n_objects) of POINT containing the 			image points to be moved.  	dxy:		2-element array specifying the translation as [dx,dy].  	dtheta:		Rotation angle in radians.    OUTPUT: 	object_ptd:	The input points are be modified on return.    KEYWORDS:   INPUT: 	axis_ptd:	POINT containing a single image point 			to be used as the axis of rotation.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	pg_drag    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_move.html#pg_move", "pg_move", 'routine in <a href="nv/com/pg/pg_move.html">pg_move.pro</a>', "pg_move.pro", "", "pg_move", "", "axis_ptdobject_ptddxydtheta", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_nearest_points.html", "pg_nearest_points.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_nearest_points.pro", "", "", " NAME: 	pg_nearest_points    PURPOSE: 	xx    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = xx(xx, xx) 	xx, xx, xx    ARGUMENTS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    KEYWORDS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    ENVIRONMENT VARIABLES: 	xx:	xx  	xx:	xx    RETURN: 	xx    COMMON BLOCKS: 	xx:	xx  	xx:	xx    SIDE EFFECTS: 	xx    RESTRICTIONS: 	xx    PROCEDURE: 	xx    EXAMPLE: 	xx    STATUS: 	xx    SEE ALSO: 	xx, xx, xx    MODIFICATION HISTORY:  	Written by:	xx, xx/xx/xxxx   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_nearest_points.html#pg_nearest_points", "pg_nearest_points", 'routine in <a href="nv/com/pg/pg_nearest_points.html">pg_nearest_points.pro</a>', "pg_nearest_points.pro", "", "pg_nearest_points", "", "object_ptd_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_northangle.html", "pg_northangle.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_northangle.pro", "", "", " NAME: 	pg_northangle    PURPOSE: 	Computes the angle between the image-coordinate y-axis and the 	projected z-axis of the given body.  Increasing angle corresponds to 	clockwise rotation in the image.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	northangle = pg_northangle(cd=cd, bx=bx) 	northangle = pg_northangle(gd=gd)    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd:	Array (n_timesteps) of camera descriptors.  	bx:	Array (n_objects, n_timesteps) of descriptors of objects 		which must be a subclass of BODY.  	gd:	Generic descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.  	dd:	Data descriptor containing a generic descriptor to use 		if gd not given.    OUTPUT: NONE    RETURN: 	Array (n_objects) of double giving the northangles in radians.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 11/2001   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_northangle.html#pg_northangle", "pg_northangle", 'routine in <a href="nv/com/pg/pg_northangle.html">pg_northangle.pro</a>', "pg_northangle.pro", "", "pg_northangle", "", "cdbxddgd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_photom.html", "pg_photom.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_photom.pro", "", "", " NAME: 	pg_photom    PURPOSE: 	Photometric image correction for disk or globe objects.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_photom(dd, cd=cd, gbx=gbx)    ARGUMENTS:   INPUT: 	dd:	Data descriptor containing image to correct.     OUTPUT: 	NONE   KEYWORDS:   INPUT: 	cd:	Camera descriptor  	gbx:	Globe descriptor  	dkx:	Disk descriptor  	sund:	Sun descriptor  	gd:	Generic descriptor.  If present, cd, dkx, and gbx are taken 		from here if contained.   	outline_ptd:	POINT with image points outlining the 			region of the image to correct.  To correct the entire 			planet, this input could be generated using pg_limb(). 			If this keyword is not given, the entire image is used.  	refl_fn:	String naming reflectance function to use.  Default is 			'pht_minneart'.  	refl_parms:	Array of parameters for the photometric function named 			by the 'refl_fn' keyword.  	phase_fn:	String naming phase function to use.  Default is none.  	phase_parms:	Array of parameters for the photometric function named 			by the 'phase_fn' keyword.  	overwrite:	If set, the output descriptor is the input descriptor 			with the relevant fields modified.    OUTPUT: 	emm_out:	Image emission angles.  	inc_out:	Image incidence angles.  	phase_out:	Image phase angles.    RETURN: 	Data descriptor containing the corrected image.  The photometric angles 	emm, inc, and phase are placed in the user data arrays with the tags 	'EMM', 'INC', and 'PHASE' respectively.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2004   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_photom.html#pg_photom", "pg_photom", 'routine in <a href="nv/com/pg/pg_photom.html">pg_photom.pro</a>', "pg_photom.pro", "", "pg_photom", "", "outline_ptdcdgbxdkxsundgdrefl_fnphase_fnrefl_parmphase_parmemm_outinc_outphase_outoverwritedd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_photom_disk.html", "pg_photom_disk.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_photom_disk.pro", "", "", " NAME: 	pg_photom_disk    PURPOSE: 	Photometric image correction for disk objects.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_photom_globe(dd, cd=cd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor containing image to correct.     OUTPUT: 	NONE   KEYWORDS:   INPUT: 	cd:	Camera descriptor  	dkx:	Disk descriptor  	sund:	Sun descriptor  	gd:	Generic descriptor.  If present, cd and dkx are taken from 		here if contained.   	outline_ptd:	POINT with image points outlining the 			region of the image to correct.  To correct the entire 			disk, this input could be generated using pg_ring(). 			If this keyword is not given, the entire image is used. 			If two arrays are given, they are taken as the inner 			and outer boundaries.  	refl_fn:	String naming reflectance function to use.  Default is 			'pht_minneart'.  	refl_parms:	Array of parameters for the photometric function named 			by the 'refl_fn' keyword.  	phase_fn:	String naming phase function to use.  Default is none.  	phase_parms:	Array of parameters for the photometric function named 			by the 'phase_fn' keyword.  	overwrite:	If set, the output descriptor is the input descriptor 			with the relevant fields modified.    OUTPUT: 	emm_out:	Image emission angles.  	inc_out:	Image incidence angles.  	phase_out:	Image phase angles.    RETURN: 	New data descriptor containing the corrected image.  The photometric 	angles emm, inc, and phase are placed in the user data arrays with 	the tags'EMM', 'INC', and 'PHASE' respectively.  Unless /overwrite is 	set, the nw descriptor is a clone of the input descriptor, with the 	relevant fields modified.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/2002 (pg_photom) 	 Spitale, 6/2004:	changed to pg_photom_disk   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_photom_disk.html#pg_photom_disk", "pg_photom_disk", 'routine in <a href="nv/com/pg/pg_photom_disk.html">pg_photom_disk.pro</a>', "pg_photom_disk.pro", "", "pg_photom_disk", "", "outline_ptdcddkxsundgdrefl_fnphase_fnrefl_parmphase_parmemm_outinc_outphase_outoverwritedd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_photom_globe.html", "pg_photom_globe.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_photom_globe.pro", "", "", " NAME: 	pg_photom_globe    PURPOSE: 	Photometric image correction for globe objects.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_photom_globe(dd, cd=cd, gbx=gbx)    ARGUMENTS:   INPUT: 	dd:	Data descriptor containing image to correct.     OUTPUT: 	NONE   KEYWORDS:   INPUT: 	cd:	Camera descriptor  	gbx:	Globe descriptor  	sund:	Sun descriptor  	gd:	Generic descriptor.  If present, cd and gbx are taken from 		here if contained.   	outline_ptd:	POINT with image points outlining the 			region of the image to correct.  To correct the entire 			planet, this input could be generated using pg_limb(). 			If this keyword is not given, the entire image is used.  	refl_fn:	String naming reflectance function to use.  Default is 			'pht_refl_minneart'.  	refl_parms:	Array of parameters for the photometric function named 			by the 'refl_fn' keyword.  	phase_fn:	String naming phase function to use.  Default is none.  	phase_parms:	Array of parameters for the photometric function named 			by the 'phase_fn' keyword.  	overwrite:	If set, the output descriptor is the input descriptor 			with the relevant fields modified.    OUTPUT: 	emm_out:	Image emission angles.  	inc_out:	Image incidence angles.  	phase_out:	Image phase angles.    RETURN: 	New data descriptor containing the corrected image.  The photometric 	angles emm, inc, and phase are placed in the user data arrays with 	the tags'EMM', 'INC', and 'PHASE' respectively.  Unless /overwrite is 	set, the nw descriptor is a clone of the input descriptor, with the 	relevant fields modified.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/2002 (pg_photom) 	 Spitale, 6/2004:	changed to pg_photom_globe   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_photom_globe.html#pg_photom_globe", "pg_photom_globe", 'routine in <a href="nv/com/pg/pg_photom_globe.html">pg_photom_globe.pro</a>', "pg_photom_globe.pro", "", "pg_photom_globe", "", "outline_ptdcdgbxsundgdrefl_fnphase_fnrefl_parmphase_parmemm_outinc_outphase_outoverwritedd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_profile_image.html", "pg_profile_image.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_profile_image.pro", "", "", " NAME: 	pg_profile_image    PURPOSE: 	Generates a dn profile along a line in an image.   CATEGORY: 	NV/PG    CALLING SEQUENCE:     result = pg_profile_image(dd, cd=cd, outline_ptd)    ARGUMENTS:   INPUT: 	  dd:	Data descriptor.   outline_ptd:   POINT giving the outline of the region to plot,                as produced by the pg_image_sector.    OUTPUT:         NONE   KEYWORDS:   INPUT: 	  cd:	Camera descriptor.  Needed for sinc interpolation. (to get PSF)           gd:   Optional generic descriptor containing cd.       interp:   Type of interpolation to use.  Options are:                'nearest', 'mean', 'bilinear', 'cubic', 'sinc'.           bg:	Uniform value to subtract from profile.   arg_interp:   Arguments to pass to the interpolation function.     OUTPUT:     profile:   The profile.        sigma:   Array giving the standard deviation at each point in the 		profile.      distance:  Array giving the distance, in pixels, along the profile.     image_pts:  Image point for each point along the profile.    RETURN: 	Two data descriptors: the first contains the profile; the second contains 	the profile sigma.    MODIFICATION HISTORY:        Written by:     Spitale, 6/2005   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_profile_image.html#pg_profile_image", "pg_profile_image", 'routine in <a href="nv/com/pg/pg_profile_image.html">pg_profile_image.pro</a>', "pg_profile_image.pro", "", "pg_profile_image", "", "cdgddistanceinterparg_interpsigmaprofileimage_ptsbgddoutline_ptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_profile_image.html#test", "test", 'routine in <a href="nv/com/pg/pg_profile_image.html">pg_profile_image.pro</a>', "pg_profile_image.pro", "", "test", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_profile_ring.html", "pg_profile_ring.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_profile_ring.pro", "", "", " NAME: 	pg_profile_ring    PURPOSE: 	Generates radial or longitudinal ring profiles from the given image 	using an image outline.   CATEGORY: 	NV/PG    CALLING SEQUENCE:     result = pg_profile_ring(dd, cd=cd, dkx=dkx, outline_ptd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor.         outline_ptd:    POINT giving the outline of the sector to plot,                       as produced by the pg_ring_sector.    OUTPUT:         NONE   KEYWORDS:   INPUT: 	  cd:	Camera descriptor.          dkx:   Disk descriptor.           gd:   Generic descriptor, if used, cd and dkx taken from it unless                overriden by cd and dkx arguments.    azimuthal:   If set, the plot is longitudinal instead of radial.         bin:    If set, pixels in sector are binned according to                radius or longitude rather than dn averaged at equal                radius or longitude spacing      interp:    Type of interpolation to use: 'nearest', 'bilinear', 'cubic',                or 'sinc'.  'sinc' is the default.           bg:	Uniform value to subtract from profile.   arg_interp:   Arguments to pass to the interpolation function.    OUTPUT:     profile:   The profile.      dsk_pts:	Array of disk coordinates corresponding to each value in the 		returned dn profile.      im_pts:	Array of image coordinates corresponding to each value in the 		returned dn profile.        sigma:   Array giving the standard deviation at each point in the 		profile.        width:   Array giving the width of the scan, in pixels along the                averaging direction, at each point in the profile.           nn:   Number of image samples averaged into each profile point.   RETURN: 	Two data descriptors: the first contains the profile; the second contains 	the profile sigma.    PROCEDURE: 	The image points of the sector outline are first calculated.  If        /outline is selected then this is output.  If not, then the        /azimuthal keyword determines if this is a radius or longitude        profile.  The radius and longitude spacing for profile is then is        determined. If n_lon or n_rad is given, then these are used.  If not,        then the outline is used to determine the spacing in radius and        longitude so that the maximum spacing is a pixel.  If oversamp is        given then the number of samples is multiplied by this factor.        Then the image is sampled with this radius x longitude grid and        the dn interpolated with the routine image_interp at each point.        The dn's are then averaged along the requested profile direction.        If /bin keyword is selected then the image is not interpolated but        rather each pixel is binned in a histogram with the calculated        spacing.    EXAMPLE:      lon = [175.,177.]      rad = [65000000.,138000000.]      outline_ptd = pg_ring_sector(cd=cd, dkx=rd, rad=rad, lon=lon)      pg_draw, outline_ptd       profile = pg_profile_ring(dd, cd=cd, dkx=rd, $                                           outline_ptd, dsk_pts=dsk_pts)      window, /free, xs=500, ys=300      plot, dsk_pts[*,0], profile    MODIFICATION HISTORY:        Written by:     Vance Haemmerle & Spitale, 6/1998 	Modified to use outline_ptd instead of (rad,lon): Spitale 5/2005   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_profile_ring.html#pg_profile_ring", "pg_profile_ring", 'routine in <a href="nv/com/pg/pg_profile_ring.html">pg_profile_ring.pro</a>', "pg_profile_ring.pro", "", "pg_profile_ring", "", "cddkxgdazimuthalsigmawidthnnbindsk_ptsim_ptsinterparg_interpprofilebgddoutline_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_ptassoc.html", "pg_ptassoc.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_ptassoc.pro", "", "", " NAME: 	pg_ptassoc    PURPOSE: 	Associates points between two arrays by searching for the most 	frequent offset between the two.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	assoc_scan_ptd = pg_ptassoc(scan_ptd, model_ptd, assoc_model_ptd)    ARGUMENTS:   INPUT: 	scan_ptd:	POINT(s) containing first array, typically 			an array of candidate points detected in an image.  	model_ptd:	POINT(s) containing the second array, typically 			an array of computed model points.    OUTPUT: 	assoc_model_ptd:	POINT containing the output model points. 			Each of these points is associated with a point 			in the returned array.  If this argument is not 			present, the model_ptd array is overwritten with 			the output model points.    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	POINT containing an associated scan point for each output 	model point in assoc_model_ptd.    PROCEDURE: 	Points are associated by searching for the most frequent offset 	between scan points and model points.    STATUS: 	Complete    SEE ALSO: 	pg_cvscan, pg_cvscan_coeff, pg_ptscan, pg_ptscan_coeff, 	pg_cvchisq, pg_ptchisq, pg_threshold    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2004   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_ptassoc.html#pg_ptassoc", "pg_ptassoc", 'routine in <a href="nv/com/pg/pg_ptassoc.html">pg_ptassoc.pro</a>', "pg_ptassoc.pro", "", "pg_ptassoc", "", "radiusdxymaxcountscan_ptdmodel_ptdassoc_model_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_ptchisq.html", "pg_ptchisq.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_ptchisq.pro", "", "", " NAME: 	pg_ptchisq    PURPOSE: 	Computes chi-squared value for given point fit parameters.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	chisq = pg_ptchisq(dxy, dtheta, scan_ptd, axis_ptd=axis_ptd)    ARGUMENTS:   INPUT: 	dxy:		2-element vector giving the translation as [dx,dy].  	dtheta:		Rotation in radians.  	scan_ptd:	Array (n_points) of POINT output from 			pg_ptscan containing scanned image points as well as 			other necessary scan data.    OUTPUT: NONE    KEYWORDS:   INPUT: 	axis_ptd:	POINT containing a single image  point 			to be used as the axis of rotation.  	fix:		Array specifying which parameters to fix as 			[dx,dy,dtheta].    OUTPUT: NONE    RETURN: 	Single chi-square values for totality of points.    RESTRICTIONS: 	The caller is responsible for ensuring that the input parameters are 	consistent with those used with other programs like pg_fit.    STATUS: 	Complete    SEE ALSO: 	pg_cvscan, pg_cvscan_coeff, pg_cvchisq, pg_ptscan, pg_ptscan_coeff, 	pg_ptchisq, pg_fit, pg_threshold    MODIFICATION HISTORY:  	Written by:	Haemmerle, 12/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_ptchisq.html#pg_ptchisq", "pg_ptchisq", 'routine in <a href="nv/com/pg/pg_ptchisq.html">pg_ptchisq.pro</a>', "pg_ptchisq.pro", "", "pg_ptchisq", "", "axis_ptdfixdxydthetascan_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_ptcntrd.html", "pg_ptcntrd.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_ptcntrd.pro", "", "", " NAME: 	pg_ptcntrd    PURPOSE: 	Attempts to find points of highest correlation with a given model 	centered near given features in an image, then returns the centroid.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_ptcntrd(dd, object_ptd)    ARGUMENTS:   INPUT: 	dd:		Data descriptor  	object_ptd: 	Array (n_pts) of POINT giving the points. 			Only the image coordinates of the points need to be 			specified.    OUTPUT:        NONE   KEYWORDS:   INPUT:        model:          Point spread model to be used in correlation.  If                        not given a default gaussian is used.         width:          Width to search around expected point location.  If                        not given, a default width of 20 pixels is used.         edge:           Distance from edge from which to ignore points.  If                        not given, an edge distance of 0 is used.         ccmin:          If given, points are discarded if the correlation                        is below this value.         gdmax:          If given, points are discarded if the gradiant of                        the correlation function is higher than this value.    OUTPUT: NONE    RETURN: 	An array of type POINT giving the detected position for        each object.  The correlation coeff values for each detection is        saved in the data portion of POINT with tag 'scan_cc'.        The x and y offset from the given position is also saved.    SIDE EFFECTS: 	xx    RESTRICTIONS: 	Currently does not work for multiple time steps.    PROCEDURE: 	For each visible object, a section of the image of size width +        the size of the model is extracted and sent to routine ptloc to        find the pixel offset with the highest correlation with the given        model. Then call astrolib routine cntrd to return centroid.    EXAMPLE: 	To find stellar positions with a correlation higher than 0.6...         star_ptd=pg_center(bx=sd, gd=gd) & pg_hide, star_ptd, gd=gd, /rm        ptscan_ptd=pg_ptscan(dd, star_ptd, edge=30, width=40, ccmin=0.6)   SEE ALSO: 	ptscan, pg_ptscan   STATUS: 	Complete.    MODIFICATION HISTORY:  	Written by:	Haemmerle, 5/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_ptcntrd.html#pg_ptcntrd", "pg_ptcntrd", 'routine in <a href="nv/com/pg/pg_ptcntrd.html">pg_ptcntrd.pro</a>', "pg_ptcntrd.pro", "", "pg_ptcntrd", "", "modelwidthedgeccmingdmaxddobject_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_ptfarscan.html", "pg_ptfarscan.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_ptfarscan.pro", "", "", " NAME: 	pg_ptfarscan    PURPOSE: 	Attempts to find all occurrences of a model in an image.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_ptfarscan(dd)    ARGUMENTS:   INPUT: 	dd:		Data descriptor    OUTPUT:        NONE   KEYWORDS:   INPUT:        model:          Point spread model to be used in correlation.  If                        not given a default gaussian is used.  	wmod:		x, ysize of default gaussian model.  	wpsf:		Half width of default gaussian psf model.         edge:           Distance from edge from which to ignore points.  If                        not given, an edge distance of 0 is used.         gdmax:		If given, the maximum gradiant of correlation coefficient 			to accept.         ccmin:          Minimum correlation to consider in search.  Default 			is 0.8.         gdmax:          If given, points where the gradient of the                        correlation function is higher than this value 			are not considered in the search.  	sky:		If set, it is assumed that the image contains only 			point sources and sky.  Any object more than nsig 			standard deviations above the image mean are 			selected as candidates.  	nsig:		For use with the /sky option, standard deviation 			threshold for detecting point sources.  	nmax:		Max. number of point sources to return.  If more 			are found, nsig is raised until thiws is satisified.  	smooth:		If given, the input image is smoothed using 			this width before any further processing.  	median:		If given, the input image is filtered using 			a median filter of this width before any further 			processing.  	mask:		If set, an attempt is made to mask out extended 			objects before performing the scan  	extend:		If nonzero, star masks are extended by this 			many pixels in all directions.  	name:		Name to use for the returned POINT objects.    OUTPUT: NONE    RETURN: 	An array of type POINT giving the detected position for        each object.  The correlation coeff value for each detection is        saved in the data portion of POINT with tag 'scan_cc'.    SEE ALSO: 	pg_ptscan   STATUS: 	Complete.    MODIFICATION HISTORY:  	Written by:	Spitale 2/2004   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_ptfarscan.html#pg_ptfarscan", "pg_ptfarscan", 'routine in <a href="nv/com/pg/pg_ptfarscan.html">pg_ptfarscan.pro</a>', "pg_ptfarscan.pro", "", "pg_ptfarscan", "", "namemodeledgeccmingdmaxsmoothwmodwpsfskynsigmedianmaskextendnmaxchifitdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_ptscan.html", "pg_ptscan.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_ptscan.pro", "", "", " NAME: 	pg_ptscan    PURPOSE: 	Attempts to find points of highest correlation with a given model 	centered near given features in an image.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_ptscan(dd, object_ptd)    ARGUMENTS:   INPUT: 	dd:		Data descriptor  	object_ptd: 	Array (n_pts) of POINT giving the points. 			Only the image coordinates of the points need to be 			specified.    OUTPUT:        NONE   KEYWORDS:   INPUT:        model:          Point spread model to be used in correlation.  If                        not given a default gaussian is used.  	wmod:		x, ysize of default gaussian model.  	wpsf:		Half-width of default gaussian psf model.         width:          Width to search around expected point location.  If                        not given, a default width of 20 pixels is used.  	radius:		Width outside of which to exclude detections whose 			offset varies too far from the most frequent offset. 			Detections with offsets outside this radius receive 			correlation coefficients of zero.         edge:           Distance from edge from which to ignore points.  If                        not given, an edge distance of 0 is used.         ccmin:          If given, points are discarded if the correlation                        is below this value.  	chisqmax:	Max chisq between the model and the image.         gdmax:          If given, points are discarded if the gradiant of                        the correlation function is higher than this value.  	smooth:		If given, the input image is smoothed using 			this width before any further processing.  	median:		If given, the input image is filtered using 			a median filter of this width before any further 			processing.    OUTPUT: NONE    RETURN: 	An array of type POINT giving the detected position for        each object.  The correlation coeff value for each detection is        saved in the data portion of POINT with tag 'scan_cc'.        The x and y offset from the given position is also saved.    RESTRICTIONS: 	Currently does not work for multiple time steps, only considers 	one point per given POINT.    PROCEDURE: 	For each visible object, a section of the image of size width +        the size of the model is extracted and sent to routine ptloc to        find the pixel offset with the highest correlation with the given        model.    EXAMPLE: 	To find stellar positions with a correlation higher than 0.6...         star_ptd=pg_center(bx=sd, gd=gd) & pg_hide, star_ptd, gd=gd, /rm        ptscan_ptd=pg_ptscan(dd, star_ptd, edge=30, width=40, ccmin=0.6)   SEE ALSO: 	pg_ptfarscan   STATUS: 	Complete.    MODIFICATION HISTORY:  	Written by:	Haemmerle, 5/1998 	Modified:	Spitale 9/2002 -- added twice model width to search 			width.   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_ptscan.html#pg_ptscan", "pg_ptscan", 'routine in <a href="nv/com/pg/pg_ptscan.html">pg_ptscan.pro</a>', "pg_ptscan.pro", "", "pg_ptscan", "", "modelradiuswidthedgeccmingdmaxsmoothshowwmodwpsfmedianchisqmaxcc_outroundspikeddobject_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_ptscan_coeff.html", "pg_ptscan_coeff.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_ptscan_coeff.pro", "", "", " NAME: 	pg_ptscan_coeff    PURPOSE: 	Computes linear least-squares coefficients for a fit to the image 	coordinate offset which matches a point to a feature in an image.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_ptscan_coeff(pts_ptd)    ARGUMENTS:   INPUT:        pts_ptd:        Array (n_pts) of POINT output from                        pg_ptscan containing image points as well as                        other necessary data.;    OUTPUT: NONE    KEYWORDS:   INPUT:        axis_ptd:       POINT containing a single image point                        to be used as the axis of rotation in the fit for                        every point.         fix:            Array specifying which parameters to fix in the                        fit as [dx,dy,dtheta].;    OUTPUT: NONE   RETURN:        Array (n_pts) of pg_fit_coeff_struct containing coefficients for        the least-square fit to be input to pg_fit.    PROCEDURE:        pg_ptscan_coeff extracts the scan data from the given        scan_ptd structure and uses ipt_coeff to compute the coefficients.        See the documentation for that routine for details.    EXAMPLE:        The following command uses data from pg_ptscan to compute        least square coefficients for a fit such that only dx and dtheta        will be allowed to vary:         optic_ptd = pnt_create_descriptors(points=cam_oaxis(cd))        ptscan_cf = pg_ptscan_coeff(pts_ptd, axis=optic_ptd, fix=[1])         In this call, pts_ptd is a POINT containing the point data        from pg_ptscan and optic_ptd is a POINT giving the optic axis        of the camera as computed by cam_oaxis.    STATUS: 	Complete.    MODIFICATION HISTORY:  	Written by:	Haemmerle, 5/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_ptscan_coeff.html#pg_ptscan_coeff", "pg_ptscan_coeff", 'routine in <a href="nv/com/pg/pg_ptscan_coeff.html">pg_ptscan_coeff.pro</a>', "pg_ptscan_coeff.pro", "", "pg_ptscan_coeff", "", "axis_ptdfixmodel_ptdpts_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_put_arrays.html", "pg_put_arrays.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_put_arrays.pro", "", "", " NAME: 	pg_put_arrays    PURPOSE: 	Outputs array descriptors through the translators.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_put_arrays, dd, ard=ard    ARGUMENTS:   INPUT: 	dd:	Data descriptor.  	trs:	String containing keywords and values to be passed directly 		to the translators as if they appeared as arguments in the 		translators table.  These arguments are passed to every 		translator called, so the user should be aware of possible 		conflicts.  Keywords passed using this mechanism take 		precedence over keywords appearing in the translators table.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	ard:	Star descriptors to output.  	arr_*:		All star override keywords are accepted.  	tr_override:	String giving a comma-separated list of translators 			to use instead of those in the translators table.  If 			this keyword is specified, no translators from the 			table are called, but the translators keywords 			from the table are still used.    OUTPUT: 	NONE    SIDE EFFECTS: 	Translator-dependent.  The data descriptor may be affected.    PROCEDURE: 	CameStarra descriptors are passed to the translators.  Any star 	keywords are used to override the corresponding quantities in the 	output descriptors.    STATUS: 	Complete    SEE ALSO: 	pg_put_planets, pg_put_rings, pg_put_cameras, pg_put_maps    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_put_arrays.html#pg_put_arrays", "pg_put_arrays", 'routine in <a href="nv/com/pg/pg_put_arrays.html">pg_put_arrays.pro</a>', "pg_put_arrays.pro", "", "pg_put_arrays", "", "ardodsddtrs@arr__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_put_cameras.html", "pg_put_cameras.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_put_cameras.pro", "", "", " NAME: 	pg_put_cameras    PURPOSE: 	Outputs camera descriptors through the translators.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_put_cameras, dd, cd=cd    ARGUMENTS:   INPUT: 	dd:	Data descriptor.  	trs:	String containing keywords and values to be passed directly 		to the translators as if they appeared as arguments in the 		translators table.  These arguments are passed to every 		translator called, so the user should be aware of possible 		conflicts.  Keywords passed using this mechanism take 		precedence over keywords appearing in the translators table.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	cd:	Camera descriptors to output.  	cam_*:		All camera override keywords are accepted.  	tr_override:	String giving a comma-separated list of translators 			to use instead of those in the translators table.  If 			this keyword is specified, no translators from the 			table are called, but the translators keywords 			from the table are still used.    OUTPUT: 	NONE    SIDE EFFECTS: 	Translator-dependent.  The data descriptor may be affected.    PROCEDURE: 	Camera descriptors are passed to the translators.  Any camera 	keywords are used to override the corresponding quantities in the 	output descriptors.    STATUS: 	Complete    SEE ALSO: 	pg_put_planets, pg_put_rings, pg_put_stars, pg_put_maps    MODIFICATION HISTORY:  	Written by:	Spitale, 1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_put_cameras.html#pg_put_cameras", "pg_put_cameras", 'routine in <a href="nv/com/pg/pg_put_cameras.html">pg_put_cameras.pro</a>', "pg_put_cameras.pro", "", "pg_put_cameras", "", "cdddtrs@cam__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_put_maps.html", "pg_put_maps.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_put_maps.pro", "", "", " NAME: 	pg_put_maps    PURPOSE: 	Outputs map descriptors through the translators.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_put_maps, dd, md=md    ARGUMENTS:   INPUT: 	dd:	Data descriptor.  	trs:	String containing keywords and values to be passed directly 		to the translators as if they appeared as arguments in the 		translators table.  These arguments are passed to every 		translator called, so the user should be aware of possible 		conflicts.  Keywords passed using this mechanism take 		precedence over keywords appearing in the translators table.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	md:	Map descriptors to output.  	map_*:		All map override keywords are accepted.  	tr_override:	String giving a comma-separated list of translators 			to use instead of those in the translators table.  If 			this keyword is specified, no translators from the 			table are called, but the translators keywords 			from the table are still used.    OUTPUT: 	NONE    SIDE EFFECTS: 	Translator-dependent.  The data descriptor may be affected.    PROCEDURE: 	Map descriptors are passed to the translators.  Any map 	keywords are used to override the corresponding quantities in the 	output descriptors.    STATUS: 	Complete    SEE ALSO: 	pg_put_planets, pg_put_rings, pg_put_stars, pg_put_cameras    MODIFICATION HISTORY:  	Written by:	Spitale, 1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_put_maps.html#pg_put_maps", "pg_put_maps", 'routine in <a href="nv/com/pg/pg_put_maps.html">pg_put_maps.pro</a>', "pg_put_maps.pro", "", "pg_put_maps", "", "mdddtrs@map__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_put_planets.html", "pg_put_planets.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_put_planets.pro", "", "", " NAME: 	pg_put_planets    PURPOSE: 	Outputs planet descriptors through the translators.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_put_planets, dd, pd=pd    ARGUMENTS:   INPUT: 	dd:	Data descriptor.  	trs:	String containing keywords and values to be passed directly 		to the translators as if they appeared as arguments in the 		translators table.  These arguments are passed to every 		translator called, so the user should be aware of possible 		conflicts.  Keywords passed using this mechanism take 		precedence over keywords appearing in the translators table.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	pd:	Planet descriptors to output.  	plt_*:		All planet override keywords are accepted.  	raw:		If set, no aberration corrections are performed.  	tr_override:	String giving a comma-separated list of translators 			to use instead of those in the translators table.  If 			this keyword is specified, no translators from the 			table are called, but the translators keywords 			from the table are still used.    OUTPUT: 	NONE    SIDE EFFECTS: 	Translator-dependent.  The data descriptor may be affected.    PROCEDURE: 	Planet descriptors are passed to the translators.  Any planet 	keywords are used to override the corresponding quantities in the 	output descriptors.    STATUS: 	Complete    SEE ALSO: 	pg_put_cameras, pg_put_rings, pg_put_stars, pg_put_maps    MODIFICATION HISTORY:  	Written by:	Spitale, 1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_put_planets.html#pg_put_planets", "pg_put_planets", 'routine in <a href="nv/com/pg/pg_put_planets.html">pg_put_planets.pro</a>', "pg_put_planets.pro", "", "pg_put_planets", "", "pdodsrawddtrs@plt__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_put_rings.html", "pg_put_rings.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_put_rings.pro", "", "", " NAME: 	pg_put_rings    PURPOSE: 	Outputs ring descriptors through the translators.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_put_rings, dd, rd=rd    ARGUMENTS:   INPUT: 	dd:	Data descriptor.  	trs:	String containing keywords and values to be passed directly 		to the translators as if they appeared as arguments in the 		translators table.  These arguments are passed to every 		translator called, so the user should be aware of possible 		conflicts.  Keywords passed using this mechanism take 		precedence over keywords appearing in the translators table.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	rd:	Ring descriptors to output.  	rng_*:		All ring override keywords are accepted.  	tr_override:	String giving a comma-separated list of translators 			to use instead of those in the translators table.  If 			this keyword is specified, no translators from the 			table are called, but the translators keywords 			from the table are still used.    OUTPUT: 	NONE    SIDE EFFECTS: 	Translator-dependent.  The data descriptor may be affected.    PROCEDURE: 	Ring descriptors are passed to the translators.  Any ring 	keywords are used to override the corresponding quantities in the 	output descriptors.    STATUS: 	Complete    SEE ALSO: 	pg_put_planets, pg_put_cameras, pg_put_stars, pg_put_maps    MODIFICATION HISTORY:  	Written by:	Spitale, 1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_put_rings.html#pg_put_rings", "pg_put_rings", 'routine in <a href="nv/com/pg/pg_put_rings.html">pg_put_rings.pro</a>', "pg_put_rings.pro", "", "pg_put_rings", "", "rdodsddtrs@rng__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_put_stars.html", "pg_put_stars.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_put_stars.pro", "", "", " NAME: 	pg_put_stars    PURPOSE: 	Outputs star descriptors through the translators.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_put_stars, dd, sd=sd    ARGUMENTS:   INPUT: 	dd:	Data descriptor.  	trs:	String containing keywords and values to be passed directly 		to the translators as if they appeared as arguments in the 		translators table.  These arguments are passed to every 		translator called, so the user should be aware of possible 		conflicts.  Keywords passed using this mechanism take 		precedence over keywords appearing in the translators table.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	sd:	Star descriptors to output.  	str_*:		All star override keywords are accepted.  	tr_override:	String giving a comma-separated list of translators 			to use instead of those in the translators table.  If 			this keyword is specified, no translators from the 			table are called, but the translators keywords 			from the table are still used.    OUTPUT: 	NONE    SIDE EFFECTS: 	Translator-dependent.  The data descriptor may be affected.    PROCEDURE: 	CameStarra descriptors are passed to the translators.  Any star 	keywords are used to override the corresponding quantities in the 	output descriptors.    STATUS: 	Complete    SEE ALSO: 	pg_put_planets, pg_put_rings, pg_put_cameras, pg_put_maps    MODIFICATION HISTORY:  	Written by:	Spitale, 1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_put_stars.html#pg_put_stars", "pg_put_stars", 'routine in <a href="nv/com/pg/pg_put_stars.html">pg_put_stars.pro</a>', "pg_put_stars.pro", "", "pg_put_stars", "", "sdodsddtrs@str__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_put_stations.html", "pg_put_stations.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_put_stations.pro", "", "", " NAME: 	pg_put_stations    PURPOSE: 	Outputs station descriptors through the translators.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_put_stations, dd, std=std    ARGUMENTS:   INPUT: 	dd:	Data descriptor.  	trs:	String containing keywords and values to be passed directly 		to the translators as if they appeared as arguments in the 		translators table.  These arguments are passed to every 		translator called, so the user should be aware of possible 		conflicts.  Keywords passed using this mechanism take 		precedence over keywords appearing in the translators table.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	std:	Star descriptors to output.  	stn_*:		All star override keywords are accepted.  	tr_override:	String giving a comma-separated list of translators 			to use instead of those in the translators table.  If 			this keyword is specified, no translators from the 			table are called, but the translators keywords 			from the table are still used.    OUTPUT: 	NONE    SIDE EFFECTS: 	Translator-dependent.  The data descriptor may be affected.    PROCEDURE: 	CameStarra descriptors are passed to the translators.  Any star 	keywords are used to override the corresponding quantities in the 	output descriptors.    STATUS: 	Complete    SEE ALSO: 	pg_put_planets, pg_put_rings, pg_put_cameras, pg_put_maps    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_put_stations.html#pg_put_stations", "pg_put_stations", 'routine in <a href="nv/com/pg/pg_put_stations.html">pg_put_stations.pro</a>', "pg_put_stations.pro", "", "pg_put_stations", "", "stdodsddtrs@stn__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_range.html", "pg_range.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_range.pro", "", "", " NAME: 	pg_range    PURPOSE: 	Computes distance between the centers of two bodies.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	range = pg_center(bx1, bx2)    ARGUMENTS:   INPUT: 	bx1:	Array (n_objects, n_timesteps) of descriptors of objects 		which must be a subclass of BODY.  	bx2:	Array (n_objects, n_timesteps) of descriptors of objects 		which must be a subclass of BODY.    OUTPUT: NONE    RETURN: 	Array (n_objects) doubles giving the ranges.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 11/2001   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_range.html#pg_range", "pg_range", 'routine in <a href="nv/com/pg/pg_range.html">pg_range.pro</a>', "pg_range.pro", "", "pg_range", "", "bx1bx2", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_ray.html", "pg_ray.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_ray.pro", "", "", " NAME: 	pg_ray    PURPOSE: 	Computes image points on each specified ray.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	ray_ptd = pg_ray(cd=cd, r=r, v=v)    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd:	 Array (nt) of camera descriptors.  	bx:	 Array (nt) of body descriptors to be used for transforming 		 the points instead of the camera descriptor.  Use this 		 input if cd is a map.  	gd:	Generic descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.  	dd:	Data descriptor containing a generic descriptor to use 		if gd not given.  	r:	 Array (nv,3,nt) of inertial vectors giving the starting 		 point for each ray.  	v:	 Array (nv,3,nt) of inertial unit vectors giving the direction 		 for each ray.  	len:	 Array (nv,nt) giving the length for each ray.  Lengths 		 default to 1 if not given.  	npoints: Number of points to compute per ray.  Default is 1000.  	clip:	 If set points are computed only within this many camera 		 fields of view.  	cull:	 If set, POINT objects excluded by the clip keyword 		 are not returned.  Normally, empty POINT objects 		 are returned as placeholders.  	cat:	 If set, all points for each descriptor are concatenated 		 into a single array of nv*npoints points.  	dispersion: If set, points will be randomly dispersed in a cone 	            of this opening angle about the ray.    OUTPUT: NONE    RETURN: 	Array (nt) of POINT each containing image points (2,nv,npoints) and 	the corresponding inertial vectors (nv,3,npoints).     STATUS:     MODIFICATION HISTORY:  	Written by:	Spitale, 9/2012   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_ray.html#pgr_density_uniform", "pgr_density_uniform", 'routine in <a href="nv/com/pg/pg_ray.html">pg_ray.pro</a>', "pg_ray.pro", "", "pgr_density_uniform", "", "npnvlen", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_ray.html#pg_ray", "pg_ray", 'routine in <a href="nv/com/pg/pg_ray.html">pg_ray.pro</a>', "pg_ray.pro", "", "pg_ray", "", "rvlencdbxddgdclipcullnpointscatdensity_fndispersion", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_reflection.html", "pg_reflection.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_reflection.pro", "", "", " NAME: 	pg_reflection    PURPOSE: 	Computes image coordinates of given inertial vectors projected onto 	surface of the given disks and globes with respect to the given 	observer.  Returns only the closest reflection point for each objoect 	point.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_reflection, object_ptd, cd=cd, ods=ods, dkx=dkx, gbx=gbx    ARGUMENTS:   INPUT: 	object_ptd:	Array of POINT containing inertial vectors.    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd:	Array (n_timesteps) of camera descriptors.  	gbx:	Array (n_globes, n_timesteps) of descriptors of objects 		which must be a subclass of GLOBE.  	dkx:	Array (n_disks, n_timesteps) of descriptors of objects 		which must be a subclass of DISK.  	bx:	Array (n_disks, n_timesteps) of descriptors of objects 		which must be a subclass of BODY.  	od:	Array (n_timesteps) of descriptors of objects 		which must be a subclass of BODY.  These objects are used 		as the source from which points are projected.  If no observer 		descriptor is given, then the sun descriptor in gd is used. 		Only one observer is allowed.  	gd:	Generic descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.  	dd:	Data descriptor containing a generic descriptor to use 		if gd not given.  	  All other keywords are passed directly to pg_reflection_globe 	  and pg_reflection_disk and are documented with those programs.    OUTPUT: NONE    RETURN: 	Array (n_disks,n_objects) of POINT containing image 	points and the corresponding inertial vectors.    STATUS: 	Soon to be replaced by a new program that merges pg_reflection_globe and 	pg_reflection_disk.  The API for the new routine may be slightly different.    SEE ALSO: 	pg_reflection_disk, pg_reflection_globe, pg_reflection_points    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_reflection.html#pg_reflection", "pg_reflection", 'routine in <a href="nv/com/pg/pg_reflection.html">pg_reflection.pro</a>', "pg_reflection.pro", "", "pg_reflection", "", "cdoddkxgbxbxddgdrevealclipnocullallobject_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_reflection_disk.html", "pg_reflection_disk.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_reflection_disk.pro", "", "", " NAME: 	pg_reflection_disk    PURPOSE: 	Computes image coordinates of given inertial vectors reflected onto 	surface of the given disk with respect to the given observer.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_reflection_disk(object_ptd, cd=cd, ods=ods, dkx=dkx)    ARGUMENTS:   INPUT: 	object_ptd:	Array of POINT containing inertial vectors.    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd:	Array (n_timesteps) of camera descriptors.  	dkx:	Array (n_disks, n_timesteps) of descriptors of objects 		which must be a subclass of DISK.  	od:	Array (n_timesteps) of descriptors of objects 		which must be a subclass of BODY.  These objects are used 		as the source from which points are projected.  If no observer 		descriptor is given, then the camera descriptor in gd is used. 		Only one observer is allowed.  	gd:	Generic descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.  	dd:	Data descriptor containing a generic descriptor to use 		if gd not given.  	reveal:	 Normally, disks whose opaque flag is set are ignored. 		 /reveal suppresses this behavior.  	clip:	 If set reflection points are cropped to within this many camera 		 fields of view.  	cull:	 If set, POINT objects excluded by the clip keyword 		 are not returned.  Normally, empty POINT objects 		 are returned as placeholders.  	all:	 If set, all points are returned, even if invalid.    OUTPUT: NONE    RETURN: NONE 	Array (n_disks,n_objects) of POINT containing image 	points and the corresponding inertial vectors.    STATUS: 	Soon to be obsolete.  This program will be merged with pg_shadow_globe 	to make a more general program, which will replace pg_shadow.    SEE ALSO: 	pg_reflection, pg_reflection_globe    MODIFICATION HISTORY:  	Written by:	Spitale, 1/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_reflection_disk.html#pg_reflection_disk", "pg_reflection_disk", 'routine in <a href="nv/com/pg/pg_reflection_disk.html">pg_reflection_disk.pro</a>', "pg_reflection_disk.pro", "", "pg_reflection_disk", "", "cdoddkxddgdnocullall_ptdrevealclipcullallobject_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_reflection_globe.html", "pg_reflection_globe.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_reflection_globe.pro", "", "", " NAME: 	pg_reflection_globe    PURPOSE: 	Computes image coordinates of the given inertial vectors projected onto 	surface of the given globe with respect to the given observer.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_reflection_globe(object_ptd, cd=cd, od=od, gbx=gbx)    ARGUMENTS:   INPUT: 	object_ptd:	Array of POINT containing inertial vectors.    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd:	Array (n_timesteps) of camera descriptors.  	gbx:	Array (n_globes, n_timesteps) of descriptors of objects 		which must be a subclass of GLOBE.  	od:	Array (n_timesteps) of descriptors of objects 		which must be a subclass of BODY.  These objects are used 		as the source from which points are projected.  If no observer 		descriptor is given, then the sun descriptor in gd is used. 		Only one observer is allowed.  	gd:	Generic descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.  	dd:	Data descriptor containing a generic descriptor to use 		if gd not given.  	reveal:	 Normally, disks whose opaque flag is set are ignored. 		 /reveal suppresses this behavior.  	clip:	 If set reflection points are cropped to within this many camera 		 fields of view.  	cull:	 If set, POINT objects excluded by the clip keyword 		 are not returned.  Normally, empty POINT objects 		 are returned as placeholders.  	all:	 If set, all points are returned, even if invalid.  	nosolve: If set, reflection points are not computed.    OUTPUT: NONE    RETURN: 	Array (n_globes,n_objects) of POINT containing image 	points and the corresponding inertial vectors.    STATUS: 	Soon to be obsolete.  This program will be merged with pg_reflection_disk 	to make a more general program, which will replace pg_reflection.    SEE ALSO: 	pg_reflection, pg_reflection_disk, pg_reflection_points    MODIFICATION HISTORY:  	Written by:	Spitale, 6/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_reflection_globe.html#pg_reflection_globe", "pg_reflection_globe", 'routine in <a href="nv/com/pg/pg_reflection_globe.html">pg_reflection_globe.pro</a>', "pg_reflection_globe.pro", "", "pg_reflection_globe", "", "cdodgbxddgdnocullrevealclipcullallnosolveobject_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_render.html", "pg_render.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_render.pro", "", "", " NAME: 	pg_render    PURPOSE: 	Performs rendering on an array of bodies.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_render(cd=cd, bx=bx, sund=sund, ddmap=dd_render, md=md)    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd:	      Camera descriptor.  	bx:	      Array of object descriptors; must be a subclass of BODY.  	sund:         Star descriptor for the Sun.  	md:           Array of map descriptors for each ddmap.  	gd:		Generic descriptor.  If given, the descriptor inputs 			are taken from this structure if not explicitly given.  	dd:		Data descriptor containing a generic descriptor to use 			if gd not given.  	ddmap:        Array of data descriptors containing the body maps, 	              one for each body.  If not given, maps are loaded using 		      pg_load_maps.  	sample:       Amount by which to subsample pixels.  	pc_size:      To save memory, the projection is performed in pieces 	              of this size.  Default is 65536.  	limit_source: If set, secondary vectors originating on a given 	              body are not considered for targets that are the 	              same body.  Default is on.  	standoff:     If given, secondary vectors are advanced by this distance 	              before tracing in order to avoid hitting target bodies 	              through round-off error.  	nodd:         If set, no data descrptor is produced.  The return value 	              is zero and the rendering is returned via the IMAGE 	              keyword.  	psf:          If set, the rendering is convolved with a point-spread 	              function.  If /psf, then the PSF is obtained via cd; if 	              psf is a 2D array, then is is used as the PSF.  	npsf:         Width of psf array to use if PSF is obtained via cd. 	              Default is 10.  	penumbra:     If set, lighting rays are traced to random points on 	              each secondary body rather then the center.  	no_secondary: If set, no secondary ray tracing is performed, 	              resulting in no shadows.  	image_ptd:    POINT or array with image points 	              specifying the grid to trace.  If not set, the entire 	              image described by cd is used.  The array can have 	              dimensions of (2,np) or (2,nx,ny).  If the latter, 	              the output map will have dimensions (nx,ny).  Note 	              that a PSF cannot be applied if nx and ny are not known.  	mask_width:   Width of trace mask.  Default is 512.  If set to zero, 	              no masking is performed.  	no_maps:      If set, maps are not loaded.  	pht_min:      Minimum value to assign to photometric output.     OUTPUT: 	map:	       2-D array containing the rendered scene.    RETURN: 	Data descriptor containing the rendered image.    PROCEDURE:     EXAMPLE:    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_render.html#pg_render", "pg_render", 'routine in <a href="nv/com/pg/pg_render.html">pg_render.pro</a>', "pg_render.pro", "", "pg_render", "", "cdsundbxddmapmdddgdsamplepc_sizeshowpht_minno_phtmapstandofflimit_sourcenoddpsfnpsfpenumbrano_secondaryimage_ptdmask_widthno_maps", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_renderfit.html", "pg_renderfit.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_renderfit.pro", "", "", " NAME: 	pg_renderfit    PURPOSE: 	Searches for the offset (dx,dy) that gives the best agreement between 	two uncorrelated sets of image points.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	dxy = pg_renderfit(dd, cd=cd, sund=sund, bx=bx)    ARGUMENTS:   INPUT: 	dd:		Data descriptor.    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd: 		Camera descriptor.  	sund:		Sun descriptor.  	bx:		Array of body descriptors describing objects in the scene.  	show:		If specified, some graphics are displayed illustrating 			aspects of the search.     OUTPUT: NONE    RETURN: 	2-element array giving the fit offset as [dx,dy].    PROCEDURE: 	pg_renderfit finds the offset that gives the best correlation between 	the given image and a simulated image.    STATUS: 	Some bugs.  One problem is that the current search grid wraps pixels 	instead of truncating them.  This causes problems for images where 	a large body is not entirly within the FOV.    NOTES: 	This could be improved by iterating, starting with a broader, more 	coarsely sampled scene.    SEE ALSO: 	pg_farfit    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_renderfit.html#pg_renderfit", "pg_renderfit", 'routine in <a href="nv/com/pg/pg_renderfit.html">pg_renderfit.pro</a>', "pg_renderfit.pro", "", "pg_renderfit", "", "cdsundbxshowfovdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_repoint.html", "pg_repoint.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_repoint.pro", "", "", " NAME: 	pg_repoint    PURPOSE: 	Modifies the camera orientation matrix based on the given image 	coordinate translation and rotation.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_repoint, cd=cd, dxy, dtheta, axis_ptd=axis_ptd 	pg_repoint, gd=gd, dxy, dtheta, axis_ptd=axis_ptd    ARGUMENTS:   INPUT: 	dxy:		Array (2,1,nt) or (2,1) specifying the 			translation as [dx,dy] in pixels.  	dtheta:		Array (nt) specfying the rotation angle in radians.    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd:	 Array (nt) of camera descriptors.  	gd:	 Generic descriptor.  If given, the cd input is taken from the 		 cd field of this structure instead of from that keyword.  	axis_ptd: POINT containing a single image point 		 to be used as the axis of rotation.  Default is the camera 		 optic axis.  	bore_cd:  Array (nt) of camera descriptors from which to copy the 		  new orientation instead of using dxy, dtheta, and axis_ptd.  	bore_rot: If given, the orientation from bore_cd will be rotated 		  using this rotation matrix (3,3) before being copied.  	bore_dxy: Boresight offset in pixels.  	absolute: If set, the dxy argument represents and abosolute image 		  position rather than an offset.    OUTPUT: 	cd:	 If given, the camera descriptor is modified with a new 		 orientation matrix.  	gd:	 If given in this way, the camera descriptor contained in the 		 generic descriptor is modified with a new orientation matrix.    RETURN: NONE    SIDE EFFECTS: 	pg_repoint adds its name to the task list of each given camera 	descriptor.    STATUS: 	Complete    SEE ALSO: 	pg_fit, pg_drag    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_repoint.html#pg_repoint", "pg_repoint", 'routine in <a href="nv/com/pg/pg_repoint.html">pg_repoint.pro</a>', "pg_repoint.pro", "", "pg_repoint", "", "cdgdaxis_ptdbore_cdbore_rotbore_dxyabsolute_dxy_dtheta", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_repos.html", "pg_repos.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_repos.pro", "", "", " NAME: 	pg_repos    PURPOSE: 	Modifies the body position based on the given offset and observer.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_repos, bx=bx, dv 	pg_repos, bx=bx, dv, od=od    ARGUMENTS:   INPUT: 	dv:		Array (nv,3,nt) specifying the translation vector. 			The components are assumed to be given wrt to the 			inertial frame unless od is given.  In that case 			dv is interpreted as a vector in the body frame of od.  			For convenience, if dv is given in the nonstandard form 			of a 3-element array, it is reinterpreted as a column 			vector (1,3).  			If ref_bx is given, then dv is interpreted as a distance 			and the direction is constructed from one of the directional 			keywords below.    OUTPUT: NONE    KEYWORDS:   INPUT: 	 bx:	   Array (nt) of body descriptors to translate.  	 od:	   Observer descriptor; specifies the body frame for the 		   translation vector.    	 gd:	   Generic descriptor.  If given, the descriptor inputs 		   are taken from this structure if not explicitly given.  	 dd:	   Data descriptor containing a generic descriptor to use 		   if gd not given.  	 ref_bx:   Body descriptor giving reference position for directional 		   keywords.  	toward:    Body should be translated toward ref_bx (default).  	away:      Body should be translated away from ref_bx.  	at:        Body should be placed at the position of ref_bx.  	along:     Index of bx axis along which to translate.     OUTPUT: 	NONE.    RETURN: NONE    SIDE EFFECTS: 	pg_repos modifies bx and adds its name to the task list of each given 	descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2007   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_repos.html#pg_repos", "pg_repos", 'routine in <a href="nv/com/pg/pg_repos.html">pg_repos.pro</a>', "pg_repos.pro", "", "pg_repos", "", "bxodref_bxddgdtowardawayatalong_dv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_resfit.html", "pg_resfit.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_resfit.pro", "", "", " NAME: 	pg_resfit    PURPOSE: 	Computes polynomial coefficients for a camera distortion model by 	comparing detected reseaus with the known focal plane locations.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_resfit, scan_ptd, foc_ptd, n, cd=cd    ARGUMENTS:   INPUT: 	scan_ptd:	POINT containing image coordinates of 			the scanned reseau candidates as output by pg_resloc.  	foc_ptd:		POINT containing the known focal 			coordinates of the reseau marks.  	n:		Order of polynomial to fit.  Default is 4.    OUTPUT: 	NONE    KEYWORDS:   INPUT:        cd:		Camera descriptor to be modified.         gd:		Generic descriptor containing the camera descriptor 			to be modified.         range:		Range to use in associating candidate reseaus 			with known reseaus. default is 10 pixels.  	assoc:		If set, the program returns after generating 			the scan_sub array, but before fitting the polynomial 			coefficients.  	nom_ptd:		If given, this POINT contains image 			coordinates of nominal reseau locations corresponding 			to each point in foc_ptd.  The positions of each mark 			for which there is no scan_ptd match is computed 			as the nominal position plus an offset determined 			by looking at the differences between neighboring 			scanned marks and their corresponding nominal positions.  	use_nom:	If set, scan_ptd will be ignored and nom_ptd will be used 			instead.    OUTPUT: 	res_ptd:		POINT containing the new image 			coordinates of the known reseau marks.  	fcp:		POINT returning the focal points from 			foc_ptd that were able to be associated with a scanned 			reseau.  	scp:		POINT returning the scanned points from 			scan_ptd that were able to be associated with a 			known location.   RETURN: 	NONE    PROCEDURE: 	First, candidate reseaus are associated with nominal reseaus by 	choosing the candidate with the highest correlation coefficient 	within a given number of pixels surrounding each known reseau.  	Next, coefficients for a polynomial of order n are derived using a 	least-squares fit.    STATUS: 	Complete    SEE ALSO: 	pg_resloc, pg_linearize_image, pg_blemish    MODIFICATION HISTORY:  	Written by:	Spitale, 5/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_resfit.html#pgrf_associate_marks", "pgrf_associate_marks", 'routine in <a href="nv/com/pg/pg_resfit.html">pg_resfit.pro</a>', "pg_resfit.pro", "", "pgrf_associate_marks", "", "scan_ptsfoc_ptsccrange", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_resfit.html#pgrf_get_matches", "pgrf_get_matches", 'routine in <a href="nv/com/pg/pg_resfit.html">pg_resfit.pro</a>', "pg_resfit.pro", "", "pgrf_get_matches", "", "nom_ptdfpspscan_subfoc_ptsscan_pts", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_resfit.html#pg_resfit", "pg_resfit", 'routine in <a href="nv/com/pg/pg_resfit.html">pg_resfit.pro</a>', "pg_resfit.pro", "", "pg_resfit", "", "cdgdrangenom_ptdres_ptdscpfcpassocuse_nomscan_ptdfoc_ptdn", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_residuals.html", "pg_residuals.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_residuals.pro", "", "", " NAME: 	pg_residuals    PURPOSE: 	Computes residuals value for given curve- or point-fit parameters.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	chisq = pg_residuals(scan_ptd)    ARGUMENTS:   INPUT: 	scan_ptd:	Array (n_curves) of POINT output from 			pg_cvscan or pg_ptscan containing scan data.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (2,n_curves) of residuals.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_residuals.html#pg_residuals", "pg_residuals", 'routine in <a href="nv/com/pg/pg_residuals.html">pg_residuals.pro</a>', "pg_residuals.pro", "", "pg_residuals", "", "scan_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_resloc.html", "pg_resloc.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_resloc.pro", "", "", " NAME: 	pg_resloc    PURPOSE: 	Scans an image for candidate reseau marks.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_resloc(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor containing the image to scan.    OUTPUT: 	NONE    KEYWORDS:   INPUT:         edge:  Distance from edge within which points are ignored.         ccmin:  Minimum correlation coefficient to accept.  Default is 0.8 .         gdmax:  Maximum gradiant of correlation coefficient to accept. 		Default is 0.25         model:  2-D array giving a model of the reseau image.  Default model 		is an inverted Gaussian.  	nom_ptd:	If given, reseau marks are searched for only within the 		given radius about each nominal point.  	radius:	Radius about no_ptd to search.  Default is ten pixels.    OUTPUT: 	NONE    RETURN: 	Points structure containing the image coordinates of each candidiate 	reseau mark and the corresponding correlation coefficients.  If not 	marks are found, zero is returned.    PROCEDURE: 	A correlation map is computed across image.  Candidates reseau marks 	are identified as local maxima in the correlation map by accepting 	points where the correlation is above the specified threshold and 	where the gradient of the correlation map is below the specified 	threshold.    STATUS: 	Complete    SEE ALSO: 	pg_resfit, modloc    MODIFICATION HISTORY:  	Written by:	Spitale, 1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_resloc.html#pg_resloc", "pg_resloc", 'routine in <a href="nv/com/pg/pg_resloc.html">pg_resloc.pro</a>', "pg_resloc.pro", "", "pg_resloc", "", "edgemodelccmingdmaxnom_ptdradiusdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_retarg.html", "pg_retarg.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_retarg.pro", "", "", " NAME: 	pg_retarg    PURPOSE: 	Modifies the camera orientation such that the optic axis points 	along a given vector, or toward a specified body.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_retarg, cd=cd, bx=bx    ARGUMENTS:   INPUT: 	v:	Inertial vector giving new optic axis direction.    OUTPUT: NONE    KEYWORDS:   INPUT: 	 cd:	 Camera descriptor to repoint.  	 bx:	 Body descriptor at which to point.  	 gd:	 Generic descriptor.  If given, the descriptor inputs 		 are taken from this structure if not explicitly given.  	 dd:	 Data descriptor containing a generic descriptor to use 		 if gd not given.  	 toward: Camera should be pointed toward bx (default).  	 away:   Camera should be pointed away from bx.  	along:   Index of bx axis along which to point.     OUTPUT: 	NONE.    RETURN: NONE    SIDE EFFECTS: 	pg_retarg modifies cd and adds its name to the task list of each given 	descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2007   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_retarg.html#pg_retarg", "pg_retarg", 'routine in <a href="nv/com/pg/pg_retarg.html">pg_retarg.pro</a>', "pg_retarg.pro", "", "pg_retarg", "", "cdbxref_bxddgdtowardawayalongv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_ring_sector.html", "pg_ring_sector.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_ring_sector.pro", "", "", " NAME: 	pg_ring_sector   PURPOSE: 	Allows the user to select a ring sector by clicking and dragging. 	With the left button, the sector is defined along lines of constant 	radius and longitude.  With the right button, the sides of the sector 	are perpendicular to the projected radial direction.   CATEGORY:        NV/PG   CALLING SEQUENCE:      rad=pg_ring_sector(cd=cd, dkx=dkx)    ARGUMENTS:   INPUT:       NONE    OUTPUT: 	NONE     KEYWORDS:   INPUT:            cd:     Camera descriptor.  	   dkx:     Disk descriptor describing the ring.             gd:     Generic descriptor containing the above descriptors.        win_num:     Window number of IDL graphics window in which to select                    box, default is current window.        restore:     Do not leave the box in the image.             p0:     First corner of box.  If set, then the routine immediately                    begins to drag from that point until a button is released.          color:     Color to use for rectangle, default is !color.          slope:     This keyword allows the longitude to vary from the                    nominal direction as a function of radius as:                    lon = slope*(rad - rad0).         sample:     Sets the grid sampling in pixels.  Default is one.   xor_graphics:     If set, the sector outline is drawn and erased using xor                    graphics instead of a pixmap.          nodsk:     If set, image points will not be included in the output                    POINT.         silent:     If set, messages are suppressed.        rad,lon:     If set, these values are used as bounds for the ring                    the ring sector instead of pronpting the user.     OUTPUT:        button:     Code of the detected button.    RETURN:       POINT containing points on the sector outline.  The point       spacing is determined by the sample keyword.  The POINT object       also contains the disk coordinate for each point and the user fields       'nrad' and 'nlon' giving the number of points in radius and longitude.   KNOWN BUGS: 	The sector flips when it hits zero azimuth rather than retaining a 	consistent sense.    MODIFICATION HISTORY : 	J. Spitale ; 5/2005 -- Original pg_ring_sector renamed 	                       pg_ring_sector_rad; this program created.   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_ring_sector.html#pg_ring_sector", "pg_ring_sector", 'routine in <a href="nv/com/pg/pg_ring_sector.html">pg_ring_sector.pro</a>', "pg_ring_sector.pro", "", "pg_ring_sector", "", "cddkxgdradlonsamplewin_numrestoreslopep0buttonxor_graphicscolorsilentnodsk", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_ring_sector_box.html", "pg_ring_sector_box.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_ring_sector_box.pro", "", "", " NAME: 	pg_ring_sector_box   PURPOSE: 	Allows the user to select a box to use with pg_profile_ring.   CATEGORY:        NV/PG   CALLING SEQUENCE:      outline_ptd = pg_ring_sector_box()      outline_ptd = pg_ring_sector_box(corners)    ARGUMENTS:   INPUT:       corners:	    Array of image points giving the corners of the box. 		    If not given, the user is prompted to select a box.    OUTPUT: 	NONE     KEYWORDS:   INPUT:       win_num:     Window number of IDL graphics window in which to select                    box, default is current window.        restore:     Do not leave the box in the image.             p0:     First corner of box.  If set, then the routine immediately                    begins to drag from that point until a button is released.          color:     Color to use for rectangle, default is !color.   xor_graphics:     If set, the sector outline is drawn and erased using xor                    graphics instead of a pixmap.         silent:     If set, messages are suppressed.         sample:     Grid sampling, default is 1.     OUTPUT:        button:     Code of the detected button.    RETURN:       POINT containing points on the sector outline.  The point       spacing is determined by the sample keyword.   KNOWN BUGS: 	The sector flips when it hits zero azimuth rather than retaining a 	consistent sense.    ORIGINAL AUTHOR : J. Spitale ; 6/2005   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_ring_sector_box.html#pg_ring_sector_box", "pg_ring_sector_box", 'routine in <a href="nv/com/pg/pg_ring_sector_box.html">pg_ring_sector_box.pro</a>', "pg_ring_sector_box.pro", "", "pg_ring_sector_box", "", "samplewin_numrestorebuttonp0xor_graphicscolorsilentp", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_ring_sector_box.html#test", "test", 'routine in <a href="nv/com/pg/pg_ring_sector_box.html">pg_ring_sector_box.pro</a>', "pg_ring_sector_box.pro", "", "test", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_ring_sector_box_oblique.html", "pg_ring_sector_box_oblique.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_ring_sector_box_oblique.pro", "", "", " NAME: 	pg_ring_sector_box_oblique   PURPOSE: 	Allows the user to select an oblique box to use with pg_profile_ring.   CATEGORY:        NV/PG   CALLING SEQUENCE:      outline_ptd=pg_ring_sector_box_oblique()      outline_ptd=pg_ring_sector_box_oblique(corners)    ARGUMENTS:   INPUT:       corners:	    Array of image points giving the four corners of the box. 		    If not given, the user is prompted to select a box.     OUTPUT: 	NONE     KEYWORDS:   INPUT:       win_num:     Window number of IDL graphics window in which to select                    box, default is current window.        restore:     Do not leave the box in the image.             p0:     First corner of box.  If set, then the routine immediately                    begins to drag from that point until a button is released.          color:     Color to use for rectangle, default is !color.          slope:     This keyword allows the longitude to vary from the                    perpendicular direction as a function of radius as:                    lon = slope*(rad - rad0).   xor_graphics:     If set, the sector outline is drawn and erased using xor                    graphics instead of a pixmap.      noverbose:     If set, messages are suppressed.         sample:     Grid sampling, default is 1.     OUTPUT:          NONE    RETURN:       POINT object containing points on the sector outline.  The point       spacing is determined by the sample keyword.  The POINT object       also contains the disk coordinate for each point and the user fields       'nrad' and 'nlon' giving the number of points in radius and longitude.   KNOWN BUGS: 	The sector flips when it hits zero azimuth rather than retaining a 	consistent sense.    ORIGINAL AUTHOR : J. Spitale ; 9/2006   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_ring_sector_box_oblique.html#pg_ring_sector_box_oblique", "pg_ring_sector_box_oblique", 'routine in <a href="nv/com/pg/pg_ring_sector_box_oblique.html">pg_ring_sector_box_oblique.pro</a>', "pg_ring_sector_box_oblique.pro", "", "pg_ring_sector_box_oblique", "", "lonsamplewin_numrestorep0xor_graphicscolornoverbosep", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_ring_sector_box_oblique.html#test", "test", 'routine in <a href="nv/com/pg/pg_ring_sector_box_oblique.html">pg_ring_sector_box_oblique.pro</a>', "pg_ring_sector_box_oblique.pro", "", "test", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_ring_sector_box_ortho.html", "pg_ring_sector_box_ortho.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_ring_sector_box_ortho.pro", "", "", " NAME: 	pg_ring_sector_box_ortho   PURPOSE: 	Allows the user to select a box to use with pg_profile_ring.   CATEGORY:        NV/PG   CALLING SEQUENCE:      outline_ptd = pg_ring_sector_box_ortho()      outline_ptd = pg_ring_sector_box_ortho(corners)    ARGUMENTS:   INPUT:       corners:	    Array of image points giving the corners of the box. 		    If not given, the user is prompted to select a box.    OUTPUT: 	NONE     KEYWORDS:   INPUT:       win_num:     Window number of IDL graphics window in which to select                    box, default is current window.        restore:     Do not leave the box in the image.             p0:     First corner of box.  If set, then the routine immediately                    begins to drag from that point until a button is released.          color:     Color to use for rectangle, default is !color.   xor_graphics:     If set, the sector outline is drawn and erased using xor                    graphics instead of a pixmap.         silent:     If set, messages are suppressed.         sample:     Grid sampling, default is 1.     OUTPUT:          NONE    RETURN:       POINT containing points on the sector outline.  The point       spacing is determined by the sample keyword.   KNOWN BUGS: 	The sector flips when it hits zero azimuth rather than retaining a 	consistent sense.    ORIGINAL AUTHOR : J. Spitale ; 6/2005   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_ring_sector_box_ortho.html#pg_ring_sector_box_ortho", "pg_ring_sector_box_ortho", 'routine in <a href="nv/com/pg/pg_ring_sector_box_ortho.html">pg_ring_sector_box_ortho.pro</a>', "pg_ring_sector_box_ortho.pro", "", "pg_ring_sector_box_ortho", "", "samplewin_numrestorep0xor_graphicscolorsilentp", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_ring_sector_box_ortho.html#test", "test", 'routine in <a href="nv/com/pg/pg_ring_sector_box_ortho.html">pg_ring_sector_box_ortho.pro</a>', "pg_ring_sector_box_ortho.pro", "", "test", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_ring_sector_oblique.html", "pg_ring_sector_oblique.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_ring_sector_oblique.pro", "", "", " NAME: 	pg_ring_sector_oblique   PURPOSE: 	Allows the user to select a ring sector by clicking and dragging. 	The top and bottom of the sector are defined along lines of constant 	radius, while the sides are perpendicular to the image-projected 	radial direction.   CATEGORY:        NV/PG   CALLING SEQUENCE:      outline_ptd=pg_ring_sector_oblique(cd=cd, dkx=dkx)    ARGUMENTS:   INPUT:       NONE    OUTPUT: 	NONE     KEYWORDS:   INPUT:            cd:     Camera descriptor.  	   dkx:     Disk descriptor describing the ring.             gd:     Generic descriptor containnig the above descriptors.        win_num:     Window number of IDL graphics window in which to select                    box, default is current window.        restore:     Do not leave the box in the image.             p0:     First corner of box.  If set, then the routine immediately                    begins to drag from that point until a button is released.          color:     Color to use for rectangle, default is !color.          slope:     This keyword allows the longitude to vary from the                    perpendicular direction as a function of radius as:                    lon = slope*(rad - rad0).   xor_graphics:     If set, the sector outline is drawn and erased using xor                    graphics instead of a pixmap.         silent:     If set, messages are suppressed.         sample:     Grid sampling, default is 1.          nodsk:     If set, image points will not be included in the output                    POINT.    OUTPUT:          NONE    RETURN:       POINT containing points on the sector outline.  The point       spacing is determined by the sample keyword.  The POINT object       also contains the disk coordinate for each point and the user fields       'nrad' and 'nlon' giving the number of points in radius and longitude.   KNOWN BUGS: 	The sector flips when it hits zero azimuth rather than retaining a 	consistent sense.    ORIGINAL AUTHOR : J. Spitale ; 5/2005   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_ring_sector_oblique.html#pg_ring_sector_oblique", "pg_ring_sector_oblique", 'routine in <a href="nv/com/pg/pg_ring_sector_oblique.html">pg_ring_sector_oblique.pro</a>', "pg_ring_sector_oblique.pro", "", "pg_ring_sector_oblique", "", "cddkxgdlonsamplewin_numrestoreslopep0xor_graphicscolorsilentnodsk", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_ring_sector_perp.html", "pg_ring_sector_perp.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_ring_sector_perp.pro", "", "", " NAME: 	pg_ring_sector_perp   PURPOSE: 	Allows the user to select a ring sector by clicking and dragging. 	The top and bottom of the sector are defined along lines of constant 	radius, while the sides are perpendicular to the image-projected 	radial direction.   CATEGORY:        NV/PG   CALLING SEQUENCE:      outline_ptd=pg_ring_sector_perp(cd=cd, dkx=dkx)    ARGUMENTS:   INPUT:             p:     Corners of the sector.  If not given, the user selects                    them by hand.    OUTPUT: 	NONE     KEYWORDS:   INPUT:            cd:     Camera descriptor.  	   dkx:     Disk descriptor describing the ring.             gd:     Generic descriptor containnig the above descriptors.        win_num:     Window number of IDL graphics window in which to select                    box, default is current window.        restore:     Do not leave the box in the image.             p0:     First corner of box.  If set, then the routine immediately                    begins to drag from that point until a button is released.          color:     Color to use for rectangle, default is !color.         sample:     Sets the grid sampling in pixels.  Default is one.          slope:     This keyword allows the longitude to vary from the                    perpendicular direction as a function of radius as:                    lon = slope*(rad - rad0).   xor_graphics:     If set, the sector outline is drawn and erased using xor                    graphics instead of a pixmap.          nodsk:     If set, image points will not be included in the output                    POINT.         silent:     If set, messages are suppressed.     OUTPUT:          NONE    RETURN:       POINT containing points on the sector outline.  The point       spacing is determined by the sample keyword.  The POINT object       also contains the disk coordinate for each point and the user fields       'nrad' and 'nlon' giving the number of points in radius and longitude.   KNOWN BUGS: 	The sector flips when it hits zero azimuth rather than retaining a 	consistent sense.    ORIGINAL AUTHOR : J. Spitale ; 5/2005   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_ring_sector_perp.html#pg_ring_sector_perp", "pg_ring_sector_perp", 'routine in <a href="nv/com/pg/pg_ring_sector_perp.html">pg_ring_sector_perp.pro</a>', "pg_ring_sector_perp.pro", "", "pg_ring_sector_perp", "", "cddkxgdlonsamplewin_numrestoreslopep0xor_graphicscolorsilentnodskp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_ring_sector_rad.html", "pg_ring_sector_rad.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_ring_sector_rad.pro", "", "", " NAME: 	pg_ring_sector_rad   PURPOSE: 	Allows the user to select a ring sector by clicking and dragging. 	The sector is defined along lines of constant radius and longitude.   CATEGORY:        NV/PG   CALLING SEQUENCE:      outline_ptd=pg_ring_sector_rad(cd=cd, dkx=dkx)    ARGUMENTS:   INPUT:       NONE    OUTPUT: 	NONE     KEYWORDS:   INPUT:            cd:     Camera descriptor.  	   dkx:     Disk descriptor describing the ring.             gd:     Generic descriptor containing the above descriptors.        win_num:     Window number of IDL graphics window in which to select                    box, default is current window.        restore:     Do not leave the box in the image.             p0:     First corner of box.  If set, then the routine immediately                    begins to drag from that point until a button is released.          color:     Color to use for rectangle, default is !color.         sample:     Sets the grid sampling in pixels.  Default is one.          slope:     This keyword allows the longitude to vary as a function                    of radius as: lon = slope*(rad - rad0).   xor_graphics:     If set, the sector outline is drawn and erased using xor                    graphics instead of a pixmap.         silent:     If set, messages are suppressed.          nodsk:     If set, image points will not be included in the output                    POINT.     OUTPUT:          NONE    RETURN:       POINT containing points on the sector outline.  The point       spacing is determined by the sample keyword.  The POINT object       also contains the disk coordinate for each point and the user fields       'nrad' and 'nlon' giving the number of points in radius and longitude.   KNOWN BUGS: 	The sector flips when it hits zero azimuth rather than retaining a 	consistent sense.    ORIGINAL AUTHOR : pg_ring_sector -- J. Spitale ; 8/94  Modified: Haemmerle, 6/98  renamed -- Spitale; 5/2005   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_ring_sector_rad.html#pg_ring_sector_rad", "pg_ring_sector_rad", 'routine in <a href="nv/com/pg/pg_ring_sector_rad.html">pg_ring_sector_rad.pro</a>', "pg_ring_sector_rad.pro", "", "pg_ring_sector_rad", "", "cddkxgdlonsamplewin_numrestoreslopep0xor_graphicscolorsilentnodsk", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_ring_sector_radlon.html", "pg_ring_sector_radlon.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_ring_sector_radlon.pro", "", "", " NAME: 	pg_ring_sector_radlon   PURPOSE: 	Constructs a ring sector outline for use with pg_profile_ring given 	radius and longitude bounds.   CATEGORY:        NV/PG   CALLING SEQUENCE:      outline_ptd = pg_ring_sector_radlon(cd=cd, dkx=dkx, rad, lon)    ARGUMENTS:   INPUT:       rad:	2-element array giving the lower and upper radial bounds 		for the sector.        lon:	2-elements array giving the lower and upper longitude bounds 		for the sector in radians.    OUTPUT: 	NONE     KEYWORDS:   INPUT:            cd:     Camera descriptor.  	   dkx:     Disk descriptor describing the ring.             gd:     Generic descriptor containnig the above descriptors.         sample:     Sets the grid sampling in pixels.  Default is one.           nlon:     Total number of samples in the longitude direction.                    Determined by the 'sample' keyword by default.           nrad:     Total number of samples in the radial direction.                    Determined by the 'sample' keyword by default.          slope:     This keyword allows the longitude to vary as a function                    of radius as: lon = slope*(rad - rad0).          nodsk:     If set, image points will not be included in the output                    POINT.    OUTPUT:          NONE    RETURN:       POINT containing points on the sector outline.  The point       spacing is determined by the sample keyword.  The POINT object       also contains the disk coordinate for each point and the user fields       'nrad' and 'nlon' giving the number of points in radius and longitude.   KNOWN BUGS: 	The sector flips when it hits zero azimuth rather than retaining a 	consistent sense.    ORIGINAL AUTHOR : 	Spitale; 5/2005   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_ring_sector_radlon.html#pg_ring_sector_radlon", "pg_ring_sector_radlon", 'routine in <a href="nv/com/pg/pg_ring_sector_radlon.html">pg_ring_sector_radlon.pro</a>', "pg_ring_sector_radlon.pro", "", "pg_ring_sector_radlon", "", "cddkxgdsampleslopenodsknlonnradradlon", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_rm_points.html", "pg_rm_points.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_rm_points.pro", "", "", " NAME: 	pg_rm_points    PURPOSE: 	xx    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = xx(xx, xx) 	xx, xx, xx    ARGUMENTS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    KEYWORDS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    ENVIRONMENT VARIABLES: 	xx:	xx  	xx:	xx    RETURN: 	xx    COMMON BLOCKS: 	xx:	xx  	xx:	xx    SIDE EFFECTS: 	xx    RESTRICTIONS: 	xx    PROCEDURE: 	xx    EXAMPLE: 	xx    STATUS: 	xx    SEE ALSO: 	xx, xx, xx    MODIFICATION HISTORY:  	Written by:	xx, xx/xx/xxxx   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_rm_points.html#pg_rm_points", "pg_rm_points", 'routine in <a href="nv/com/pg/pg_rm_points.html">pg_rm_points.pro</a>', "pg_rm_points.pro", "", "pg_rm_points", "", "radiusptdxptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_select.html", "pg_select.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_select.pro", "", "", " NAME: 	pg_select    PURPOSE: 	Allows the user to select objects in an image using the mouse.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	region = pg_select(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor containing the image.    OUTPUT: NONE    KEYWORDS:   INPUT: 	silent: 	If set, turns off the notification that cursor 			movement is required.  	psym: 		Plotting symbol to use for plotting points.  	one:		If set, the routine will exit after selecting one point.  	number:		If set, points will be labeled with numbers.  	region:		If set, the user selects a region in the image. 			This is the default.  	points:		If set, the user selects points.    OUTPUT: 	cancelled:	Set if routine is caused to return by the cancel button.    RETURN: 	Array of subscripts of all image points which lie within the selected 	region.    STATUS: 	Complete    SEE ALSO: 	pg_trim    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_select.html#pg_select", "pg_select", 'routine in <a href="nv/com/pg/pg_select.html">pg_select.pro</a>', "pg_select.pro", "", "pg_select", "", "silentregionpointsdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_select_bodies.html", "pg_select_bodies.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_select_bodies.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_select_bodies.html#pg_select_bodies", "pg_select_bodies", 'routine in <a href="nv/com/pg/pg_select_bodies.html">pg_select_bodies.pro</a>', "pg_select_bodies.pro", "", "pg_select_bodies", "", "odddbxselect", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_select_points.html", "pg_select_points.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_select_points.pro", "", "", " NAME: 	pg_select_points    PURPOSE: 	Allows the user to select points in an image using the mouse.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	region = pg_select_points(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor containing the image.    OUTPUT: NONE    KEYWORDS:   INPUT: 	noverbose: 	If set, turns off the notification that cursor 			movement is required.  	psym: 		Plotting symbol to use for the points.  	one:		If set, the routine will exit after selecting one point.  	number:		If set, each point will be labeled with a number.  	color:		Color to use for graphics overlays.  	ptd_output:	If set, a POINT object is returned instead 			of a points array.  	p0:		Initial point, instead of user selection.    OUTPUT: 	cancelled:	Set if routine is caused to return by the cancel button.    RETURN: 	Array of image points (2,n).    EXAMPLE:    To print the coordinates of each point as the user selects them, use:     can=0 & while(NOT can) do print, pg_select_points(dd, /one, /nov, can=can)    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 9/2001   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_select_points.html#pg_select_points", "pg_select_points", 'routine in <a href="nv/com/pg/pg_select_points.html">pg_select_points.pro</a>', "pg_select_points.pro", "", "pg_select_points", "", "psymnoverbosecolorp0onenumbercancelledptd_outputdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_select_region.html", "pg_select_region.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_select_region.pro", "", "", " NAME: 	pg_select_region    PURPOSE: 	Allows the user to select regions in an image using the mouse.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	region = pg_select_region(dd)    ARGUMENTS:   INPUT: 	dd:	Data descriptor containing an image.    OUTPUT: NONE    KEYWORDS:   INPUT: 	silent: 	If set, turns off the notification that cursor 			movement is required.  	color:		Color to use for graphics overlays.   	p0:		First point of line.  If set, then the routine 			immediately begins to drag from that point until a 			button is released.  	select_button:	Index of button to use as the select button instead 			of the left button (1).  	end_button:	Index of button to use as the end button instead 			of the right button (4).  	cancel_button:	Index of mouse button to be used as a cancel 			button instead of left+middle, (3).  	points:		If set, the selected points are returned instead 			of enclosed indices.  	autoclose:	If set, the region is automaticaly closed when the 			end button is pressed.  	box:		If set, a rectanguar region is selected.     OUTPUT: NONE    RETURN: 	Array of subscripts of all image points which lie within the selected 	region.  -1 is returned if the cancel button is pressed.    STATUS: 	Complete    SEE ALSO: 	pg_trim    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_select_region.html#pg_select_region", "pg_select_region", 'routine in <a href="nv/com/pg/pg_select_region.html">pg_select_region.pro</a>', "pg_select_region.pro", "", "pg_select_region", "", "colorselect_buttoncancel_buttonend_buttonsilentp0autoclosepointsnoclosedataboximage_ptsdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_shadow.html", "pg_shadow.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_shadow.pro", "", "", " NAME: 	pg_shadow    PURPOSE: 	Computes image coordinates of given inertial vectors projected onto 	surface of the given disks and globes with respect to the given 	observer.  Returns only the closest shadow point for each objoect 	point.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_shadow, object_ptd, cd=cd, ods=ods, dkx=dkx, gbx=gbx    ARGUMENTS:   INPUT: 	object_ptd:	Array of POINT containing inertial vectors.    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd:	Array (n_timesteps) of camera descriptors.  	gbx:	Array (n_globes, n_timesteps) of descriptors of objects 		which must be a subclass of GLOBE.  	dkx:	Array (n_disks, n_timesteps) of descriptors of objects 		which must be a subclass of DISK.  	bx:	Array (n_disks, n_timesteps) of descriptors of objects 		which must be a subclass of BODY.  	od:	Array (n_timesteps) of descriptors of objects 		which must be a subclass of BODY.  These objects are used 		as the source from which points are projected.  If no observer 		descriptor is given, then the sun descriptor in gd is used. 		Only one observer is allowed.  	gd:	Generic descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.  	dd:	Data descriptor containing a generic descriptor to use 		if gd not given.  	  All other keywords are passed directly to pg_shadow_globe 	  and pg_shadow_disk and are documented with those programs.    OUTPUT: NONE    RETURN: 	Array (n_disks,n_objects) of POINT containing image 	points and the corresponding inertial vectors.    STATUS: 	Soon to be replaced by a new program that merges pg_shadow_globe and 	pg_shadow_disk.  The API for the new routine may be slightly different.    SEE ALSO: 	pg_shadow_disk, pg_shadow_globe, pg_shadow_points    MODIFICATION HISTORY:  	Written by:	Spitale, 1/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_shadow.html#pg_shadow", "pg_shadow", 'routine in <a href="nv/com/pg/pg_shadow.html">pg_shadow.pro</a>', "pg_shadow.pro", "", "pg_shadow", "", "cdoddkxgbxbxddgdrevealclipnocullallbothbackshadowepsilonnosolveobject_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_shadow_disk.html", "pg_shadow_disk.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_shadow_disk.pro", "", "", " NAME: 	pg_shadow_disk    PURPOSE: 	Computes image coordinates of given inertial vectors projected onto 	surface of the given disk with respect to the given observer.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_shadow_disk(object_ptd, cd=cd, ods=ods, dkx=dkx)    ARGUMENTS:   INPUT: 	object_ptd:	Array of POINT containing inertial vectors.    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd:	Array (n_timesteps) of camera descriptors.  	dkx:	Array (n_disks, n_timesteps) of descriptors of objects 		which must be a subclass of DISK.  	od:	Array (n_timesteps) of descriptors of objects 		which must be a subclass of BODY.  These objects are used 		as the source from which points are projected.  If no observer 		descriptor is given, then the sun descriptor in gd is used. 		Only one observer is allowed.  	gd:	Generic descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.  	dd:	Data descriptor containing a generic descriptor to use 		if gd not given.  	reveal:	 Normally, disks whose opaque flag is set are ignored. 		 /reveal suppresses this behavior.  	clip:	 If set shadow points are cropped to within this many camera 		 fields of view.  	cull:	 If set, POINT objects excluded by the clip keyword 		 are not returned.  Normally, empty POINT objects 		 are returned as placeholders.     backshadow:	 If set, only backshadows (shadows cast between the object and  		 observer) are returned.  	both:	 If set, both shadows and backshadows are returned.  	all:	 If set, all points are returned, even if invalid.  	epsilon: If set, shadow points that are closer than this amount 		 to the source point will be excluded.    OUTPUT: NONE    RETURN: 	Array (n_disks,n_objects) of POINT containing image 	points and the corresponding inertial vectors.    STATUS: 	Soon to be obsolete.  This program will be merged with pg_shadow_globe 	to make a more general program, which will replace pg_shadow.    SEE ALSO: 	pg_shadow, pg_shadow_globe, pg_shadow_points    MODIFICATION HISTORY:  	Written by:	Spitale, 1/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_shadow_disk.html#pg_shadow_disk", "pg_shadow_disk", 'routine in <a href="nv/com/pg/pg_shadow_disk.html">pg_shadow_disk.pro</a>', "pg_shadow_disk.pro", "", "pg_shadow_disk", "", "cdoddkxgbxddgdnocullbothrevealclipcullbackshadowallepsilonobject_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_shadow_globe.html", "pg_shadow_globe.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_shadow_globe.pro", "", "", " NAME: 	pg_shadow_globe    PURPOSE: 	Computes image coordinates of the given inertial vectors projected onto 	surface of the given globe with respect to the given observer.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_shadow_globe(object_ptd, cd=cd, od=od, gbx=gbx)    ARGUMENTS:   INPUT: 	object_ptd:	Array of POINT containing inertial vectors.    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd:	Array (n_timesteps) of camera descriptors.  	gbx:	Array (n_globes, n_timesteps) of descriptors of objects 		which must be a subclass of GLOBE.  	od:	Array (n_timesteps) of descriptors of objects 		which must be a subclass of BODY.  These objects are used 		as the source from which points are projected.  If no observer 		descriptor is given, then the sun descriptor in gd is used. 		Only one observer is allowed.  	gd:	Generic descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.  	dd:	Data descriptor containing a generic descriptor to use 		if gd not given.  	reveal:	 Normally, disks whose opaque flag is set are ignored. 		 /reveal suppresses this behavior.  	clip:	 If set shadow points are cropped to within this many camera 		 fields of view.  	cull:	 If set, POINT objects excluded by the clip keyword 		 are not returned.  Normally, empty POINT objects 		 are returned as placeholders.     backshadow:	 If set, only backshadows (shadows cast between the object and  		 observer) are returned.  	both:	 If set, both shadows and backshadows are returned.  	all:	 If set, all points are returned, even if invalid.  	epsilon: If set, shadow points that are closer than this amount 		 to the source point will be excluded.  	nosolve: If set, shadow points are not computed.    OUTPUT: NONE    RETURN: 	Array (n_globes,n_objects) of POINT containing image 	points and the corresponding inertial vectors.    STATUS: 	Soon to be obsolete.  This program will be merged with pg_shadow_disk 	to make a more general program, which will replace pg_shadow.    SEE ALSO: 	pg_shadow, pg_shadow_disk, pg_shadow_points    MODIFICATION HISTORY:  	Written by:	Spitale, 1/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_shadow_globe.html#pg_shadow_globe", "pg_shadow_globe", 'routine in <a href="nv/com/pg/pg_shadow_globe.html">pg_shadow_globe.pro</a>', "pg_shadow_globe.pro", "", "pg_shadow_globe", "", "cdodgbxddgdnocullbothrevealclipcullbackshadowallepsilonnosolveobject_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_shadow_points.html", "pg_shadow_points.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_shadow_points.pro", "", "", " NAME: 	pg_shadow_points    PURPOSE: 	Determines whether each given point is shadowed by the given object.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_shadow_points, object_ptd, cd=cd, od=od, bx=bx    ARGUMENTS:   INPUT: 	object_ptd:	Array of POINT containing inertial vectors 			to shadow.    OUTPUT: 	shadow_ptd:	Array of POINT containing the shadowed 			points.    KEYWORDS:   INPUT: 	cd:	Array (n_timesteps) of camera descriptors.  	bx:	Array (nbx, n_timesteps) of descriptors of objects 		which must be a subclass of BODY describing the shadowing 		bodies.  	od:	Array (n_timesteps) of descriptors of objects 		which must be a subclass of BODY.  These objects are used 		as the source from which points are projected.  If no observer 		descriptor is given, then the sun descriptor in gd is used. 		Only one observer is allowed.  	gd:	Generic descriptor.  If given, the cd and bx inputs 		are taken from the corresponding fields of this structure 		instead of from those keywords.  	clip:	 If set shadow points are cropped to within this many camera 		 fields of view.  	cull:	 If set, POINT objects excluded by the clip keyword 		 are not returned.  Normally, empty POINT objects 		 are returned as placeholders.     backshadow:	 If set, only backshadows (shadows cast between the object and  		 observer) are considered.  	both:	 If set, both shadows and backshadows are returned.  	edge:	 If set, only points near the edge of the shadow are returned.    OUTPUT: NONE    RETURN: NONE    SIDE EFFECTS: 	Shadowed points are flagged as invisible.    STATUS:     SEE ALSO: 	pg_shadow, pg_shadow_globe, pg_shadow_disk    MODIFICATION HISTORY:  	Written by:	Spitale, 9/2012   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_shadow_points.html#pg_shadow_points", "pg_shadow_points", 'routine in <a href="nv/com/pg/pg_shadow_points.html">pg_shadow_points.pro</a>', "pg_shadow_points.pro", "", "pg_shadow_points", "", "cdodbxgdnoculledgenosolveclipcullbothbackshadowobject_ptdshadow_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_shift.html", "pg_shift.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_shift.pro", "", "", " NAME: 	pg_shift    PURPOSE: 	Shifts the given image by a non-integer offset and adjusts the camera 	pointing accordingly.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_shift, dd, cd=cd, dxy    ARGUMENTS:   INPUT: 	dd:	Array of data descriptors giving images to shift.    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd:	Array of camera descripors, one for each input image.  	dxy:	Array (2,np) of shifts for each input image.  	gd:	Generic descriptor containing the camera and body 		descriptors or an array of generic descriptors, one for each 		input image.     OUTPUT: NONE    SIDE EFFECTS: 	The given data and camera descriptors are modified: the images are 	shifted and the camera descriptor optic axes are changed accordingly.    STATUS: 	xx    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2008   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_shift.html#pg_shift", "pg_shift", 'routine in <a href="nv/com/pg/pg_shift.html">pg_shift.pro</a>', "pg_shift.pro", "", "pg_shift", "", "cdgddddxy", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_spikes.html", "pg_spikes.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_spikes.pro", "", "", " NAME: 	pg_spikes    PURPOSE: 	Locates spurious features like cosmic-ray hits.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_spikes(dd)    ARGUMENTS:   INPUT: 	dd:		Data descriptor containing the image to be despiked.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	nsig:		Number of standard deviations above the local 			mean data value to flag for removal.  Default is 2.  	grad:		Minimum data value gradient to use when searching 			for clusters of hot pixels.  Default is 5.  	umask:		Byte image of the same size as the input image 			in which nonzero pixel values indicate locations 			where spikes should not be flagged.  	extend:		Number of pixels away from masked pixels before 			locations may be flagged as spikes.  	scale:		Typical size of objects to be flagged.  Default is 10.  	edge:		Regions closer than this to the edge of the image 			will be ignored.  Default is 10.  	local:		Multiplier that determines the width of the region 			over which the local mean and standard deviation are 			taken.  That width is local * scale.  Default is 5.  	allpix:		If set, all pixels in the spike region are returned 			instead of of the centroids.    OUTPUT: 	NONE    RETURN: 	POINT containing the detected spike points.    PROCEDURE:  	Clusters of hot pixels of size 'scale' are identified by looking 	for regions bounded by large gradients.  Each cluster is then 	examined for pixels whose values are larger than nsig standard 	deviations above the local mean.    STATUS: 	Complete    SEE ALSO: 	pg_despike, pg_mask    EXAMPLE: 	dd = dat_read(filename) 	spike_ptd = pg_spikes(dd) 	dd1 = pg_despike(dd, spike_ptd)    MODIFICATION HISTORY:  	Written by:	Spitale, 4/2005   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_spikes.html#pg_spikes", "pg_spikes", 'routine in <a href="nv/com/pg/pg_spikes.html">pg_spikes.pro</a>', "pg_spikes.pro", "", "pg_spikes", "", "nsiggradmaskumaskextendscaleedgelocalnohotallpixdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_station.html", "pg_station.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_station.pro", "", "", " NAME: 	pg_station    PURPOSE: 	Computes image points for given station descriptors.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	station_ptd = pg_station(gd=gd)    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd:	Array (n_timesteps) of camera descriptors.  	std:	Array (n_objects, n_timesteps) of descriptors of objects 		that must be a subclass of STATION.  	gbx:	Array (n_xd, n_timesteps) of descriptors of objects 		that must be a subclass of GLOBE.  	dkx:	Array (n_xd, n_timesteps) of descriptors of objects 		that must be a subclass of DISK.  	bx:	Array (n_xd, n_timesteps) of descriptors of objects 		that must be a subclass of BODY, instead of gbx or dkx.  	gd:	Generic descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.  	dd:	Data descriptor containing a generic descriptor to use 		if gd not given.  	clip:	 If set points are computed only within this many camera 		 fields of view.  	cull:	 If set, POINT objects excluded by the clip keyword 		 are not returned.  Normally, empty POINT objects 		 are returned as placeholders.     OUTPUT: NONE    RETURN: 	Array (n_objects) of POINT containing image points and 	the corresponding inertial vectors.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 10/2012   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_station.html#pg_station", "pg_station", 'routine in <a href="nv/com/pg/pg_station.html">pg_station.pro</a>', "pg_station.pro", "", "pg_station", "", "cdstdgbxdkxbxddgdclipcull", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_stereo_split.html", "pg_stereo_split.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_stereo_split.pro", "", "", " NAME: 	pg_stereo_split    PURPOSE: 	Produces two camera descriptors whose positions are offset 	in the +/-x image directions for computing stereo overlays.     CATEGORY: 	NV/PG    CALLING SEQUENCE: 	cds = pg_stereo_split(cd=cd)    ARGUMENTS:   NONE    KEYWORDS:   INPUT: 	cd:		Camera descriptor to be split.  	separation:	stereo separation for the new camera descriptors.    OUTPUT: 	NONE    RETURN: 	Array containing two camera descriptors.    STATUS: 	xx    MODIFICATION HISTORY:  	Written by:	Spitale; 7/29/2005   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_stereo_split.html#pg_stereo_split", "pg_stereo_split", 'routine in <a href="nv/com/pg/pg_stereo_split.html">pg_stereo_split.pro</a>', "pg_stereo_split.pro", "", "pg_stereo_split", "", "cdseparation", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_str_limit_mag.html", "pg_str_limit_mag.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_str_limit_mag.pro", "", "", " NAME: 	pg_str_limit_mag    PURPOSE: 	Removes stars whose visual magnitude falls outside the given minimum 	and maximum values.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	result = pg_str_limit_mag(sd, max=max, min=min)    ARGUMENTS:   INPUT: 	sd:	Array of star descriptors.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	max:	Maximum visual magnitude.  	min:	Minimum visual magnitude.    OUTPUT: 	NONE    RETURN: 	Array of star descriptors whose visual magnitudes fall within the 	specified range.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Haemmerle, 1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_str_limit_mag.html#pg_str_limit_mag", "pg_str_limit_mag", 'routine in <a href="nv/com/pg/pg_str_limit_mag.html">pg_str_limit_mag.pro</a>', "pg_str_limit_mag.pro", "", "pg_str_limit_mag", "", "maxminsds", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_strip.html", "pg_strip.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_strip.pro", "", "", " NAME:        pg_strip    PURPOSE: 	Plots the portion of an image between two chosen points.    CATEGORY:        COM/PG    CALLING SEQUENCE:        pg_strip, im    ARGUMENTS:   INPUT:        im:		The two-dimensional array from which the 			plotted strip will be extracted.    OUTPUT:        NONE    KEYWORDS:   INPUT:        width:		An odd integer giving the width in pixels of the 			extracted strip (default=5).  This width is rebinned 			to a single pixel for plotting.  	nw:		When set, each plot is done in a new window.  	nomarks:	Suppresses the marks that show the locations of 			the chosen points, which are difficult to 			entirely erase.  	xs:		Specifies the x-dimension of the window, in pixels. 			Default is 400.  	ys:		Specifies the y-dimension of the window, in pixels. 			Default is 300.    OUTPUT:        NONE    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Tiscareno, 7/00   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_strip.html#pg_strip", "pg_strip", 'routine in <a href="nv/com/pg/pg_strip.html">pg_strip.pro</a>', "pg_strip.pro", "", "pg_strip", "", "widthnwnomarksdevicexsysim", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_sub_body.html", "pg_sub_body.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_sub_body.pro", "", "", " NAME: 	pg_sub_body    PURPOSE: 	Computes surface coordinates of sub-body point.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	range = pg_sub_body(gbx=gbx, bx=bx, gd=gd)    KEYWORD:   INPUT: 	gbx:	Array (n_objects, n_timesteps) of descriptors of objects 		which must be a subclass of GLOBE.  	bx:	Array (n_objects, n_timesteps) of descriptors of objects 		which must be a subclass of BODY.  	gd:	Generic descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.  	dd:	Data descriptor containing a generic descriptor to use 		if gd not given.    OUTPUT: NONE    RETURN: 	Array (n_objects,3) of surface coordinate vectors.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 11/2001   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_sub_body.html#pg_sub_body", "pg_sub_body", 'routine in <a href="nv/com/pg/pg_sub_body.html">pg_sub_body.pro</a>', "pg_sub_body.pro", "", "pg_sub_body", "", "gbxbxddgd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_threshold.html", "pg_threshold.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_threshold.pro", "", "", " NAME: 	pg_threshold    PURPOSE: 	Excludes points whose associated data lie outside of specified 	thresholds by setting the PTD_MASK_INVISIBLE.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_threshold, object_ptd, tag=tag, max=max, min=min    ARGUMENTS:   INPUT: 	object_ptd:	Array (n_objects) of POINT giving the 			points to be thresholded.    OUTPUT: 	object_ptd:	Modified array of POINT.  PTD_MASK_INVISIBLE 			is set for all excluded points.    KEYWORDS:   INPUT: 	tag:		Tag name for user data array to threshold.  Default 			is 'scan_cc'.  	max:		Upper threshold - values greater than this will be 			excluded.  	min:		Lower threshold - values less than this will be 			excluded.  	relative:	If set, the max and min arguments will be taken as 			fractions of the maximum value in the array.    OUTPUT: NONE    RETURN: NONE    SIDE EFFECTS: 	The input argument object_ptd is modified.    RESTRICTIONS: 	xx    PROCEDURE: 	The thresholding is performed by cc_threshold.  See the documentation 	for that routine for details.    EXAMPLE: 	xx    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 6/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_threshold.html#pg_threshold", "pg_threshold", 'routine in <a href="nv/com/pg/pg_threshold.html">pg_threshold.pro</a>', "pg_threshold.pro", "", "pg_threshold", "", "tagminmaxrelativescan_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_tiepoints.html", "pg_tiepoints.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_tiepoints.pro", "", "", " NAME:        pg_tiepoints    PURPOSE:        Computes tiepoint image offsets.    CATEGORY:        NV/PG    CALLING SEQUENCE:        tie_ptd = pg_tiepoints(cd=cd, bx=bx, body_pts=body_pts, ptd)    ARGUMENTS:   INPUT:    ptd:         POINT containing the image points.   KEYWORDS:   INPUT:          cd:	Camera descriptor.           bx:	Body descriptor; can be GLOBE or RING.          gbx:	Globe descriptor for each globe in image instead of 		specifying bx.          dkx:	Disk descriptor for each globe in image instead of 		specifying bx.  	  gd:	Generic descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.  	  dd:	Data descriptor containing a generic descriptor to use 		if gd not given.     body_pts:	Array of np column vectors giving the body-frame coordinates 		for each tie point.  If not given, then the given geometry 		is used to compute it.     OUTPUT:    body_pts: 	Array of np column vectors giving the body-frame coordinates 		for each tie point.  If this keyword is given as an input, 		then no output is generated.   EXAMPLE:   1) Manually select a set of tiepoints in a set of images and fit      a pointing offset:  	ndd = n_elements(dd) 	for i=0, ndd-1 do ptd[i] = pg_select_points(dd[i], /ptd)  	body_pts = 0 	for i=0, ndd-1 do $ 	 begin &$ 	  tie_ptd = pg_tiepoints(cd=cd[i], bx=pd[i], ptd[i], body_pts=body_pts) &$ 	  tpcoeff = pg_ptscan_coeff(tie_ptd, fix=[2]) &$ 	  dxy = pg_fit(tpcoeff) &$ 	  pg_repoint, dxy, 0d, cd=cd[i] &$ 	 end       In the above example, the first image is used as a reference;      because body_pts is initially undefined, those points are computed      for the first image, but not subsequently.  Instead, the subsequent      images will have a nonzero offset stored in the tie_ptd structure,      which are then used by pg_ptscan_coeff to compute fit coefficients.    STATUS:        Complete    MODIFICATION HISTORY:        Written by:     Spitale, 8/2006   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_tiepoints.html#pg_tiepoints", "pg_tiepoints", 'routine in <a href="nv/com/pg/pg_tiepoints.html">pg_tiepoints.pro</a>', "pg_tiepoints.pro", "", "pg_tiepoints", "", "cdbxgbxdkxddgdbody_ptsdxyptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/com/pg/pg_trim.html", "pg_trim.pro", '.pro file in <a href="nv/com/pg/dir-overview.html">nv/com/pg/ directory</a>', "pg_trim.pro", "", "", " NAME: 	pg_trim    PURPOSE: 	For each given object, excludes points contained in the given region 	by setting the PTD_MASK_INVISIBLE.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	pg_trim, dd, object_ptd, region    ARGUMENTS:   INPUT: 	dd:		Data descriptor containing the image.  	object_ptd:	Array (n_objects) of POINT containing the 			image points to be trimmed.  	region:		Array of subscripts of image points to be trimmed.    OUTPUT: 	object_ptd:	The input points are be modified on return.    KEYWORDS:   INPUT: 	mask:		Mask to use instead of PTD_MASK_INVISIBLE.  	off:		If set, the masked flag bit will be turned off.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	pg_select    MODIFICATION HISTORY:  	Written by:	Spitale, 2/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/com/pg/pg_trim.html#pg_trim", "pg_trim", 'routine in <a href="nv/com/pg/pg_trim.html">pg_trim.pro</a>', "pg_trim.pro", "", "pg_trim", "", "maskoffddobject_ptdregion", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/phase_correction.html", "phase_correction.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "phase_correction.pro", "", "", " NAME:        phase_correction    PURPOSE: 	Assuming body gbx is a sphere, this routine computes the correction 	in pixels needed to obtain its true image center given a measurement 	of its center of light.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        dxy = phase_correction(cd, gbx, sund)    ARGUMENTS:   INPUT: 	cd:	Any subclass of DISK.  	gbx:	Any subclass of GLOBE.  	sund:	STAR descriptor representing the sun.    OUTPUT:  NONE    KEYOWRDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (2) giving the phase correction offset.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/phase_correction.html#phase_correction", "phase_correction", 'routine in <a href="nv/obj/tools/phase_correction.html">phase_correction.pro</a>', "phase_correction.pro", "", "phase_correction", "", "cdgbxsund", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/pht/pht_angles.html", "pht_angles.pro", '.pro file in <a href="nv/obj/tools/pht/dir-overview.html">nv/obj/tools/pht/ directory</a>', "pht_angles.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/pht/pht_angles.html#pht_angles", "pht_angles", 'routine in <a href="nv/obj/tools/pht/pht_angles.html">pht_angles.pro</a>', "pht_angles.pro", "", "pht_angles", "", "inertialemmincgvalidbody_ptsnorthimage_ptscdbxsund", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/pht/pht_lamb.html", "pht_lamb.pro", '.pro file in <a href="nv/obj/tools/pht/dir-overview.html">nv/obj/tools/pht/ directory</a>', "pht_lamb.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/pht/pht_lamb.html#pht_lamb", "pht_lamb", 'routine in <a href="nv/obj/tools/pht/pht_lamb.html">pht_lamb.pro</a>', "pht_lamb.pro", "", "pht_lamb", "", "mumu0parm", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/pht/pht_lunar.html", "pht_lunar.pro", '.pro file in <a href="nv/obj/tools/pht/dir-overview.html">nv/obj/tools/pht/ directory</a>', "pht_lunar.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/pht/pht_lunar.html#pht_lunar", "pht_lunar", 'routine in <a href="nv/obj/tools/pht/pht_lunar.html">pht_lunar.pro</a>', "pht_lunar.pro", "", "pht_lunar", "", "mumu0parm", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/pht/pht_lunar_lambert.html", "pht_lunar_lambert.pro", '.pro file in <a href="nv/obj/tools/pht/dir-overview.html">nv/obj/tools/pht/ directory</a>', "pht_lunar_lambert.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/pht/pht_lunar_lambert.html#pht_lunar_lambert", "pht_lunar_lambert", 'routine in <a href="nv/obj/tools/pht/pht_lunar_lambert.html">pht_lunar_lambert.pro</a>', "pht_lunar_lambert.pro", "", "pht_lunar_lambert", "", "mumu0parm", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/pht/pht_minneart.html", "pht_minneart.pro", '.pro file in <a href="nv/obj/tools/pht/dir-overview.html">nv/obj/tools/pht/ directory</a>', "pht_minneart.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/pht/pht_minneart.html#pht_minneart", "pht_minneart", 'routine in <a href="nv/obj/tools/pht/pht_minneart.html">pht_minneart.pro</a>', "pht_minneart.pro", "", "pht_minneart", "", "mumu0parm", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/pht/pht_phase_corr.html", "pht_phase_corr.pro", '.pro file in <a href="nv/obj/tools/pht/dir-overview.html">nv/obj/tools/pht/ directory</a>', "pht_phase_corr.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/pht/pht_phase_corr.html#pht_phase_corr", "pht_phase_corr", 'routine in <a href="nv/obj/tools/pht/pht_phase_corr.html">pht_phase_corr.pro</a>', "pht_phase_corr.pro", "", "pht_phase_corr", "", "fnparmgg1", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/pht/pht_phase_henyey_greenstein.html", "pht_phase_henyey_greenstein.pro", '.pro file in <a href="nv/obj/tools/pht/dir-overview.html">nv/obj/tools/pht/ directory</a>', "pht_phase_henyey_greenstein.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/pht/pht_phase_henyey_greenstein.html#pht_phase_henyey_greenstein", "pht_phase_henyey_greenstein", 'routine in <a href="nv/obj/tools/pht/pht_phase_henyey_greenstein.html">pht_phase_henyey_greenstein.pro</a>', "pht_phase_henyey_greenstein.pro", "", "pht_phase_henyey_greenstein", "", "gparm", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/pht/pht_phase_isotropic.html", "pht_phase_isotropic.pro", '.pro file in <a href="nv/obj/tools/pht/dir-overview.html">nv/obj/tools/pht/ directory</a>', "pht_phase_isotropic.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/pht/pht_phase_isotropic.html#pht_phase_isotropic", "pht_phase_isotropic", 'routine in <a href="nv/obj/tools/pht/pht_phase_isotropic.html">pht_phase_isotropic.pro</a>', "pht_phase_isotropic.pro", "", "pht_phase_isotropic", "", "gparm", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/pht/pht_refl_corr.html", "pht_refl_corr.pro", '.pro file in <a href="nv/obj/tools/pht/dir-overview.html">nv/obj/tools/pht/ directory</a>', "pht_refl_corr.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/pht/pht_refl_corr.html#pht_refl_corr", "pht_refl_corr", 'routine in <a href="nv/obj/tools/pht/pht_refl_corr.html">pht_refl_corr.pro</a>', "pht_refl_corr.pro", "", "pht_refl_corr", "", "fnparmmumu0mu1mu01", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/pht/pht_refl_lunar.html", "pht_refl_lunar.pro", '.pro file in <a href="nv/obj/tools/pht/dir-overview.html">nv/obj/tools/pht/ directory</a>', "pht_refl_lunar.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/pht/pht_refl_lunar.html#pht_refl_lunar", "pht_refl_lunar", 'routine in <a href="nv/obj/tools/pht/pht_refl_lunar.html">pht_refl_lunar.pro</a>', "pht_refl_lunar.pro", "", "pht_refl_lunar", "", "mumu0parm", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/pht/pht_refl_lunar_lambert.html", "pht_refl_lunar_lambert.pro", '.pro file in <a href="nv/obj/tools/pht/dir-overview.html">nv/obj/tools/pht/ directory</a>', "pht_refl_lunar_lambert.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/pht/pht_refl_lunar_lambert.html#pht_refl_lunar_lambert", "pht_refl_lunar_lambert", 'routine in <a href="nv/obj/tools/pht/pht_refl_lunar_lambert.html">pht_refl_lunar_lambert.pro</a>', "pht_refl_lunar_lambert.pro", "", "pht_refl_lunar_lambert", "", "mumu0parm", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/pht/pht_refl_minneart.html", "pht_refl_minneart.pro", '.pro file in <a href="nv/obj/tools/pht/dir-overview.html">nv/obj/tools/pht/ directory</a>', "pht_refl_minneart.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/pht/pht_refl_minneart.html#pht_refl_minneart", "pht_refl_minneart", 'routine in <a href="nv/obj/tools/pht/pht_refl_minneart.html">pht_refl_minneart.pro</a>', "pht_refl_minneart.pro", "", "pht_refl_minneart", "", "mumu0parm", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/pickfiles.html", "pickfiles.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "pickfiles.pro", "", "", " NAME: 	xx    PURPOSE: 	xx    CATEGORY: 	UTIL    CALLING SEQUENCE: 	result = xx(xx, xx) 	xx, xx, xx    ARGUMENTS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    KEYWORDS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    ENVIRONMENT VARIABLES: 	xx:	xx  	xx:	xx    RETURN: 	xx    COMMON BLOCKS: 	xx:	xx  	xx:	xx    SIDE EFFECTS: 	xx    RESTRICTIONS: 	xx    PROCEDURE: 	xx    EXAMPLE: 	xx    STATUS: 	xx    SEE ALSO: 	xx, xx, xx    MODIFICATION HISTORY:  	Written by:	xx, xx/xx/xxxx   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/pickfiles.html#pf_ok_callback", "pf_ok_callback", 'routine in <a href="util/pickfiles.html">pickfiles.pro</a>', "pickfiles.pro", "", "pf_ok_callback", "", "_files_path", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/pickfiles.html#pickfiles_event", "pickfiles_event", 'routine in <a href="util/pickfiles.html">pickfiles.pro</a>', "pickfiles.pro", "", "pickfiles_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/pickfiles.html#pickfiles", "pickfiles", 'routine in <a href="util/pickfiles.html">pickfiles.pro</a>', "pickfiles.pro", "", "pickfiles", "", "get_pathpathtitleonefiltermust_existbutton_baseoptionsselected_optiondefaultfilename", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/pixel_grid.html", "pixel_grid.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "pixel_grid.pro", "", "", " NAME:        pixel_grid    PURPOSE: 	Generates grid lines aligned with the image window.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        grid_pts = pixel_grid()    ARGUMENTS:   INPUT: NONE    OUTPUT:  NONE    KEYOWRDS:   INPUT: 	spacing:	Distance in pixels between grid lines.  	np:	Number of points on each grid line.  	wnum:	Window number for determining grid size.  If not set, 		the current grapics window is used.    OUTPUT: NONE    RETURN:        Angle in radians.     MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/pixel_grid.html#pixel_grid", "pixel_grid", 'routine in <a href="nv/obj/tools/pixel_grid.html">pixel_grid.pro</a>', "pixel_grid.pro", "", "pixel_grid", "", "spacingnpwnum", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/planck_v.html", "planck_v.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "planck_v.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/planck_v.html#planck_v", "planck_v", 'routine in <a href="util/planck_v.html">planck_v.pro</a>', "planck_v.pro", "", "planck_v", "", "hckvT", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/plot_arrow.html", "plot_arrow.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "plot_arrow.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/plot_arrow.html#plot_arrow", "plot_arrow", 'routine in <a href="util/plot_arrow.html">plot_arrow.pro</a>', "plot_arrow.pro", "", "plot_arrow", "", "hsizeanglecolorlinestylethicklabellposloffsetlsizelrotdraw_wnumlcolorp0p1", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/plot_inertial.html", "plot_inertial.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "plot_inertial.pro", "", "", " NAME:        plot_inertial    PURPOSE:        Plots inertial vectors on a camera image.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        plot_inertial, cd, v, r    ARGUMENTS:   INPUT: 	cd:	Camera descriptor.  	v:	Inertial vectors giving origins of vectors to plot.  If only one 		vector, this will be used as the origin for all of the plotted 		vectors.  	r:	Inertial vectors giving the vectors to plot, starting at 		the given origins.    OUTPUT:        NONE   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale; 7/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/plot_inertial.html#plot_inertial", "plot_inertial", 'routine in <a href="nv/obj/tools/plot_inertial.html">plot_inertial.pro</a>', "plot_inertial.pro", "", "plot_inertial", "", "colorthicklabelscd_vr", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/plt/plt_assign.html", "plt_assign.pro", '.pro file in <a href="nv/obj/plt/dir-overview.html">nv/obj/plt/ directory</a>', "plt_assign.pro", "", "", " NAME: 	plt_assign    PURPOSE: 	Replaces fields in a PLANET object.  This is a convenient way of 	setting multiple fields in one call, and only a single event is 	generated.    CATEGORY: 	NV/OBJ/PLT    CALLING SEQUENCE: 	plt_assign, pd, <keywords>=<values>    ARGUMENTS:   INPUT: 	pd:		PLANET object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	PLANET fields to set.  	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	plt_set_*     MODIFICATION HISTORY:  	Written by:	Spitale		2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/plt/plt_assign.html#plt_assign", "plt_assign", 'routine in <a href="nv/obj/plt/plt_assign.html">plt_assign.pro</a>', "plt_assign.pro", "", "plt_assign", "", "noeventxd@plt__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/plt/plt_create_descriptors.html", "plt_create_descriptors.pro", '.pro file in <a href="nv/obj/plt/dir-overview.html">nv/obj/plt/ directory</a>', "plt_create_descriptors.pro", "", "", " NAME:        plt_create_descriptors    PURPOSE: 	Init method for the PLANET class.    CATEGORY:        NV/LIB/PLT    CALLING SEQUENCE:        pd = plt_create_descriptors(n)    ARGUMENTS:   INPUT:        n:      Number of planet descriptors.    OUTPUT:        NONE    KEYWORDS:   INPUT: 	pd:	Planet descriptor(s) to initialize, instead of creating new ones.  	gbd:	Globe descriptor(s) to pass to glb_create_descriptors.  	sld:	Solid descriptor(s) to pass to sld_create_descriptors.  	bd:	Body descriptor(s) to pass to bod_create_descriptors.  	crd:	Core descriptor(s) to pass to cor_create_descriptors.    OUTPUT: NONE   RETURN:        An array (n) of planet descriptors.   STATUS:        Completed.    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/plt/plt_create_descriptors.html#plt_create_descriptors", "plt_create_descriptors", 'routine in <a href="nv/obj/plt/plt_create_descriptors.html">plt_create_descriptors.pro</a>', "plt_create_descriptors.pro", "", "plt_create_descriptors", "", "crdbdsldgbdpdn@plt__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/plt/plt_evolve.html", "plt_evolve.pro", '.pro file in <a href="nv/obj/plt/dir-overview.html">nv/obj/plt/ directory</a>', "plt_evolve.pro", "", "", " NAME: 	plt_evolve    PURPOSE: 	Computes new planet descriptors at the given time offsets from the 	given planet descriptors using the taylor series expansion 	corresponding to the derivatives contained in the given planet 	descriptor.    CATEGORY: 	NV/LIB/PLT    CALLING SEQUENCE: 	pdt = plt_evolve(px, dt)    ARGUMENTS:   INPUT: 	px:	 Any subclass of PLANET.  	dt:	 Time offset.    OUTPUT: NONE    KEYWORDS:   INPUT: 	nodv:	 If set, derivatives will not be evolved.  	copy:	If set, the evolved descriptor is copied into the input 		descriptor and it is freed.  The input descriptor is returned.     OUTPUT: NONE    RETURN: 	Array (npd,ndt) of newly allocated descriptors, of class PLANET, 	evolved by time dt, where npd is the number of px, and ndt 	is the number of dt.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/plt/plt_evolve.html#plt_evolve", "plt_evolve", 'routine in <a href="nv/obj/plt/plt_evolve.html">plt_evolve.pro</a>', "plt_evolve.pro", "", "plt_evolve", "", "nodvcopypddt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/plt/plt_query.html", "plt_query.pro", '.pro file in <a href="nv/obj/plt/dir-overview.html">nv/obj/plt/ directory</a>', "plt_query.pro", "", "", " NAME: 	plt_query    PURPOSE: 	Returns the fields associated with a PLANET object.  This is a 	convenient way of getting multiple fields in one call, and only a 	single event is generated.    CATEGORY: 	NV/OBJ/PLT    CALLING SEQUENCE: 	plt_query, pd, <keywords>=<values>    ARGUMENTS:   INPUT: 	pd:	PLANET object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	PLANET object fields to set.  	condition:	Structure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT object, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.  	cat:		If set, arrays from mulitple input objets are 			concatenated.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.  	noevent:	If set, no event is generated.    OUTPUT: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/plt/plt_query.html#plt_query", "plt_query", 'routine in <a href="nv/obj/plt/plt_query.html">plt_query.pro</a>', "plt_query.pro", "", "plt_query", "", "conditioncatnoeventxd@plt__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/plt/plt_replicate.html", "plt_replicate.pro", '.pro file in <a href="nv/obj/plt/dir-overview.html">nv/obj/plt/ directory</a>', "plt_replicate.pro", "", "", " NAME: 	plt_replicate    PURPOSE: 	Replicates the given descriptor, producing an array of the given 	dimensions containing cloned versions of the input descriptor.    CATEGORY: 	NV/LIB/PLT    CALLING SEQUENCE: 	pds = plt_replicate(pd, dim)    ARGUMENTS:   INPUT: 	pd:	 Planet descriptor.  	dim:	 Dimensions of the result.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Array of the given dimensions containing cloned versions of the input 	descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/plt/plt_replicate.html#plt_replicate", "plt_replicate", 'routine in <a href="nv/obj/plt/plt_replicate.html">plt_replicate.pro</a>', "plt_replicate.pro", "", "plt_replicate", "", "pddim", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/png_close.html", "png_close.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "png_close.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/png_close.html#png_close", "png_close", 'routine in <a href="util/png_close.html">png_close.pro</a>', "png_close.pro", "", "png_close", "", "fname", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/png_image.html", "png_image.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "png_image.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/png_image.html#png_image", "png_image", 'routine in <a href="util/png_image.html">png_image.pro</a>', "png_image.pro", "", "png_image", "", "wnummonoquantizeorderfilename", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/png_open.html", "png_open.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "png_open.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/png_open.html#png_open", "png_open", 'routine in <a href="util/png_open.html">png_open.pro</a>', "png_open.pro", "", "png_open", "", "imxsizeysizezim", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/png_overlays.html", "png_overlays.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "png_overlays.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/png_overlays.html#png_overlays", "png_overlays", 'routine in <a href="util/png_overlays.html">png_overlays.pro</a>', "png_overlays.pro", "", "png_overlays", "", "fnameimsizeoverlay_prodata", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_apply_condition.html", "pnt_apply_condition.pro", '.pro file in <a href="nv/obj/pnt/dir-overview.html">nv/obj/pnt/ directory</a>', "pnt_apply_condition.pro", "", "", " NAME: 	pnt_apply_condition    PURPOSE: 	Selects point in POINT structures based on a given condition structure.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	indices = _pnt_apply_condition(_ps, condition)    ARGUMENTS:   INPUT: 	ptd:		Points object.  	condition:	Condition structure to compare against the flags 			contained in _ps.  			The condition structure is organized as follows: 			  field	   values 			  ----------------------------------------------------- 			  mask:	   PTD_MASK_INVISIBLE, etc. (see pnt_include.pro) 			  state:   PTD_TRUE, PTD_FALSE    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Condition structure corresponding to the given keyword.    STATUS: 	Complete    SEE ALSO: pnt_points, pnt_vectors, pnt_data    MODIFICATION HISTORY:   	Spitale, 11/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_apply_condition.html#pnt_apply_condition", "pnt_apply_condition", 'routine in <a href="nv/obj/pnt/pnt_apply_condition.html">pnt_apply_condition.pro</a>', "pnt_apply_condition.pro", "", "pnt_apply_condition", "", "ptdcondition", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_assign.html", "pnt_assign.pro", '.pro file in <a href="nv/obj/pnt/dir-overview.html">nv/obj/pnt/ directory</a>', "pnt_assign.pro", "", "", " NAME: 	pnt_assign    PURPOSE: 	Replaces fields in a POINT object.  This is a convenient way of 	setting multiple fields in one call, and only a single event is 	generated.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	pnt_assign, ptd, <keywords>=<values>    ARGUMENTS:   INPUT: 	ptd:		POINT object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	POINT fields to set.  	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	pnt_assign_*     MODIFICATION HISTORY:  	Written by:	Spitale		12/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_assign.html#pnt_assign", "pnt_assign", 'routine in <a href="nv/obj/pnt/pnt_assign.html">pnt_assign.pro</a>', "pnt_assign.pro", "", "pnt_assign", "", "noeventxd@pnt__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_assoc_xd.html", "pnt_assoc_xd.pro", '.pro file in <a href="nv/obj/pnt/dir-overview.html">nv/obj/pnt/ directory</a>', "pnt_assoc_xd.pro", "", "", " NAME: 	pnt_assoc_xd    PURPOSE: 	Returns the associated descriptor for a CORE object.    CATEGORY: 	NV/SYS/PNT    CALLING SEQUENCE: 	assoc_xd = pnt_assoc_xd(ptd)    ARGUMENTS:   INPUT: 	ptd:	POINT object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: 	The associated descriptor for the POINT object.    STATUS: 	Complete    SEE ALSO: 	pnt_set_assoc_xd     MODIFICATION HISTORY:  	Written by:	Spitale, 11/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_assoc_xd.html#pnt_assoc_xd", "pnt_assoc_xd", 'routine in <a href="nv/obj/pnt/pnt_assoc_xd.html">pnt_assoc_xd.pro</a>', "pnt_assoc_xd.pro", "", "pnt_assoc_xd", "", "noeventptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_compress.html", "pnt_compress.pro", '.pro file in <a href="nv/obj/pnt/dir-overview.html">nv/obj/pnt/ directory</a>', "pnt_compress.pro", "", "", " NAME: 	pnt_compress    PURPOSE: 	Compresses many POINT objects into one.  Arrays are concatenated 	in the nv/np directions unless /nt is specified.  Point-by-point data 	arrays must be identical.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	new_ptd = pnt_compress(ptd)    ARGUMENTS:   INPUT: 	ptd:	Array of POINT objects.    OUTPUT: NONE    KEYWORDS:   INPUT: 	nt:		If given, arrays are concatenated in the nt dimension. 			this requires that all input arrays have the same number 			of points (nv/np), and only one element in the nt 			direction.  	pptd:		If given, this points object is used to store the 			result, rather than allocating a new one.    OUTPUT: NONE    RETURN: 	POINT object containing the concatenated data.     MODIFICATION HISTORY:   Spitale, 11/2015; 	Adapted from pgs_compress   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_compress.html#pnt_compress", "pnt_compress", 'routine in <a href="nv/obj/pnt/pnt_compress.html">pnt_compress.pro</a>', "pnt_compress.pro", "", "pnt_compress", "", "ntpptdptd0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_condition.html", "pnt_condition.pro", '.pro file in <a href="nv/obj/pnt/dir-overview.html">nv/obj/pnt/ directory</a>', "pnt_condition.pro", "", "", " NAME: 	pnt_condition    PURPOSE: 	Returns predefined condition structures for various common situations.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	condition = pnt_condition(</visible | /invisible | /select|...>)    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: 	condition:	If a condition structure is given as in input, it 			is returned.     *** The following keywords are defined in pnt_condition_keywords.include ***  	visible:	Returns a condition structure corresponding to 			points whose visible flag is not set.  	invisible:	Returns a condition structure corresponding to 			points whose visible flag is set.  	selected:	Returns a condition structure corresponding to 			points whose select flag is set.  	unselected:	Returns a condition structure corresponding to 			points whose select flag is not set.    OUTPUT: NONE    RETURN: 	Condition structure corresponding to the given keyword.    STATUS: 	Complete    SEE ALSO: pnt_points, pnt_vectors, pnt_data    MODIFICATION HISTORY:   	Spitale, 11/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_condition.html#pnt_condition_set", "pnt_condition_set", 'routine in <a href="nv/obj/pnt/pnt_condition.html">pnt_condition.pro</a>', "pnt_condition.pro", "", "pnt_condition_set", "", "statemaskflag", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_condition.html#pnt_condition_unset", "pnt_condition_unset", 'routine in <a href="nv/obj/pnt/pnt_condition.html">pnt_condition.pro</a>', "pnt_condition.pro", "", "pnt_condition_unset", "", "statemaskflag", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_condition.html#pnt_condition", "pnt_condition", 'routine in <a href="nv/obj/pnt/pnt_condition.html">pnt_condition.pro</a>', "pnt_condition.pro", "", "pnt_condition", "", "condition@pnt_condition_keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_create_descriptors.html", "pnt_create_descriptors.pro", '.pro file in <a href="nv/obj/pnt/dir-overview.html">nv/obj/pnt/ directory</a>', "pnt_create_descriptors.pro", "", "", " NAME: 	pnt_create_descriptors    PURPOSE: 	Creates and initializes a POINT object.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	ps = pnt_create_descriptors()    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: 	name:		Data set name.  	desc:		Data set description.  	input:		Description of input data used to produce these points.  	points:		Image points.  	vectors:	Inertial vectors.  	flags:		Point-by-point flag array.  	data:		Point-by-point data array.  	tags:		Tags for point-by-point data.      OUTPUT: NONE    RETURN: 	Newly created and initialized POINT object.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 11/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_create_descriptors.html#pnt_create_descriptors", "pnt_create_descriptors", 'routine in <a href="nv/obj/pnt/pnt_create_descriptors.html">pnt_create_descriptors.pro</a>', "pnt_create_descriptors.pro", "", "pnt_create_descriptors", "", "crdptdn@pnt__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_cull.html", "pnt_cull.pro", '.pro file in <a href="nv/obj/pnt/dir-overview.html">nv/obj/pnt/ directory</a>', "pnt_cull.pro", "", "", " NAME: 	pnt_cull    PURPOSE: 	Cleans out an array of POINT objects by removing invisible points 	and/or empty POINT objects.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	new_ptd = pnt_cull(ptd)    ARGUMENTS:   INPUT: 	ptd:	Array of POINT objects.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.  If this 			case, pnt_cull removes objects for which the specified 			conditions return no points.  	nofree:		If set, invalid POINT object are not freed.    OUTPUT: NONE    RETURN: 	Array POINT objects, or 0 if all were empty.     MODIFICATION HISTORY:   Spitale, 11/2015; 	Adapted from pgs_cull   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_cull.html#pnt_cull", "pnt_cull", 'routine in <a href="nv/obj/pnt/pnt_cull.html">pnt_cull.pro</a>', "pnt_cull.pro", "", "pnt_cull", "", "nofreecondition_ptd@pnt_condition_keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_data.html", "pnt_data.pro", '.pro file in <a href="nv/obj/pnt/dir-overview.html">nv/obj/pnt/ directory</a>', "pnt_data.pro", "", "", " NAME: 	pnt_data    PURPOSE: 	Returns the point-by-point data associated with a POINT object.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	data = pnt_data(ptd)    ARGUMENTS:   INPUT: 	ptd:	POINT object.  If multiple POINT object are given, 		and /cat is not specified, only pointers to the arrays are 		returned, and conditions and tags are not applied.    OUTPUT: NONE    KEYWORDS:   INPUT: 	tags:	If given, data arrays are returned only for these tags, 		and are arranged in this order.  	condition:	Structure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT object, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.  	cat:		If set, arrays from mulitple input objets are 			concatenated.  	sample:		Sampling interval in the nv direction.  Default is 1.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.  	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: 	The point-by-point data associated with the POINT object.    STATUS: 	Complete    SEE ALSO: 	pnt_set_data     MODIFICATION HISTORY:  	Written by:	Spitale, 11/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_data.html#pnt_data", "pnt_data", 'routine in <a href="nv/obj/pnt/pnt_data.html">pnt_data.pro</a>', "pnt_data.pro", "", "pnt_data", "", "tagssamplecatconditionnoeventptd0@pnt_condition_keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_desc.html", "pnt_desc.pro", '.pro file in <a href="nv/obj/pnt/dir-overview.html">nv/obj/pnt/ directory</a>', "pnt_desc.pro", "", "", " NAME: 	pnt_desc    PURPOSE: 	Returns the description associated with a POINT object.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	desc = pnt_desc(ptd)    ARGUMENTS:   INPUT: 	ptd:	POINT object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: 	The description associated with the POINT object.    STATUS: 	Complete    SEE ALSO: 	pnt_set_desc     MODIFICATION HISTORY:  	Written by:	Spitale, 11/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_desc.html#pnt_desc", "pnt_desc", 'routine in <a href="nv/obj/pnt/pnt_desc.html">pnt_desc.pro</a>', "pnt_desc.pro", "", "pnt_desc", "", "noeventptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_explode.html", "pnt_explode.pro", '.pro file in <a href="nv/obj/pnt/dir-overview.html">nv/obj/pnt/ directory</a>', "pnt_explode.pro", "", "", " NAME: 	pnt_explode    PURPOSE: 	Explodes a POINT object into single-point objects.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	xptd = pnt_explode(ptd)    ARGUMENTS:   INPUT: 	ptd:		POINT object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	n:	If given, new objects will have nv = n instead of nv = 1. 		nv must be divisible by n.    OUTPUT: NONE    RETURN: 	Array (nv/n x nt) of POINT objects, each containing a n points.    STATUS: 	Complete      MODIFICATION HISTORY:  	Adapted from pgs_explode:	Spitale, 11/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_explode.html#pnt_explode", "pnt_explode", 'routine in <a href="nv/obj/pnt/pnt_explode.html">pnt_explode.pro</a>', "pnt_explode.pro", "", "pnt_explode", "", "nptd", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_explode.html#__pnt_explode", "__pnt_explode", 'routine in <a href="nv/obj/pnt/pnt_explode.html">pnt_explode.pro</a>', "pnt_explode.pro", "", "__pnt_explode", "", "nptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_flags.html", "pnt_flags.pro", '.pro file in <a href="nv/obj/pnt/dir-overview.html">nv/obj/pnt/ directory</a>', "pnt_flags.pro", "", "", " NAME: 	pnt_flags    PURPOSE: 	Returns the flags associated with a POINT object.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	flags = pnt_flags(ptd)    ARGUMENTS:   INPUT: 	ptd:	POINT object.  If multiple POINT objects are given, 		and /cat is not speciied, only pointers to the arrays are 		returned, and conditions and tags are not applied.    OUTPUT: NONE    KEYWORDS:   INPUT: 	condition:	Structure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT object, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.  	cat:		If set, arrays from mulitple input objets are 			concatenated.  	sample:		Sampling interval in the nv direction.  Default is 1.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.  	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: 	The flags associated with the POINT object.    STATUS: 	Complete    SEE ALSO: 	pnt_set_flags     MODIFICATION HISTORY:  	Written by:	Spitale, 11/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_flags.html#pnt_flags", "pnt_flags", 'routine in <a href="nv/obj/pnt/pnt_flags.html">pnt_flags.pro</a>', "pnt_flags.pro", "", "pnt_flags", "", "samplecatconditionnoeventptd0@pnt_condition_keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_include.html", "pnt_include.pro", '.pro file in <a href="nv/obj/pnt/dir-overview.html">nv/obj/pnt/ directory</a>', "pnt_include.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_input.html", "pnt_input.pro", '.pro file in <a href="nv/obj/pnt/dir-overview.html">nv/obj/pnt/ directory</a>', "pnt_input.pro", "", "", " NAME: 	pnt_input    PURPOSE: 	Returns the input description associated with a POINT object.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	input = pnt_input(ptd)    ARGUMENTS:   INPUT: 	ptd:	POINT object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: 	The input description associated with the POINT object.    STATUS: 	Complete    SEE ALSO: 	pnt_set_input     MODIFICATION HISTORY:  	Written by:	Spitale, 11/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_input.html#pnt_input", "pnt_input", 'routine in <a href="nv/obj/pnt/pnt_input.html">pnt_input.pro</a>', "pnt_input.pro", "", "pnt_input", "", "noeventptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_nt.html", "pnt_nt.pro", '.pro file in <a href="nv/obj/pnt/dir-overview.html">nv/obj/pnt/ directory</a>', "pnt_nt.pro", "", "", " NAME: 	pnt_nt    PURPOSE: 	Returns the nt dimension of a POINT object.    CATEGORY: 	nt/SYS/PS    CALLING SEQUENCE: 	nt = pnt_nt(ptd)    ARGUMENTS:   INPUT: 	ptd:	POINT object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: 	The nt dimensions of the POINT object.    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 11/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_nt.html#pnt_nt", "pnt_nt", 'routine in <a href="nv/obj/pnt/pnt_nt.html">pnt_nt.pro</a>', "pnt_nt.pro", "", "pnt_nt", "", "conditionnoeventptd@pnt_condition_keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_nv.html", "pnt_nv.pro", '.pro file in <a href="nv/obj/pnt/dir-overview.html">nv/obj/pnt/ directory</a>', "pnt_nv.pro", "", "", " NAME: 	pnt_nv    PURPOSE: 	Returns the nv dimension of a POINT object.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	nv = pnt_nv(ptd)    ARGUMENTS:   INPUT: 	ptd:	POINT object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: 	The nv dimensions of the POINT object.    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 11/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_nv.html#pnt_nv", "pnt_nv", 'routine in <a href="nv/obj/pnt/pnt_nv.html">pnt_nv.pro</a>', "pnt_nv.pro", "", "pnt_nv", "", "conditionnoeventptd@pnt_condition_keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_offset.html", "pnt_offset.pro", '.pro file in <a href="nv/obj/pnt/dir-overview.html">nv/obj/pnt/ directory</a>', "pnt_offset.pro", "", "", " NAME: 	pnt_offset    PURPOSE: 	Offsets points in a POINT object.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	pnt_offset, ptd, offset    ARGUMENTS:   INPUT: 	ptd:		POINT object.  	offset:		Offset to apply.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE.     MODIFICATION HISTORY:   Spitale, 11/2015; 	Adapted from pgs_offset   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_offset.html#pnt_offset", "pnt_offset", 'routine in <a href="nv/obj/pnt/pnt_offset.html">pnt_offset.pro</a>', "pnt_offset.pro", "", "pnt_offset", "", "noeventptdoffset", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_points.html", "pnt_points.pro", '.pro file in <a href="nv/obj/pnt/dir-overview.html">nv/obj/pnt/ directory</a>', "pnt_points.pro", "", "", " NAME: 	pnt_points    PURPOSE: 	Returns the points associated with a POINT object.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	points = pnt_points(ptd)    ARGUMENTS: 	ptd:	POINT object.  If multiple POINT objects are given, 		and /cat is not speciied, only pointers to the arrays are 		returned, and conditions and tags are not applied.     OUTPUT: NONE    KEYWORDS:   INPUT: 	condition:	Structure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT object, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.  	cat:		If set, arrays from multiple input objects are 			concatenated.  	sample:		Sampling interval in the nv direction.  Default is 1.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.  	noevent:	If set, no event is generated.    OUTPUT: 	segments:	Subscripts in the output array denoting segments in the 			(assumed) continuous curve due to the point selection 			conditions.    RETURN: 	The points associated with the POINT object, or zero.    STATUS: 	Complete    SEE ALSO: 	pnt_set_points     MODIFICATION HISTORY:  	Written by:	Spitale, 11/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_points.html#pnt_points", "pnt_points", 'routine in <a href="nv/obj/pnt/pnt_points.html">pnt_points.pro</a>', "pnt_points.pro", "", "pnt_points", "", "segmentssamplecatconditionnoeventptd0@pnt_condition_keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_query.html", "pnt_query.pro", '.pro file in <a href="nv/obj/pnt/dir-overview.html">nv/obj/pnt/ directory</a>', "pnt_query.pro", "", "", " NAME: 	pnt_query    PURPOSE: 	Returns the fields associated with a POINT object.  This is a 	convenient way of getting multiple fields in one call, and only a 	single event is generated.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	pnt_query, ptd, <keywords>=<values>    ARGUMENTS:   INPUT: 	ptd:	POINT object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	POINT object fields to set.  	condition:	Structure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT object, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.  	cat:		If set, arrays from mulitple input objets are 			concatenated.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.  	noevent:	If set, no event is generated.    OUTPUT: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 12/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_query.html#pnt_query", "pnt_query", 'routine in <a href="nv/obj/pnt/pnt_query.html">pnt_query.pro</a>', "pnt_query.pro", "", "pnt_query", "", "conditioncatnoeventxd@pnt__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_read.html", "pnt_read.pro", '.pro file in <a href="nv/obj/pnt/dir-overview.html">nv/obj/pnt/ directory</a>', "pnt_read.pro", "", "", " NAME:  	pnt_read    PURPOSE:  	Reads a POINT file.    CATEGORY:  	NV/OBJ/PNT    CALLING SEQUENCE:  	ptd = pnt_read(filename)    ARGUMENTS:   INPUT:  	filename: Name of the file to read.    OUTPUT: NONE    KEYWORDS:   INPUT:  	bin:		If set, a binary POINT file is read;  			not currently implemented.   	visible:	If set, only visible points are returned.   	no_ptd:		If set, POINT objects are not created.    OUTPUT:  	name: 		Array names.   	desc:  		Array descriptions.   	flags:  	Array flags   	points:  	Point arrays.   	vectors: 	Vector arrays.    RETURN:  	Normally, this routine returns a POINT containing  	the points from the file.  If no_ptd is set, then 0 is returned  	instead.    SEE ALSO: 	pnt_write    MODIFICATION HISTORY:   Spitale, 11/2015; 	Adapted from pgs_read_ps   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_read.html#pnt_read_0", "pnt_read_0", 'routine in <a href="nv/obj/pnt/pnt_read.html">pnt_read.pro</a>', "pnt_read.pro", "", "pnt_read_0", "", "visiblenamedescflagspointsvectorscommentfilename", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_read.html#psrpnt_get_next", "psrpnt_get_next", 'routine in <a href="nv/obj/pnt/pnt_read.html">pnt_read.pro</a>', "pnt_read.pro", "", "psrpnt_get_next", "", "stopstatusnbinbufunittoken", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_read.html#pnt_read_1", "pnt_read_1", 'routine in <a href="nv/obj/pnt/pnt_read.html">pnt_read.pro</a>', "pnt_read.pro", "", "pnt_read_1", "", "visiblenamedescflagspointsvectorscommentversiondatatagsfilename", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_read.html#pnt_read_2", "pnt_read_2", 'routine in <a href="nv/obj/pnt/pnt_read.html">pnt_read.pro</a>', "pnt_read.pro", "", "pnt_read_2", "", "visiblenamedescflagspointsvectorscommentversiondatatagsfilename", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_read.html#pnt_read", "pnt_read", 'routine in <a href="nv/obj/pnt/pnt_read.html">pnt_read.pro</a>', "pnt_read.pro", "", "pnt_read", "", "binnamedescflagspointsvectorscommentdatatagsfilename", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_scale.html", "pnt_scale.pro", '.pro file in <a href="nv/obj/pnt/dir-overview.html">nv/obj/pnt/ directory</a>', "pnt_scale.pro", "", "", " NAME: 	pnt_scale    PURPOSE: 	Scales points in a POINT object.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	pnt_scale, ptd, scale    ARGUMENTS:   INPUT: 	ptd:		POINT object.  	scale:		Scale to apply.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE.     MODIFICATION HISTORY:   Spitale, 11/2015; 	Adapted from pgs_scale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_scale.html#pnt_scale", "pnt_scale", 'routine in <a href="nv/obj/pnt/pnt_scale.html">pnt_scale.pro</a>', "pnt_scale.pro", "", "pnt_scale", "", "noeventptdscale", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_set_assoc_xd.html", "pnt_set_assoc_xd.pro", '.pro file in <a href="nv/obj/pnt/dir-overview.html">nv/obj/pnt/ directory</a>', "pnt_set_assoc_xd.pro", "", "", " NAME: 	pnt_set_assoc_xd    PURPOSE: 	Replaces the assoc_xd field in a CORE object.    CATEGORY: 	NV/SYS/PNT    CALLING SEQUENCE: 	pnt_set_assoc_xd, ptd, assoc_xd    ARGUMENTS:   INPUT: 	ptd:		POINT object.  	assoc_xd:	New assoc_xd.    OUTPUT: NONE    KEYWORDS:   INPUT: 	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	pnt_assoc_xd     MODIFICATION HISTORY:  	Written by:	Spitale		11/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_set_assoc_xd.html#pnt_set_assoc_xd", "pnt_set_assoc_xd", 'routine in <a href="nv/obj/pnt/pnt_set_assoc_xd.html">pnt_set_assoc_xd.pro</a>', "pnt_set_assoc_xd.pro", "", "pnt_set_assoc_xd", "", "noeventptdassoc_xd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_set_data.html", "pnt_set_data.pro", '.pro file in <a href="nv/obj/pnt/dir-overview.html">nv/obj/pnt/ directory</a>', "pnt_set_data.pro", "", "", " NAME: 	pnt_set_data    PURPOSE: 	Replaces the point-by-point data in a POINT object.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	pnt_set_data, ptd, data    ARGUMENTS:   INPUT: 	ptd:		POINT object.  	data:		New point-by-point data array.    OUTPUT: NONE    KEYWORDS:   INPUT: 	noevent:	If set, no event is generated.  	tags:	If given, data arrays are replaced only for these tags, and in 		this order.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	pnt_data     MODIFICATION HISTORY:  	Written by:	Spitale		11/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_set_data.html#pnt_set_data", "pnt_set_data", 'routine in <a href="nv/obj/pnt/pnt_set_data.html">pnt_set_data.pro</a>', "pnt_set_data.pro", "", "pnt_set_data", "", "tagsnoeventptdnew_data", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_set_desc.html", "pnt_set_desc.pro", '.pro file in <a href="nv/obj/pnt/dir-overview.html">nv/obj/pnt/ directory</a>', "pnt_set_desc.pro", "", "", " NAME: 	pnt_set_desc    PURPOSE: 	Replaces the description field in a POINT object.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	pnt_set_desc, ptd, desc    ARGUMENTS:   INPUT: 	ptd:		POINT object.  	desc:		New description.    OUTPUT: NONE    KEYWORDS:   INPUT: 	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	pnt_desc     MODIFICATION HISTORY:  	Written by:	Spitale		11/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_set_desc.html#pnt_set_desc", "pnt_set_desc", 'routine in <a href="nv/obj/pnt/pnt_set_desc.html">pnt_set_desc.pro</a>', "pnt_set_desc.pro", "", "pnt_set_desc", "", "noeventptddesc", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_set_flags.html", "pnt_set_flags.pro", '.pro file in <a href="nv/obj/pnt/dir-overview.html">nv/obj/pnt/ directory</a>', "pnt_set_flags.pro", "", "", " NAME: 	pnt_set_flags    PURPOSE: 	Replaces the flags in a POINT object.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	pnt_set_flags, ptd, flags    ARGUMENTS:   INPUT: 	ptd:		POINT object.  	flags:		New flags array.    OUTPUT: NONE    KEYWORDS:   INPUT: 	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	pnt_flags     MODIFICATION HISTORY:  	Written by:	Spitale		11/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_set_flags.html#pnt_set_flags", "pnt_set_flags", 'routine in <a href="nv/obj/pnt/pnt_set_flags.html">pnt_set_flags.pro</a>', "pnt_set_flags.pro", "", "pnt_set_flags", "", "noeventptdflags", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_set_input.html", "pnt_set_input.pro", '.pro file in <a href="nv/obj/pnt/dir-overview.html">nv/obj/pnt/ directory</a>', "pnt_set_input.pro", "", "", " NAME: 	pnt_set_input    PURPOSE: 	Replaces the input description field in a POINT object.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	pnt_set_input, ptd, input    ARGUMENTS:   INPUT: 	ptd:		POINT object.  	input:		New input description.    OUTPUT: NONE    KEYWORDS:   INPUT: 	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	pnt_input     MODIFICATION HISTORY:  	Written by:	Spitale		11/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_set_input.html#pnt_set_input", "pnt_set_input", 'routine in <a href="nv/obj/pnt/pnt_set_input.html">pnt_set_input.pro</a>', "pnt_set_input.pro", "", "pnt_set_input", "", "noeventptdinput", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_set_points.html", "pnt_set_points.pro", '.pro file in <a href="nv/obj/pnt/dir-overview.html">nv/obj/pnt/ directory</a>', "pnt_set_points.pro", "", "", " NAME: 	pnt_set_points    PURPOSE: 	Replaces the points in a POINT object.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	pnt_set_points, ptd, points    ARGUMENTS:   INPUT: 	ptd:		POINT object.  	points:		New points array.    OUTPUT: NONE    KEYWORDS:   INPUT: 	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	pnt_points     MODIFICATION HISTORY:  	Written by:	Spitale		11/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_set_points.html#pnt_set_points", "pnt_set_points", 'routine in <a href="nv/obj/pnt/pnt_set_points.html">pnt_set_points.pro</a>', "pnt_set_points.pro", "", "pnt_set_points", "", "noeventptdpoints", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_set_tags.html", "pnt_set_tags.pro", '.pro file in <a href="nv/obj/pnt/dir-overview.html">nv/obj/pnt/ directory</a>', "pnt_set_tags.pro", "", "", " NAME: 	pnt_set_tags    PURPOSE: 	Replaces the tags in a POINT object.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	pnt_set_tags, ptd, tags    ARGUMENTS:   INPUT: 	ptd:		POINT object.  	tags:		New tags array.    OUTPUT: NONE    KEYWORDS:   INPUT: 	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	pnt_tags     MODIFICATION HISTORY:  	Written by:	Spitale		11/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_set_tags.html#pnt_set_tags", "pnt_set_tags", 'routine in <a href="nv/obj/pnt/pnt_set_tags.html">pnt_set_tags.pro</a>', "pnt_set_tags.pro", "", "pnt_set_tags", "", "noeventptdtags", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_set_vectors.html", "pnt_set_vectors.pro", '.pro file in <a href="nv/obj/pnt/dir-overview.html">nv/obj/pnt/ directory</a>', "pnt_set_vectors.pro", "", "", " NAME: 	pnt_set_vectors    PURPOSE: 	Replaces the vectors in a POINT object.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	pnt_set_vectors, ptd, vectors    ARGUMENTS:   INPUT: 	ptd:		POINT object.  	vectors:	New vectors array.    OUTPUT: NONE    KEYWORDS:   INPUT: 	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	pnt_vectors     MODIFICATION HISTORY:  	Written by:	Spitale		11/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_set_vectors.html#pnt_set_vectors", "pnt_set_vectors", 'routine in <a href="nv/obj/pnt/pnt_set_vectors.html">pnt_set_vectors.pro</a>', "pnt_set_vectors.pro", "", "pnt_set_vectors", "", "noeventptdvectors", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_tags.html", "pnt_tags.pro", '.pro file in <a href="nv/obj/pnt/dir-overview.html">nv/obj/pnt/ directory</a>', "pnt_tags.pro", "", "", " NAME: 	pnt_tags    PURPOSE: 	Returns the tags associated with a POINT object.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	tags = pnt_tags(ptd)    ARGUMENTS:   INPUT: 	ptd:	POINT object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: 	The tags associated with the POINT object.    STATUS: 	Complete    SEE ALSO: 	pnt_set_tags     MODIFICATION HISTORY:  	Written by:	Spitale, 11/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_tags.html#pnt_tags", "pnt_tags", 'routine in <a href="nv/obj/pnt/pnt_tags.html">pnt_tags.pro</a>', "pnt_tags.pro", "", "pnt_tags", "", "noeventptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_template.html", "pnt_template.pro", '.pro file in <a href="nv/obj/pnt/dir-overview.html">nv/obj/pnt/ directory</a>', "pnt_template.pro", "", "", " NAME: 	pnt_template    PURPOSE: 	Creates a new POINT using an existing one as a template.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	ptd = pnt_template(ptd0)    ARGUMENTS:   INPUT: 	ptd0:		POINT object.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	New POINT with array fields left blank.    STATUS: 	Complete      MODIFICATION HISTORY:  	Written:	Spitale, 11/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_template.html#pnt_template", "pnt_template", 'routine in <a href="nv/obj/pnt/pnt_template.html">pnt_template.pro</a>', "pnt_template.pro", "", "pnt_template", "", "ptd0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_test.html", "pnt_test.pro", '.pro file in <a href="nv/obj/pnt/dir-overview.html">nv/obj/pnt/ directory</a>', "pnt_test.pro", "", "", " NAME: 	pnt_test    PURPOSE: 	Assesses the validity of a single POINT object.  This function 	differs from pnt_valid in that it simply returns true or false, rather 	than a list of validity flags.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	test = pnt_test(ptd)    ARGUMENTS:   INPUT: 	ptd:	Array of POINT objects.    OUTPUT: NONE    KEYWORDS:   INPUT: 	generic:	If set, a generic input is test to determine whether 			it is a POINT object.  Its validity is not tested.    OUTPUT: NONE    RETURN: 	1 if the given POINT object is valid and contains points, 0 otherwise.    STATUS: 	Complete    SEE ALSO: 	pnt_test    MODIFICATION HISTORY:   Spitale, 12/2015; 	Adapted from pgs_test   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_test.html#pnt_test", "pnt_test", 'routine in <a href="nv/obj/pnt/pnt_test.html">pnt_test.pro</a>', "pnt_test.pro", "", "pnt_test", "", "genericnoeventptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_threshold.html", "pnt_threshold.pro", '.pro file in <a href="nv/obj/pnt/dir-overview.html">nv/obj/pnt/ directory</a>', "pnt_threshold.pro", "", "", " NAME: 	pnt_threshold    PURPOSE: 	Flags points whose given indicator falls below or above a given 	threshold.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	pnt_threshold, ptd, indicators, threshold, /above 	pnt_threshold, ptd, indicators, threshold, /below    ARGUMENTS:   INPUT: 	ptd:		POINT object.  	indicators:	Values to be tested against the threshold.  One for 			each point in ptd.  	threshold:	Threshold value.    OUTPUT: NONE    KEYWORDS:   INPUT: 	above:	If set, values above the theshold are allowed.  	below:	If set, values below the theshold are allowed.    OUTPUT: NONE    RETURN: NONE.     MODIFICATION HISTORY:   Spitale, 11/2015; 	Adapted from pgs_threshold   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_threshold.html#pnt_threshold", "pnt_threshold", 'routine in <a href="nv/obj/pnt/pnt_threshold.html">pnt_threshold.pro</a>', "pnt_threshold.pro", "", "pnt_threshold", "", "abovebelowptdindicatorsthreshold", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_uncompress.html", "pnt_uncompress.pro", '.pro file in <a href="nv/obj/pnt/dir-overview.html">nv/obj/pnt/ directory</a>', "pnt_uncompress.pro", "", "", " NAME: 	pnt_uncompress    PURPOSE: 	Explodes a compressed POINT object back into an array of POINT objects 	using the original POINT objects as a template.  The 	compressed POINT object is freed.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	new_ptd = pnt_uncompress(pptd, ptd)    ARGUMENTS:   INPUT: 	pptd:	Compressed POINT object.  	ptd:	Array of original POINT objects to use as a template. 		Must be in the same order as when compressed.    OUTPUT: NONE    KEYWORDS:   INPUT: 	nn:		If given, it is assumed that there are nn elements 			in the compressed array for each element in the 			original input arrays.    OUTPUT: NONE    RETURN: 	Array of POINT objects containing the uncompressed data.     MODIFICATION HISTORY:   Spitale, 11/2015; 	Adapted from pgs_uncompress   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_uncompress.html#pnt_uncompress", "pnt_uncompress", 'routine in <a href="nv/obj/pnt/pnt_uncompress.html">pnt_uncompress.pro</a>', "pnt_uncompress.pro", "", "pnt_uncompress", "", "nnpptdptd0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_valid.html", "pnt_valid.pro", '.pro file in <a href="nv/obj/pnt/dir-overview.html">nv/obj/pnt/ directory</a>', "pnt_valid.pro", "", "", " NAME: 	pnt_valid    PURPOSE: 	Assesses the validity of POINT objects.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	valid = pnt_valid(ptd)    ARGUMENTS:   INPUT: 	ptd:	Array of POINT objects.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array of flags, one for each input PS.  1 indicates that the PS 	contains points.    STATUS: 	Complete    SEE ALSO: 	pnt_test    MODIFICATION HISTORY:   Spitale, 11/2015; 	Adapted from pgs_valid   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_valid.html#pnt_valid", "pnt_valid", 'routine in <a href="nv/obj/pnt/pnt_valid.html">pnt_valid.pro</a>', "pnt_valid.pro", "", "pnt_valid", "", "noeventptd0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_vectors.html", "pnt_vectors.pro", '.pro file in <a href="nv/obj/pnt/dir-overview.html">nv/obj/pnt/ directory</a>', "pnt_vectors.pro", "", "", " NAME: 	pnt_vectors    PURPOSE: 	Returns the vectors associated with a POINT object.    CATEGORY: 	NV/OBJ/PNT    CALLING SEQUENCE: 	vectors = pnt_vectors(ptd)    ARGUMENTS:   INPUT: 	ptd:	POINT object.  If multiple POINT objects are given, 		and /cat is not speciied, only pointers to the arrays are 		returned, and conditions and tags are not applied.     OUTPUT: NONE    KEYWORDS:   INPUT: 	condition:	Structure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT objects, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.  	cat:		If set, arrays from mulitple input objets are 			concatenated.  	sample:		Sampling interval in the nv direction.  Default is 1.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.  	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: 	The vectors associated with the POINT object.    STATUS: 	Complete    SEE ALSO: 	pnt_set_vectors     MODIFICATION HISTORY:  	Written by:	Spitale, 11/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_vectors.html#pnt_vectors", "pnt_vectors", 'routine in <a href="nv/obj/pnt/pnt_vectors.html">pnt_vectors.pro</a>', "pnt_vectors.pro", "", "pnt_vectors", "", "samplecatconditionnoeventptd0@pnt_condition_keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_write.html", "pnt_write.pro", '.pro file in <a href="nv/obj/pnt/dir-overview.html">nv/obj/pnt/ directory</a>', "pnt_write.pro", "", "", " NAME:  	pnt_write    PURPOSE:  	Writes a POINT object to a file.    CATEGORY:  	NV/OBJ/PNT    CALLING SEQUENCE:  	pnt_write, filename, ptd    ARGUMENTS:   INPUT:  	filename:	Name of the file to write.  	ptd:		POINT object to write.    OUTPUT: NONE    KEYWORDS:   INPUT:  	bin:	If set, a binary POINT object file is written;  		not currently implemented.    OUTPUT: NONE    RETURN: NONE    SEE ALSO: 	pnt_read    MODIFICATION HISTORY:   Spitale, 11/2015; 	Adapted from pgs_write_ps   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/pnt/pnt_write.html#pnt_write", "pnt_write", 'routine in <a href="nv/obj/pnt/pnt_write.html">pnt_write.pro</a>', "pnt_write.pro", "", "pnt_write", "", "binnoeventfilenameptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/pointpds.html", "pointpds.pro", '.pro file in <a href="config/pds/Readpds_4.4/dir-overview.html">config/pds/Readpds_4.4/ directory</a>', "pointpds.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/pointpds.html#pointpds", "pointpds", 'routine in <a href="config/pds/Readpds_4.4/pointpds.html">pointpds.pro</a>', "pointpds.pro", "", "pointpds", "", "labelfnameobjname", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/points_dxy.html", "points_dxy.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "points_dxy.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/points_dxy.html#points_dxy", "points_dxy", 'routine in <a href="util/points_dxy.html">points_dxy.pro</a>', "points_dxy.pro", "", "points_dxy", "", "x1y1x2y2p1p2", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/poly_filter.html", "poly_filter.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "poly_filter.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/poly_filter.html#poly_filter", "poly_filter", 'routine in <a href="util/poly_filter.html">poly_filter.pro</a>', "poly_filter.pro", "", "poly_filter", "", "polyfxdegree", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/poly_flux.html", "poly_flux.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "poly_flux.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/poly_flux.html#poly_flux", "poly_flux", 'routine in <a href="util/poly_flux.html">poly_flux.pro</a>', "poly_flux.pro", "", "poly_flux", "", "ext_fluxnormshowext_indicesindicesimagep", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/poly_rectify.html", "poly_rectify.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "poly_rectify.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/poly_rectify.html#pr_combine", "pr_combine", 'routine in <a href="util/poly_rectify.html">poly_rectify.pro</a>', "poly_rectify.pro", "", "pr_combine", "", "pseg_pssub_psused", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/poly_rectify.html#poly_rectify", "poly_rectify", 'routine in <a href="util/poly_rectify.html">poly_rectify.pro</a>', "poly_rectify.pro", "", "poly_rectify", "", "subplengths", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/poly_transform.html", "poly_transform.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "poly_transform.pro", "", "", " NAME:        poly_transform    PURPOSE:        Transforms an array of points given a polynomial transformation    CATEGORY:        UTIL    CALLING SEQUENCE:        result = poly_transform(Dx, Dy, v)    ARGUMENTS:   INPUT:        Dx:     Polynominal distortion coefficients in x.         Dy:     Polynominal distortion coefficients in y.          v:     Array of points to transform.    OUTPUT:        NONE    RETURN:        Array of transformed points.    SEE ALSO:        power_matrix, vecgen, mxgen, trace    MODIFICATION HISTORY:        Written by:     Spitale, 6/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/poly_transform.html#poly_transform", "poly_transform", 'routine in <a href="util/poly_transform.html">poly_transform.pro</a>', "poly_transform.pro", "", "poly_transform", "", "DxDyv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/power_matrix.html", "power_matrix.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "power_matrix.pro", "", "", " NAME:        power_matrix    PURPOSE:        Constructs an array of n x n matrices such that the (i,j)th element        of the kth matrix is:                                   i    j                    M(i,j,k) = p(k) q(k)   CATEGORY:        UTIL    CALLING SEQUENCE:        result = power_matrix(p, q, n)    ARGUMENTS:   INPUT:        p:      An input array of k elements         q:      An input array of k elements         n:      Dimension of 2d matrix     OUTPUT:        NONE   KEYWORDS:        NONE    RETURN:        The power_matrix as described above.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/power_matrix.html#power_matrix", "power_matrix", 'routine in <a href="util/power_matrix.html">power_matrix.pro</a>', "power_matrix.pro", "", "power_matrix", "", "_p_qn", "          -1", "");
  
  

libdata[libdataItem++] = new Array("vims_src_tmp/pp_buffered_vector__define.html", "pp_buffered_vector__define.pro", '.pro file in <a href="vims_src_tmp/dir-overview.html">vims_src_tmp/ directory</a>', "pp_buffered_vector__define.pro", "Paulo Penteado (pp.penteado@gmail.com), Sep/2009  ", "", " ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("vims_src_tmp/pp_buffered_vector__define.html#pp_buffered_vector::init", "pp_buffered_vector::init", 'routine in <a href="vims_src_tmp/pp_buffered_vector__define.html">pp_buffered_vector__define.pro</a>', "pp_buffered_vector__define.pro", "Paulo Penteado (pp.penteado@gmail.com), Oct/2009  ", "pp_buffered_vector::init", "    Creates a pp_buffered_vector object, with the contents of the given array, or empty     if it is not provided.     The buffered vector can contain elements of any type. The type is determined by the type of     the first element put into it (if not at initialization, at the first append operation).   ", "buffersize      Size of the step to use when incrementing the number of elements contained by the object.   initvec      An array whose elements are to be placed in the object on creation.   ", "          -1", "    See the example in pp_bufferedvector__define.    ");
  
  libdata[libdataItem++] = new Array("vims_src_tmp/pp_buffered_vector__define.html#pp_buffered_vector::append", "pp_buffered_vector::append", 'routine in <a href="vims_src_tmp/pp_buffered_vector__define.html">pp_buffered_vector__define.pro</a>', "pp_buffered_vector__define.pro", "Paulo Penteado (pp.penteado@gmail.com), Oct/2009  ", "pp_buffered_vector::append", "    Adds the given data (scalar or array) to the end of the buffered vector, expanding     its allocated size if necessary.   ", "data      The scalar or array to be put at the end of the buffered vector.   ", "          -1", "    See the example in pp_bufferedvector__define.    ");
  
  libdata[libdataItem++] = new Array("vims_src_tmp/pp_buffered_vector__define.html#pp_buffered_vector::getdata", "pp_buffered_vector::getdata", 'routine in <a href="vims_src_tmp/pp_buffered_vector__define.html">pp_buffered_vector__define.pro</a>', "pp_buffered_vector__define.pro", "Paulo Penteado (pp.penteado@gmail.com), Oct/2009  ", "pp_buffered_vector::getdata", "    Retrieves one or more data elements currently stored in the buffered vector.   ", "all      If set, all the elements stored in the buffered vector are returned.  count      Returns the number of elements retrieved.   nget      The number of elements to retrieve. If positive, the nget first elements are returned. If       negative, the last -nget elements are returned. If abs(nget) is larger than the number of       elements in the buffered vector, all the elements are returned. The value returned by count       must be checked to find out how many elements were actually returned.   ", "          -1", "    See the example in pp_bufferedvector__define.        If the buffered vector is empty, returns 0, with a count of 0. Otherwise, returns an array with     the selected elements from the buffered vector, and the number of elements in count.   ");
  
  libdata[libdataItem++] = new Array("vims_src_tmp/pp_buffered_vector__define.html#pp_buffered_vector::getcount", "pp_buffered_vector::getcount", 'routine in <a href="vims_src_tmp/pp_buffered_vector__define.html">pp_buffered_vector__define.pro</a>', "pp_buffered_vector__define.pro", "Paulo Penteado (pp.penteado@gmail.com), Oct/2009  ", "pp_buffered_vector::getcount", "    Returns the number of elements currently stored in the buffered vector.   ", "", "          -1", "    See the example in pp_bufferedvector__define.    ");
  
  libdata[libdataItem++] = new Array("vims_src_tmp/pp_buffered_vector__define.html#pp_buffered_vector::getsize", "pp_buffered_vector::getsize", 'routine in <a href="vims_src_tmp/pp_buffered_vector__define.html">pp_buffered_vector__define.pro</a>', "pp_buffered_vector__define.pro", "Paulo Penteado (pp.penteado@gmail.com), Oct/2009  ", "pp_buffered_vector::getsize", "    Returns the currently allocated length for the buffered vector.   ", "", "          -1", "    See the example in pp_bufferedvector__define.    ");
  
  libdata[libdataItem++] = new Array("vims_src_tmp/pp_buffered_vector__define.html#pp_buffered_vector::getbuffersize", "pp_buffered_vector::getbuffersize", 'routine in <a href="vims_src_tmp/pp_buffered_vector__define.html">pp_buffered_vector__define.pro</a>', "pp_buffered_vector__define.pro", "Paulo Penteado (pp.penteado@gmail.com), Oct/2009  ", "pp_buffered_vector::getbuffersize", "    Returns the step by which the buffered vector is incremented when necessary.   ", "", "          -1", "    See the example in pp_bufferedvector__define.    ");
  
  libdata[libdataItem++] = new Array("vims_src_tmp/pp_buffered_vector__define.html#pp_buffered_vector__define", "pp_buffered_vector__define", 'routine in <a href="vims_src_tmp/pp_buffered_vector__define.html">pp_buffered_vector__define.pro</a>', "pp_buffered_vector__define.pro", "Paulo Penteado (pp.penteado@gmail.com), Sep/2009  ", "pp_buffered_vector__define", "   Object to keep an adjustable length vector, using a buffer to decrease the frequency of resizing     It is a simple (without DLM) and relatively efficient implementation of a container similar to a list,    intended for light use. For heavy use, it would take a DLM to implement a proper list.   ", "", "          -1", "   Make a new empty buffered vector: <span class= code-output > a=obj_new('pp_buffered_vector')</span> <span class= code-output > print,a-&gt;getcount()</span> <span class= code-output > ;0</span> <span class= code-output > a-&gt;append,indgen(10)</span> <span class= code-output > print,a-&gt;getcount()</span> <span class= code-output > ;10</span> <span class= code-output > print,a-&gt;getdata(5)</span> <span class= code-output > ;0       1       2       3       4</span> <span class= code-output > rint,a-&gt;getdata(-5)</span> <span class= code-output > ;5       6       7       8       9</span> <span class= code-output > print,a-&gt;getdata(/all)</span> <span class= code-output > ;0       1       2       3       4       5       6       7       8       9</span> <span class= code-output > print,a-&gt;getsize()</span> <span class= code-output > ;100</span> <span class= code-output > print,a-&gt;getbuffersize()</span> <span class= code-output > ;100</span> <span class= code-output > obj_destroy,a</span>   ");
  
  

libdata[libdataItem++] = new Array("util/pp_build_extra.html", "pp_build_extra.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "pp_build_extra.pro", "Paulo Penteado (http://www.ppenteado.net), Jul/2016  ", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/pp_build_extra.html#pp_build_extra", "pp_build_extra", 'routine in <a href="util/pp_build_extra.html">pp_build_extra.pro</a>', "pp_build_extra.pro", "Paulo Penteado (http://www.ppenteado.net), Jul/2016  ", "pp_build_extra", "    Creates a structure to carry keywords and values to a routine,     by means of the _extra keyword inheritance mechanism.   ", "keys      An array of strings with the names for the keywords. The number of elements       and their order must match the values in the vals array.  vals      An array of pointers with the values corresponding to the keywords specified       in the keys array: each element is the pointer to the variable that contains       that keyword's value.   ", "          -1", "    Create 3 keys and their values: <span class= code-output > keys=['arg1','arg2','arg3']</span> <span class= code-output > vals=[ptr_new([0,1,2]),ptr_new(['a','b']),ptr_new(27.8d0)]</span>     Pack these into an _extra-type structure: <span class= code-output > extra=pp_build_extra(keys,vals)</span> <span class= code-output > help,extra</span> <span class= code-output > ;** Structure &lt;a4643e48&gt;, 3 tags, length=48, data length=46, refs=1:</span> <span class= code-output > ;ARG1            INT       Array[3]</span> <span class= code-output > ;ARG2            STRING    Array[2]</span> <span class= code-output > ;ARG3            DOUBLE           27.800000</span> <span class= code-output > print,extra.arg1</span> <span class= code-output > ;0       1       2</span> <span class= code-output > print,extra.arg2</span> <span class= code-output > ;a b</span> <span class= code-output > print,extra,/implied</span> <span class= code-output > ;{</span> <span class= code-output > ; ARG1 : [0, 1, 2],</span> <span class= code-output > ; ARG2 : [  a ,  b ],</span> <span class= code-output > ; ARG3 : 27.800000000000001</span> <span class= code-output > ;}</span>     This result could then be used in a call to a function/procedure that uses     these keywords: <span class= code-output > my_procedure,_extra=extra</span>  IDL 8.0 (could be easily rewritten to be compatible with earlier  versions, if needed).   ");
  
  

libdata[libdataItem++] = new Array("util/downloader/pp_command_line_args_parse.html", "pp_command_line_args_parse.pro", '.pro file in <a href="util/downloader/dir-overview.html">util/downloader/ directory</a>', "pp_command_line_args_parse.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/downloader/pp_command_line_args_parse.html#pp_command_line_args_parse", "pp_command_line_args_parse", 'routine in <a href="util/downloader/pp_command_line_args_parse.html">pp_command_line_args_parse.pro</a>', "pp_command_line_args_parse.pro", "Paulo Penteado (http://www.ppenteado.net)  ", "pp_command_line_args_parse", "    Parses arguments provided in the command line into a more usable form:       simple arguments are provided as a list, in the order they were given in       the command line. Additionally, some arguments are parsed into a hash:        1) -foo is parsed as a hash element with key foo and value 1       2) --foo=bar is parsed as a hash element with key foo and value bar   ", "", "          -1", ":     Suposing the IDL session was started as: <span class= code-output > idl -args arg1 arg2 -key1 --key2=value1</span>    A call to pp_command_lne_args_parse will return: <span class= code-output > args=pp_command_line_args_parse()</span> <span class= code-output > help,args</span> <span class= code-output > ;** Structure &lt;19a2d18&gt;, 4 tags, length=16, data length=16, refs=1:</span> <span class= code-output > ;ARGCOUNT        LONG                 2</span> <span class= code-output > ;KEYCOUNT        LONG                 2</span> <span class= code-output > ;ARGUMENTS       OBJREF    &lt;ObjHeapVar75(LIST)&gt;</span> <span class= code-output > ;KEYWORDS        OBJREF    &lt;ObjHeapVar73(HASH)&gt;</span> <span class= code-output > print,args.arguments</span> <span class= code-output > ;arg1</span> <span class= code-output > ;arg2</span> <span class= code-output > print,args.keywords</span> <span class= code-output > ;key1:            1</span> <span class= code-output > ;key2: value1</span>   ");
  
  

libdata[libdataItem++] = new Array("vims_src_tmp/pp_extractfields.html", "pp_extractfields.pro", '.pro file in <a href="vims_src_tmp/dir-overview.html">vims_src_tmp/ directory</a>', "pp_extractfields.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("vims_src_tmp/pp_extractfields.html#pp_extractfields", "pp_extractfields", 'routine in <a href="vims_src_tmp/pp_extractfields.html">pp_extractfields.pro</a>', "pp_extractfields.pro", "Paulo Penteado (pp.penteado@gmail.com)  ", "pp_extractfields", "    Given a string containing a comma-separated sequence of values, returns     a string array with each value. Values can be quoted strings, in which case     they can contain a comma inside them (which is why this routine exists, otherwise     strsplit could do the job). Either type of quote can be used to mark the strings, but     each string must be finished with the same type of quote it started.   ", "str      The string containing the comma-separated fields.  count      The number of fields found.   ", "          -1", "   Split ' 1,2 , 2 , 3 , 4 ' into its fields: <span class= code-output > print,pp_extractfields(' 1,2 , 2 , 3 , 4 ',count),count</span> <span class= code-output > ; 1,2   2   3   4 </span> <span class= code-output > ;       4</span>       A string array where each element is one of the comma-separated fields in str.   ");
  
  

libdata[libdataItem++] = new Array("util/downloader/pp_ftp__define.html", "pp_ftp__define.pro", '.pro file in <a href="util/downloader/dir-overview.html">util/downloader/ directory</a>', "pp_ftp__define.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/downloader/pp_ftp__define.html#pp_ftp::init", "pp_ftp::init", 'routine in <a href="util/downloader/pp_ftp__define.html">pp_ftp__define.pro</a>', "pp_ftp__define.pro", "", "pp_ftp::init", "", "userpwurlverbosetimeoutdebugblocksizeclobbercallback_datacallback_function", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/downloader/pp_ftp__define.html#pp_ftp::send", "pp_ftp::send", 'routine in <a href="util/downloader/pp_ftp__define.html">pp_ftp__define.pro</a>', "pp_ftp__define.pro", "", "pp_ftp::send", "", "stri", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/downloader/pp_ftp__define.html#pp_ftp::socket_read", "pp_ftp::socket_read", 'routine in <a href="util/downloader/pp_ftp__define.html">pp_ftp__define.pro</a>', "pp_ftp__define.pro", "", "pp_ftp::socket_read", "", "verblinesbstr_ref_extra", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/downloader/pp_ftp__define.html#pp_ftp::getftpdirlist", "pp_ftp::getftpdirlist", 'routine in <a href="util/downloader/pp_ftp__define.html">pp_ftp__define.pro</a>', "pp_ftp__define.pro", "", "pp_ftp::getftpdirlist", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/downloader/pp_ftp__define.html#pp_ftp::cd", "pp_ftp::cd", 'routine in <a href="util/downloader/pp_ftp__define.html">pp_ftp__define.pro</a>', "pp_ftp__define.pro", "", "pp_ftp::cd", "", "splitpath", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/downloader/pp_ftp__define.html#pp_ftp::getpwd", "pp_ftp::getpwd", 'routine in <a href="util/downloader/pp_ftp__define.html">pp_ftp__define.pro</a>', "pp_ftp__define.pro", "", "pp_ftp::getpwd", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/downloader/pp_ftp__define.html#pp_ftp::getproperty", "pp_ftp::getproperty", 'routine in <a href="util/downloader/pp_ftp__define.html">pp_ftp__define.pro</a>', "pp_ftp__define.pro", "", "pp_ftp::getproperty", "", "pathurl_schemeurl_porturl_pathurl_hostnameurl_userurl_password", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/downloader/pp_ftp__define.html#pp_ftp::setproperty", "pp_ftp::setproperty", 'routine in <a href="util/downloader/pp_ftp__define.html">pp_ftp__define.pro</a>', "pp_ftp__define.pro", "", "pp_ftp::setproperty", "", "url_porturl_path", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/downloader/pp_ftp__define.html#pp_ftp::get", "pp_ftp::get", 'routine in <a href="util/downloader/pp_ftp__define.html">pp_ftp__define.pro</a>', "pp_ftp__define.pro", "", "pp_ftp::get", "", "bufferfilenameltimestring", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/downloader/pp_ftp__define.html#pp_ftp::cleanup", "pp_ftp::cleanup", 'routine in <a href="util/downloader/pp_ftp__define.html">pp_ftp__define.pro</a>', "pp_ftp__define.pro", "", "pp_ftp::cleanup", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/downloader/pp_ftp__define.html#pp_ftp__define", "pp_ftp__define", 'routine in <a href="util/downloader/pp_ftp__define.html">pp_ftp__define.pro</a>', "pp_ftp__define.pro", "", "pp_ftp__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("vims_src_tmp/pp_get_label_value.html", "pp_get_label_value.pro", '.pro file in <a href="vims_src_tmp/dir-overview.html">vims_src_tmp/ directory</a>', "pp_get_label_value.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("vims_src_tmp/pp_get_label_value.html#pp_get_label_value", "pp_get_label_value", 'routine in <a href="vims_src_tmp/pp_get_label_value.html">pp_get_label_value.pro</a>', "pp_get_label_value.pro", "", "pp_get_label_value", "", "_labelkey", "          -1", "");
  
  

libdata[libdataItem++] = new Array("vims_src_tmp/pp_getcubeheadervalue.html", "pp_getcubeheadervalue.pro", '.pro file in <a href="vims_src_tmp/dir-overview.html">vims_src_tmp/ directory</a>', "pp_getcubeheadervalue.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("vims_src_tmp/pp_getcubeheadervalue.html#pp_getcubeheadervalue", "pp_getcubeheadervalue", 'routine in <a href="vims_src_tmp/pp_getcubeheadervalue.html">pp_getcubeheadervalue.pro</a>', "pp_getcubeheadervalue.pro", "Paulo Penteado (pp.penteado@gmail.com), Oct/2009  ", "pp_getcubeheadervalue", "   Retrieves the value of the given key from the given header in ISIS cube format.   ", "not_trimmed      This routine needs that each line of the header is trimmed from       whitespaces on both sides. If the provided header is not trimmed, set       this keyword so that it will be trimmed before processing (the input       variable is unchanged). This option exists to save repeated trimming on       multiple queries of the same header, in which case it should be trimmed       before the multiple calls of this routine, for better efficiency.  count      The number of occurences of the key found in the header. If more than 1       is found, the last occurence is used by default. Check this value to determine if       the key was not found (count will be 0 in that case).  fold_case      Passed to stregex when searching for the key. If set, capitalization of       the key is ignored.  lines      The line index (starting at zero) of the line in the header that provided       the retrieved value. If valued spanned more than one line, this is a vector       with the indexes of all such lines. If key not found, -1 is returned.  unquote      If set, enclosing quotes are removed from the return values  sel      In case more than one ocurrence of a keyword is found, sel gives the       index of the ocurrence to use (starts at 0). If not set, the last ocurrence       is the one used.   continueblankheader      A string array where each element is one line of an ISIS cube.  key      A string scalar with the key to be retrieved. Regular expression metacharacters must be escaped.   ", "          -1", "    Make a simple example header: <span class= code-output > head=strarr(3)</span> <span class= code-output > head[0]='BAND_SUFFIX_NAME = (LATITUDE,LONGITUDE,SAMPLE_RESOLUTION,LINE_RESOLUTION,'</span> <span class= code-output > head[1]='PHASE_ANGLE,INCIDENCE_ANGLE,EMISSION_ANGLE,NORTH_AZIMUTH)'</span> <span class= code-output > head[2]='START_TIME =  2007-084T10:00:57.286Z '</span>     Get its values: <span class= code-output > print,pp_getcubeheadervalue(head,'BAND_SUFFIX_NAME')</span> <span class= code-output > ;LATITUDE LONGITUDE SAMPLE_RESOLUTION LINE_RESOLUTION PHASE_ANGLE INCIDENCE_ANGLE EMISSION_ANGLE NORTH_AZIMUTH</span> <span class= code-output > print,pp_getcubeheadervalue(head,'START_TIME')</span> <span class= code-output > ; 2007-084T10:00:57.286Z </span>  pp_extractfields     A string scalar or vector (depending on the value being scalar or not) with    the value of the given key from the header. If not found, returns 0. If the    value is a quoted string, the quotes are not removed.   ");
  
  

libdata[libdataItem++] = new Array("util/downloader/pp_jget.html", "pp_jget.pro", '.pro file in <a href="util/downloader/dir-overview.html">util/downloader/ directory</a>', "pp_jget.pro", "Paulo Penteado (http://www.ppenteado.net),  ", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/downloader/pp_jget.html#pp_jget", "pp_jget", 'routine in <a href="util/downloader/pp_jget.html">pp_jget.pro</a>', "pp_jget.pro", "Paulo Penteado (http://www.ppenteado.net),  ", "pp_jget", "    Simple function to retrieve a URL as a string array, similar to     IDLNetURL::get(). The purpose of this function is simply to avoid the segfault     that IDLNetURL::getftpdirlist() throws on some very specific URLs before     IDL 8.4.   ", "verboseurl      URL to download.   ", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/downloader/pp_parse_date.html", "pp_parse_date.pro", '.pro file in <a href="util/downloader/dir-overview.html">util/downloader/ directory</a>', "pp_parse_date.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/downloader/pp_parse_date.html#pp_parse_date", "pp_parse_date", 'routine in <a href="util/downloader/pp_parse_date.html">pp_parse_date.pro</a>', "pp_parse_date.pro", "Paulo Penteado (http://www.ppenteado.net)  ", "pp_parse_date", "    Parses date strings into julian dates. More formats will be supported in     the future. Example dates in currently supported formats:      Fri, 22 Jan 2016 18:03:25 GMT   ", "idstr      String(s) with date(s) to be converted to JD. Can be scalar or array.   ", "          -1", "   Convert Fri, 22 Jan 2016 18:03:25 GMT: <span class= code-output > print,pp_parse_date('Fri, 22 Jan 2016 18:03:25 GMT')</span> <span class= code-output > ;       2457410.3</span>    ");
  
  

libdata[libdataItem++] = new Array("vims_src_tmp/pp_read_isis.html", "pp_read_isis.pro", '.pro file in <a href="vims_src_tmp/dir-overview.html">vims_src_tmp/ directory</a>', "pp_read_isis.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("vims_src_tmp/pp_read_isis.html#pp_read_isis", "pp_read_isis", 'routine in <a href="vims_src_tmp/pp_read_isis.html">pp_read_isis.pro</a>', "pp_read_isis.pro", "", "pp_read_isis", "", "silentsamplenodatagffabscissareturned_samplesfilenamelabeludatadimtype_min_max", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/downloader/pp_readablesize.html", "pp_readablesize.pro", '.pro file in <a href="util/downloader/dir-overview.html">util/downloader/ directory</a>', "pp_readablesize.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/downloader/pp_readablesize.html#pp_readablesize", "pp_readablesize", 'routine in <a href="util/downloader/pp_readablesize.html">pp_readablesize.pro</a>', "pp_readablesize.pro", "Paulo Penteado (http://www.ppenteado.net)  ", "pp_readablesize", "    Converts a number of bytes into a more human-readable form, by expressing it     in KB, MB, GB or TB, depending on the value.   ", "units      The unit(s) corresponding to each converted size, as strings.  strs      A string version of the output, with the number(s) plus the unit strings.  string      If set, output has string(s) with the converted numbers plus the units.   sizes      Number(s) of bytes to be convertedo to KB/MB/GB/TB. Can be scalar or array.   ", "          -1", "   Convert a few values into strings with units: <span class= code-output > print,pp_readablesize([1023,1024,2d6,3d9],/string)</span> <span class= code-output > ; 1023.0000 B 1.0000000 KB 1.9073486 MB 2.7939677 GB</span>    Without units appended: <span class= code-output > print,pp_readablesize([1023,1024,2d6,3d9])</span> <span class= code-output > ; 1023.0000       1.0000000       1.9073486       2.7939677</span>  ");
  
  

libdata[libdataItem++] = new Array("vims_src_tmp/pp_readcube__define.html", "pp_readcube__define.pro", '.pro file in <a href="vims_src_tmp/dir-overview.html">vims_src_tmp/ directory</a>', "pp_readcube__define.pro", "Paulo Penteado (pp.penteado@gmail.com), Oct/2009  ", "", " ", "", "          -1", "pp_getcubeheadervalue, pp_extractfields, pp_buffered_vector  ");
  
  
  libdata[libdataItem++] = new Array("vims_src_tmp/pp_readcube__define.html#pp_readcube::init", "pp_readcube::init", 'routine in <a href="vims_src_tmp/pp_readcube__define.html">pp_readcube__define.pro</a>', "pp_readcube__define.pro", "Paulo Penteado (pp.penteado@gmail.com), Oct/2009  ", "pp_readcube::init", "    Provided with the name of the file, initializes the object reading the cube in it.   ", "special      Determines the type of special value replacement to use:        0 uses the default special values        1 uses the special values found in the header        2 disables special value replacement   file      The name of the file that contains the cube.   ", "          -1", "    See the example on pp_readcube__define.   ");
  
  libdata[libdataItem++] = new Array("vims_src_tmp/pp_readcube__define.html#pp_readcube::cleanup", "pp_readcube::cleanup", 'routine in <a href="vims_src_tmp/pp_readcube__define.html">pp_readcube__define.pro</a>', "pp_readcube__define.pro", "", "pp_readcube::cleanup", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("vims_src_tmp/pp_readcube__define.html#pp_readcube::parselabels", "pp_readcube::parselabels", 'routine in <a href="vims_src_tmp/pp_readcube__define.html">pp_readcube__define.pro</a>', "pp_readcube__define.pro", "", "pp_readcube::parselabels", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("vims_src_tmp/pp_readcube__define.html#pp_readcube::processdata", "pp_readcube::processdata", 'routine in <a href="vims_src_tmp/pp_readcube__define.html">pp_readcube__define.pro</a>', "pp_readcube__define.pro", "", "pp_readcube::processdata", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("vims_src_tmp/pp_readcube__define.html#pp_readcube::getspecialvalues", "pp_readcube::getspecialvalues", 'routine in <a href="vims_src_tmp/pp_readcube__define.html">pp_readcube__define.pro</a>', "pp_readcube__define.pro", "Paulo Penteado (pp.penteado@gmail.com), Oct/2009  ", "pp_readcube::getspecialvalues", "    Provides a structure with the special values to use in this cube,     determined by the special replacement mode selected when the object     was created (see documentation of the init method).   ", "default", "          -1", "    A structure where each field is one of the six special values:     VALID_MIN,NULL,LOW_REPR_SAT,LOW_INSTR_SAT,HIGH_INSTR_SAT,HIGH_REPR_SAT   ");
  
  libdata[libdataItem++] = new Array("vims_src_tmp/pp_readcube__define.html#pp_readcube_specialreplace", "pp_readcube_specialreplace", 'routine in <a href="vims_src_tmp/pp_readcube__define.html">pp_readcube__define.pro</a>', "pp_readcube__define.pro", "", "pp_readcube_specialreplace", "", "dataspecial", "          -1", "");
  
  libdata[libdataItem++] = new Array("vims_src_tmp/pp_readcube__define.html#pp_readcube::getexerpt", "pp_readcube::getexerpt", 'routine in <a href="vims_src_tmp/pp_readcube__define.html">pp_readcube__define.pro</a>', "pp_readcube__define.pro", "", "pp_readcube::getexerpt", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("vims_src_tmp/pp_readcube__define.html#pp_readcube::getproperty", "pp_readcube::getproperty", 'routine in <a href="vims_src_tmp/pp_readcube__define.html">pp_readcube__define.pro</a>', "pp_readcube__define.pro", "Paulo Penteado (pp.penteado@gmail.com), Oct/2009  ", "pp_readcube::getproperty", "    Retrieves parts of the data contained in the object. If keyword all is given,     returns all the properties as fields of a structure.   ", "all      A structure containing every property as a field with the same name as the corresponding keyword.  file      File from which the cube was read.  special      The special value replacement mode used when the data was processed: 0 for default special values,       1 for special values given in the header, 2 for no special value replacement.  labels      String array with one element for each line of the label part of the cube header.  history      String array with one element for each line of the history part of the cube header.  core      3D array with the core data values.  backplanes      3D array with the backplane values, if there are blackplanes, a null pointer otherwise.  sideplanes      3D array with the sideplane values, if there are sideplanes, a null pointer otherwise.  bottomplanes      3D array with the bottomplane values, if there are bottomplanes, a null pointer otherwise.  info      A structure with the cube parameters that were used to read it.  lines      The number of lines in the core.  bands      The number of bands in the core.  samples      The number of samples in the core.  nback      The number of backplanes in the suffix.  nside      The number of sideplanes in the suffix.  nbottom      The number of bottomplanes in the suffix.  rawdata      The unprocessed binary part of the cube.  wavelengths      A string array with the wavelength of each core band ('UNKNOWN's if not found).  backnames      A string array with the name of each backplane ('UNKNOWN_'+sindgen(nback) if not found).  sidenames      A string array with the name of each sideplane ('UNKNOWN_'+sindgen(nside) if not found).  bottomnames      A string array with the name of each bottomplane ('UNKNOWN_'+sindgen(nbottom) if not found).  units      A string with the wavelength unit of the core bands ('UNKNOWN' if not found).  backunits      A string array with the name of each backplane's unit ('UNKNOWN's if not found).  sideunits      A string array with the name of each sideplane's unit ('UNKNOWN's if not found).  bottomunits      A string array with the name of each bottomplane's unit ('UNKNOWN's if not found).  struct_backplanes      2D array of structures, each with one field for each backplane, if there are blackplanes, a null pointer otherwise.   npixelslatslons", "          -1", "    See the example on pp_readcube__define.       See keyword descriptions.   ");
  
  libdata[libdataItem++] = new Array("vims_src_tmp/pp_readcube__define.html#pp_readcube::getproperty", "pp_readcube::getproperty", 'routine in <a href="vims_src_tmp/pp_readcube__define.html">pp_readcube__define.pro</a>', "pp_readcube__define.pro", "Paulo Penteado (pp.penteado@gmail.com), Oct/2009  ", "pp_readcube::getproperty", "    Simple function wrapper for the routine method getproperty. Has the same keywords,     and retrieves the same values, but with function semantics instead of routine. Only     one keyword should be set, and the corresponding value is the function's return value.   ", "allfilespeciallabelshistorycorebackplanessideplanesbottomplanesinfolinesbandssamplesnbacknsidenbottomrawdatawavelengthsbacknamessidenamesbottomnamesunitsbackunitssideunitsbottomunits", "          -1", "    See the example on pp_readcube__define.   ");
  
  libdata[libdataItem++] = new Array("vims_src_tmp/pp_readcube__define.html#pp_readcube::getsuffixbyname", "pp_readcube::getsuffixbyname", 'routine in <a href="vims_src_tmp/pp_readcube__define.html">pp_readcube__define.pro</a>', "pp_readcube__define.pro", "Paulo Penteado (pp.penteado@gmail.com), Oct/2009  ", "pp_readcube::getsuffixbyname", "    Retrieves suffix planes by their names. If all suffix planes, or their names,     are to be retrieved, the getproperty method should be used instead. By default,     backplanes are retrieved, but sideplanes and bottomplanes can be returned if the     corresponding keyword is set.   ", "found      An integer array with the same number of elements as names, with the number       of suffix planes that match each given name. If more than one suffix plane has       the selected name, the first one is the one returned (though proper cubes should       not have multiple planes with the same name).  case_sensitive      If set, name matches are case-sensitive (though proper cubes should not have planes       the same name in different capitalizations).  side      By default, the search for the planes is done among the cube's backplanes. If this keyword is       set, sideplanes are used instead.  bottom      By default, the search for the planes is done among the cube's backplanes. If this keyword is       set, bottomplanes are used instead.  back      If set, the search for the planes is done among the cube's backplanes (default).   index      An integer array with the same number of elements as names, with the index of the returned       suffix planes that matched each given name. If more than one suffix plane has       the selected name, the first one is the one returned (though proper cubes should       not have multiple planes with the same name). When that plane was not found, the corresponding       index will be -1.  names      A scalar or string array with the name(s) of the suffix plane(s) to retrieve.       If more than one plane is returned, their order (in the 3rd dimension of the       returned array) is the same as the order of the names in this array.   ", "          -1", "    See the example on pp_readcube__define.       A 2D array (if only one plane is requested) or 3D array (if several planes) with     the names suffix planes. If one plane is not found, the corresponding array plane contains     either NaN (for real types) or special.null (for integer types).   ");
  
  libdata[libdataItem++] = new Array("vims_src_tmp/pp_readcube__define.html#pp_readcube::getbandbywavelength", "pp_readcube::getbandbywavelength", 'routine in <a href="vims_src_tmp/pp_readcube__define.html">pp_readcube__define.pro</a>', "pp_readcube__define.pro", "Paulo Penteado (pp.penteado@gmail.com), Oct/2009  ", "pp_readcube::getbandbywavelength", "    Retrieves one or more core bands from their wavelengths. The returned bands     are those with wavelength nearest to the ones provided, so they need not     match exactly.   ", "index      Returns the index of the band that matched each provided wavelength.   wavelengths      Returns the wavelength of the band that matched each provided wavelength.   wavs      A scalar or array with the value(s) of the wavelength(s) to search for.   ", "          -1", "    See the example on pp_readcube__define.       If only one wavelength is provided, returns a 2D array with that band.     If more than one wavelength is provided, the result is a 3D array, with the     3rd dimension being the bands.   ");
  
  libdata[libdataItem++] = new Array("vims_src_tmp/pp_readcube__define.html#pp_readcube::getbandbyindex", "pp_readcube::getbandbyindex", 'routine in <a href="vims_src_tmp/pp_readcube__define.html">pp_readcube__define.pro</a>', "pp_readcube__define.pro", "Paulo Penteado (pp.penteado@gmail.com), Oct/2009  ", "pp_readcube::getbandbyindex", "    Retrieves one or more core bands from their indexes.   ", "wavelengths      Returns the wavelength of the band that matched each provided index.   index      A scalar or array with the value(s) of the index(es) to search for.   ", "          -1", "    See the example on pp_readcube__define.       If only one index is provided, returns a 2D array with that band.     If more than one index is provided, the result is a 3D array, with the     3rd dimension being the bands.   ");
  
  libdata[libdataItem++] = new Array("vims_src_tmp/pp_readcube__define.html#pp_readcube::getfromheader", "pp_readcube::getfromheader", 'routine in <a href="vims_src_tmp/pp_readcube__define.html">pp_readcube__define.pro</a>', "pp_readcube__define.pro", "Paulo Penteado (pp.penteado@gmail.com), Oct/2009  ", "pp_readcube::getfromheader", "    Retrieves values contained in the label or history part of the cube header.     Just a wrapper for pp_getcubeheadervalue. See its documentation for details.   ", "history      If set, reading is done on the history part of the header, instead of the label part.  count      Passed to pp_getcubeheadervalue.       The number of occurences of the key found in the header. If more than 1       is found, the last occurence is used. Check this value to determine if       the key was not found (count will be 0 in that case).  fold_case      Passed to pp_getcubeheadervalue.       Passed to stregex when searching for the key. If set, capitalization of       the key is ignored.  lines      Passed to pp_getcubeheadervalue.       The line index (starting at zero) of the line in the header that provided       the retrieved value. If valued spanned more than one line, this is a vector       with the indexes of all such lines. If key not found, -1 is returned.  unquote      Passed to pp_getcubeheadervalue.       If set, enclosing quotes are removed from the return values  sel      Passed to pp_getcubeheadervalue.       In case more than one ocurrence of a keyword is found, sel gives the       index of the ocurrence to use (starts at 0). If not set, the last ocurrence       is the one used.   contkey      Key name to be retrieved.   ", "          -1", "    See the examples on pp_readcube__define and pp_getcubeheadervalue.   ");
  
  libdata[libdataItem++] = new Array("vims_src_tmp/pp_readcube__define.html#pp_readcube::_overloadBracketsRightSide", "pp_readcube::_overloadBracketsRightSide", 'routine in <a href="vims_src_tmp/pp_readcube__define.html">pp_readcube__define.pro</a>', "pp_readcube__define.pro", "Paulo Penteado (pp.penteado@gmail.com), Feb/2011  ", "pp_readcube::_overloadBracketsRightSide", "    Simple overloading to retrieve core bands, backplanes, or wavelenghts from the cube.      Only 1D is processed. If more than 1D is specified, !null is returned.   ", "isRangesub1sub2sub3sub4sub5sub6sub7sub8", "          -1", "    See the example on pp_readcube__define.       The returned value depends on the type of the index provided:      If the index is an integer type (including a range), a 2D or 3D array is returned,     with the corresponding core band(s).      If the index is of string type, then a 2D or 3D array with the corresponsing     backplane(s) is returned.      If the index is of type double, a 2D or 3D array is returned with the core bands     that have wavelength(s) closest to the wavelength(s) given by the subscript.      If the index is of type float, a 1D array is returned with the core wavelengths     that are nearest to the correspoinding given wavelength(s).   ");
  
  libdata[libdataItem++] = new Array("vims_src_tmp/pp_readcube__define.html#pp_readcube__define", "pp_readcube__define", 'routine in <a href="vims_src_tmp/pp_readcube__define.html">pp_readcube__define.pro</a>', "pp_readcube__define.pro", "Paulo Penteado (pp.penteado@gmail.com), Oct/2009  ", "pp_readcube__define", "     Object to read an ISIS cube.      Initialization parses the cube into the object, other methods retrieve parts of it.      Assumes that all suffix items are the same data type as core items.      Assumes that cube has 3 axes in BSQ order.      Assumes constant length records.      The only methods intended to be public are getproperty,getspecialvalues, getfromheader,     getsuffixbyname, and getbandbywavelength.   ", "", "          -1", "    To read the cube CM_1553510065_1_ir.cub: <span class= code-output > a=obj_new('pp_readcube','CM_1553510065_1_ir.cub')</span>     To get the core and its wavelengths: <span class= code-output > a-&gt;getproperty,core=core,wavelengths=wavs</span> <span class= code-output > print,min(wavs,max=mw),mw</span> <span class= code-output > ;0.88421000       5.1225000</span>     To get the backplanes and their names: <span class= code-output > a-&gt;getproperty,backplanes=back,backnames=bnames</span> <span class= code-output > print,bnames</span> <span class= code-output > ;LATITUDE LONGITUDE SAMPLE_RESOLUTION LINE_RESOLUTION PHASE_ANGLE INCIDENCE_ANGLE EMISSION_ANGLE NORTH_AZIMUTH</span>     To get the file name: <span class= code-output > print,a-&gt;getproperty(/file)</span> <span class= code-output > ;CM_1553510065_1_ir.cub</span>     To get all the properties at once: <span class= code-output >a-&gt;getproperty,all=a_all</span> <span class= code-output >;** Structure PP_READCUBE_ALL, 24 tags, length=98912, data length=98895:</span> <span class= code-output >;   FILE            STRING    'CM_1553510065_1_ir.cub'</span> <span class= code-output >;   SPECIAL         BYTE         0</span> <span class= code-output >;   LABELS          STRING    Array[268]</span> <span class= code-output >;   HISTORY         STRING    Array[479]</span> <span class= code-output >;   CORE            FLOAT     Array[1, 40, 256]</span> <span class= code-output >;   BACKPLANES      FLOAT     Array[1, 40, 8]</span> <span class= code-output >;   SIDEPLANES      POINTER   &lt;NullPointer&gt;</span> <span class= code-output >;   BOTTOMPLANES    POINTER   &lt;NullPointer&gt;</span> <span class= code-output >;   INFO            STRUCT    -&gt; PP_READCUBE_INFO Array[1]</span> <span class= code-output >;   LINES           LONG                40</span> <span class= code-output >;   SAMPLES         LONG                 1</span> <span class= code-output >;   BANDS           LONG               256</span> <span class= code-output >;   NBACK           LONG                 8</span> <span class= code-output >;   NSIDE           LONG                 0</span> <span class= code-output >;   NBOTTOM         LONG                 0</span> <span class= code-output >;   RAW             FLOAT     Array[1, 40, 264]</span> <span class= code-output >;   WAVELENGTHS     DOUBLE    Array[256]</span> <span class= code-output >;   BACKNAMES       STRING    Array[8]</span> <span class= code-output >;   SIDENAMES       POINTER   &lt;NullPointer&gt;</span> <span class= code-output >;   BOTTOMNAMES     POINTER   &lt;NullPointer&gt;</span> <span class= code-output >;   UNITS           STRING    'MICROMETER'</span> <span class= code-output >;   BACKUNITS       STRING    Array[8]</span> <span class= code-output >;   SIDEUNITS       POINTER   &lt;NullPointer&gt;</span> <span class= code-output >;   BOTTOMUNITS     POINTER   &lt;NullPointer&gt;</span>     To get the latitudes: <span class= code-output > lats=a-&gt;getsuffixbyname('LATITUDE')</span>     Or, equivalenty: <span class= code-output > lats=a['LATITUDE']</span>     To get the band with wavelength nearest to 2.1 (in the units used in the cube): <span class= code-output > selband=a-&gt;getbandbywavelength(2.1,wavelengths=selwavs)</span> <span class= code-output > print,selwavs</span> <span class= code-output > ;2.1003400</span>     Or, equivalently: <span class= code-output > selband=a[2.1d0]</span> <span class= code-output > selwavs=a[2.1]</span> <span class= code-output > print,selwavs</span> <span class= code-output > ;2.1003400</span>     To get the start time of the cube: <span class= code-output > print,a-&gt;getfromheader('START_TIME')</span> <span class= code-output > ; 2007-084T10:00:57.286Z </span>     Destroy the object when done with it: <span class= code-output > obj_destroy,a</span>  pp_getcubeheadervalue, pp_extractfields  ");
  
  

libdata[libdataItem++] = new Array("util/w10n/pp_w10n__define.html", "pp_w10n__define.pro", '.pro file in <a href="util/w10n/dir-overview.html">util/w10n/ directory</a>', "pp_w10n__define.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/w10n/pp_w10n__define.html#pp_w10n::init", "pp_w10n::init", 'routine in <a href="util/w10n/pp_w10n__define.html">pp_w10n__define.pro</a>', "pp_w10n__define.pro", "", "pp_w10n::init", "", "_ref_extrafile", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/w10n/pp_w10n__define.html#pp_w10n::getproperty", "pp_w10n::getproperty", 'routine in <a href="util/w10n/pp_w10n__define.html">pp_w10n__define.pro</a>', "pp_w10n__define.pro", "", "pp_w10n::getproperty", "", "_ref_extravariablesgeotiffindeximagedimensionsowd", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/w10n/pp_w10n__define.html#pp_w10n::_overloadBracketsRightSide", "pp_w10n::_overloadBracketsRightSide", 'routine in <a href="util/w10n/pp_w10n__define.html">pp_w10n__define.pro</a>', "pp_w10n__define.pro", "", "pp_w10n::_overloadBracketsRightSide", "", "isRangesub1sub2sub3sub4sub5sub6sub7sub8", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/w10n/pp_w10n__define.html#pp_w10n::getvar", "pp_w10n::getvar", 'routine in <a href="util/w10n/pp_w10n__define.html">pp_w10n__define.pro</a>', "pp_w10n__define.pro", "", "pp_w10n::getvar", "", "var", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/w10n/pp_w10n__define.html#pp_w10n::clearcache", "pp_w10n::clearcache", 'routine in <a href="util/w10n/pp_w10n__define.html">pp_w10n__define.pro</a>', "pp_w10n__define.pro", "", "pp_w10n::clearcache", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/w10n/pp_w10n__define.html#pp_w10n__define", "pp_w10n__define", 'routine in <a href="util/w10n/pp_w10n__define.html">pp_w10n__define.pro</a>', "pp_w10n__define.pro", "", "pp_w10n__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/w10n/pp_w10ndata__define.html", "pp_w10ndata__define.pro", '.pro file in <a href="util/w10n/dir-overview.html">util/w10n/ directory</a>', "pp_w10ndata__define.pro", "Paulo Penteado (http://www.ppenteado.net), Aug/2016  ", "", " Class to provide access to w10n data. Can handle authentication  through a URS server (https://urs.earthdata.nasa.gov/).   ", "", "          -1", "   Retrieve the variable TSurfAir from a AIRS granule. The EOSDIS server    requires URS authentication: <span class= code-output > f=pp_w10ndata('http://airsl2.gesdisc.eosdis.nasa.gov/pomegranate/Aqua_AIRS_Level2/AIRS2SUP.006/2002/244/AIRS.2002.09.01.001.L2.RetSup_IR.v6.0.7.0.G13207161125.hdf',/urs)</span> <span class= code-output > ts=f['TSurfAir']</span> <span class= code-output > ;Enter username for urs.earthdata.nasa.gov</span> <span class= code-output > ;Enter password for urs.earthdata.nasa.gov (it will show in the terminal, and possibly, in the IDL command history)</span> <span class= code-output > help,ts</span> <span class= code-output > ;TS              FLOAT     = Array[30, 45]</span>    Now that login was performed, the cookies from the URS server can be saved    for future use, without neeed to provide username and password again. Here    we will use the default cookie file location (~/.pp_w10ndatarc), but it can    be provided with the cookiefile keyword.       f.savecookies      f2=pp_w10ndata('http://airsl2.gesdisc.eosdis.nasa.gov/pomegranate/Aqua_AIRS_Level2/AIRS2SUP.006/2002/244/AIRS.2002.09.01.001.L2.RetSup_IR.v6.0.7.0.G13207161125.hdf',/urs,/cookiefile)      ts=f2['TSurfAir']      help,ts      ;TS              FLOAT     = Array[30, 45]     Thus authentication is only needed once, to create the cookies file.    There are two alternatives to typing the username/password interactively:    1) Provide them as keywords, and    2) Provide them in a .netrc file.    It is the same file that can be used by    wget. In this example, we will use the    default .netrc file location (~/.netrc), but an alternate location can    be provided with the netrc keyword: <span class= code-output > f3=pp_w10ndata('http://airsl2.gesdisc.eosdis.nasa.gov/pomegranate/Aqua_AIRS_Level2/AIRS2SUP.006/2002/244/AIRS.2002.09.01.001.L2.RetSup_IR.v6.0.7.0.G13207161125.hdf',/urs,/netrc)</span> <span class= code-output > ts=f3['TSurfAir']</span> <span class= code-output > ;pp_ursurl: trying authentication with netrc credentials provided</span> <span class= code-output > help,ts</span> <span class= code-output > ;TS              FLOAT     = Array[30, 45]</span>    Note that the host on the .netrc must be the one that does the authentication,    which is the URS server, urs.earthdata.nasa.gov, not the one that servers    the data. See https://wiki.earthdata.nasa.gov/display/HDD/Wget+with+URS+Authentication    for more information on URS authentication.   IDL 8.2, pp_ursurl__define, pp_readtxt, pp_parsenetrc, mg_getpassword   Caching, retrieving only selected indices, parsing file metadata  to provide a variable tree.   ");
  
  
  libdata[libdataItem++] = new Array("util/w10n/pp_w10ndata__define.html#pp_w10ndata::init", "pp_w10ndata::init", 'routine in <a href="util/w10n/pp_w10ndata__define.html">pp_w10ndata__define.pro</a>', "pp_w10ndata__define.pro", "", "pp_w10ndata::init", "", "cookiefilenetrcfileurs_ref_extradebugurl", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/w10n/pp_w10ndata__define.html#pp_w10ndata::_overloadBracketsRightSide", "pp_w10ndata::_overloadBracketsRightSide", 'routine in <a href="util/w10n/pp_w10ndata__define.html">pp_w10ndata__define.pro</a>', "pp_w10ndata__define.pro", "", "pp_w10ndata::_overloadBracketsRightSide", "", "isRangesub1sub2sub3sub4sub5sub6sub7sub8", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/w10n/pp_w10ndata__define.html#pp_w10ndata::getvar", "pp_w10ndata::getvar", 'routine in <a href="util/w10n/pp_w10ndata__define.html">pp_w10ndata__define.pro</a>', "pp_w10ndata__define.pro", "", "pp_w10ndata::getvar", "", "var", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/w10n/pp_w10ndata__define.html#pp_w10ndata::getvariables", "pp_w10ndata::getvariables", 'routine in <a href="util/w10n/pp_w10ndata__define.html">pp_w10ndata__define.pro</a>', "pp_w10ndata__define.pro", "", "pp_w10ndata::getvariables", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/w10n/pp_w10ndata__define.html#pp_w10ndata::getproperty", "pp_w10ndata::getproperty", 'routine in <a href="util/w10n/pp_w10ndata__define.html">pp_w10ndata__define.pro</a>', "pp_w10ndata__define.pro", "", "pp_w10ndata::getproperty", "", "_ref_extracookies", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/w10n/pp_w10ndata__define.html#pp_w10ndata::clearcache", "pp_w10ndata::clearcache", 'routine in <a href="util/w10n/pp_w10ndata__define.html">pp_w10ndata__define.pro</a>', "pp_w10ndata__define.pro", "", "pp_w10ndata::clearcache", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/w10n/pp_w10ndata__define.html#pp_w10ndata::savecookies", "pp_w10ndata::savecookies", 'routine in <a href="util/w10n/pp_w10ndata__define.html">pp_w10ndata__define.pro</a>', "pp_w10ndata__define.pro", "", "pp_w10ndata::savecookies", "", "file", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/w10n/pp_w10ndata__define.html#pp_w10ndata::readcookies", "pp_w10ndata::readcookies", 'routine in <a href="util/w10n/pp_w10ndata__define.html">pp_w10ndata__define.pro</a>', "pp_w10ndata__define.pro", "", "pp_w10ndata::readcookies", "", "file", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/w10n/pp_w10ndata__define.html#pp_w10ndata::readnetrc", "pp_w10ndata::readnetrc", 'routine in <a href="util/w10n/pp_w10ndata__define.html">pp_w10ndata__define.pro</a>', "pp_w10ndata__define.pro", "", "pp_w10ndata::readnetrc", "", "file", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/w10n/pp_w10ndata__define.html#pp_w10ndata__define", "pp_w10ndata__define", 'routine in <a href="util/w10n/pp_w10ndata__define.html">pp_w10ndata__define.pro</a>', "pp_w10ndata__define.pro", "", "pp_w10ndata__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/downloader/pp_wget__define.html", "pp_wget__define.pro", '.pro file in <a href="util/downloader/dir-overview.html">util/downloader/ directory</a>', "pp_wget__define.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/downloader/pp_wget__define.html#pp_wget::init", "pp_wget::init", 'routine in <a href="util/downloader/pp_wget__define.html">pp_wget__define.pro</a>', "pp_wget__define.pro", "Paulo Penteado (http://www.ppenteado.net)  ", "pp_wget::init", "    This class is used to provide functionality similar to the UNIX wget     or IDL's wget (introduced in IDL 8.5). The main differences relative     to IDL's wget is that timestamps of the downloaded files are set to match     the timestamps informed by the server, and the optional arguments, to control     things such as overwriting of existing files, recursivenes and regular expression     matching.   ", "clobber      If set to 0 (default), exisiting files with the same timestamp as that       returned by the server will be skipped. If set to 1, files will be downloaded,       even if overwriting existing local files. If set to 2, existing files will       be skipped, without checking the timestamp. Setting this argument to 1       is useful to resume an interrupted download of a directory.  pattern      A string with a regular expression that file names in the server will be       matched to. If provided, only those files matching this expression will be       downloaded.  recursive      If set and baseurl is a directory, all directories contained inside it       will be recursively downloaded.  localdir      Local directory where the downloaded files are to be stored. Defaults to the       current directory.  debugtimestamps      If provided, a hash (empty or not) where the timestamps of the downloaded       files will be stored. Such a hash is always created internally and can be       retrieved as a property (called timestamps). The reason to provide a hash       is to have the timestamps be appended to this hash, instead of having a new       hash created.  bdir      For internal use by recursive calls only.  xpattern      A string with a regular expression that file names in the server will be       matched to. If provided, only those files NOT matching this expression will be       downloaded.  absolute_paths      If set, the timestamps hash will contain absolute paths instead of relative paths.   _ref_extrassl_certificate_filesplitrowsallow_slashlmtzquietftpwmdonlybaseurl", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/downloader/pp_wget__define.html#pp_wget_callback", "pp_wget_callback", 'routine in <a href="util/downloader/pp_wget__define.html">pp_wget__define.pro</a>', "pp_wget__define.pro", "Paulo Penteado (http://www.ppenteado.net)  ", "pp_wget_callback", "    Internal function, inteded to be used by pp_wget::geturl.   ", "StatusInfoProgressInfoCallbackData", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/downloader/pp_wget__define.html#pp_wget::setproperty", "pp_wget::setproperty", 'routine in <a href="util/downloader/pp_wget__define.html">pp_wget__define.pro</a>', "pp_wget__define.pro", "", "pp_wget::setproperty", "", "last_modifiedcontent_lengthtzhlmquietmdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/downloader/pp_wget__define.html#pp_wget::getproperty", "pp_wget::getproperty", 'routine in <a href="util/downloader/pp_wget__define.html">pp_wget__define.pro</a>', "pp_wget__define.pro", "", "pp_wget::getproperty", "", "local_file_tmclobberdebugcontent_lengthlocal_file_existstimestampslast_modifiedtzhlmquietmdonlymdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/downloader/pp_wget__define.html#pp_wget::geturl", "pp_wget::geturl", 'routine in <a href="util/downloader/pp_wget__define.html">pp_wget__define.pro</a>', "pp_wget__define.pro", "Paulo Penteado (http://www.ppenteado.net)  ", "pp_wget::geturl", "    Starts the download of the URL set when the object was instantiated.   ", "listonly", "          -1", "    Download all files at ,skipping exisiting files, recursively:   ");
  
  libdata[libdataItem++] = new Array("util/downloader/pp_wget__define.html#pp_wget::retrieve", "pp_wget::retrieve", 'routine in <a href="util/downloader/pp_wget__define.html">pp_wget__define.pro</a>', "pp_wget__define.pro", "Paulo Penteado (http://www.ppenteado.net)  ", "pp_wget::retrieve", "    Internal function, inteded to be used by pp_wget::geturl.   ", "lmskip_missinglink", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/downloader/pp_wget__define.html#pp_wget__define", "pp_wget__define", 'routine in <a href="util/downloader/pp_wget__define.html">pp_wget__define.pro</a>', "pp_wget__define.pro", "Paulo Penteado (http://www.ppenteado.net)  ", "pp_wget__define", "    Type definition for pp_wget. See the documentation on pp_wget::init.   ", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/downloader/pp_wgetcl.html", "pp_wgetcl.pro", '.pro file in <a href="util/downloader/dir-overview.html">util/downloader/ directory</a>', "pp_wgetcl.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/downloader/pp_wgetcl.html#pp_wgetcl", "pp_wgetcl", 'routine in <a href="util/downloader/pp_wgetcl.html">pp_wgetcl.pro</a>', "pp_wgetcl.pro", "Paulo Penteado (http://www.ppenteado.net), Dec/2016  ", "pp_wgetcl", "    A wrapper to pp_wget, to be called from the system command line. Any arguments     are passed on to pp_wget, except for the timestamps argument, which specifies     a file where the timestamps of the downloaded files are to be stored.      See the documentation for pp_wget__define for its optional arguments.      Example: <span class= code-output > From the command line (outside IDL), download some files non recursively</span> <span class= code-output > and save the timestamps to the file pp_wgetcl_timestamps.json:</span> <span class= code-output > idl -e pp_wgetcl -args http://naif.jpl.nasa.gov/pub/naif/CASSINI/kernels/lsk/ --timestamps=pp_wgetcl_timestamps.json --clobber</span>       The files are downloaded to the local directory (pp_wget's default location),       and the timestamps look like: <span class= code-output > ;{</span> <span class= code-output > ; naif0007.tls : 2451644.2442013896,</span> <span class= code-output > ; naif0010.tls : 2455945.6274537044,</span> <span class= code-output > ; naif0011.tls : 2457035.4201967600,</span> <span class= code-output > ; naif0012.tls : 2457603.9250231488,</span> <span class= code-output > ; naif0008.tls : 2453588.2689467599,</span> <span class= code-output > ; naif0009.tls : 2454669.5206018523,</span> <span class= code-output > ; aareadme.txt : 2452662.3099884265</span> <span class= code-output > ;}</span>   ", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/prod.html", "prod.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "prod.pro", "", "", " NAME:        prod    PURPOSE:        Computes the product of the elements of the given array.    CATEGORY:        UTIL    CALLING SEQUENCE:        result = prod(array, dim)    ARGUMENTS:   INPUT:        array:  An input array           dim:  The dimension over which to multiply.    OUTPUT:        NONE   KEYWORDS:        NONE    RETURN:        The product of all the elements in the array.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/prod.html#prod", "prod", 'routine in <a href="util/prod.html">prod.pro</a>', "prod.pro", "", "prod", "", "arraydim", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/product.html", "product.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "product.pro", "", "", " NAME:        product    PURPOSE:        Computes the slow product of the elements of the given array. 	This routine gives better results than prod for input arrays of integer 	types with small numbers of elements.    CATEGORY:        UTIL    CALLING SEQUENCE:        result = product(array)    ARGUMENTS:   INPUT:        array:  An input array    OUTPUT:        NONE   KEYWORDS:        NONE    RETURN:        The product of all the elements in the array.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/product.html#product", "product", 'routine in <a href="util/product.html">product.pro</a>', "product.pro", "", "product", "", "array", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/project_map.html", "project_map.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "project_map.pro", "", "", " NAME:        project_map    PURPOSE:        Reprojects images.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        result = project_map(image, md=md, cd=cd, bx=bx, sund=sund, $                             pc_xsize, pc_ysize, $                             hide_fn=hide_fn, hide_data_p=hide_data_p)   ARGUMENTS:   INPUT:           image:     Array (xsize,ysize,nplanes) giving the image(s) to 		      reproject.         pc_xsize:     x size of map workspace         pc_ysize:     y size of map workspace  	bounds:	      Projection bounds specified as [lat0, lat1, lon0, lon1].     OUTPUT:        NONE   KEYWORDS:   INPUT: 	md:	Map descriptor.  	cd:	Camera descriptor.  	bx:	Body descriptor.  If two descriptors given, then the 		first is used with the cd input and the second is used with 		the map input.  	sund:	Star descriptor for the sun.  If not given, the dark side 		is mapped.  If two descriptors given, then the 		first is used with the cd input and the second is used with 		the map input.  	hide_fn:	Array of hide functions, e.g. 'pm_hide_ring'  	hide_data_p:	Array of hide data pointers, e.g. nv_ptr_new(rd)  	offset:	Offset in [lat,lon] to apply to map coordinates before 		projecting.  	interp:	Type of interpolation, see image_interp_cam.  	arg_interp:	Interpolation argument, see image_interp_cam.  	roi:	Subscripts in the output map specifying the map region 		to project, instead of the whole thing.  	edge:	Number of pixels to exclude from edge of the input image.  	smooth:	If set, the input image is smoothed before reprojection.   OUTPUT: 	NONE    RETURN:        Array (xsize,ysize,nplanes) giving the reprojected image(s).    MODIFICATION HISTORY:        Written by:     Spitale, 6/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/project_map.html#pm_hide_ring", "pm_hide_ring", 'routine in <a href="nv/obj/tools/project_map.html">project_map.pro</a>', "project_map.pro", "", "pm_hide_ring", "", "rdmap_image_ptscam_image_ptssurface_ptsbody_ptspos_cam", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/tools/project_map.html#pm_hide_globe", "pm_hide_globe", 'routine in <a href="nv/obj/tools/project_map.html">project_map.pro</a>', "project_map.pro", "", "pm_hide_globe", "", "xdmap_image_ptscam_image_ptssurface_ptsbody_ptspos_cam", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/tools/project_map.html#pm_rm_globe", "pm_rm_globe", 'routine in <a href="nv/obj/tools/project_map.html">project_map.pro</a>', "project_map.pro", "", "pm_rm_globe", "", "xdmap_image_ptscam_image_ptssurface_ptsbody_ptspos_cam", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/tools/project_map.html#pm_rm_globe", "pm_rm_globe", 'routine in <a href="nv/obj/tools/project_map.html">project_map.pro</a>', "project_map.pro", "", "pm_rm_globe", "", "xdmap_image_ptscam_image_ptssurface_ptsbody_ptspos_cam", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/tools/project_map.html#pm_bounds", "pm_bounds", 'routine in <a href="nv/obj/tools/project_map.html">project_map.pro</a>', "project_map.pro", "", "pm_bounds", "", "boundssurface_pts", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/tools/project_map.html#pm_hide_points_limb", "pm_hide_points_limb", 'routine in <a href="nv/obj/tools/project_map.html">project_map.pro</a>', "project_map.pro", "", "pm_hide_points_limb", "", "bxpos_cambody_pts", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/tools/project_map.html#pm_wind_zonal", "pm_wind_zonal", 'routine in <a href="nv/obj/tools/project_map.html">project_map.pro</a>', "project_map.pro", "", "pm_wind_zonal", "", "bxmap_ptswind_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/tools/project_map.html#pm_wind_kepler", "pm_wind_kepler", 'routine in <a href="nv/obj/tools/project_map.html">project_map.pro</a>', "project_map.pro", "", "pm_wind_kepler", "", "bxmap_ptswind_data", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/tools/project_map.html#project_map", "project_map", 'routine in <a href="nv/obj/tools/project_map.html">project_map.pro</a>', "project_map.pro", "", "project_map", "", "mdcdbxsundboundshitvaluehide_fnhide_data_proiinterparg_interpoffsetwind_fnwind_dataedgesmoothimage_pc_xsize_pc_ysize", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/abbrev/pt.html", "pt.pro", '.pro file in <a href="util/abbrev/dir-overview.html">util/abbrev/ directory</a>', "pt.pro", "", "", " NAME: 	pt   PURPOSE: 	Abbreviation for the nv_ptr_new() function   CATEGORY:        UTIL/ABBREV  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/abbrev/pt.html#pt", "pt", 'routine in <a href="util/abbrev/pt.html">pt.pro</a>', "pt.pro", "", "pt", "", "x", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/ptloc.html", "ptloc.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "ptloc.pro", "", "", " NAME:        ptloc    PURPOSE:        Locates a point in an image that best fits a psf model.    CATEGORY:        UTIL    CALLING SEQUENCE:        result = ptloc(image, model, width)    ARGUMENTS:   INPUT:        image:  Image, or subimage in which to find the point.                Size of image should be at least width + size of model.         model:  Model of the point spread function.         width:  Width of box around calculated point in which to                find the point.    OUTPUT: 	sigma:	Position uncertainty.           ccp:  The correlation coefficient at the point found.    RETURN:        The point (x,y) in the image that best fits the model.    PROCEDURE:        The correlation between the image and the model is calculated. 	If possible, a gaussian is fit to the correlation peak and the 	sub-pixel location of the center of the gaussian is the result. 	If that fit does not converge, then the location of the pixel with 	the maximum correlation is returned and a warning is printed.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Haemmerle, 6/1998 	Modified:	Spitale, 9/2002 -- Fit to gaussian to determine 				  subpixel location of correlation peak.   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/ptloc.html#ptloc", "ptloc", 'routine in <a href="util/ptloc.html">ptloc.pro</a>', "ptloc.pro", "", "ptloc", "", "ccpsigmachisqstatusroundspikeimagemodelwidth", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/ptr_copy_recurse.html", "ptr_copy_recurse.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "ptr_copy_recurse.pro", "", "", " NAME: 	ptr_copy_recurse    PURPOSE: 	Copies data from the given pointer and from all pointers pointed to 	by it.    CATEGORY: 	UTIL    CALLING SEQUENCE: 	result = ptr_copy_recurse(p)    ARGUMENTS:   INPUT: 	p:	Pointer to be copied.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	NONE    OUTPUT: 	NONE    STATUS: 	xx    MODIFICATION HISTORY:  	Written by:	Spitale,  6/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/ptr_copy_recurse.html#pcr_recurse", "pcr_recurse", 'routine in <a href="util/ptr_copy_recurse.html">ptr_copy_recurse.pro</a>', "ptr_copy_recurse.pro", "", "pcr_recurse", "", "p", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/ptr_copy_recurse.html#ptr_copy_recurse", "ptr_copy_recurse", 'routine in <a href="util/ptr_copy_recurse.html">ptr_copy_recurse.pro</a>', "ptr_copy_recurse.pro", "", "ptr_copy_recurse", "", "p", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/ptr_free_recurse.html", "ptr_free_recurse.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "ptr_free_recurse.pro", "", "", " NAME: 	nv_ptr_free_recurse    PURPOSE: 	Frees the given pointer and all pointers pointed to by it.    CATEGORY: 	UTIL    CALLING SEQUENCE: 	nv_ptr_free_recurse, p    ARGUMENTS:   INPUT: 	p:	Pointer to be freed.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	NONE    OUTPUT: 	NONE    STATUS: 	Not complete, currently just frees the given pointer.    MODIFICATION HISTORY:  	Written by:	Spitale,  5/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/ptr_free_recurse.html#pfr_recurse", "pfr_recurse", 'routine in <a href="util/ptr_free_recurse.html">ptr_free_recurse.pro</a>', "ptr_free_recurse.pro", "", "pfr_recurse", "", "p", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/ptr_free_recurse.html#nv_ptr_free_recurse", "nv_ptr_free_recurse", 'routine in <a href="util/ptr_free_recurse.html">ptr_free_recurse.pro</a>', "ptr_free_recurse.pro", "", "nv_ptr_free_recurse", "", "p", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/pwd.html", "pwd.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "pwd.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/pwd.html#pwd", "pwd", 'routine in <a href="util/pwd.html">pwd.pro</a>', "pwd.pro", "", "pwd", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/pwplot.html", "pwplot.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "pwplot.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/pwplot.html#pwplot", "pwplot", 'routine in <a href="util/pwplot.html">pwplot.pro</a>', "pwplot.pro", "", "pwplot", "", "psymsymsizecolorwrapthick_x_y", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/pythag.html", "pythag.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "pythag.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/pythag.html#pythag", "pythag", 'routine in <a href="util/pythag.html">pythag.pro</a>', "pythag.pro", "", "pythag", "", "values", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/quadsolve.html", "quadsolve.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "quadsolve.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/quadsolve.html#qus_fn", "qus_fn", 'routine in <a href="util/quadsolve.html">quadsolve.pro</a>', "quadsolve.pro", "", "qus_fn", "", "x", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/quadsolve.html#quadsolve", "quadsolve", 'routine in <a href="util/quadsolve.html">quadsolve.pro</a>', "quadsolve.pro", "", "quadsolve", "", "validnorootsabc", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/qubepds.html", "qubepds.pro", '.pro file in <a href="config/pds/Readpds_4.4/dir-overview.html">config/pds/Readpds_4.4/ directory</a>', "qubepds.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/qubepds.html#extract_qube_keywords", "extract_qube_keywords", 'routine in <a href="config/pds/Readpds_4.4/qubepds.html">qubepds.pro</a>', "qubepds.pro", "", "extract_qube_keywords", "", "start_indend_indlabelparamrequired", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/qubepds.html#check_qube_keywords", "check_qube_keywords", 'routine in <a href="config/pds/Readpds_4.4/qubepds.html">qubepds.pro</a>', "qubepds.pro", "", "check_qube_keywords", "", "keywds", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/qubepds.html#obtain_current_qube_params", "obtain_current_qube_params", 'routine in <a href="config/pds/Readpds_4.4/qubepds.html">qubepds.pro</a>', "qubepds.pro", "", "obtain_current_qube_params", "", "start_indend_indlabel", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/qubepds.html#obtain_qube_architecture", "obtain_qube_architecture", 'routine in <a href="config/pds/Readpds_4.4/qubepds.html">qubepds.pro</a>', "qubepds.pro", "", "obtain_qube_architecture", "", "type", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/qubepds.html#obtain_item_idltype", "obtain_item_idltype", 'routine in <a href="config/pds/Readpds_4.4/qubepds.html">qubepds.pro</a>', "qubepds.pro", "", "obtain_item_idltype", "", "typebytes", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/qubepds.html#obtain_qube_structure", "obtain_qube_structure", 'routine in <a href="config/pds/Readpds_4.4/qubepds.html">qubepds.pro</a>', "qubepds.pro", "", "obtain_qube_structure", "", "keywds", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/qubepds.html#read_qube_data", "read_qube_data", 'routine in <a href="config/pds/Readpds_4.4/qubepds.html">qubepds.pro</a>', "qubepds.pro", "", "read_qube_data", "", "pointerstructarch", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/qubepds.html#convert_qube_data", "convert_qube_data", 'routine in <a href="config/pds/Readpds_4.4/qubepds.html">qubepds.pro</a>', "qubepds.pro", "", "convert_qube_data", "", "currentlabelstart_indend_indkeywdsnoscale", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/qubepds.html#process_all_qubes", "process_all_qubes", 'routine in <a href="config/pds/Readpds_4.4/qubepds.html">qubepds.pro</a>', "qubepds.pro", "", "process_all_qubes", "", "filenamelabelobjectssilentnoscale", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/qubepds.html#qubepds", "qubepds", 'routine in <a href="config/pds/Readpds_4.4/qubepds.html">qubepds.pro</a>', "qubepds.pro", "", "qubepds", "", "SILENTNOSCALEfilenamelabel", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/ra_to_xyz.html", "ra_to_xyz.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "ra_to_xyz.pro", "", "", " NAME:        ra_to_xyz    PURPOSE: 	Convert array of RA and DEC to an array of 1x3 position vectors    CATEGORY:        UTIL    CALLING SEQUENCE:        ra_to_xyz, ra, dec, pos    ARGUMENTS:   INPUT:         ra:	Array of Right Ascensions (in degrees)         dec:	Array of Declinations (in degrees)    OUTPUT:        pos:	An array of 1x3 column vectors dimensioned (1,3,n)   KEYWORDS:         NONE   RETURN:         An array of n 1x3 column vectors.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Haemmerle 6/2000   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/ra_to_xyz.html#ra_to_xyz", "ra_to_xyz", 'routine in <a href="util/ra_to_xyz.html">ra_to_xyz.pro</a>', "ra_to_xyz.pro", "", "ra_to_xyz", "", "radecpos", "          -1", "");
  
  

libdata[libdataItem++] = new Array("demo/radar_example.html", "radar_example.pro", '.pro file in <a href="demo/dir-overview.html">demo/ directory</a>', "radar_example.pro", "", "", " RADAR EXAMPLE     This script demonstrates reading a Cassini RADAR SAR image and projecting it    onto an orthographical map for display.     The data file used, BIFQI22N068_D045_T003S01_V02.IMG, is too large (202 MB)    to include with the OMINAS distribution. This script will look for the file    under ~/ominas_data/sar/, and if not found, will download it from    PDS&lt;http://pds-imaging.jpl.nasa.gov/data/cassini/cassini_orbiter/CORADR_0045/DATA/BIDR/BIFQI22N068_D045_T003S01_V02.ZIP&gt;,    then unzip it.     Setup: The instrument detectors, translators and transforms must contain the    RADAR definitions, as is included in demo/data/instrument_detectors.tab,    demo/data/translators.tab, and demo/data/transforms.tab. Since the RADAR    data is in PDS format, the PDS detector and io functions must also be set up    in the corresponding tables, as is in config/tab/filetype_detectors.tab    and config/tab/io.tab.     There is no need for SPICE/Icy for this example. It can be run just by doing: <span class= code-output > .run radar_example</span>    From within an OMINAS IDL session.    Read SAR file     Cassini RADAR SAR image to read must be set in the variable img, otherwise    this default location is used: <span class= code-output > ;Download the file, if needed</span> <span class= code-output > ldir='~/ominas_data/sar'</span> <span class= code-output > spawn,'eval echo '+ldir,res</span> <span class= code-output > ldir=res</span> <span class= code-output > img=ldir+path_sep()+'BIFQI22N068_D045_T003S01_V02.IMG'</span> <span class= code-output > if ~file_test(img,/read) then begin</span> <span class= code-output >   print,'SAR file needed for the demo not found. Downloading it from PDS...'</span> <span class= code-output >   p=pp_wget('http://pds-imaging.jpl.nasa.gov/data/cassini/cassini_orbiter/CORADR_0045/DATA/BIDR/BIFQI22N068_D045_T003S01_V02.ZIP',localdir=ldir)</span> <span class= code-output >   p.geturl</span> <span class= code-output >   print,'ZIP file downloaded, decompressing it...'</span> <span class= code-output >   file_unzip,ldir+path_sep()+'CORADR_0045/DATA/BIDR/BIFQI22N068_D045_T003S01_V02.ZIP',/verbose</span> <span class= code-output > endif</span>  <span class= code-output > ;Read the file</span> <span class= code-output > dd=dat_read(img)</span>  ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("nv/obj/tools/radec_angle.html", "radec_angle.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "radec_angle.pro", "", "", " NAME:        radec_angle    PURPOSE: 	Computes angles between vectors specified in the radec system.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        angle = radec_angle(radec1, radec2)    ARGUMENTS:   INPUT: 	radec1:	Array (nv,3,nt) giving the radec representation of the 		first vector.  	radec2:	Array (nv,3,nt) giving the radec representation of the 		second vector.    OUTPUT:  NONE    KEYOWRDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (nv,nt) of angles between the input vectors.     MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/radec_angle.html#radec_angle", "radec_angle", 'routine in <a href="nv/obj/tools/radec_angle.html">radec_angle.pro</a>', "radec_angle.pro", "", "radec_angle", "", "radec1radec2", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/radec_grid.html", "radec_grid.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "radec_grid.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/radec_grid.html#radec_grid", "radec_grid", 'routine in <a href="nv/obj/tools/radec_grid.html">radec_grid.pro</a>', "radec_grid.pro", "", "radec_grid", "", "nnpcd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/radec_image_bounds.html", "radec_image_bounds.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "radec_image_bounds.pro", "", "", " NAME:        radec_image_bounds    PURPOSE: 	Determines radec coordinate ranges visible in an image described 	by a given camera descriptor.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        radec_image_bounds, cd, $ 	        ramin=ramin, ramax=ramax, decmin=decmin, decmax=decmax    ARGUMENTS:   INPUT: 	cd:	Camera descripor.    OUTPUT:  NONE    KEYOWRDS:   INPUT: 	corners:	Array(2,2) giving corers of image region to consider.  	slop:	Number of pixels by which to expand the image in each 		direction.     OUTPUT: 	ramin:	Minimum RA in image.  	ramax:	Maximum RA in image.  	decmin:	Minimum DEC in image.  	decmax:	Maximum DEC in image.  	border_pts_im:	Array (2,np) of points along the edge of the image.  	status:	-1 if no globe in the image, 0 otherwise.    RETURN: NONE    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/radec_image_bounds.html#radec_image_bounds", "radec_image_bounds", 'routine in <a href="nv/obj/tools/radec_image_bounds.html">radec_image_bounds.pro</a>', "radec_image_bounds.pro", "", "radec_image_bounds", "", "slopborder_pts_imraminramaxdecmindecmaxcornersstatuscd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/composite/radec_to_image.html", "radec_to_image.pro", '.pro file in <a href="nv/obj/tools/composite/dir-overview.html">nv/obj/tools/composite/ directory</a>', "radec_to_image.pro", "", "", " NAME:        radec_to_image    PURPOSE:        Transforms points in polar ra/dec coords w.r.t the inertial frame 	to image coords.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = radec_to_image(cd, p)    ARGUMENTS:   INPUT: 	cd:	Array of nt camera descriptors.  	p:	Array (nv x 3 x nt) of radec points    OUTPUT:        NONE   KEYWORDS:    INPUT: NONE     OUTPUT: 	body_pts:	Body coordinates of output points.    RETURN:        Array (2 x nv x nt) of image points.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale 3/2002  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/composite/radec_to_image.html#radec_to_image", "radec_to_image", 'routine in <a href="nv/obj/tools/composite/radec_to_image.html">radec_to_image.pro</a>', "radec_to_image.pro", "", "radec_to_image", "", "body_ptscdp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/radec_to_orient.html", "radec_to_orient.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "radec_to_orient.pro", "", "", " NAME:        radec_to_orient    PURPOSE: 	Computes orientation matrices such that the optic axis (axis 1) 	points in the direction of the given radec and the image y direction 	(axis 2) points toward celestial north (inertial [0,0,1]).    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        M = radec_to_orient(radec)    ARGUMENTS:   INPUT: 	radec:	Array (nt) giving the radec representations of the 		pointing vectors.    OUTPUT:  NONE    KEYOWRDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (3,3,nt) of orientation matrices.     MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/radec_to_orient.html#radec_to_orient", "radec_to_orient", 'routine in <a href="nv/obj/tools/radec_to_orient.html">radec_to_orient.pro</a>', "radec_to_orient.pro", "", "radec_to_orient", "", "radec", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/radec_twist_to_cd.html", "radec_twist_to_cd.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "radec_twist_to_cd.pro", "", "", " NAME:        radec_twist_to_cd    PURPOSE:        Computes a camera orietation matrix from thegiven Euler angles.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        radec_twist_to_cd, ra, dec, twist, cd=cd    ARGUMENTS:   INPUT:        ra:	Right ascension relative to the inertial frame.  	dec:	Declination relative to the inertial frame.  	twist:	Twist angle relative to the inertial frame.    OUTPUT:        NONE    KEYOWRDS:   INPUT: 	cd:	Array (nt) of initial camera descriptors.  This 		argument must contain a valid camera descriptor 		upon calling this routine.    OUTPUT: 	cd:	Array (nt) of camera descriptors with new 		orientations.    RETURN: NONE    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/radec_twist_to_cd.html#radec_twist_to_cd", "radec_twist_to_cd", 'routine in <a href="nv/obj/tools/radec_twist_to_cd.html">radec_twist_to_cd.pro</a>', "radec_twist_to_cd.pro", "", "radec_twist_to_cd", "", "cdradectwist", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/ray_points.html", "ray_points.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "ray_points.pro", "", "", " NAME:        ray_points    PURPOSE:        Computes points along rays.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        ray_pts = ray_points(r, v, np, dp)    ARGUMENTS:   INPUT:        r:	Array (nt) of inertial ray origins.         v:	Array (nt) of inertial ray directions, of unit length.  	np:	Number of points to compute on each ray.  	dp:	Point spacing.    OUTPUT:        NONE    KEYOWRDS:   INPUT: 	cd:	Optional array (nt) of camera descriptors.    OUTPUT: NONE   RETURN: 	If no camera descriptor is given, an array (np,3,nt) of inertial 	position vectors is returned.  If cd is given, an array (2,np,nt) 	of image points is returned.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/ray_points.html#ray_points", "ray_points", 'routine in <a href="nv/obj/tools/ray_points.html">ray_points.pro</a>', "ray_points.pro", "", "ray_points", "", "cdrvnpdp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/ray_sub_point_graphic.html", "ray_sub_point_graphic.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "ray_sub_point_graphic.pro", "", "", " NAME: 	ray_sub_point_graphic    PURPOSE: 	Iterates to find the point on the surface of the globe where the 	given ray is closest to the surface.   CATEGORY: 	NV/LIB/TOOLS    CALLING SEQUENCE:     result = ray_sub_point_graphic(gbx, v, r)    ARGUMENTS:   INPUT: 	gbx:	Any subclass of GLOBE.  	v:	Array (nv,3) giving the ray origins in the BODY frame.  	r:	Array (nv,3) giving the ray directions in the BODY frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	normal:	Array (nv,3) of surface normals at each closest 	approach.    RETURN: 	Array (nv,3) of closest approach poitns in the BODY frame.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/ray_sub_point_graphic.html#ray_sub_point_graphic", "ray_sub_point_graphic", 'routine in <a href="nv/obj/tools/ray_sub_point_graphic.html">ray_sub_point_graphic.pro</a>', "ray_sub_point_graphic.pro", "", "ray_sub_point_graphic", "", "vvnormalpdvr", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/raytrace.html", "raytrace.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "raytrace.pro", "", "", " NAME: 	raytace    PURPOSE: 	Traces rays from a camera to a set of objects.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	raytrace, image_pts, cd=cd, bx=bx		; For primary rays 		hit_matrix=hit_matrix, $ 		hit_indices=hit_indices, $ 		range_matrix=range_matrix, hit_list=hit_list  	raytrace, bx=bx, sbx=sbx, $			; For secondary rays 		hit_matrix=hit_matrix, $ 		hit_indices=hit_indices, $ 		range_matrix=range_matrix, hit_list=hit_list    ARGUMENTS:   INPUT: 	image_pts:  Array (2,np) of image points relative to cd.  These 	            points will be turned into rays to be traced from the 	            position of the camera.    OUTPUT: NONE    KEYWORDS:   INPUT: 	cd:	       Camera descriptor.  	bx:	       Array of object descriptors; must be a subclass of BODY.  	sbx:           Body descriptor for secondary ray tracing.  If set, 	               image_pts and cd are not used; instead, secondary rays 	               are traced from the given hit_matrix points to sbx.  	hit_matrix:    Body-frame points from prior call, to be used as 	               source points for secondary rays.  	hit_indices:   Body index for each secondary ray.  	limit_source : If set, secondary vectors originating on a given 	               body are not considered for targets that are the 	               same body.  Default is off.  	standoff:      If given, secondary vectors are advanced by this distance 	               before tracing in order to avoid hitting target bodies 	               through round-off error.  Default is 1 unit.  	penumbra:      If set, lighting rays are traced to random points on 	               each secondary body rather then the center.      OUTPUT: 	hit_list:     Array (nhit) giving indices of all bx that have ray 	              intersections.  	hit_indices:  Array (nray) of body indices corresponding to the first 	              intersection for each ray.  	hit_matrix:   Array (nray,3,nhit) of body-frame points for nearest 	              ray intersections.  	range_matrix: Array (nhit,nray) giving distance to the near-side 	              ray intersection for each body in the hit_matrix.  	far_matrix:   Array (nray,3,nhit) of body-frame points for all 	              far-side intersections with bodies in the hit_list.  	near_matrix:   Array (nray,3,nhit) of body-frame points for all 	               near-side intersections with bodies in the hit_list.    RETURN: NONE    PROCEDURE:     EXAMPLE:    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/raytrace.html#raytrace", "raytrace", 'routine in <a href="nv/obj/tools/raytrace.html">raytrace.pro</a>', "raytrace.pro", "", "raytrace", "", "cdbxsbxhit_matrixshowpenumbrahit_indicesrange_matrixhit_listfar_matrixnear_matrixbackstandofflimit_sourceimage_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/ext/read_ext.html", "read_ext.pro", '.pro file in <a href="config/ext/dir-overview.html">config/ext/ directory</a>', "read_ext.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/ext/read_ext.html#read_ext", "read_ext", 'routine in <a href="config/ext/read_ext.html">read_ext.pro</a>', "read_ext.pro", "", "read_ext", "", "dimtypefilenamelabel", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/fits/read_fits.html", "read_fits.pro", '.pro file in <a href="config/fits/dir-overview.html">config/fits/ directory</a>', "read_fits.pro", "", "", " NAME: 	read_fits    PURPOSE: 	Reads a FITS file into IDL data and optionally header variables.    CATEGORY: 	UTIL/FITS    CALLING SEQUENCE: 	result = read_fits(filename, [ header ])    ARGUMENTS:   INPUT: 	filename:	String containing the name of the file to be read.    OUTPUT: 	header:		String array containing the header from the FITS file.    KEYWORDS:   INPUT: 	NOSCALE:	If present and non-zero, then the ouput data will not be 			scaled using the optional BSCALE and BZERO keywords in 			the FITS header.   Default is to scale.  	SILENT:		Normally, READFITS will display the size the array at 			the terminal.  The SILENT keyword will suppress this  	NaNVALUE:	This scalar is only needed on Vax architectures.   It 			specifying the value to translate any IEEE  not a 			number  values in the FITS data array.   It is needed 			because the Vax does not recognize the  not a number  			convention.  	EXTEN_NO:	Scalar integer specify the FITS extension to read.  For 			example, specify EXTEN = 1 or /EXTEN to read the first 			FITS extension.    Extensions are read using recursive 			calls to READFITS.  	POINT_LUN:	Position (in bytes) in the FITS file at which to start 			reading.   Useful if READFITS is called by another 			procedure which needs to directly read a FITS extension. 			Should always be a multiple of 2880.  	STARTROW:	This keyword only applies when reading a FITS extension 			It specifies the row (scalar integer) of the extension 			table at which to begin reading. Useful when one does 			not want to read the entire table.  	NUMROW:		This keyword only applies when reading a FITS extension. 			If specifies the number of rows (scalar integer) of the 			extension table to read.   Useful when one does not want 			to read the entire table.    OUTPUT: NONE    RETURN: 	FITS data array constructed from designated record.    RESTRICTIONS:      (1)	Cannot handle random group FITS      (2)       User's with versions of IDL before 2.2.1 should remove the                call to the TEMPORARY function near the end of the program    EXAMPLE: 	Read a FITS file TEST.FITS into an IDL image array, IM and FITS        header array, H.   Do not scale the data with BSCALE and BZERO.                IDL> im = READFITS( 'TEST.FITS', h, /NOSCALE)         If the file contain a FITS extension, it could be read with                IDL> tab = READFITS( 'TEST.FITS', htab, /EXTEN )         To read only rows 100-149 of the FITS extension,                IDL> tab = READFITS( 'TEST.FITS', htab, /EXTEN,                                     STARTR=100, NUMR = 50 )    STATUS: 	Complete    SEE ALSO: 	write_fits    MODIFICATION HISTORY:        MODIFIED, Wayne Landsman  October, 1991                 Reset BSCALE and BZERO after using them        Added call to TEMPORARY function to speed processing     Feb-92        Added a check for fixed record length file  under VMS    Jun-92        Added STARTROW and NUMROW keywords for FITS tables       Jul-92 	Spitale; Jan 1998 - added xdr conversions, changed name 	                    from 'readfits' to 'read_fits'   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/fits/read_fits.html#read_fits", "read_fits", 'routine in <a href="config/fits/read_fits.html">read_fits.pro</a>', "read_fits.pro", "", "read_fits", "", "NOSCALENaNvalueSILENTEXTEN_NONUMROWPOINTLUNSTARTROWnaxtypefilenameheader", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/read_json.html", "read_json.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "read_json.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/read_json.html#read_json", "read_json", 'routine in <a href="util/read_json.html">read_json.pro</a>', "read_json.pro", "", "read_json", "", "filename", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/mask/read_mask.html", "read_mask.pro", '.pro file in <a href="config/mask/dir-overview.html">config/mask/ directory</a>', "read_mask.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/mask/read_mask.html#read_mask", "read_mask", 'routine in <a href="config/mask/read_mask.html">read_mask.pro</a>', "read_mask.pro", "", "read_mask", "", "headerdimtyperawsubfilename", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/multi/read_multi.html", "read_multi.pro", '.pro file in <a href="config/multi/dir-overview.html">config/multi/ directory</a>', "read_multi.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/multi/read_multi.html#read_multi", "read_multi", 'routine in <a href="config/multi/read_multi.html">read_multi.pro</a>', "read_multi.pro", "", "read_multi", "", "dimtypenodatafilename", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/occ/read_occ.html", "read_occ.pro", '.pro file in <a href="config/occ/dir-overview.html">config/occ/ directory</a>', "read_occ.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/occ/read_occ.html#read_occ", "read_occ", 'routine in <a href="config/occ/read_occ.html">read_occ.pro</a>', "read_occ.pro", "", "read_occ", "", "disk_ptssamplenodatatime_offsettime_unitstimesdnradlondimtypefilenamelabel", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/read_povray.html", "read_povray.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "read_povray.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/read_povray.html#read_povray", "read_povray", 'routine in <a href="util/read_povray.html">read_povray.pro</a>', "read_povray.pro", "", "read_povray", "", "facesfilename", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/tdl/read_tdl.html", "read_tdl.pro", '.pro file in <a href="config/tdl/dir-overview.html">config/tdl/ directory</a>', "read_tdl.pro", "", "", " NAME: 	read_tdl    PURPOSE: 	Reads a tdl data file.  This is essentially a VICAR file, except 	that the data are written in string form.    CATEGORY: 	UTIL/TDL    CALLING SEQUENCE: 	data = read_tdl(filename, label)    ARGUMENTS:   INPUT: 	filename:	String giving the name of the file to be read.    OUTPUT: 	label:		Named variable in which the tdl label will be 			returned.    KEYWORDS:   INPUT: 	n_l:	If set, this will override the number of lines given by the 		'NL' field of the label.  	n_s:	If set, this will override the number of samples given by the 		'NS' field of the label.  	n_b:	If set, this will override the number of bands given by the 		'NB' field of the label.  	silent:	If set, no messages are printed.    OUTPUT: 	status:	If no errors occur, status will be zero, otherwise 		it will be a string giving an error message.    RETURN: 	The data array read from the file.    RESTRICTIONS:  	This routine relies on the presence of the routines vigetpar 	and vicsetpar.    STATUS: 	Complete    SEE ALSO: 	write_tdl    MODIFICATION HISTORY:  	Written by:	Spitale, 1/2006  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/tdl/read_tdl.html#rtdl_pl_suffix", "rtdl_pl_suffix", 'routine in <a href="config/tdl/read_tdl.html">read_tdl.pro</a>', "read_tdl.pro", "", "rtdl_pl_suffix", "", "n", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/tdl/read_tdl.html#rtdl_strip_quotes", "rtdl_strip_quotes", 'routine in <a href="config/tdl/read_tdl.html">read_tdl.pro</a>', "read_tdl.pro", "", "rtdl_strip_quotes", "", "s", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/tdl/read_tdl.html#read_tdl", "read_tdl", 'routine in <a href="config/tdl/read_tdl.html">read_tdl.pro</a>', "read_tdl.pro", "", "read_tdl", "", "statussilentn_ln_sn_bshownodataget_nlget_nsget_nbtyefilenamelabel", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/read_txt_file.html", "read_txt_file.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "read_txt_file.pro", "", "", " NAME: 	read_txt_file    PURPOSE: 	Reads a text file, parsing some basic directives and removing 	comments.    CATEGORY: 	UTIL    CALLING SEQUENCE: 	text = read_txt_file(fname, notes)    ARGUMENTS:   INPUT: 	fname:	Name of the file to read.    OUTPUT: 	notes:  Array of strings giving note text for each line.  This text is taken 		from the 'note' input.    KEYWORDS:   INPUT: 	start:	If given, the returned text begins at the first line 		in which this string appears.  Default is '--begin--'.  	stop:	If given, the returned text ends at the first line 		in which this string appears.  Default is '--end--'.         note:	If this string appears in the file, this line is used as the note 		for each returned line until this string appears again, and so on. 		Default is '--note--'.  	raw:	If set, the 'start' and 'stop' keywords are ignored. 		Comments are also not removed.  	all:	If set, the 'start' and 'stop' keywords are ignored.  	sample:	If set, only every nth line is returned, where n is the value 		of this keyword; the first line is always returned.  If there 		are notes, then this operation applies separately to each block 		of lines with the same note.  	select: If set, only lines with the given note string will be returned.     OUTPUT: 	status:	0 if successful, -1 if file not found    RETURN: 	String array containing the text read from the file.  Unless /raw 	is specified, the returned text will not contain any characters 	appearing after the comment character '#', and the start and stop 	directoves are used to select the return block of text.    STATUS: 	Complete    SEE ALSO: 	write_txt_file    MODIFICATION HISTORY:  	Written by:	Spitale, 8/1994   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/read_txt_file.html#rtf_read", "rtf_read", 'routine in <a href="util/read_txt_file.html">read_txt_file.pro</a>', "read_txt_file.pro", "", "rtf_read", "", "statusnotelfstartstoprawincludeallsampleoffsetselectunotesindicesflagsfnotesfnamenotes", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/read_txt_file.html#read_txt_file", "read_txt_file", 'routine in <a href="util/read_txt_file.html">read_txt_file.pro</a>', "read_txt_file.pro", "", "read_txt_file", "", "statusnotelfstartstoprawincludeallsampleoffsetselectunotesindicesflagsfnotesfnamenotes", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/read_txt_table.html", "read_txt_table.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "read_txt_table.pro", "", "", " NAME: 	read_txt_table    PURPOSE: 	Reads a text file composed of rows and columns into an array.    CATEGORY: 	UTIL    CALLING SEQUENCE: 	result = read_txt_table(filename)    ARGUMENTS:   INPUT: 	filename:	Name of file to read    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	comment_char:	String giving character to use as line comment. 			Defaults to '#'.  	continue_char:	String giving character to use for line continuation. 			Defaults to '\'.  	delim_char:	String giving character to use to delimit columns. 			Defaults to ' '.    OUTPUT: 	NONE    RETURN: 	Array (ncolumns,nrows) of strings.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 2/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/read_txt_table.html#read_txt_table", "read_txt_table", 'routine in <a href="util/read_txt_table.html">read_txt_table.pro</a>', "read_txt_table.pro", "", "read_txt_table", "", "linesheaderrawallcomment_charcontinue_chardelim_charfilename", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/vgr_cd/read_vgr_cd.html", "read_vgr_cd.pro", '.pro file in <a href="config/vgr_cd/dir-overview.html">config/vgr_cd/ directory</a>', "read_vgr_cd.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/vgr_cd/read_vgr_cd.html#rvgrcd_pdslab", "rvgrcd_pdslab", 'routine in <a href="config/vgr_cd/read_vgr_cd.html">read_vgr_cd.pro</a>', "read_vgr_cd.pro", "", "rvgrcd_pdslab", "", "filename", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/vgr_cd/read_vgr_cd.html#rvgrcd_getval", "rvgrcd_getval", 'routine in <a href="config/vgr_cd/read_vgr_cd.html">read_vgr_cd.pro</a>', "read_vgr_cd.pro", "", "rvgrcd_getval", "", "pdslabkeyword", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/vgr_cd/read_vgr_cd.html#read_vgr_cd", "read_vgr_cd", 'routine in <a href="config/vgr_cd/read_vgr_cd.html">read_vgr_cd.pro</a>', "read_vgr_cd.pro", "", "read_vgr_cd", "", "samplenodatafilenamelabel", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/vicar/read_vicar.html", "read_vicar.pro", '.pro file in <a href="config/vicar/dir-overview.html">config/vicar/ directory</a>', "read_vicar.pro", "", "", " NAME: 	read_vicar    PURPOSE: 	Reads a vicar data file.    CATEGORY: 	UTIL/VIC    CALLING SEQUENCE: 	data = read_vicar(filename, label)    ARGUMENTS:   INPUT: 	filename:	String giving the name of the file to be read.    OUTPUT: 	label:		Named variable in which the vicar label will be 			returned.    KEYWORDS:   INPUT: 	n_l:	If set, this will override the number of lines given by the 		'NL' field of the label.  	n_s:	If set, this will override the number of samples given by the 		'NS' field of the label.  	n_b:	If set, this will override the number of bands given by the 		'NB' field of the label.  	nlb:	If set, this will override the number of binary header records 		given by the 'NLB' field of the label.  	nbb:	If set, this will override the number of binary prefix bytes 		given by the 'NBB' field of the label.  	silent:	If set, no messages are printed.  	swap:	If set, the data array will be byte-swapped.  If not set, 		then read_vicar will automatically determine whether 		to byte swapping is necessary.  	flip:	If set, the data array will be subjected to a rotate(data, 7), 		i.e., if its an image, it will be flipped vertically.  	default_format:	Data format to use if not given in the label. 			choices are 'BYTE', 'HALF', 'FULL , 'REAL', and 			'DOUB'.  default is 'BYTE'.         bpa:    Binary Prefix Array.  The caller must ensure that this array 		has appropriate dimensions.  	bha:	Binary Header Array.  The caller must ensure that this array 		has appropriate dimensions.    OUTPUT: 	status:	If no errors occur, status will be zero, otherwise 		it will be a string giving an error message.    RETURN: 	The data array read from the file.    RESTRICTIONS: 	This program only works with band-sequential data.  If EOL present, 	the EOL variable is returned as 0, the second LBLSIZE is erased 	and the first LBLSIZE is adjusted to appear as if the label was 	not split in two.    STATUS: 	Complete    SEE ALSO: 	write_vicar    MODIFICATION HISTORY:  	Written by:	Spitale, 10/1995                        Dyer Lytle, 8/1999 			Vance Haemmerle, 9/1999         EOL support:    Vance Haemmerle, 6/2000   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/vicar/read_vicar.html#rvc_pl_suffix", "rvc_pl_suffix", 'routine in <a href="config/vicar/read_vicar.html">read_vicar.pro</a>', "read_vicar.pro", "", "rvc_pl_suffix", "", "n", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/vicar/read_vicar.html#rvc_strip_quotes", "rvc_strip_quotes", 'routine in <a href="config/vicar/read_vicar.html">read_vicar.pro</a>', "read_vicar.pro", "", "rvc_strip_quotes", "", "s", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/vicar/read_vicar.html#read_vicar", "read_vicar", 'routine in <a href="config/vicar/read_vicar.html">read_vicar.pro</a>', "read_vicar.pro", "", "read_vicar", "", "statussilentdefault_formatswapn_ln_sn_bnlbnbbshowflipbpabhanodataget_nlget_nsget_nbtypefilenamelabel", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/vicar/read_vicar_label.html", "read_vicar_label.pro", '.pro file in <a href="config/vicar/dir-overview.html">config/vicar/ directory</a>', "read_vicar_label.pro", "", "", " NAME: 	read_vicar_label    PURPOSE: 	Reads the label of a vicar data file.    CATEGORY: 	UTIL/VIC    CALLING SEQUENCE: 	label = read_vicar_label(filename)    ARGUMENTS:   INPUT: 	filename:	String giving the name of the file to be read.    OUTPUT:      NONE    KEYWORDS:   INPUT: 	n_l:	If set, this will override the number of lines given by the 		'NL' field of the label.  	n_s:	If set, this will override the number of samples given by the 		'NS' field of the label.  	n_b:	If set, this will override the number of bands given by the 		'NB' field of the label.  	nlb:	If set, this will override the number of binary header records 		given by the 'NLB' field of the label.  	nbb:	If set, this will override the number of binary prefix bytes 		given by the 'NBB' field of the label.  	silent:	If set, no messages are printed.  	default_format:	Data format to use if not given in the label. 			choices are 'BYTE', 'HALF', 'FULL , 'REAL', and 			'DOUB'.  default is 'BYTE'.         bpa:    Must be set to 1 for Binary Prefix Array to be returned.  	bha:	Must be set to 1 for Binary Header Array to be returned.    OUTPUT:        bpa:    Binary Prefix Array  	bha:	Binary Header Array    RETURN: 	The label read from the file.    RESTRICTIONS: 	This program only works with band-sequential data.  If EOL present, 	the EOL variable is returned as 0, the second LBLSIZE is erased 	and the first LBLSIZE is adjusted to appear as if the label was 	not split in two.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 10/1995                        Dyer Lytle, 8/1999 			Vance Haemmerle, 9/1999        EOL support:    Vance Haemmerle, 6/2000           Modified:    Tiscareno, 8/2000 (from read_vicar)   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/vicar/read_vicar_label.html#rvc_pl_suffix", "rvc_pl_suffix", 'routine in <a href="config/vicar/read_vicar_label.html">read_vicar_label.pro</a>', "read_vicar_label.pro", "", "rvc_pl_suffix", "", "n", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/vicar/read_vicar_label.html#rvc_strip_quotes", "rvc_strip_quotes", 'routine in <a href="config/vicar/read_vicar_label.html">read_vicar_label.pro</a>', "read_vicar_label.pro", "", "rvc_strip_quotes", "", "s", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/vicar/read_vicar_label.html#read_vicar_label", "read_vicar_label", 'routine in <a href="config/vicar/read_vicar_label.html">read_vicar_label.pro</a>', "read_vicar_label.pro", "", "read_vicar_label", "", "statussilentdefault_formatn_ln_sn_bnlbnbbshowflipbpabhafilenamelabel", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/vicar/read_vicar_lite.html", "read_vicar_lite.pro", '.pro file in <a href="config/vicar/dir-overview.html">config/vicar/ directory</a>', "read_vicar_lite.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/readpds.html", "readpds.pro", '.pro file in <a href="config/pds/Readpds_4.4/dir-overview.html">config/pds/Readpds_4.4/ directory</a>', "readpds.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/readpds.html#get_all_objects", "get_all_objects", 'routine in <a href="config/pds/Readpds_4.4/readpds.html">readpds.pro</a>', "readpds.pro", "", "get_all_objects", "", "label", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/readpds.html#dotable", "dotable", 'routine in <a href="config/pds/Readpds_4.4/readpds.html">readpds.pro</a>', "readpds.pro", "", "dotable", "", "fnamelabelstobjindex", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/readpds.html#doarrcol", "doarrcol", 'routine in <a href="config/pds/Readpds_4.4/readpds.html">readpds.pro</a>', "readpds.pro", "", "doarrcol", "", "fnamelabelstobjindex", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/readpds.html#readpds", "readpds", 'routine in <a href="config/pds/Readpds_4.4/readpds.html">readpds.pro</a>', "readpds.pro", "", "readpds", "", "SILENTNOSCALEHISTOGRAMfilename", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/util/readres.html", "readres.pro", '.pro file in <a href="config/util/dir-overview.html">config/util/ directory</a>', "readres.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/util/readres.html#readres", "readres", 'routine in <a href="config/util/readres.html">readres.pro</a>', "readres.pro", "", "readres", "", "fname", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/util/readrob.html", "readrob.pro", '.pro file in <a href="config/util/dir-overview.html">config/util/ directory</a>', "readrob.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/util/readrob.html#readrob", "readrob", 'routine in <a href="config/util/readrob.html">readrob.pro</a>', "readrob.pro", "", "readrob", "", "fname", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/readspreadsheet.html", "readspreadsheet.pro", '.pro file in <a href="config/pds/Readpds_4.4/dir-overview.html">config/pds/Readpds_4.4/ directory</a>', "readspreadsheet.pro", "", "", " NAME:       READSPREADSHEET   PURPOSE:       This function reads data in PDS Spreadsheet object.        This function is meant to be integrated into the READPDS package       from the PDS Small Bodies Node to add spreadsheet support.   CATEGORY:       Scientific Data Extraction Routines   CALLING SEQUENCE:       Result = READSPREADSHEET(filename, label, objindex [,SILENT] [,PRINT_TIME])        Note: this routine is intended to be called from the READPDS.PRO routine       (see examples below)   INPUTS:       Filename: Scalar string containing the name of the PDS file to read.       Label: String array containing the spreadsheet label information.       Objindex: Integer specifying the starting index of the current object          in the label array to be read.   OUTPUTS:       Result: Spreadsheet structure containing records for each field in the object,       along with a string array NAMES with the names of all the fields.   OPTIONAL INPUT:       SILENT: Suppresses any messages from the procedure.       PRINT_TIME: Prints processing times for each of the Fields   EXTERNAL FUNCTIONS USED:       SBNIDL ReadPDS Package: OBJPDS, GET_INDEX, CLEAN, REMOVE, STR2NUM, PDSPAR, POINTPDS   PROCEDURE:       (1) Preprocess object definition parameters       (2) Create data structure to be read       (3) Read data structure from file using subroutine       (4) Re-organize data structures into arrays       (5) Return Data   SIDE EFFECTS:       Fields with missing values (e.g. 2,1,,,4,5,,7,,,) are converted to ZERO       This should be corrected in a later version. Possible using NaN (!values.f_nan)   TEST STATUS       This routine has been tested on SUN/SPARC/SOLARIS2.9 and WINDOWS XP with IDL6.1   EXAMPLES:       This routine is intended to be called from the READPDS.PRO routine       To read a PDS file TEST.LBL into an IDL spreadsheet structure, spr:         IDL> spr = READPDS ( TEST.LBL ,/SILENT)         IDL> help, /STRUCTURE, spr                OBJECTS      INT       1                SPREADSHEET  STRUCT    -> <Anonymous> Array[1]         IDL> help, /STRUCTURE, spr.(1)                NAMES           STRING    Array[8]                FIELD1           TYPE     Array[...]                FIELD2           TYPE     Array[...]                 ...                FIELDN           TYPE     Array[...]   MODIFICATION HISTORY:    Written by: A.Cardesin (ESA/ESTEC), 2006Feb (based on TASCPDS by P.Khetarpal)  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/readspreadsheet.html#obtain_Spreadsheet_keyword", "obtain_Spreadsheet_keyword", 'routine in <a href="config/pds/Readpds_4.4/readspreadsheet.html">readspreadsheet.pro</a>', "readspreadsheet.pro", "", "obtain_Spreadsheet_keyword", "", "KWnamelabelstart_indend_indobjname", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/readspreadsheet.html#remove_SpreadSheet_name", "remove_SpreadSheet_name", 'routine in <a href="config/pds/Readpds_4.4/readspreadsheet.html">readspreadsheet.pro</a>', "readspreadsheet.pro", "", "remove_SpreadSheet_name", "", "namelabelstart_indend_ind", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/readspreadsheet.html#clean_SpreadSheet_data_type", "clean_SpreadSheet_data_type", 'routine in <a href="config/pds/Readpds_4.4/readspreadsheet.html">readspreadsheet.pro</a>', "readspreadsheet.pro", "", "clean_SpreadSheet_data_type", "", "data_type", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/readspreadsheet.html#obtain_SpreadSheet_req", "obtain_SpreadSheet_req", 'routine in <a href="config/pds/Readpds_4.4/readspreadsheet.html">readspreadsheet.pro</a>', "readspreadsheet.pro", "", "obtain_SpreadSheet_req", "", "labelstart_indend_indobjname", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/readspreadsheet.html#obtain_spreadsheet_items", "obtain_spreadsheet_items", 'routine in <a href="config/pds/Readpds_4.4/readspreadsheet.html">readspreadsheet.pro</a>', "readspreadsheet.pro", "", "obtain_spreadsheet_items", "", "labelreq_keywdsstart_indend_indobjname", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/readspreadsheet.html#process_field_items", "process_field_items", 'routine in <a href="config/pds/Readpds_4.4/readspreadsheet.html">readspreadsheet.pro</a>', "readspreadsheet.pro", "", "process_field_items", "", "keywdsitemscurr_indnext_indobjname", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/readspreadsheet.html#convert_spreadsheet_element", "convert_spreadsheet_element", 'routine in <a href="config/pds/Readpds_4.4/readspreadsheet.html">readspreadsheet.pro</a>', "readspreadsheet.pro", "", "convert_spreadsheet_element", "", "elementtype", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/readspreadsheet.html#create_spreadsheet_struct", "create_spreadsheet_struct", 'routine in <a href="config/pds/Readpds_4.4/readspreadsheet.html">readspreadsheet.pro</a>', "readspreadsheet.pro", "", "create_spreadsheet_struct", "", "keywdsitemslabelstart_indend_indobjname", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/readspreadsheet.html#read_spreadsheet_data", "read_spreadsheet_data", 'routine in <a href="config/pds/Readpds_4.4/readspreadsheet.html">readspreadsheet.pro</a>', "readspreadsheet.pro", "", "read_spreadsheet_data", "", "pointerdata_structkeywdssilent", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/readspreadsheet.html#organize_spreadsheet_data", "organize_spreadsheet_data", 'routine in <a href="config/pds/Readpds_4.4/readspreadsheet.html">readspreadsheet.pro</a>', "readspreadsheet.pro", "", "organize_spreadsheet_data", "", "keywdsdataprint_time", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/readspreadsheet.html#READSPREADSHEET", "READSPREADSHEET", 'routine in <a href="config/pds/Readpds_4.4/readspreadsheet.html">readspreadsheet.pro</a>', "readspreadsheet.pro", "", "READSPREADSHEET", "", "SILENTPRINT_TIMEfilenamelabelobjindex", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/real.html", "real.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "real.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/real.html#real", "real", 'routine in <a href="util/real.html">real.pro</a>', "real.pro", "", "real", "", "z", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/rectify_angles.html", "rectify_angles.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "rectify_angles.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/rectify_angles.html#rectify_angles", "rectify_angles", 'routine in <a href="util/rectify_angles.html">rectify_angles.pro</a>', "rectify_angles.pro", "", "rectify_angles", "", "_theta", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/rectify_longitudes.html", "rectify_longitudes.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "rectify_longitudes.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/rectify_longitudes.html#rectify_longitudes", "rectify_longitudes", 'routine in <a href="util/rectify_longitudes.html">rectify_longitudes.pro</a>', "rectify_longitudes.pro", "", "rectify_longitudes", "", "lonminlonmax", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/reduce_angle.html", "reduce_angle.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "reduce_angle.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/reduce_angle.html#reduce_angle", "reduce_angle", 'routine in <a href="util/reduce_angle.html">reduce_angle.pro</a>', "reduce_angle.pro", "", "reduce_angle", "", "maxmintheta", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/reduce_dim.html", "reduce_dim.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "reduce_dim.pro", "", "", " NAME:        reduce_dim    PURPOSE:        Converts an array to a 1d array.    CATEGORY:        UTIL    CALLING SEQUENCE:        result = reduce_dim(x)    ARGUMENTS:   INPUT:        x:      An input array    OUTPUT:        NONE   KEYWORDS:        NONE    RETURN:        The input array reformed as a 1d array.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/reduce_dim.html#reduce_dim", "reduce_dim", 'routine in <a href="util/reduce_dim.html">reduce_dim.pro</a>', "reduce_dim.pro", "", "reduce_dim", "", "x", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/reduce_range.html", "reduce_range.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "reduce_range.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/reduce_range.html#reduce_range", "reduce_range", 'routine in <a href="util/reduce_range.html">reduce_range.pro</a>', "reduce_range.pro", "", "reduce_range", "", "inclusive_x_min_max", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/remove.html", "remove.pro", '.pro file in <a href="config/pds/Readpds_4.4/dir-overview.html">config/pds/Readpds_4.4/ directory</a>', "remove.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/remove.html#REMOVE", "REMOVE", 'routine in <a href="config/pds/Readpds_4.4/remove.html">remove.pro</a>', "remove.pro", "", "REMOVE", "", "textparam", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/remove_lines.html", "remove_lines.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "remove_lines.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/remove_lines.html#remove_lines", "remove_lines", 'routine in <a href="nv/obj/tools/remove_lines.html">remove_lines.pro</a>', "remove_lines.pro", "", "remove_lines", "", "slopptdlines", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/render.html", "render.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "render.pro", "", "", " NAME: 	render    PURPOSE: 	Performs rendering on an array of bodies.    CATEGORY: 	NV/PG    CALLING SEQUENCE: 	map = render(cd=cd, bx=bx, sund=sund)     ARGUMENTS:   INPUT: NONE 	image_pts:    Array of the image points defining the grid to be traced.    OUTPUT: NONE 	image_pts:    Array of the image points giving the grid that was traced.    KEYWORDS:   INPUT: 	cd:	      Camera descriptor.  	bx:	      Array of object descriptors; must be a subclass of BODY.  	sund:         Star descriptor for the Sun.  	md:           Array of map descriptors, one for each body.  	ddmap:        Array of data descriptors containing the body maps, 	              one for each body.  	sample:       Amount by which to subsample pixels.  	pc_size:      To save memory, the projection is performed in pieces 	              of this size.  Default is 65536.  	penumbra:     If set, lighting rays are traced to random points on 	              each secondary body rather then the center.  	no_secondary: If set, no secondary ray tracing is performed, so 	              resulting in no shadows.     OUTPUT:     RETURN: 	2D array containing the rendered image.    PROCEDURE:     EXAMPLE:    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/render.html#map_smoothing_width", "map_smoothing_width", 'routine in <a href="nv/obj/tools/render.html">render.pro</a>', "render.pro", "", "map_smoothing_width", "", "datai", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/tools/render.html#rdr_photometry", "rdr_photometry", 'routine in <a href="nv/obj/tools/render.html">render.pro</a>', "render.pro", "", "rdr_photometry", "", "no_phtdatacdsundbxbody_pts", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/tools/render.html#rdr_map", "rdr_map", 'routine in <a href="nv/obj/tools/render.html">render.pro</a>', "render.pro", "", "rdr_map", "", "datapiecebxmdddmapbody_ptsphotii", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/tools/render.html#rdr_piece", "rdr_piece", 'routine in <a href="nv/obj/tools/render.html">render.pro</a>', "render.pro", "", "rdr_piece", "", "dataimage_pts", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/tools/render.html#render", "render", 'routine in <a href="nv/obj/tools/render.html">render.pro</a>', "render.pro", "", "render", "", "cdsundbxddmapmdsamplepc_sizeshowpht_minno_phtstandofflimit_sourcepenumbrano_secondaryimage_pts", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/tools/render.html#test", "test", 'routine in <a href="nv/obj/tools/render.html">render.pro</a>', "render.pro", "", "test", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/reproject.html", "reproject.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "reproject.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/reproject.html#map_cam_reproject", "map_cam_reproject", 'routine in <a href="util/reproject.html">reproject.pro</a>', "reproject.pro", "", "map_cam_reproject", "", "cdodimage_map_xsize_map_ysize", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/reproject_image.html", "reproject_image.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "reproject_image.pro", "", "", " NAME:        reproject_image    PURPOSE:        xx    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        result = project_map(image, md=md, cd=cd, gbx=gbx, $                             pc_xsize, pc_ysize, $                             hide_fn=hide_fn, hide_data_p=hide_data_p)    ARGUMENTS:   INPUT:           image:     Image of body.         pc_xsize:     x size of map workspace         pc_ysize:     y size of map workspace     OUTPUT:        NONE   KEYWORDS:   INPUT:              md:     Map descriptor.               cd:     Camera descriptor.              gbx:     Globe descriptor.          hide_fn:     Array of hide functions, e.g. 'pm_hide_ring'      hide_data_p:     Array of hide data pointers, e.g. nv_ptr_new(rd)              map:     Input map.  If given, the new map will be projected OVER                      this map.  This input map must be consistent with the                      given map desciptor.   OUTPUT: 	NONE    RETURN:        The reprojected image.   MODIFICATION HISTORY:        Written by:     Spitale, 6/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/reproject_image.html#reproject_image", "reproject_image", 'routine in <a href="nv/obj/tools/reproject_image.html">reproject_image.pro</a>', "reproject_image.pro", "", "reproject_image", "", "cdnew_cdsizeinterparg_interpimagepc_xsizepc_ysize", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/resize_array.html", "resize_array.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "resize_array.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/resize_array.html#resize_array", "resize_array", 'routine in <a href="util/resize_array.html">resize_array.pro</a>', "resize_array.pro", "", "resize_array", "", "arraynew_dim", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/grim/rim.html", "rim.pro", '.pro file in <a href="nv/grim/dir-overview.html">nv/grim/ directory</a>', "rim.pro", "", "", " NAME: 	rim    PURPOSE: 	Prints the headers, or specific header values, for the specified files.    CATEGORY: 	NV/GR    CALLING SEQUENCE: 	rim, files    ARGUMENTS:   INPUT: 	files:	List of filenames and file specifications.  Only files whose 		filetypes can be detected are loaded.  An array of 		data descriptors may also be specified.    OUTPUT: NONE    KEYWORDS:   INPUT: 	keywords:	String array giving keywords for which values are 			desired.  Results are filetype-dependent.  If keywords 			are specfied, the results are printed as a table.    OUTPUT: NONE    RETURN: 	NONE    STATUS: 	Complete.    MODIFICATION HISTORY:  	Written by:	Spitale, 8/2013   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/grim/rim.html#rim", "rim", 'routine in <a href="nv/grim/rim.html">rim.pro</a>', "rim.pro", "", "rim", "", "keywordsfiles", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/rings/ring_input.html", "ring_input.pro", '.pro file in <a href="config/rings/dir-overview.html">config/rings/ directory</a>', "ring_input.pro", "", "", " NAME: 	ring_input    PURPOSE: 	Input translator for planetary rings.    CATEGORY: 	NV/CONFIG    CALLING SEQUENCE(only to be called by dat_get_value): 	result = ring_input(dd, keyword)    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	keyword:	String giving the name of the translator quantity.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	key1:		Planet descriptor -- required  	key2:		Camera descriptor    OUTPUT: 	status:		Zero if valid data is returned    ENVIRONMENT VARIABLES: 	NV_RING_DATA:	Sets the directory in which to look for data files.     TRANSLATOR KEYWORDS: 	system:		Asks translator to return a single ring descriptor 			encompassing the entire ring system.  If not specified, 			the translator may return a more detailed set of 			individual rings.    RETURN: 	Data associated with the requested keyword.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale; 8/2004   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/rings/ring_input.html#ri_clone", "ri_clone", 'routine in <a href="config/rings/ring_input.html">ring_input.pro</a>', "ring_input.pro", "", "ri_clone", "", "_rd", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/rings/ring_input.html#ri_build", "ri_build", 'routine in <a href="config/rings/ring_input.html">ring_input.pro</a>', "ring_input.pro", "", "ri_build", "", "datnamepd", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/rings/ring_input.html#ri_system", "ri_system", 'routine in <a href="config/rings/ring_input.html">ring_input.pro</a>', "ring_input.pro", "", "ri_system", "", "innerouterdkd", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/rings/ring_input.html#ri_merge", "ri_merge", 'routine in <a href="config/rings/ring_input.html">ring_input.pro</a>', "ring_input.pro", "", "ri_merge", "", "dkd_innerdkd_outerpdopaque", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/rings/ring_input.html#ring_input", "ring_input", 'routine in <a href="config/rings/ring_input.html">ring_input.pro</a>', "ring_input.pro", "", "ring_input", "", "valuesstatusddkeywordprefix@nv_trs_keywords_include.pro", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/rings/ringcat_read.html", "ringcat_read.pro", '.pro file in <a href="config/rings/dir-overview.html">config/rings/ directory</a>', "ringcat_read.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/rings/ringcat_read.html#ringcat_read", "ringcat_read", 'routine in <a href="config/rings/ringcat_read.html">ringcat_read.pro</a>', "ringcat_read.pro", "", "ringcat_read", "", "namesdefaultfiducialopaquesmaecclpdlpdtinclandlandtmepochfilename", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/rings/ringcat_record__define.html", "ringcat_record__define.pro", '.pro file in <a href="config/rings/dir-overview.html">config/rings/ directory</a>', "ringcat_record__define.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/rings/ringcat_record__define.html#ringcat_record__define", "ringcat_record__define", 'routine in <a href="config/rings/ringcat_record__define.html">ringcat_record__define.pro</a>', "ringcat_record__define.pro", "", "ringcat_record__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/ringplane_radial_bounds.html", "ringplane_radial_bounds.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "ringplane_radial_bounds.pro", "", "", " NAME:        ringplane_radial_bounds    PURPOSE: 	Finds ringplane radial bounds by projecting the camera FOV on 	the ringplane.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        result = ringplane_radial_bounds(cd, dkx)    ARGUMENTS:   INPUT: 	cd:	Camera descriptor.  	dkx:	Any subclass of DISK.    OUTPUT:  NONE    KEYOWRDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (2) giving the minimum and maximum disk radii visible 	to the camera.     MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/ringplane_radial_bounds.html#ringplane_radial_bounds", "ringplane_radial_bounds", 'routine in <a href="nv/obj/tools/ringplane_radial_bounds.html">ringplane_radial_bounds.pro</a>', "ringplane_radial_bounds.pro", "", "ringplane_radial_bounds", "", "cddkx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/rm_list_item.html", "rm_list_item.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "rm_list_item.pro", "", "", " NAME: 	rm_list_item    PURPOSE: 	Remove the item with index i from the given list and return the 	new list.  If the index is not in the list, then return the original 	list unchanged.    CATEGORY: 	UTIL    CALLING SEQUENCE: 	newlist = rm_list_item(list, i)    ARGUMENTS:   INPUT: 	list:	The list from which to remove item with index i.  	i:	Index of items in list to be removed.    OUTPUT: NONE    KEYWORDS:   INPUT: 	only:	If set, then return is [only] if removing the only element of 		the list. Otherwise return [0] on this condition.  	scalar:	If set, the output will be a scalar if there is only one 		element.    OUTPUT: NONE    RETURN: 	New list with item i removed.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 8/1994   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/rm_list_item.html#rm_list_item", "rm_list_item", 'routine in <a href="util/rm_list_item.html">rm_list_item.pro</a>', "rm_list_item.pro", "", "rm_list_item", "", "onlyscalarlisti", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/rmtag.html", "rmtag.pro", '.pro file in <a href="config/pds/Readpds_4.4/dir-overview.html">config/pds/Readpds_4.4/ directory</a>', "rmtag.pro", "", "", "  NAME:     REMOVE_TAGS   PURPOSE:     remove the specified tags from input structure   CALLING SEQUENCE:     remove_tags, oldstruct, tagnames, newstruct   INPUTS:     oldstruct: the original structure     tagnames: the names of tags to be removed (can be an array)   OPTIONAL INPUTS:     NONE.   KEYWORD PARAMETERS:     NONE.   OUTPUTS:     newstruct: the new structure without tags.   OPTIONAL OUTPUTS:     NONE   CALLED ROUTINES:    PROCEDURE:     REVISION HISTORY:     ????? Judith Racusin     25-OCT-2000 Modified to handle arbitrary tag types. Also error           handling. Erin Scott Sheldon    ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/rmtag.html#remove_tags", "remove_tags", 'routine in <a href="config/pds/Readpds_4.4/rmtag.html">rmtag.pro</a>', "rmtag.pro", "", "remove_tags", "", "structtagnamesnewstruct", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/rng/rng_assign.html", "rng_assign.pro", '.pro file in <a href="nv/obj/rng/dir-overview.html">nv/obj/rng/ directory</a>', "rng_assign.pro", "", "", " NAME: 	rng_assign    PURPOSE: 	Replaces fields in a RING object.  This is a convenient way of 	setting multiple fields in one call, and only a single event is 	generated.    CATEGORY: 	NV/OBJ/RNG    CALLING SEQUENCE: 	rng_assign, rd, <keywords>=<values>    ARGUMENTS:   INPUT: 	rd:		RING object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	RING fields to set.  	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	rng_set_*     MODIFICATION HISTORY:  	Written by:	Spitale		2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/rng/rng_assign.html#rng_assign", "rng_assign", 'routine in <a href="nv/obj/rng/rng_assign.html">rng_assign.pro</a>', "rng_assign.pro", "", "rng_assign", "", "noeventxd@rng__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/rng/rng_create_descriptors.html", "rng_create_descriptors.pro", '.pro file in <a href="nv/obj/rng/dir-overview.html">nv/obj/rng/ directory</a>', "rng_create_descriptors.pro", "", "", " NAME:        rng_create_descriptors    PURPOSE: 	Init method for the RING class.    CATEGORY:        NV/LIB/RNG    CALLING SEQUENCE:        rd = rng_create_descriptors(n)    ARGUMENTS:   INPUT:        n:      Number of ring descriptors.    OUTPUT:        NONE    KEYWORDS:   INPUT: 	rd:	Ring descriptor(s) to initialize, instead of creating new 		ones.  	dkd:	Disk descriptor(s) to pass to dsk_create_descriptors.  	sld:	Solid descriptor(s) to pass to sld_create_descriptors.  	bd:	Body descriptor(s) to pass to bod_create_descriptors.  	crd:	Core descriptor(s) to pass to cor_create_descriptors.  	primary:	Array (n) of primary descriptors.  	desc:	Array (n) of description strings.    OUTPUT: NONE   RETURN:        An array (n) of ring descriptors.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/rng/rng_create_descriptors.html#rng_create_descriptors", "rng_create_descriptors", 'routine in <a href="nv/obj/rng/rng_create_descriptors.html">rng_create_descriptors.pro</a>', "rng_create_descriptors.pro", "", "rng_create_descriptors", "", "crdbdslddkdrdn@rng__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/rng/rng_desc.html", "rng_desc.pro", '.pro file in <a href="nv/obj/rng/dir-overview.html">nv/obj/rng/ directory</a>', "rng_desc.pro", "", "", " NAME: 	rng_desc    PURPOSE: 	Returns the description string for each given ring descriptor.    CATEGORY: 	NV/LIB/RNG    CALLING SEQUENCE: 	desc = rng_desc(rd)    ARGUMENTS:   INPUT: 	rd:	 Array (nt) of RING descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Description string associated with each given ring descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/rng/rng_desc.html#rng_desc", "rng_desc", 'routine in <a href="nv/obj/rng/rng_desc.html">rng_desc.pro</a>', "rng_desc.pro", "", "rng_desc", "", "noeventrd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/rng/rng_evolve.html", "rng_evolve.pro", '.pro file in <a href="nv/obj/rng/dir-overview.html">nv/obj/rng/ directory</a>', "rng_evolve.pro", "", "", " NAME: 	rng_evolve    PURPOSE: 	Computes new ring descriptors at the given time offsets from the 	given ring descriptors using the taylor series expansion 	corresponding to the derivatives contained in the given ring 	descriptor.    CATEGORY: 	NV/LIB/RNG    CALLING SEQUENCE: 	rdt = rng_evolve(rd, dt)    ARGUMENTS:   INPUT: 	rd:	 Any subclass of RING.  	dt:	 Time offset.    OUTPUT: NONE    KEYWORDS:   INPUT: 	nodv:	 If set, derivatives will not be evolved.  	copy:	If set, the evolved descriptor is copied into the input 		descriptor and it is freed.  The input descriptor is returned.     OUTPUT: NONE    RETURN: 	Array (nrd,ndt) of newly allocated descriptors, of class RING, 	evolved by time dt, where nrd is the number of rd, and ndt 	is the number of dt.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/rng/rng_evolve.html#rng_evolve", "rng_evolve", 'routine in <a href="nv/obj/rng/rng_evolve.html">rng_evolve.pro</a>', "rng_evolve.pro", "", "rng_evolve", "", "nodvcopyrddt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/rng/rng_primary.html", "rng_primary.pro", '.pro file in <a href="nv/obj/rng/dir-overview.html">nv/obj/rng/ directory</a>', "rng_primary.pro", "", "", " NAME: 	rng_primary    PURPOSE: 	Returns the primary string for each given ring descriptor.    CATEGORY: 	NV/LIB/RNG    CALLING SEQUENCE: 	primary = rng_primary(rd)    ARGUMENTS:   INPUT: 	rd:	 Array (nt) of RING descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Primary string associated with each given ring descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/rng/rng_primary.html#rng_primary", "rng_primary", 'routine in <a href="nv/obj/rng/rng_primary.html">rng_primary.pro</a>', "rng_primary.pro", "", "rng_primary", "", "noeventrd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/rng/rng_query.html", "rng_query.pro", '.pro file in <a href="nv/obj/rng/dir-overview.html">nv/obj/rng/ directory</a>', "rng_query.pro", "", "", " NAME: 	rng_query    PURPOSE: 	Returns the fields associated with a RING object.  This is a 	convenient way of getting multiple fields in one call, and only a 	single event is generated.    CATEGORY: 	NV/OBJ/RNG    CALLING SEQUENCE: 	rng_query, rd, <keywords>=<values>    ARGUMENTS:   INPUT: 	rd:	RING object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	RING object fields to set.  	condition:	Structure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT object, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.  	cat:		If set, arrays from mulitple input objets are 			concatenated.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.  	noevent:	If set, no event is generated.    OUTPUT: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/rng/rng_query.html#rng_query", "rng_query", 'routine in <a href="nv/obj/rng/rng_query.html">rng_query.pro</a>', "rng_query.pro", "", "rng_query", "", "conditioncatnoeventxd@rng__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/rng/rng_replicate.html", "rng_replicate.pro", '.pro file in <a href="nv/obj/rng/dir-overview.html">nv/obj/rng/ directory</a>', "rng_replicate.pro", "", "", " NAME: 	rng_replicate    PURPOSE: 	Replicates the given descriptor, producing an array of the given 	dimensions containing cloned versions of the input descriptor.    CATEGORY: 	NV/LIB/RNG    CALLING SEQUENCE: 	rds = rng_replicate(rd, dim)    ARGUMENTS:   INPUT: 	rd:	 Ring descriptor.  	dim:	 Dimensions of the result.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Array of the given dimensions containing cloned versions of the input 	descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/rng/rng_replicate.html#rng_replicate", "rng_replicate", 'routine in <a href="nv/obj/rng/rng_replicate.html">rng_replicate.pro</a>', "rng_replicate.pro", "", "rng_replicate", "", "rddim", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/rng/rng_set_desc.html", "rng_set_desc.pro", '.pro file in <a href="nv/obj/rng/dir-overview.html">nv/obj/rng/ directory</a>', "rng_set_desc.pro", "", "", " NAME: 	rng_set_desc    PURPOSE: 	Replaces the description string in each given ring descriptor.    CATEGORY: 	NV/LIB/RNG    CALLING SEQUENCE: 	rng_set_desc, rd, desc    ARGUMENTS:   INPUT: 	rd:	Array (nt) of STATION descriptors.  	desc:	Array (nt) of description strings.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/rng/rng_set_desc.html#rng_set_desc", "rng_set_desc", 'routine in <a href="nv/obj/rng/rng_set_desc.html">rng_set_desc.pro</a>', "rng_set_desc.pro", "", "rng_set_desc", "", "noeventrddesc", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/rng/rng_set_primary.html", "rng_set_primary.pro", '.pro file in <a href="nv/obj/rng/dir-overview.html">nv/obj/rng/ directory</a>', "rng_set_primary.pro", "", "", " NAME: 	rng_set_primary    PURPOSE: 	Replaces the primary string in each given ring descriptor.    CATEGORY: 	NV/LIB/RNG    CALLING SEQUENCE: 	rng_set_primary, rd, primary    ARGUMENTS:   INPUT: 	rd:	Array (nt) of STATION descriptor.  	primary:	Array (nt) of primary strings.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/rng/rng_set_primary.html#rng_set_primary", "rng_set_primary", 'routine in <a href="nv/obj/rng/rng_set_primary.html">rng_set_primary.pro</a>', "rng_set_primary.pro", "", "rng_set_primary", "", "noeventrdxd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/root_interp.html", "root_interp.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "root_interp.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/root_interp.html#root_interp", "root_interp", 'routine in <a href="util/root_interp.html">root_interp.pro</a>', "root_interp.pro", "", "root_interp", "", "arg1arg2", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/rot_image.html", "rot_image.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "rot_image.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/rot_image.html#rot_image", "rot_image", 'routine in <a href="util/rot_image.html">rot_image.pro</a>', "rot_image.pro", "", "rot_image", "", "indicesimageangle", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/rotate_coord.html", "rotate_coord.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "rotate_coord.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/rotate_coord.html#rotate_coord", "rotate_coord", 'routine in <a href="util/rotate_coord.html">rotate_coord.pro</a>', "rotate_coord.pro", "", "rotate_coord", "", "inversesizepdir", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/rotate_coord.html#_rotate_coord", "_rotate_coord", 'routine in <a href="util/rotate_coord.html">rotate_coord.pro</a>', "rotate_coord.pro", "", "_rotate_coord", "", "inversesizepdir", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/routine_exists.html", "routine_exists.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "routine_exists.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/routine_exists.html#routine_exists", "routine_exists", 'routine in <a href="util/routine_exists.html">routine_exists.pro</a>', "routine_exists.pro", "", "routine_exists", "", "compilename", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/gen/rowgen.html", "rowgen.pro", '.pro file in <a href="util/gen/dir-overview.html">util/gen/ directory</a>', "rowgen.pro", "", "", " NAME: 	rowgen    PURPOSE: 	Generates an array of subscripts to select only the desired row 	n-vectors from an array with dimensions n x nv x nt.   CATEGORY: 	UTIL/GEN    CALLING SEQUENCE: 	sub = rowgen(n, nv, nt, w)    ARGUMENTS:   INPUT: 	n, nv, nt:	 Dimensions of array from which to select.  	w:	1-d array of nw subscripts selecting from the (nv x nt) 		row vectors.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Array (n x nw) of subscripts.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/gen/rowgen.html#rowgen", "rowgen", 'routine in <a href="util/gen/rowgen.html">rowgen.pro</a>', "rowgen.pro", "", "rowgen", "", "nnvntw", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/strcat/sao_record__define.html", "sao_record__define.pro", '.pro file in <a href="config/strcat/dir-overview.html">config/strcat/ directory</a>', "sao_record__define.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/strcat/sao_record__define.html#sao_record__define", "sao_record__define", 'routine in <a href="config/strcat/sao_record__define.html">sao_record__define.pro</a>', "sao_record__define.pro", "", "sao_record__define", " Format of a record in the SAO catalog   ", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/sat_convert_longitude.html", "sat_convert_longitude.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "sat_convert_longitude.pro", "", "", " NAME: 	sat_convert_longitude    PURPOSE: 	Convert among Saturn's I, II, and III longitude systems.    CATEGORY: 	UTIL    CALLING SEQUENCE: 	result = sat_convert_longitude(lon, jd, from=from, to=to)    ARGUMENTS:   INPUT: 	lon:	Longitude to be converted; radians.  	jd:	Julian date.    KEYWORDS:   INPUT: 	from:	String specifying the input longitude system 		-- 'I', 'II', or 'III'.  	to:	String specifying the output longitude system 		-- 'I', 'II', or 'III'.   RETURN: 	Converted longitude; radians.    PROCEDURE: 	Conversions are based on the physical ephemeris parameters 	given in table 7.44.1 of the explanatory supplement to the 	astronomical almanac.    MODIFICATION HISTORY:  	Written by:	Spitale, 9/18/2001   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/sat_convert_longitude.html#sat_convert_longitude", "sat_convert_longitude", 'routine in <a href="util/sat_convert_longitude.html">sat_convert_longitude.pro</a>', "sat_convert_longitude.pro", "", "sat_convert_longitude", "", "fromtolonjd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("demo/saturn_example.html", "saturn_example.pro", '.pro file in <a href="demo/dir-overview.html">demo/ directory</a>', "saturn_example.pro", "", "", " Saturn Example    	 This example file uses Saturn and its rings to show various   	 capabilities of the software.  This includes fitting the   	 limb and rings simultaneously, hiding the limb and/or rings wrt   	 other objects in the field of view, plotting radial and longitudinal   	 sectors on the ring and mapping the saturn cloud tops.    	 This example file can be executed from the UNIX command line using: <span class= code-output >	  ominas ominas saturn_example</span>   	 or from within an OMINAS IDL session using: <span class= code-output >	  @saturn_example</span>   	 After the example stops, later code samples in this file may be executed by   	 pasting them onto the IDL command line.   Image read and display  	  	This first section uses dat_read to read in the image.  The image file    c3440346.gem is a Voyager VICAR format file where the image has had    the camera distortions removed with the VICAR program GEOMA.  dat_read    reads the image portion (im) and the image label (label) and its output    is a data descriptor (dd).  ctmod is called to reserve several colors    in the case of an 8-bit display.  tvim is called to display the image    (im) at 1/2 size in a new window with the y coordinate as top-down.  	For Example: <span class= code-output >  dd = dat_read(getenv('OMINAS_DIR')+'/demo/data/c3440346.gem', im, label)</span> <span class= code-output >  tvim, im, zoom=0.5, /order, /new</span>    Obtaining the descriptors     This section obtains the camera descriptor (cd), the planet descriptor    (pd) and the ring descriptor (rd) for use by the software.  In this    example, the various elements of these descriptors are overridden with    values that causes the software not to try to read these values from    a detached header or through a translator that would access the data    from the default source.     Change override to zero to read the data through the translators instead: <span class= code-output > override=1</span>    Camera descriptor: <span class= code-output > if(override) then $</span> <span class= code-output >   cd = pg_get_cameras(dd, /over, $</span> <span class= code-output >   name='VGR1_ISS_NA', $</span> <span class= code-output >   orient= $</span> <span class= code-output >   [ [-0.177287575, -0.966450211, -0.185857758 ], $</span> <span class= code-output >   [ 0.507898045, -0.251604865,  0.823853487 ], $</span> <span class= code-output >   [ 0.842976092, -0.051662194, -0.535464589 ] ], $</span> <span class= code-output >   avel=tr([0.0, 0.0, 0.0]), $</span> <span class= code-output >   pos=tr([0.0, 0.0, 0.0]), $</span> <span class= code-output >   vel=tr([0.0, 0.0, 0.0]), $</span> <span class= code-output >   time=972603249.d, $</span> <span class= code-output >   scale=[7.858656e-06,7.858656e-06], $</span> <span class= code-output >   oaxis=[499.0,499.0], $</span> <span class= code-output >   size=[1000,1000], $</span> <span class= code-output >   fn_focal_to_image='cam_focal_to_image_linear', $</span> <span class= code-output >   fn_image_to_focal='cam_image_to_focal_linear', $</span> <span class= code-output >   fi_data=ptr_new())</span>    Planet descriptor: <span class= code-output >   if(override) then $</span> <span class= code-output >     pd = pg_get_planets(dd, od=cd, /over, $</span> <span class= code-output >     name='SATURN', $</span> <span class= code-output >     orient= $</span> <span class= code-output >     [ [-0.254669368,  0.963251789,  0.085378596], $</span> <span class= code-output >     [-0.962535206, -0.260997177,  0.073528563], $</span> <span class= code-output >     [ 0.093110093, -0.063454432,  0.993631746] ], $</span> <span class= code-output >     avel=tr([0.0854, 0.0732, 0.9937])*1.74e-4, $</span> <span class= code-output >     pos=tr([-23433172000.0, -6105736000.0, -1223129375.0]), $</span> <span class= code-output >     vel=[ tr([9500.0, 0.0, 0.0]), $</span> <span class= code-output >     tr([0.0, 0.1, 0.0]) ], $</span> <span class= code-output >     time=972603249.d, $</span> <span class= code-output >     radii=[60268000.,60268000.,54364000.], $</span> <span class= code-output >     lora=0.0)</span>    Rings descriptor: <span class= code-output >     if(override) then $</span> <span class= code-output >       rd = pg_get_rings(dd, pd=pd, od=cd, /over, $</span> <span class= code-output >       name='MAIN_RING_SYSTEM', $</span> <span class= code-output >       primary=pd, $</span> <span class= code-output >       orient= $</span> <span class= code-output >       [ [-0.254669368,  0.963251789,  0.085378596], $</span> <span class= code-output >       [-0.962535206, -0.260997177,  0.073528563], $</span> <span class= code-output >       [ 0.093110093, -0.063454432,  0.993631746] ], $</span> <span class= code-output >       avel=tr([0.0854, 0.0732, 0.9937])*1.74e-4, $</span> <span class= code-output >       pos=tr([-23433172000.0, -6105736000.0, -1223129375.0]), $</span> <span class= code-output >       vel=[tr([9500.0, 0.0, 0.0]), $</span> <span class= code-output >       tr([0.0, 0.1, 0.0]) ] , $</span> <span class= code-output >       time=972603249.d, $</span> <span class= code-output >       sma=tr([75000000.0,136800000.0]), $</span> <span class= code-output >       ecc=tr([0.0, 0.0]))</span>    Sun (star) descriptor: <span class= code-output >       if(override) then $</span> <span class= code-output >         sund = pg_get_stars(dd, od=cd, /over, $</span> <span class= code-output >         name='SUN', $</span> <span class= code-output >         pos=tr([1.421392d12,4.3105676d10,-4.3613585d10]))</span>    If override was not set, the above could be done with just: <span class= code-output >       if(NOT override) then cd = pg_get_cameras(dd)</span> <span class= code-output >       if(NOT override) then pd = pg_get_planets(dd, od=cd)</span> <span class= code-output >       if(NOT override) then rd = pg_get_rings(dd, pd=pd, od=cd, '/system')</span> <span class= code-output >       if(NOT override) then sund = pg_get_stars(dd, od=cd, name='SUN')</span>     This example, commented out, shows how two objects can be included in   one planet descriptor.   Filling the generic descriptor    	This line fills a  generic  descriptor.  This is a convenience   	feature where in several descriptors are grouped into a structure that   	can be passed to functions in one piece.    	cd - camera descriptor part   	gbx - globe descriptor part   	dkx - disk descriptor part: <span class= code-output > 	  gd = {cd:cd, gbx:pd, dkx:rd, sund:sund}</span>   Calculating the limb, ring and planet center   Determining the plot characteristics    This section uses pg_limb to calculate the limb point structure (limb_ptd)   containing the limb points, the ring point structure (ring_ptd) and also   the planet center (center_ptd) using the routine pg_center.  It uses the   generic descriptor (gd) to pass the camera, planet and ring descriptors   to these routines.  It also uses pg_hide to remove (/rm) points from the   ring from the limb points and then again to remove the ring points   covered by the planet.  It then groups each of these into   object_ptd for plotting.  The colors, psyms, psizes and plables variables   are defined for the plot.  The center is drawn in the default color   (!p.color), the limb is in yellow (ctyellow) and the inner and outer ring   are in red (ctred).  Here you can see that each ring is treated as two   objects (inner and outer) when defining plot characteristics.  With an   8-bit display, these color routines return the values that were previously   reserved in the color table with ctmod; with a 24-bit display, these   routines return the true color values for these colors.  nlimb stores the   number of points in the limb_ptd structure, nring, the number of points in   the ring point structure.  In plabels, the limb and ring's name is not   plotted since it would be plotted at the center of the object: <span class= code-output > limb_ptd = pg_limb(gd=gd) & pg_hide, limb_ptd, gd=gd, bx=rd</span> <span class= code-output > ring_ptd = pg_disk(gd=gd) & pg_hide, ring_ptd, gd=gd, bx=pd</span> <span class= code-output > shadow_ptd = pg_shadow_globe(gd=gd, ring_ptd)</span> <span class= code-output > center_ptd = pg_center(gd=gd, bx=pd)</span> <span class= code-output > object_ptd = [center_ptd,limb_ptd,ring_ptd,shadow_ptd]</span> <span class= code-output > colors = [!p.color,ctyellow(),ctred(),ctred(),ctblue()] & psyms=[1,3,3,3,3] & psizes=[0.5]</span> <span class= code-output > plabels = [cor_name(pd), '', '']</span> <span class= code-output > nlimb = n_elements(limb_ptd)</span> <span class= code-output > nring = n_elements(ring_ptd)</span>   Drawing the limb, ring and planet center  	   This section draws the objects in the object structure (center, limb  and ring) with the colors and plot symbols and labels defined earlier.  Notice how the limb and ring curves cut off at the points of intersection  between the objects: <span class= code-output > pg_draw, object_ptd, colors=colors, psyms=psyms, psizes=psizes, plabel=plabels</span>   Draw planet and ring latitude/longitude grid  	     This sections calculates a latitude/longitude grid for the planet and a   	radius/longitude grid for the rings.  By default it draws 12 latitude   	and 12 longitude grid lines.  The longitude grid lines circle the body   	and so on a map they will appear as 24 grid lines.  The ring radius grid   	uses four grid lines by default between the inner and outer ring radius.   	It uses pg_hide to set as not visible the points on the grid behind the   	planet and ring for both objects.  It then uses pg_draw to draw the   	planet grid points in blue (ctblue) and the ring grid points in purple   	(ctpurple).    	Here is where the example then stops: <span class= code-output > 	  grid_ptd = pg_grid(gd=gd, bx=pd)</span> <span class= code-output >    pg_hide, grid_ptd, gd=gd, bx=pd, /assoc</span> <span class= code-output >    pg_hide, grid_ptd, gd=gd, bx=rd</span> <span class= code-output >    pg_draw, grid_ptd, color=ctblue()</span>  <span class= code-output >    dgrid_ptd = pg_grid(gd=gd, bx=rd) & pg_hide, dgrid_ptd, gd=gd, bx=pd</span> <span class= code-output >    pg_draw, dgrid_ptd, color=ctpurple()</span>   First-cut automatic repointing    In this section, pg_farfit is used to automatically calculate a pointing   correction, by fitting a curve to the planet's limb.    First, we draw a clean image: <span class= code-output >  tvim, im</span>   Then, we calculate the edges in the image with pg_edges, and draw them: <span class= code-output >  edge_ptd = pg_edges(dd, edge=50)</span> <span class= code-output >  pg_draw, edge_ptd</span>        Now, pg_farfit is used to find a x/y offset, by fitting the points in edge_ptd   (the edges found in the image) to the points that make up the limb, rings and   shadow (limb_ptd, ring_ptd, shadow_ptd): <span class= code-output >  dxy = pg_farfit(dd, edge_ptd, [limb_ptd[0], ring_ptd[1], shadow_ptd[0]])</span>   Now, we use pg_repoint to apply the dxy offsets, and calculate new limb, ring   shadow points: <span class= code-output >  pg_repoint, dxy, 0d, axis=center_ptd[0], gd=gd</span> <span class= code-output >  limb_ptd = pg_limb(gd=gd) & pg_hide, limb_ptd, gd=gd, bx=rd, /rm</span> <span class= code-output >  ring_ptd = pg_disk(gd=gd) & pg_hide, ring_ptd, gd=gd, bx=pd, /rm</span> <span class= code-output >  shadow_ptd = pg_shadow_globe(gd=gd, ring_ptd)</span> <span class= code-output >  center_ptd = pg_center(gd=gd, bx=pd)</span> <span class= code-output >  object_ptd = [center_ptd,limb_ptd,ring_ptd,shadow_ptd]</span>    Now, we draw the newly-derived limb, ring and shadow points on a clean image: <span class= code-output >  tvim, im</span> <span class= code-output >  pg_draw, object_ptd, colors=colors, psyms=psyms, psizes=psizes, plabel=plabels</span>        Manually repointing the geometry    This pasteable section first clears the screen of the plotted points   by redisplaying the image with tvim.  It then calls pg_drag to allow   the user to use the cursor to drag the pointing, and with it the limb,   ring and planet center.  To move the pointing with pg_drag, use the left   mouse button and translate the pointing in x,y.  Use the middle mouse   button to rotate the pointing about an axis (in this case, the axis of   rotation is set as the planet center (center_ptd[0]).  When the   desired pointing is set, the right mouse button accepts it.  pg_drag   returns the delta x,y amount dragged (dxy) as well as the rotation   angle (dtheta).  pg_repoint uses the dxy and dtheta to update the   camera descriptor (cd, passed by gd).  The limb and center is then   recalculated, the image redisplayed to clear the objects drawn, and   then pg_draw is called to replot: <span class= code-output > tvim, im</span> <span class= code-output > dxy = pg_drag(object_ptd, dtheta=dtheta, axis=center_ptd[0])</span> <span class= code-output > pg_repoint, dxy, dtheta, axis=center_ptd[0], gd=gd</span>  <span class= code-output > limb_ptd = pg_limb(gd=gd) & pg_hide, limb_ptd, gd=gd, bx=rd, /rm</span> <span class= code-output > ring_ptd = pg_disk(gd=gd) & pg_hide, ring_ptd, gd=gd, bx=pd, /rm</span> <span class= code-output > shadow_ptd = pg_shadow_globe(gd=gd, ring_ptd)</span> <span class= code-output > center_ptd = pg_center(gd=gd, bx=pd)</span> <span class= code-output > object_ptd = [center_ptd,limb_ptd,ring_ptd,shadow_ptd]</span>  <span class= code-output > tvim, im</span> <span class= code-output > pg_draw, object_ptd, colors=colors, psyms=psyms, psizes=psizes, plabel=plabels</span>   Scanning the edge to find the limb and using it to calculate the pointing    This section calls pg_cvscan to scan the image around the predicted   limb position and the ring edge position (within width of 80 pixels) and   find the points of highest correlation with a given edge model for each   object (edge_model_nav_limb = limb model used in the VICAR program NAV   and edge_model_nav_ring = ring model from NAV) and zeropoint offset in   the given model (lzero).  These points are then plotted: <span class= code-output > cvscan_ptd = pg_cvscan(dd, gd=gd, [limb_ptd,ring_ptd], edge=30, width=80, $</span> <span class= code-output > model=[make_array(nlimb,val=ptr_new(edge_model_nav_limb(zero=lzero))), $</span> <span class= code-output >   make_array(nring,val=ptr_new(edge_model_nav_ring(zero=rzero)))], $</span> <span class= code-output >   mzero=[make_array(nlimb,val=lzero),$</span> <span class= code-output >   make_array(nring,val=rzero)] )</span> <span class= code-output > tvim, im</span> <span class= code-output > pg_draw, cvscan_ptd</span>        Thresholding using correlation coefficient    This section (optional) calls pg_threshold to remove points with lower   correlation coefficients.  The /relative flag means that the minimum   and maximum thresholds are taken as a fraction to the maximum value   in the array.  Notice here again that the ring is treated as two   objects: <span class= code-output > pg_threshold, cvscan_ptd, min=[0.8, 1.0, 0.8], max=[1.2, 1.0, 1.2], /rel</span> <span class= code-output > tvim, im</span> <span class= code-output > pg_draw, cvscan_ptd</span>       Removing regions of bad points    This section (optional) calls pg_select to remove points within a   polygonal region as defined by the cursor.  Click the left mouse   button to mark a point and move the mouse to the next point and   click.  Use the middle mouse button to erase a point and the right   mouse button to end the region.  pg_trim removes the points in the   just defined region.  The scan points are then replotted.   Repeat these statements for each region a user wants to remove: <span class= code-output > region = pg_select(dd)</span> <span class= code-output > pg_trim, dd, cvscan_ptd, region</span> <span class= code-output > tvim, im</span> <span class= code-output > pg_draw, cvscan_ptd</span>   Fitting the pointing to the scanned points    This section calls pg_cvscan_coeff to determine the linear least-squares   coefficients for a fit to the image coordinate translation and rotation   which matches the computed curve to the scanned curve. It then calls   pg_fit to do the fit with the calculated coefficients to calculate the   correction in translation (dxy) and rotation (dtheta).  It calls   pg_cvchisq to get the chi square of the fit.  Then calls pg_repoint to   update the pointing. Recalculates the limb and center and replots.   The determination of the curves and their subsequent fit can be   iterated on: <span class= code-output > cvscan_cf = pg_cvscan_coeff(cvscan_ptd, axis=center_ptd[0])</span> <span class= code-output > dxy = pg_fit([cvscan_cf], dtheta=dtheta)</span> <span class= code-output > chisq = pg_chisq(dxy, dtheta, cvscan_ptd, axis=center_ptd[0])</span> <span class= code-output > print, dxy, dtheta*180./!pi, chisq</span> <span class= code-output > pg_repoint, dxy, dtheta, axis=center_ptd[0], gd=gd</span>  <span class= code-output > limb_ptd = pg_limb(gd=gd) & pg_hide, limb_ptd, gd=gd, bx=rd, /rm</span> <span class= code-output > ring_ptd = pg_disk(gd=gd) & pg_hide, ring_ptd, gd=gd, bx=pd, /rm</span> <span class= code-output > center_ptd = pg_center(gd=gd, bx=pd)</span> <span class= code-output > object_ptd = [center_ptd,limb_ptd,ring_ptd]</span>  <span class= code-output > tvim, im</span> <span class= code-output > pg_draw, object_ptd, colors=colors, psyms=psyms, psizes=psizes, plabel=plabels</span>    Draw planet and ring latitude/longitude grid    This sections calculates a latitude/longitude grid for each planet and a   radius/longitude grid for the rings.  By default it draws 12 latitude   and 12 longitude grid lines.  The longitude grid lines circle the body   and so on a map they will appear as 24 grid lines.  The ring radius grid   uses four grid lines by default between the inner and outer ring radius.   It uses pg_hide to set as not visible the points on the grid behind the   planet and ring for both objects.  It then uses pg_draw to draw the   grid points in blue (ctblue): <span class= code-output > tvim, im</span> <span class= code-output > grid_ptd = pg_grid(gd=gd, lat=lat, lon=lon)</span> <span class= code-output > pg_hide, grid_ptd, cd=cd, gbx=pd, /assoc</span> <span class= code-output > pg_hide, grid_ptd, cd=cd, gbx=pd, od=sund, /assoc</span> <span class= code-output > pg_hide, grid_ptd, gd=gd, bx=rd</span> <span class= code-output > pg_draw, grid_ptd, color=ctblue()</span>  <span class= code-output > plat_ptd = pg_grid(gd=gd, slon=!dpi/2d, lat=lat, nlon=0)</span> <span class= code-output > pg_hide, plat_ptd[0], cd=cd, gbx=pd[0], /assoc</span> <span class= code-output > pg_draw, plat_ptd[0], psym=3, plabel=strtrim(round(lat*180d/!dpi),2), /label_p</span>  <span class= code-output > plon_ptd = pg_grid(gd=gd, slat=0d, lon=lon, nlat=0)</span> <span class= code-output > pg_hide, plon_ptd[0], cd=cd, gbx=pd[0], /limb</span> <span class= code-output > pg_draw, plon_ptd[0], psym=3, plabel=strtrim(round(lon*180d/!dpi),2), /label_p</span>  <span class= code-output > dgrid_ptd = pg_grid(gd=gd, bx=rd) & pg_hide, dgrid_ptd, gd=gd, bx=pd</span> <span class= code-output > pg_draw, dgrid_ptd, color=ctpurple()</span>        Defining a ring sector for a plot    To plot a ring radius vs. intensity or longitude vs. intensity, the   user must first define the limits of the ring sector.  Here it is   done in one of two ways, the first is to define the longitude (lon)   and radius (rad) limits in an array.  The second method is to use   the cursor to sweep out a ring sector, pg_ring_sector is called to   do this.  To use the mouse, click in one corner of your desired sector   and drag the cursor to the opposite corner.  In this example,   counterclockwise is the direction of increasing longitude.  The chosen   sector is then calculated using pg_profile_ring with the /outline   keyword.  This outline is then drawn with pg_draw: <span class= code-output > tvim,im</span> <span class= code-output > outline_ptd = pg_ring_sector(gd=gd, rad=rad, lon=lon, slope=slope)</span> <span class= code-output > pg_draw, outline_ptd, col=ctgreen()</span>        Plotting ring sector plots       Below is the code for four different types of plots using pg_profile_ring.      Radial (default) and longitudinal (/azimuthal), interpolated (default)      and binned (/bin).  There is an oversamp keyword which defines the amount      to oversample (vs. 1 pixel).  In the case of a longitudinal bin scan,      pixelization can cause some bins to contain very low numbers or none at      all.  In this example oversamp=0.3 to cause the plot to have larger bins      to help alleviate this problem.  The calculated profile is then plotted      in a new window.       Radial scan: <span class= code-output >   dd_prof=pg_profile_ring(dd, gd=gd, outline_ptd, dsk_pts=dsk_pts, profile=profile)</span> <span class= code-output >   window, /free, xs=500, ys=300</span> <span class= code-output >   plot, dsk_pts[*,0], profile</span>              Longitudinal scan: <span class= code-output > dd_prof = pg_profile_ring(dd, gd=gd, outline_ptd, /azimuthal, dsk_pts=dsk_pts, profile=profile)</span> <span class= code-output > window, /free, xs=500, ys=300</span> <span class= code-output > plot, dsk_pts[*,1], profile, /yno</span>          ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("util/sec_to_hhmmss.html", "sec_to_hhmmss.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "sec_to_hhmmss.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/sec_to_hhmmss.html#sec_to_hhmmss", "sec_to_hhmmss", 'routine in <a href="util/sec_to_hhmmss.html">sec_to_hhmmss.pro</a>', "sec_to_hhmmss.pro", "", "sec_to_hhmmss", "", "sec", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/sedr/sedr2__define.html", "sedr2__define.pro", '.pro file in <a href="config/sedr/dir-overview.html">config/sedr/ directory</a>', "sedr2__define.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/sedr/sedr2__define.html#sedr2__define", "sedr2__define", 'routine in <a href="config/sedr/sedr2__define.html">sedr2__define.pro</a>', "sedr2__define.pro", "", "sedr2__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/sedr/sedr_buildcm.html", "sedr_buildcm.pro", '.pro file in <a href="config/sedr/dir-overview.html">config/sedr/ directory</a>', "sedr_buildcm.pro", "", "", " NAME: 	sedr_buildcm    PURPOSE: 	Build the C-matrix (or ME-matrix) from the euler angles (degrees).    CATEGORY: 	UTIL/SEDR    CALLING SEQUENCE: 	result = sedr_buildcm(alpha, delta, kappa)    ARGUMENTS:   INPUT: 	alpha:		Right ascension of optic axis (or planet pole) (degrees)  	delta:		Declination of optic axis (or planet pole) (degrees)  	kappa:		Rotation about optic axis (or planet pole) (degrees)    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    PROCEDURE:    RESTRICTIONS:    STATUS: 	Complete.    MODIFICATION HISTORY:  	Written by:	Haemmerle, 12/1998 ported from a NAV function 			Spitale 1/2002 transposed   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/sedr/sedr_buildcm.html#sedr_buildcm", "sedr_buildcm", 'routine in <a href="config/sedr/sedr_buildcm.html">sedr_buildcm.pro</a>', "sedr_buildcm.pro", "", "sedr_buildcm", "", "alphadeltakappa", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/sedr/sedr_get_bcons.html", "sedr_get_bcons.pro", '.pro file in <a href="config/sedr/dir-overview.html">config/sedr/ directory</a>', "sedr_get_bcons.pro", "", "", " NAME: 	sedr_get_bcons    PURPOSE: 	Returns a bcons record from an IDL bcons file.    CATEGORY: 	UTIL/SEDR    CALLING SEQUENCE: 	result = sedr_get_bcons(target_id)    ARGUMENTS:   INPUT: 	target_id:	Target id for information to retrieve.  Target 			id is sat_number*10 + planet_number as defined for 			the Voyager project.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE     ENVIRONMENT VARIABLES: 	NV_SEDR_DATA:	Directory containing the SEDR data files.  The 			variable should contain a trailing slash.    RETURN: 	A body constant record.   PROCEDURE: 	Opens a bcons and its index file, then returns the appropriate 	unpacked bcons record. It requires that the environment        variable NV_SEDR_DATA be set to the directory containing the        files.  The variable should contain a trailing slash.    STATUS: 	Complete.    MODIFICATION HISTORY:  	Written by:	Haemmerle, 1/1999   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/sedr/sedr_get_bcons.html#sedr_get_bcons", "sedr_get_bcons", 'routine in <a href="config/sedr/sedr_get_bcons.html">sedr_get_bcons.pro</a>', "sedr_get_bcons.pro", "", "sedr_get_bcons", "", "target_id", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/sedr/sedr_get_sedr2.html", "sedr_get_sedr2.pro", '.pro file in <a href="config/sedr/dir-overview.html">config/sedr/ directory</a>', "sedr_get_sedr2.pro", "", "", " NAME: 	sedr_get_sedr2    PURPOSE: 	Returns a sedr2 record from an IDL sedr2 file.    CATEGORY: 	UTIL/SEDR    CALLING SEQUENCE: 	result = sedr_get_sedr2(sctime ,planet)    ARGUMENTS:   INPUT:  	sctime:		Spacecraft time (FDS count x 100)         planet:         Planet, if given, one of 'jupiter', 'saturn',                        'uranus' or 'neptune'.     OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE     ENVIRONMENT VARIABLES: 	NV_SEDR_DATA:	Directory containing the SEDR data files.  The 			variable should contain a trailing slash.    RETURN: 	An unpacked sedr2 record.    PROCEDURE: 	Opens a sedr2 and its index file, then returns the appropriate 	unpacked sedr2 record.  It requires that the environment 	variable NV_SEDR_DATA be set to the directory containing the        files.  The variable should contain a trailing slash.    STATUS: 	Complete.    MODIFICATION HISTORY:  	Written by:	Haemmerle, 1/1999                        using some ideas from S. Ewald, 10/1998                        Fixed target_id for older Saturn sats 9/1999   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/sedr/sedr_get_sedr2.html#sedr_get_sedr2", "sedr_get_sedr2", 'routine in <a href="config/sedr/sedr_get_sedr2.html">sedr_get_sedr2.pro</a>', "sedr_get_sedr2.pro", "", "sedr_get_sedr2", "", "sctimeplanet", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/sedr/sedr_get_sedrupd.html", "sedr_get_sedrupd.pro", '.pro file in <a href="config/sedr/dir-overview.html">config/sedr/ directory</a>', "sedr_get_sedrupd.pro", "", "", " NAME: 	sedr_get_sedrupd    PURPOSE: 	Returns a sedrupd record from an IDL sedrupd file.    CATEGORY: 	UTIL/SEDR    CALLING SEQUENCE: 	result = sedr_get_sedrupd(sctime, planet, source)    ARGUMENTS:   INPUT:  	sctime:		Spacecraft time (FDS count x 100)         planet:         Planet, one of 'jupiter', 'saturn',                        'uranus' or 'neptune'.  	source:		One of 'DAVI', 'NAV ', 'FARE', 'NAV2', 'NEAR', 'AMOS'.     OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE     ENVIRONMENT VARIABLES: 	NV_SEDR_DATA:	Directory containing the SEDR data files.  The 			variable should contain a trailing slash.    RETURN: 	A sedrupd record.    PROCEDURE: 	Opens a sedrupd and its index file, then returns the appropriate 	unpacked sedrupd record. It requires that the environment        variable NV_SEDR_DATA be set to the directory containing the        files.  The variable should contain a trailing slash.    STATUS: 	Complete.    MODIFICATION HISTORY:  	Written by:	Haemmerle, 1/1999                        using some ideas from S. Ewald, 10/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/sedr/sedr_get_sedrupd.html#sedr_get_sedrupd", "sedr_get_sedrupd", 'routine in <a href="config/sedr/sedr_get_sedrupd.html">sedr_get_sedrupd.pro</a>', "sedr_get_sedrupd.pro", "", "sedr_get_sedrupd", "", "sctimeplanetsource", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/sedr/sedr_list.html", "sedr_list.pro", '.pro file in <a href="config/sedr/dir-overview.html">config/sedr/ directory</a>', "sedr_list.pro", "", "", " NAME: 	sedr_list    PURPOSE: 	Lists sedr2 and sedrupd records at a given sctime or for a given 	data descriptor and returns the number or sedr records and updates.    CATEGORY: 	UTIL/SEDR    CALLING SEQUENCE: 	count = sedr_list([dd=dd],[sctime=sctime])    ARGUMENTS:   INPUT: NONE     OUTPUT: NONE    KEYWORDS:   INPUT:  	    dd:		A data descriptor containing a Voyager VICAR 			header         sctime:         Spacecraft time (FDS count x 100)         planet:         Planet, if given, one of 'jupiter', 'saturn',                        'uranus' or 'neptune'.  If not given, uses                        sctime to guess.  	silent:		If set, function produces no output.    OUTPUT: NONE    RETURN: 	Returns the number of sedr records found (original + updates).    PROCEDURE: 	Finds the SEDR2 record for sctime and then searchs for updates 	among all valid sources.    RESTRICTIONS: 	None.    STATUS: 	Complete.    MODIFICATION HISTORY:  	Written by:	Haemmerle, 1/1999   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/sedr/sedr_list.html#sedr_list", "sedr_list", 'routine in <a href="config/sedr/sedr_list.html">sedr_list.pro</a>', "sedr_list.pro", "", "sedr_list", "", "ddsctimeplanetsilent", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/sedr/sedr_read.html", "sedr_read.pro", '.pro file in <a href="config/sedr/dir-overview.html">config/sedr/ directory</a>', "sedr_read.pro", "", "", " NAME: 	sedr_read    PURPOSE: 	Reads a sedr2 and sedrupd file at a given sctime.    CATEGORY: 	UTIL/SEDR    CALLING SEQUENCE: 	result = sedr_read(sctime)    ARGUMENTS:   INPUT:  	sctime:		Spacecraft time (FDS count x 100)     OUTPUT: NONE    KEYWORDS:   INPUT:         planet:         Planet, if given, one of 'jupiter', 'saturn',                        'uranus' or 'neptune'.  If not given, uses                        sctime to guess.         source:         SEDR source, if given one of 'SEDR', 'DAVI',                        'NAV ', 'FARE', 'NAV2', 'NEAR', 'AMOS'.  If                        not given, then default is 'SEDR'    OUTPUT: NONE    PROCEDURE:    RESTRICTIONS:    STATUS: 	Complete.    MODIFICATION HISTORY:  	Written by:	Haemmerle, 1/1999                        using some ideas from S. Ewald, 10/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/sedr/sedr_read.html#sedr_read", "sedr_read", 'routine in <a href="config/sedr/sedr_read.html">sedr_read.pro</a>', "sedr_read.pro", "", "sedr_read", "", "planetsourcesctime", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/sedr/sedr_time.html", "sedr_time.pro", '.pro file in <a href="config/sedr/dir-overview.html">config/sedr/ directory</a>', "sedr_time.pro", "", "", " NAME:        sedr_time    PURPOSE: 	Find seconds past 1950 from sedr.    CATEGORY:        UTIL/SEDR    CALLING SEQUENCE:        result = sedr_time(sedr)    ARGUMENTS:   INPUT:  	sedr:		A sedr2 type structure.     OUTPUT: NONE    STATUS: 	Complete.    MODIFICATION HISTORY: 	Written by:     Haemmerle, 1/1999   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/sedr/sedr_time.html#sedr_time", "sedr_time", 'routine in <a href="config/sedr/sedr_time.html">sedr_time.pro</a>', "sedr_time.pro", "", "sedr_time", "", "sedr", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/sedr/sedr_to_nv.html", "sedr_to_nv.pro", '.pro file in <a href="config/sedr/dir-overview.html">config/sedr/ directory</a>', "sedr_to_nv.pro", "", "", " NAME: 	sedr_to_nv    PURPOSE: 	Converts a C matrix to NV definition.    CATEGORY: 	UTIL/SEDR    CALLING SEQUENCE: 	result = sedr_to_nv(matrix)    ARGUMENTS:   INPUT:  	matrix:		A C matrix from sedr_buildcm()    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    PROCEDURE: 	The C-matrix defines the optic axis as the Z or 3rd axis. However, nv 	defines the optic axis as the Y (b1) or 2nd axis for the C-matrix 	and the pole also as the 2nd axis.  This procedure switches the 	2nd and third columns in a matrix given to it so that it follows 	the nv definition.    RESTRICTIONS: 	NONE.    STATUS: 	Complete.    MODIFICATION HISTORY:  	Written by:	Haemmerle, 1/1999   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/sedr/sedr_to_nv.html#sedr_to_nv", "sedr_to_nv", 'routine in <a href="config/sedr/sedr_to_nv.html">sedr_to_nv.pro</a>', "sedr_to_nv.pro", "", "sedr_to_nv", "", "matrix", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/sedr/sedr_unpack_bcons.html", "sedr_unpack_bcons.pro", '.pro file in <a href="config/sedr/dir-overview.html">config/sedr/ directory</a>', "sedr_unpack_bcons.pro", "", "", " NAME: 	sedr_unpack_bcons    PURPOSE: 	Unpacks the body constants record from platform-independent to platform        format or vis-versa.    CATEGORY: 	UTIL/SEDR    CALLING SEQUENCE: 	sedr_unpack_bcons, bconst    ARGUMENTS:   INPUT:  	bconst:		A bconst formatted record read from a bcons file.     OUTPUT: NONE    KEYWORDS:   INPUT:  	pack:		If set, reverses the process.    OUTPUT:    PROCEDURE: 	Floating and double precision numbers are converted from XDR format 	to host floating format while integers are byteswapped into host 	format.  If /pack is set, the process is reversed.    RESTRICTIONS: 	NONE.    STATUS: 	Complete.    MODIFICATION HISTORY: 	Written by:    Haemmerle, 12/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/sedr/sedr_unpack_bcons.html#sedr_unpack_bcons", "sedr_unpack_bcons", 'routine in <a href="config/sedr/sedr_unpack_bcons.html">sedr_unpack_bcons.pro</a>', "sedr_unpack_bcons.pro", "", "sedr_unpack_bcons", "", "packbconst", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/sedr/sedr_unpack_sedr2.html", "sedr_unpack_sedr2.pro", '.pro file in <a href="config/sedr/dir-overview.html">config/sedr/ directory</a>', "sedr_unpack_sedr2.pro", "", "", " NAME: 	sedr_unpack_sedr2    PURPOSE: 	Unpacks the sedr2 record from platform-independent to platform        format or vis-versa.    CATEGORY: 	UTIL/SEDR    CALLING SEQUENCE: 	sedr_unpack_sedr2, sedr    ARGUMENTS:   INPUT:  	sedr:		A sedr2 formatted record read from a sedr file.     OUTPUT: NONE    KEYWORDS:   INPUT:  	pack:		If set, reverses the process.     OUTPUT: NONE    PROCEDURE: 	Floating and double precision numbers are converted from XDR format 	to host floating format while integers are byteswapped into host 	format.  If /pack is set, the processes is reversed.    RESTRICTIONS: 	NONE.    STATUS: 	Complete.    MODIFICATION HISTORY:  	Written by:	S. Ewald, 10/1998 	Modified by:    Haemmerle, 12/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/sedr/sedr_unpack_sedr2.html#sedr_unpack_sedr2", "sedr_unpack_sedr2", 'routine in <a href="config/sedr/sedr_unpack_sedr2.html">sedr_unpack_sedr2.pro</a>', "sedr_unpack_sedr2.pro", "", "sedr_unpack_sedr2", "", "packsedr", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/sedr/sedr_unpack_sedrupd.html", "sedr_unpack_sedrupd.pro", '.pro file in <a href="config/sedr/dir-overview.html">config/sedr/ directory</a>', "sedr_unpack_sedrupd.pro", "", "", " NAME: 	sedr_unpack_sedrupd    PURPOSE: 	Unpacks the sedrupd record from platform-independent to platform        format or vis-versa.    CATEGORY: 	UTIL/SEDR    CALLING SEQUENCE: 	sedr_unpack_sedrupd, upd    ARGUMENTS:   INPUT:  	upd:		A sedrupd formatted record read from a sedru file.     OUTPUT: NONE    KEYWORDS:   INPUT:  	pack:		If set, the process is reversed.    OUTPUT: NONE    PROCEDURE: 	Floating and double precision numbers are converted from XDR format 	to host floating format while integers are byteswapped into host 	format.  If /pack is set, the process is reversed.    RESTRICTIONS: 	NONE.    STATUS: 	Complete.    MODIFICATION HISTORY:  	Written by:	S. Ewald, 10/1998 	Modified by:    Haemmerle, 12/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/sedr/sedr_unpack_sedrupd.html#sedr_unpack_sedrupd", "sedr_unpack_sedrupd", 'routine in <a href="config/sedr/sedr_unpack_sedrupd.html">sedr_unpack_sedrupd.pro</a>', "sedr_unpack_sedrupd.pro", "", "sedr_unpack_sedrupd", "", "packupd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/sedr/sedr_vgr_cameras.html", "sedr_vgr_cameras.pro", '.pro file in <a href="config/sedr/dir-overview.html">config/sedr/ directory</a>', "sedr_vgr_cameras.pro", "", "", " NAME: 	sedr_vgr_cameras    PURPOSE: 	To be called by Voyager SEDR input translator or similar procedure to 	convert sedr values to an nv camera descriptor   CATEGORY: 	UTIL/SEDR    RESTRICTIONS: 	By default, Voyager values return B1950 co-ordinates    MODIFICATION HISTORY:        Written by:     Haemmerle, 1/1999   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/sedr/sedr_vgr_cameras.html#sedr_vgr_cameras", "sedr_vgr_cameras", 'routine in <a href="config/sedr/sedr_vgr_cameras.html">sedr_vgr_cameras.pro</a>', "sedr_vgr_cameras.pro", "", "sedr_vgr_cameras", "", "j2000n_objdimstatusddsedrgeom", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/sedr/sedr_vgr_input.html", "sedr_vgr_input.pro", '.pro file in <a href="config/sedr/dir-overview.html">config/sedr/ directory</a>', "sedr_vgr_input.pro", "", "", " NAME: 	sedr_vgr_input    PURPOSE: 	Input translator for Voyager images using SEDR database.    CATEGORY: 	NV/CONFIG    CALLING SEQUENCE(only to be called by dat_get_value): 	result = sedr_vgr_input(dd, keyword)    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	keyword:	String giving the name of the translator quantity.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	key1:		Camera descriptor.    OUTPUT: 	status:		Zero if valid data is returned.     TRANSLATOR KEYWORDS: 	j2000:		If set, returned quantites are rotated to j2000 			reference frame.  Otherwise, results are b1950.  	sedr_source:	String giving the name of the SEDR update source to use. 			Default is 'SEDR'.     ENVIRONMENT VARIABLES: 	NV_SEDR_DATA:	Directory containing the SEDR data files.  The 			variable should contain a trailing slash.    RETURN: 	Data associated with the requested keyword.    STATUS: 	Complete    FULL DESCRIPTION:    The SEDR software is a collection of IDL functions and procedures that   allow the software to retrieve Voyager ephemeris data into NV camera,   planet and ring descriptors as well as an nv translator to do this when   there is no detached header for an image.     DATA   ====   The SEDR data are in several files and are expected to be in a directory   pointed to by the NV_SEDR_DATA environment variable:        'planet'.sdr2_idl             SEDR2 file       'planet'.sdr2_idx             SEDR2 index of sctime       'planet'.sdru_idl             SEDRUPD file       'planet'.sdru_idx             SEDRUPD index of sctime       bodyconst.dat_idl             Body Constants file       bodyconst.dat_idx             Body Constants index of Target ID    where 'planet' is one of jupiter, saturn, uranus or neptune, sctime is   the Voyager FDS multiplied by 100, Target ID is the Voyager ID for a   body (which is 10*Sat_number + Planet_number).  The *.sdr2_idl files   contain records of a structure described by the file SEDR2__DEFINE.PRO,   the *.sdru_idl records are described by the file SEDRUPD__DEFINE.PRO and   the bodyconst.dat_idl file records are described in BCONS__DEFINE.PRO.   The data is in J2000 coordinates, the angles are in degrees (lora is   degrees west longitude) and the dimensions are in km.  Each Voyager image   has a SEDR2 record which contains predict pointing information.  Some   images have updated information.  This is contained in the SEDRUPD records.   This will contain new elements to replace those in the SEDR2 record.   The source (JPL VICAR program which updated the info) is also listed in   the SEDRUPD record as one of 'DAVI', 'NAV ', 'FARE', 'NAV2', 'NEAR', 'AMOS'.   There can be more than one update for an image.  The ME-matrix of the   SEDRUPD record is already assumed to be one-way Light-travel time corrected   while the original SEDR2 value is not.     Create   ======   In the create subdirectory are procedures and a log file used to create   the SEDR data files from the original VMS indexed file counterparts.  To   be as simple as possible, the structures in the new files are identical   to the original VMS ones execpt in the fact that floats are in XDR format   and integers are in Network byte order (big-endian).  This is so that the   data files can be platform independent.  The routines sedr_unpack_sedr2,   sedr_unpack_sedrupd and sedr_unpack_bcons are used to convert this format   to the host platform integer and floating format.  The files were then   ftp'ed in binary format to other platforms.     Usage   =====   The following procedures and functions are likely to be used by users:    Procedure                     Purpose     sedr_list		List sources for a given sctime    sedr_read		Read a SEDR2+(SEDRUPD) record into a SEDR2 structure    vicar_vgrkey		Returns Voyager keywords from VICAR header     sedr_vgr_input	Voyager translator returns predict SEDR at B1950    More information about these routines are in doc_sedr.txt.     The following procedures and functions are likely to be used by programmers:    Procedure                     Purpose     bcons__define		Defines Body Constant structure    sedr2__define		Defines SEDR structure    sedrupd__define		Defines SEDR update structure     sedr_get_bcons		Reads a BCONS record from a file    sedr_get_sedr2		Reads a SEDR2 record from a SDR2 file    sedr_get_sedrupd		Reads a SEDRUPD record from a SDRU file     sedr_unpack_bcons		Unpacks a BCONS record    sedr_unpack_sedr2		Unpacks a SEDR2 record    sedr_unpack_sedrupd		Unpacks a SEDRUPD record     sedr_buildcm			Builds C-matrix or ME-matrix from euler angles    sedr_time			Converts SEDR time to secs past 1950    sedr_to_nv			Converts SEDR C-matrix to NV cam_orient format     sedr_vgr_cameras		Generates NV camera keywords from SEDR    sedr_vgr_planets		Generates NV planet keywords from SEDR    sedr_vgr_rings		Generates NV ring keywords from SEDR   MODIFICATION HISTORY:  	Written by:	VRH   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/sedr/sedr_vgr_input.html#sedr_vgr_input", "sedr_vgr_input", 'routine in <a href="config/sedr/sedr_vgr_input.html">sedr_vgr_input.pro</a>', "sedr_vgr_input.pro", "", "sedr_vgr_input", "", "valuesstatusddkeyword@nv_trs_keywords_include.pro", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/sedr/sedr_vgr_planets.html", "sedr_vgr_planets.pro", '.pro file in <a href="config/sedr/dir-overview.html">config/sedr/ directory</a>', "sedr_vgr_planets.pro", "", "", " NAME: 	sedr_vgr_planets    PURPOSE: 	To be called by Voyager SEDR input translator or similar procedure to 	convert sedr values to an nv planet descriptor   CATEGORY: 	UTIL/SEDR    RESTRICTIONS: 	By default, Voyager values return B1950 co-ordinates    MODIFICATION HISTORY:        Written by:     Haemmerle, 1/1999   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/sedr/sedr_vgr_planets.html#sedr_vgr_planets", "sedr_vgr_planets", 'routine in <a href="config/sedr/sedr_vgr_planets.html">sedr_vgr_planets.pro</a>', "sedr_vgr_planets.pro", "", "sedr_vgr_planets", "", "j2000n_objdimstatusplanetsedr", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/sedr/sedr_vgr_sun.html", "sedr_vgr_sun.pro", '.pro file in <a href="config/sedr/dir-overview.html">config/sedr/ directory</a>', "sedr_vgr_sun.pro", "", "", " NAME: 	sedr_vgr_sun    PURPOSE: 	To be called by Voyager SEDR input translator or similar procedure to 	convert sedr values to an nv planet descriptor   CATEGORY: 	UTIL/SEDR    RESTRICTIONS: 	By default, Voyager values return B1950 co-ordinates    MODIFICATION HISTORY:        Written by:     Spitale, 2/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/sedr/sedr_vgr_sun.html#sedr_vgr_sun", "sedr_vgr_sun", 'routine in <a href="config/sedr/sedr_vgr_sun.html">sedr_vgr_sun.pro</a>', "sedr_vgr_sun.pro", "", "sedr_vgr_sun", "", "j2000n_objdimstatussedrbconst", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/sedr/sedr_vgr_targets.html", "sedr_vgr_targets.pro", '.pro file in <a href="config/sedr/dir-overview.html">config/sedr/ directory</a>', "sedr_vgr_targets.pro", "", "", " NAME: 	sedr_vgr_targets    PURPOSE: 	To be called by Voyager SEDR input translator or similar procedure to 	convert sedr values to an nv planet descriptor   CATEGORY: 	UTIL/SEDR    RESTRICTIONS: 	By default, Voyager values return B1950 co-ordinates    MODIFICATION HISTORY:        Written by:     Haemmerle, 1/1999   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/sedr/sedr_vgr_targets.html#sedr_vgr_targets", "sedr_vgr_targets", 'routine in <a href="config/sedr/sedr_vgr_targets.html">sedr_vgr_targets.pro</a>', "sedr_vgr_targets.pro", "", "sedr_vgr_targets", "", "j2000n_objdimstatussedrbconst", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/sedr/sedrupd__define.html", "sedrupd__define.pro", '.pro file in <a href="config/sedr/dir-overview.html">config/sedr/ directory</a>', "sedrupd__define.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/sedr/sedrupd__define.html#sedrupd__define", "sedrupd__define", 'routine in <a href="config/sedr/sedrupd__define.html">sedrupd__define.pro</a>', "sedrupd__define.pro", "", "sedrupd__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/set/set_complement.html", "set_complement.pro", '.pro file in <a href="util/set/dir-overview.html">util/set/ directory</a>', "set_complement.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/set/set_complement.html#set_complement", "set_complement", 'routine in <a href="util/set/set_complement.html">set_complement.pro</a>', "set_complement.pro", "", "set_complement", "", "_AUsubscripts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/set/set_difference.html", "set_difference.pro", '.pro file in <a href="util/set/dir-overview.html">util/set/ directory</a>', "set_difference.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/set/set_difference.html#set_difference", "set_difference", 'routine in <a href="util/set/set_difference.html">set_difference.pro</a>', "set_difference.pro", "", "set_difference", "", "ABsubscripts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/composite/set_image_origin.html", "set_image_origin.pro", '.pro file in <a href="nv/obj/tools/composite/dir-overview.html">nv/obj/tools/composite/ directory</a>', "set_image_origin.pro", "", "", " NAME:        set_image_origin    PURPOSE: 	Sets the origin of a map or camera image.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        set_image_origin, xd, origin    ARGUMENTS:   INPUT: 	xd:      Camera or map descriptor  	origin: origin argument as in map_set_origin     OUTPUT: NONE    KEYWORDS:    INPUT: NONE     OUTPUT: NONE    RETURN: 	NONE.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/composite/set_image_origin.html#set_image_origin", "set_image_origin", 'routine in <a href="nv/obj/tools/composite/set_image_origin.html">set_image_origin.pro</a>', "set_image_origin.pro", "", "set_image_origin", "", "cdorigin", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/composite/set_image_size.html", "set_image_size.pro", '.pro file in <a href="nv/obj/tools/composite/dir-overview.html">nv/obj/tools/composite/ directory</a>', "set_image_size.pro", "", "", " NAME:        set_image_size    PURPOSE: 	Sets the size of a map or camera image.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        set_image_size, xd, size    ARGUMENTS:   INPUT: 	xd:      Camera or map descriptor  	size: 	 Size argument as in map_set_size     OUTPUT: NONE    KEYWORDS:    INPUT: NONE     OUTPUT: NONE    RETURN: 	NONE.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/composite/set_image_size.html#set_image_size", "set_image_size", 'routine in <a href="nv/obj/tools/composite/set_image_size.html">set_image_size.pro</a>', "set_image_size.pro", "", "set_image_size", "", "cdsize", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/set/set_intersection.html", "set_intersection.pro", '.pro file in <a href="util/set/dir-overview.html">util/set/ directory</a>', "set_intersection.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/set/set_intersection.html#set_intersection", "set_intersection", 'routine in <a href="util/set/set_intersection.html">set_intersection.pro</a>', "set_intersection.pro", "", "set_intersection", "", "ABiiAiiBkk", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/set/set_union.html", "set_union.pro", '.pro file in <a href="util/set/dir-overview.html">util/set/ directory</a>', "set_union.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/set/set_union.html#set_union", "set_union", 'routine in <a href="util/set/set_union.html">set_union.pro</a>', "set_union.pro", "", "set_union", "", "ABsubscripts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/settings_box.html", "settings_box.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "settings_box.pro", "", "", " settings_box   PURPOSE :  	Pops up a widget displaying user specified settings in  	various formats, allowing user to change them.  Returns -1  	if cancelled, 0 otherwise.  On return, unless cancelled,  	the string array new_settings will contain the new settings if it  	is set.  If change is set, then the init fields will be changed  	to reflect the new settings.   CALLING SEQUENCE :    status = settings_box(setup, new_settings=new_settings)    ARGUMENTS   INPUT : setup - input string array defining the settings widget, defined                   as follows:                    [ [label, type, init, par1, par2],                     [label, type, init, par1, par2],                                   .                                   .                                   .                     [label, type, init, par1, par2] ]               label : the label for setting field               type  : the type of setting widget to use, valid types are :                        INPUT   : input taken from a text widget with x and y                                 sizes taken from par1 and par2.  Defaults                                 are xsize=20 and ysize=1.                        SLIDER  : input taken from a slider widget with max                                  and min values par_1 and par_2, respectively.                        TOGGLE  : input taken from a toggle button with values                                  'On' and 'Off'.                        DROPLIST  : input taken from a drop list.  par1 is                                   a handle pointing to the list of possible                                   values.                        NEW_BASE : start a new base with the given label and                                  a frame.  Init can be either 'ROW' or                                  'COLUMN' for row or column base.  Default                                  is column base.                        NEW_COLUMN : start a new column               init  : the intial value for that field               par1, par2 : parameters where applicable     OUTPUT : NONE     KEYWORDS   INPUT : title - title for the base widget            group_leader - group leader for the base widget.            desensitize - array of indices of input widgets to be made                         insensitive.    OUTPUT : new_settings - array containing new settings in the same order                          in which they were specified.      RETURN : -1 if cancel was pressed, 0 otherwise.      EXAMPLE :    status=settings_box( $           [ ['Volume : ', 'Slider', '3', '0', '10'], $             ['Dolby  : ', 'Toggle', 'on', '', ''], $             ['Name   : ', 'Input', 'Dan Danberry', '',''] ], $                new_settings=new_settings )     NOTE: numeric data is input and output as a string.    RESTRICTIONS:     PROCEDURES USED:     KNOWN BUGS : NONE     ORIGINAL AUTHOR : J. Spitale ; 8/94   UPDATE HISTORY :   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/settings_box.html#settings_box_event", "settings_box_event", 'routine in <a href="util/settings_box.html">settings_box.pro</a>', "settings_box.pro", "", "settings_box_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/settings_box.html#settings_box", "settings_box", 'routine in <a href="util/settings_box.html">settings_box.pro</a>', "settings_box.pro", "", "settings_box", "", "new_settingstitlegroup_leaderdesensitizesetup", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/shift_image.html", "shift_image.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "shift_image.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/shift_image.html#shift_image", "shift_image", 'routine in <a href="util/shift_image.html">shift_image.pro</a>', "shift_image.pro", "", "shift_image", "", "imagesxsy", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/sign.html", "sign.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "sign.pro", "", "", " NAME:        sign   PURPOSE:        Return the sign of the operand    CATEGORY:        UTIL    CALLING SEQUENCE:        return = sign(x)    ARGUMENTS:   INPUT:        x:      An input value or array    OUTPUT:        NONE   KEYWORDS:        NONE   RETURN:        An array whose elements are the sign (+1 or -1) of the input array.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/sign.html#sign", "sign", 'routine in <a href="util/sign.html">sign.pro</a>', "sign.pro", "", "sign", "", "x", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/sinc.html", "sinc.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "sinc.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/sinc.html#sinc", "sinc", 'routine in <a href="util/sinc.html">sinc.pro</a>', "sinc.pro", "", "sinc", "", "normx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/sinfit.html", "sinfit.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "sinfit.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/sinfit.html#sinfit_fn", "sinfit_fn", 'routine in <a href="util/sinfit.html">sinfit.pro</a>', "sinfit.pro", "", "sinfit_fn", "", "xafdf", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/sinfit.html#sinfit", "sinfit", 'routine in <a href="util/sinfit.html">sinfit.pro</a>', "sinfit.pro", "", "sinfit", "", "dychisqsigfixyfitrmsxya0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/sizeof.html", "sizeof.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "sizeof.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/sizeof.html#sizeof", "sizeof", 'routine in <a href="util/sizeof.html">sizeof.pro</a>', "sizeof.pro", "", "sizeof", "", "typex", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/skip.html", "skip.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "skip.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/skip.html#skip", "skip", 'routine in <a href="util/skip.html">skip.pro</a>', "skip.pro", "", "skip", "", "offsetxj", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/sky_mask.html", "sky_mask.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "sky_mask.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/sky_mask.html#sky_mask", "sky_mask", 'routine in <a href="util/sky_mask.html">sky_mask.pro</a>', "sky_mask.pro", "", "sky_mask", "", "extendimagescale", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/sky_points.html", "sky_points.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "sky_points.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/sky_points.html#sky_points", "sky_points", 'routine in <a href="util/sky_points.html">sky_points.pro</a>', "sky_points.pro", "", "sky_points", "", "maskumaskextendnmaxedgeall_imagensigscale", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/sld/sld_albedo.html", "sld_albedo.pro", '.pro file in <a href="nv/obj/sld/dir-overview.html">nv/obj/sld/ directory</a>', "sld_albedo.pro", "", "", " NAME: 	sld_albedo    PURPOSE:        Returns the bond albedo for each given solid descriptor.    CATEGORY: 	NV/LIB/SLD    CALLING SEQUENCE: 	mass = sld_albedo(sld)    ARGUMENTS:   INPUT: 	sld:	 Array (nt) of any subclass of SOLID descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN:        Array (nt) of albedos associated with each given solid descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/sld/sld_albedo.html#sld_albedo", "sld_albedo", 'routine in <a href="nv/obj/sld/sld_albedo.html">sld_albedo.pro</a>', "sld_albedo.pro", "", "sld_albedo", "", "noeventsld", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/sld/sld_assign.html", "sld_assign.pro", '.pro file in <a href="nv/obj/sld/dir-overview.html">nv/obj/sld/ directory</a>', "sld_assign.pro", "", "", " NAME: 	sld_assign    PURPOSE: 	Replaces fields in a SOLID object.  This is a convenient way of 	setting multiple fields in one call, and only a single event is 	generated.    CATEGORY: 	NV/OBJ/SLD    CALLING SEQUENCE: 	sld_assign, sld, <keywords>=<values>    ARGUMENTS:   INPUT: 	sld:		SOLID object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	SOLID fields to set.  	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	sld_set_*     MODIFICATION HISTORY:  	Written by:	Spitale		2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/sld/sld_assign.html#sld_assign", "sld_assign", 'routine in <a href="nv/obj/sld/sld_assign.html">sld_assign.pro</a>', "sld_assign.pro", "", "sld_assign", "", "noeventxd@sld__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/sld/sld_create_descriptors.html", "sld_create_descriptors.pro", '.pro file in <a href="nv/obj/sld/dir-overview.html">nv/obj/sld/ directory</a>', "sld_create_descriptors.pro", "", "", " NAME: 	sld_create_descriptors    PURPOSE: 	Init method for the SOLID class.    CATEGORY: 	NV/LIB/SLD    CALLING SEQUENCE: 	sld = sld_create_descriptors(n)    ARGUMENTS:   INPUT: 	n:	Number of descriptors to create.    OUTPUT: NONE    KEYWORDS (in addition to those accepted by all superclasses):   INPUT: 	sld:	Globe descriptor(s) to initialize, instead of creating a new one.  	bd:	Body descriptor(s) instead of using bod_create_descriptors.  	crd:	Core descriptor(s) instead of using cor_create_descriptors.  	opacity: Array (n) of opacities for each body.  	GM:	Array (n) of masses x gravitiational constant.  	mass:	Array (n) of masses.  	phase_fn: Array (n) of phase function names.  	phase_parm:	Array (npht,n) of phase function parameters.  	refl_fn: Array (n) of reflection function names.  	refl_parm:	Array (npht,n) of reflection function parameters.  	albedo:	Array (n) of bond albedos.     OUTPUT: NONE    RETURN: 	Newly created or or freshly initialized solid descriptors, depending 	on the presence of the bd keyword.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/sld/sld_create_descriptors.html#sld_create_descriptors", "sld_create_descriptors", 'routine in <a href="nv/obj/sld/sld_create_descriptors.html">sld_create_descriptors.pro</a>', "sld_create_descriptors.pro", "", "sld_create_descriptors", "", "crdbdsldn@sld__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/sld/sld_evolve.html", "sld_evolve.pro", '.pro file in <a href="nv/obj/sld/dir-overview.html">nv/obj/sld/ directory</a>', "sld_evolve.pro", "", "", " NAME: 	sld_evolve    PURPOSE:        Computes new solid descriptors at the given time offsets from        the given solid descriptors using the taylor series expansion        corresponding to the derivatives contained in the given solid        descriptor.    CATEGORY: 	NV/LIB/SLD    CALLING SEQUENCE: 	sldt = sld_evolve(sld, dt)    ARGUMENTS:   INPUT: 	sld:	 Array (nsld) of any subclass of SOLID descriptors.  	dt:	 Array (ndt) of time offsets.    OUTPUT: NONE    KEYWORDS:   INPUT: 	nodv:	 If set, velocities will not be evolved.  	copy:	If set, the evolved descriptor is copied into the input 		descriptor and it is freed.  The input descriptor is returned.     OUTPUT: NONE    RETURN:        Array (ngd,ndt) of newly allocated solid descriptors evolved        by time dt, where ngd is the number of sld, and ndt is the        number of dt.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/sld/sld_evolve.html#sld_evolve", "sld_evolve", 'routine in <a href="nv/obj/sld/sld_evolve.html">sld_evolve.pro</a>', "sld_evolve.pro", "", "sld_evolve", "", "nodvcopyslddt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/sld/sld_gm.html", "sld_gm.pro", '.pro file in <a href="nv/obj/sld/dir-overview.html">nv/obj/sld/ directory</a>', "sld_gm.pro", "", "", " NAME: 	sld_gm    PURPOSE:        Returns the GM value for each given solid descriptor.    CATEGORY: 	NV/LIB/SLD    CALLING SEQUENCE: 	gm = sld_gm(sld)    ARGUMENTS:   INPUT: 	sld:	 Array (nt) of any subclass of SOLID descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN:        Array (nt) of GM values associated with each given solid descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/sld/sld_gm.html#sld_gm", "sld_gm", 'routine in <a href="nv/obj/sld/sld_gm.html">sld_gm.pro</a>', "sld_gm.pro", "", "sld_gm", "", "noeventsld", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/sld/sld_mass.html", "sld_mass.pro", '.pro file in <a href="nv/obj/sld/dir-overview.html">nv/obj/sld/ directory</a>', "sld_mass.pro", "", "", " NAME: 	sld_mass    PURPOSE:        Returns the mass for each given solid descriptor.    CATEGORY: 	NV/LIB/SLD    CALLING SEQUENCE: 	mass = sld_mass(sld)    ARGUMENTS:   INPUT: 	sld:	 Array (nt) of any subclass of SOLID descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN:        Array (nt) of mass values associated with each given solid 	descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/sld/sld_mass.html#sld_mass", "sld_mass", 'routine in <a href="nv/obj/sld/sld_mass.html">sld_mass.pro</a>', "sld_mass.pro", "", "sld_mass", "", "noeventsld", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/sld/sld_npht.html", "sld_npht.pro", '.pro file in <a href="nv/obj/sld/dir-overview.html">nv/obj/sld/ directory</a>', "sld_npht.pro", "", "", " NAME: 	sld_npht    PURPOSE: 	Returns an integer indicating the maximum number of parameters 	allowed in the refl_parm and phase-parm fields of the solid 	descriptor.  This number can be adjusted using the environment 	variable 'SLD_NPHT'.  The default is 4.    CATEGORY: 	NV/LIB/SLD    CALLING SEQUENCE: 	npht = sld_npht()    ARGUMENTS:   INPUT: NONE    OUTPUT: NONE    KEYWORDS:   INPUT: NONE     OUTPUT: NONE    ENVIRONMENT VARIABLES: 	SLD_NPHT:	Sets the npht value.    RETURN: 	Current npht value.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/sld/sld_npht.html#sld_npht", "sld_npht", 'routine in <a href="nv/obj/sld/sld_npht.html">sld_npht.pro</a>', "sld_npht.pro", "", "sld_npht", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/sld/sld_opacity.html", "sld_opacity.pro", '.pro file in <a href="nv/obj/sld/dir-overview.html">nv/obj/sld/ directory</a>', "sld_opacity.pro", "", "", " NAME: 	sld_opacity    PURPOSE: 	Returns the opacity for each given solid descriptor.    CATEGORY: 	NV/LIB/SLD    CALLING SEQUENCE: 	opacity = sld_opacity(sld)    ARGUMENTS:   INPUT: NONE 	sld:	 Any subclass of SOLID.    OUTPUT: NONE    KEYWORDS:   INPUT:    OUTPUT: NONE    RETURN: 	Opacity value associated with each given solid descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/sld/sld_opacity.html#sld_opacity", "sld_opacity", 'routine in <a href="nv/obj/sld/sld_opacity.html">sld_opacity.pro</a>', "sld_opacity.pro", "", "sld_opacity", "", "noeventsld", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/sld/sld_phase.html", "sld_phase.pro", '.pro file in <a href="nv/obj/sld/dir-overview.html">nv/obj/sld/ directory</a>', "sld_phase.pro", "", "", " NAME: 	sld_phase    PURPOSE: 	Computes a phase function.    CATEGORY: 	NV/LIB/SLD    CALLING SEQUENCE: 	phase = sld_phase(sld, mu, mu0)    ARGUMENTS:   INPUT: 	sld:	 Globe descriptor.  	mu:	 Cosine of the emission angle.  	mu0:	 Cosine of the incidence angle.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Phase function value for the given mu and mu0 parameters.    PROCEDURE: 	The function indicated by the phase_fn field of the solid descriptor 	is called and its return value is passed through to the caller of 	sld_phase.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/sld/sld_phase.html#sld_phase", "sld_phase", 'routine in <a href="nv/obj/sld/sld_phase.html">sld_phase.pro</a>', "sld_phase.pro", "", "sld_phase", "", "sldmumu0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/sld/sld_phase_fn.html", "sld_phase_fn.pro", '.pro file in <a href="nv/obj/sld/dir-overview.html">nv/obj/sld/ directory</a>', "sld_phase_fn.pro", "", "", " NAME: 	sld_phase_fn    PURPOSE:        Returns the name of the phase function for each given solid 	descriptor.    CATEGORY: 	NV/LIB/SLD    CALLING SEQUENCE: 	mass = sld_phase_fn(sld)    ARGUMENTS:   INPUT: 	sld:	 Array (nt) of any subclass of SOLID descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN:        Array (nt) of phase function names associated with each given solid 	descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/sld/sld_phase_fn.html#sld_phase_fn", "sld_phase_fn", 'routine in <a href="nv/obj/sld/sld_phase_fn.html">sld_phase_fn.pro</a>', "sld_phase_fn.pro", "", "sld_phase_fn", "", "noeventsld", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/sld/sld_phase_parm.html", "sld_phase_parm.pro", '.pro file in <a href="nv/obj/sld/dir-overview.html">nv/obj/sld/ directory</a>', "sld_phase_parm.pro", "", "", " NAME: 	sld_phase_parm    PURPOSE:        Returns the phase function parameters for each given solid descriptor.    CATEGORY: 	NV/LIB/SLD    CALLING SEQUENCE: 	mass = sld_phase_parm(sld)    ARGUMENTS:   INPUT: 	sld:	 Array (nt) of any subclass of SOLID descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN:        Array (npht,nt) of phase function parameters associated with each 	given solid descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/sld/sld_phase_parm.html#sld_phase_parm", "sld_phase_parm", 'routine in <a href="nv/obj/sld/sld_phase_parm.html">sld_phase_parm.pro</a>', "sld_phase_parm.pro", "", "sld_phase_parm", "", "noeventsld", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/sld/sld_query.html", "sld_query.pro", '.pro file in <a href="nv/obj/sld/dir-overview.html">nv/obj/sld/ directory</a>', "sld_query.pro", "", "", " NAME: 	sld_query    PURPOSE: 	Returns the fields associated with a CAMERA object.  This is a 	convenient way of getting multiple fields in one call, and only a 	single event is generated.    CATEGORY: 	NV/OBJ/CAM    CALLING SEQUENCE: 	sld_query, sld, <keywords>=<values>    ARGUMENTS:   INPUT: 	sld:	CAMERA object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	CAMERA object fields to set.  	condition:	Structure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT object, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.  	cat:		If set, arrays from mulitple input objets are 			concatenated.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.  	noevent:	If set, no event is generated.    OUTPUT: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/sld/sld_query.html#sld_query", "sld_query", 'routine in <a href="nv/obj/sld/sld_query.html">sld_query.pro</a>', "sld_query.pro", "", "sld_query", "", "conditioncatnoeventxd@sld__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/sld/sld_refl.html", "sld_refl.pro", '.pro file in <a href="nv/obj/sld/dir-overview.html">nv/obj/sld/ directory</a>', "sld_refl.pro", "", "", " NAME: 	sld_refl    PURPOSE: 	Computes a reflection function.    CATEGORY: 	NV/LIB/SLD    CALLING SEQUENCE: 	refl = sld_refl(sld, mu, mu0)    ARGUMENTS:   INPUT: 	sld:	 Globe descriptor.  	mu:	 Cosine of the emission angle.  	mu0:	 Cosine of the incidence angle.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Refletion function value for the given mu and mu0 parameters.    PROCEDURE: 	The function indicated by the refl_fn field of the solid descriptor 	is called and its return value is passed through to the caller of 	sld_phase.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/sld/sld_refl.html#sld_refl", "sld_refl", 'routine in <a href="nv/obj/sld/sld_refl.html">sld_refl.pro</a>', "sld_refl.pro", "", "sld_refl", "", "sldmumu0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/sld/sld_refl_fn.html", "sld_refl_fn.pro", '.pro file in <a href="nv/obj/sld/dir-overview.html">nv/obj/sld/ directory</a>', "sld_refl_fn.pro", "", "", " NAME: 	sld_refl_fn    PURPOSE:        Returns the name of the reflection function for each given solid 	descriptor.    CATEGORY: 	NV/LIB/SLD    CALLING SEQUENCE: 	mass = sld_refl_fn(sld)    ARGUMENTS:   INPUT: 	sld:	 Array (nt) of any subclass of SOLID descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN:        Array (nt) of reflection function names associated with each given 	solid descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/sld/sld_refl_fn.html#sld_refl_fn", "sld_refl_fn", 'routine in <a href="nv/obj/sld/sld_refl_fn.html">sld_refl_fn.pro</a>', "sld_refl_fn.pro", "", "sld_refl_fn", "", "noeventsld", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/sld/sld_refl_parm.html", "sld_refl_parm.pro", '.pro file in <a href="nv/obj/sld/dir-overview.html">nv/obj/sld/ directory</a>', "sld_refl_parm.pro", "", "", " NAME: 	sld_refl_parm    PURPOSE:        Returns the reflection function parameters for each given solid 	descriptor.    CATEGORY: 	NV/LIB/SLD    CALLING SEQUENCE: 	mass = sld_refl_parm(sld)    ARGUMENTS:   INPUT: 	sld:	 Array (nt) of any subclass of SOLID descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN:        Array (npht,nt) of reflection function parameters associated with 	each given solid descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/sld/sld_refl_parm.html#sld_refl_parm", "sld_refl_parm", 'routine in <a href="nv/obj/sld/sld_refl_parm.html">sld_refl_parm.pro</a>', "sld_refl_parm.pro", "", "sld_refl_parm", "", "noeventsld", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/sld/sld_set_albedo.html", "sld_set_albedo.pro", '.pro file in <a href="nv/obj/sld/dir-overview.html">nv/obj/sld/ directory</a>', "sld_set_albedo.pro", "", "", " NAME: 	sld_set_albedo    PURPOSE:        Replaces the bond albedo for each given solid descriptor.    CATEGORY: 	NV/LIB/SLD    CALLING SEQUENCE: 	sld_set_albedo, sld, albedo    ARGUMENTS:   INPUT: 	sld:	 Array (nt) of any subclass of SOLID descriptors.  	albedo:	 Array (nt) of new bond albedos.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/sld/sld_set_albedo.html#sld_set_albedo", "sld_set_albedo", 'routine in <a href="nv/obj/sld/sld_set_albedo.html">sld_set_albedo.pro</a>', "sld_set_albedo.pro", "", "sld_set_albedo", "", "noeventsldalbedo", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/sld/sld_set_gm.html", "sld_set_gm.pro", '.pro file in <a href="nv/obj/sld/dir-overview.html">nv/obj/sld/ directory</a>', "sld_set_gm.pro", "", "", " NAME: 	sld_set_gm    PURPOSE:        Replaces the GM value for each given solid descriptor.    CATEGORY: 	NV/LIB/SLD    CALLING SEQUENCE: 	sld_set_gm, sld, gm    ARGUMENTS:   INPUT: 	sld:	 Array (nt) of any subclass of SOLID descriptors.  	gm:	 Array (nt) of new GM values.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/sld/sld_set_gm.html#sld_set_gm", "sld_set_gm", 'routine in <a href="nv/obj/sld/sld_set_gm.html">sld_set_gm.pro</a>', "sld_set_gm.pro", "", "sld_set_gm", "", "nosynchnoeventsldgm", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/sld/sld_set_mass.html", "sld_set_mass.pro", '.pro file in <a href="nv/obj/sld/dir-overview.html">nv/obj/sld/ directory</a>', "sld_set_mass.pro", "", "", " NAME: 	sld_set_mass    PURPOSE:        Replaces the mass for each given solid descriptor.    CATEGORY: 	NV/LIB/SLD    CALLING SEQUENCE: 	sld_set_mass, sld, mass    ARGUMENTS:   INPUT: 	sld:	 Array (nt) of any subclass of SOLID descriptors.  	j:	 Array (nj,nt) of new masses.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/sld/sld_set_mass.html#sld_set_mass", "sld_set_mass", 'routine in <a href="nv/obj/sld/sld_set_mass.html">sld_set_mass.pro</a>', "sld_set_mass.pro", "", "sld_set_mass", "", "nosynchnoeventsldmass", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/sld/sld_set_opacity.html", "sld_set_opacity.pro", '.pro file in <a href="nv/obj/sld/dir-overview.html">nv/obj/sld/ directory</a>', "sld_set_opacity.pro", "", "", " NAME: 	sld_set_opacity    PURPOSE: 	Replaces the opacity of each given solid descriptor.    CATEGORY: 	NV/LIB/SLD    CALLING SEQUENCE: 	sld_set_opacity, sld, opacity    ARGUMENTS:   INPUT: 	sld:	 Any subclass of SOLID.  	opacity:	 New opacity value.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/sld/sld_set_opacity.html#sld_set_opacity", "sld_set_opacity", 'routine in <a href="nv/obj/sld/sld_set_opacity.html">sld_set_opacity.pro</a>', "sld_set_opacity.pro", "", "sld_set_opacity", "", "noeventsldopacity", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/sld/sld_set_phase_fn.html", "sld_set_phase_fn.pro", '.pro file in <a href="nv/obj/sld/dir-overview.html">nv/obj/sld/ directory</a>', "sld_set_phase_fn.pro", "", "", " NAME: 	sld_set_phase_fn    PURPOSE:        Replaces the phase function for each given solid descriptor.    CATEGORY: 	NV/LIB/SLD    CALLING SEQUENCE: 	sld_set_phase_fn, sld, phase_fn    ARGUMENTS:   INPUT: 	sld:	 Array (nt) of any subclass of SOLID descriptors.  	phase_fn: Array (nt) of new phase functions.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/sld/sld_set_phase_fn.html#sld_set_phase_fn", "sld_set_phase_fn", 'routine in <a href="nv/obj/sld/sld_set_phase_fn.html">sld_set_phase_fn.pro</a>', "sld_set_phase_fn.pro", "", "sld_set_phase_fn", "", "noeventsldphase_fn", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/sld/sld_set_phase_parm.html", "sld_set_phase_parm.pro", '.pro file in <a href="nv/obj/sld/dir-overview.html">nv/obj/sld/ directory</a>', "sld_set_phase_parm.pro", "", "", " NAME: 	sld_set_phase_parm    PURPOSE:        Replaces the phase function parameters for each given solid descriptor.    CATEGORY: 	NV/LIB/SLD    CALLING SEQUENCE: 	sld_set_phase_parm, sld, phase_parm    ARGUMENTS:   INPUT: 	sld:		Array (nt) of any subclass of SOLID descriptors.  	phase_parm:	Array (nt) of new phase function parameters.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/sld/sld_set_phase_parm.html#sld_set_phase_parm", "sld_set_phase_parm", 'routine in <a href="nv/obj/sld/sld_set_phase_parm.html">sld_set_phase_parm.pro</a>', "sld_set_phase_parm.pro", "", "sld_set_phase_parm", "", "noeventsldphase_parm", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/sld/sld_set_refl_fn.html", "sld_set_refl_fn.pro", '.pro file in <a href="nv/obj/sld/dir-overview.html">nv/obj/sld/ directory</a>', "sld_set_refl_fn.pro", "", "", " NAME: 	sld_set_refl_fn    PURPOSE:        Replaces the reflection function for each given solid descriptor.    CATEGORY: 	NV/LIB/SLD    CALLING SEQUENCE: 	sld_set_refl_fn, sld, refl_fn    ARGUMENTS:   INPUT: 	sld:	 Array (nt) of any subclass of SOLID descriptors.  	refl_fn: Array (nt) of new reflection functions.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/sld/sld_set_refl_fn.html#sld_set_refl_fn", "sld_set_refl_fn", 'routine in <a href="nv/obj/sld/sld_set_refl_fn.html">sld_set_refl_fn.pro</a>', "sld_set_refl_fn.pro", "", "sld_set_refl_fn", "", "noeventsldrefl_fn", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/sld/sld_set_refl_parm.html", "sld_set_refl_parm.pro", '.pro file in <a href="nv/obj/sld/dir-overview.html">nv/obj/sld/ directory</a>', "sld_set_refl_parm.pro", "", "", " NAME: 	sld_set_refl_parm    PURPOSE:        Replaces the reflection function parameters for each given solid 	descriptor.    CATEGORY: 	NV/LIB/SLD    CALLING SEQUENCE: 	sld_set_refl_parm, sld, refl_parm    ARGUMENTS:   INPUT: 	sld:		Array (nt) of any subclass of SOLID descriptors.  	refl_parm:	Array (nt) of new reflection function parameters.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/sld/sld_set_refl_parm.html#sld_set_refl_parm", "sld_set_refl_parm", 'routine in <a href="nv/obj/sld/sld_set_refl_parm.html">sld_set_refl_parm.pro</a>', "sld_set_refl_parm.pro", "", "sld_set_refl_parm", "", "noeventsldrefl_parm", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/smear_psf.html", "smear_psf.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "smear_psf.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/smear_psf.html#smear_psf", "smear_psf", 'routine in <a href="nv/obj/tools/smear_psf.html">smear_psf.pro</a>', "smear_psf.pro", "", "smear_psf", "", "cdbxwidth", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/smooth_on_curve.html", "smooth_on_curve.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "smooth_on_curve.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/smooth_on_curve.html#smooth_on_curve", "smooth_on_curve", 'routine in <a href="nv/obj/tools/smooth_on_curve.html">smooth_on_curve.pro</a>', "smooth_on_curve.pro", "", "smooth_on_curve", "", "cdimagepwidth", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/tools/smooth_on_curve.html#_smooth_on_curve", "_smooth_on_curve", 'routine in <a href="nv/obj/tools/smooth_on_curve.html">smooth_on_curve.pro</a>', "smooth_on_curve.pro", "", "_smooth_on_curve", "", "imagepwidth", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/icy/spice_bodvar.html", "spice_bodvar.pro", '.pro file in <a href="config/spice/icy/dir-overview.html">config/spice/icy/ directory</a>', "spice_bodvar.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/icy/spice_bodvar.html#spice_bodvar", "spice_bodvar", 'routine in <a href="config/spice/icy/spice_bodvar.html">spice_bodvar.pro</a>', "spice_bodvar.pro", "", "spice_bodvar", "", "idnameval", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/icy/spice_cameras.html", "spice_cameras.pro", '.pro file in <a href="config/spice/icy/dir-overview.html">config/spice/icy/ directory</a>', "spice_cameras.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/icy/spice_cameras.html#spice_cameras", "spice_cameras", 'routine in <a href="config/spice/icy/spice_cameras.html">spice_cameras.pro</a>', "spice_cameras.pro", "", "spice_cameras", "", "scinstplatcam_timedtcam_scalecam_oaxiscam_exposurecam_sizecam_fn_focal_to_imagecam_fn_image_to_focalcam_fi_datatolconstantsn_objdimstatusorientspice_fnposcam_fn_psfcam_filtersobsddrefk_inuk_in", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/icy/spice_clear.html", "spice_clear.pro", '.pro file in <a href="config/spice/icy/dir-overview.html">config/spice/icy/ directory</a>', "spice_clear.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/icy/spice_clear.html#spice_clear", "spice_clear", 'routine in <a href="config/spice/icy/spice_clear.html">spice_clear.pro</a>', "spice_clear.pro", "", "spice_clear", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/icy/spice_cull.html", "spice_cull.pro", '.pro file in <a href="config/spice/icy/dir-overview.html">config/spice/icy/ directory</a>', "spice_cull.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/icy/spice_cull.html#spice_cull", "spice_cull", 'routine in <a href="config/spice/icy/spice_cull.html">spice_cull.pro</a>', "spice_cull.pro", "", "spice_cull", "", "full", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/icy/spice_daf_comment.html", "spice_daf_comment.pro", '.pro file in <a href="config/spice/icy/dir-overview.html">config/spice/icy/ directory</a>', "spice_daf_comment.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/icy/spice_daf_comment.html#spice_daf_comment", "spice_daf_comment", 'routine in <a href="config/spice/icy/spice_daf_comment.html">spice_daf_comment.pro</a>', "spice_daf_comment.pro", "", "spice_daf_comment", "", "fname", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/spice_et2jed.html", "spice_et2jed.pro", '.pro file in <a href="config/spice/dir-overview.html">config/spice/ directory</a>', "spice_et2jed.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/spice_et2jed.html#spice_et2jed", "spice_et2jed", 'routine in <a href="config/spice/spice_et2jed.html">spice_et2jed.pro</a>', "spice_et2jed.pro", "", "spice_et2jed", "", "et", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/icy/spice_et2str.html", "spice_et2str.pro", '.pro file in <a href="config/spice/icy/dir-overview.html">config/spice/icy/ directory</a>', "spice_et2str.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/icy/spice_et2str.html#spice_et2str", "spice_et2str", 'routine in <a href="config/spice/icy/spice_et2str.html">spice_et2str.pro</a>', "spice_et2str.pro", "", "spice_et2str", "", "formatprecets", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/icy/spice_get_all_target_names.html", "spice_get_all_target_names.pro", '.pro file in <a href="config/spice/icy/dir-overview.html">config/spice/icy/ directory</a>', "spice_get_all_target_names.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/icy/spice_get_all_target_names.html#spice_get_all_target_names", "spice_get_all_target_names", 'routine in <a href="config/spice/icy/spice_get_all_target_names.html">spice_get_all_target_names.pro</a>', "spice_get_all_target_names.pro", "", "spice_get_all_target_names", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/icy/spice_get_cameras.html", "spice_get_cameras.pro", '.pro file in <a href="config/spice/icy/dir-overview.html">config/spice/icy/ directory</a>', "spice_get_cameras.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/icy/spice_get_cameras.html#spice_get_cameras", "spice_get_cameras", 'routine in <a href="config/spice/icy/spice_get_cameras.html">spice_get_cameras.pro</a>', "spice_get_cameras.pro", "", "spice_get_cameras", "", "obsscinstplatrefettolcam_poscam_velcmatcam_avelpos_only", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/spice_get_kpath.html", "spice_get_kpath.pro", '.pro file in <a href="config/spice/dir-overview.html">config/spice/ directory</a>', "spice_get_kpath.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/spice_get_kpath.html#spice_get_kpath", "spice_get_kpath", 'routine in <a href="config/spice/spice_get_kpath.html">spice_get_kpath.pro</a>', "spice_get_kpath.pro", "", "spice_get_kpath", "", "envklist", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/icy/spice_get_planets.html", "spice_get_planets.pro", '.pro file in <a href="config/spice/icy/dir-overview.html">config/spice/icy/ directory</a>', "spice_get_planets.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/icy/spice_get_planets.html#spice_get_planets", "spice_get_planets", 'routine in <a href="config/spice/icy/spice_get_planets.html">spice_get_planets.pro</a>', "spice_get_planets.pro", "", "spice_get_planets", "", "constantsobsnamesrefetposvelavelorientradiiloragmjcoeffoundidsrrefrefl_fnrefl_parmphase_fnphase_parmalbedo", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/icy/spice_ids.html", "spice_ids.pro", '.pro file in <a href="config/spice/icy/dir-overview.html">config/spice/icy/ directory</a>', "spice_ids.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/icy/spice_ids.html#spice_ids", "spice_ids", 'routine in <a href="config/spice/icy/spice_ids.html">spice_ids.pro</a>', "spice_ids.pro", "", "spice_ids", "", "name", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/spice_input.html", "spice_input.pro", '.pro file in <a href="config/spice/dir-overview.html">config/spice/ directory</a>', "spice_input.pro", "", "", " NAME: 	spice_input    PURPOSE: 	Generic NAIF/SPICE input translator core.  This routine is not an 	OMINAS input translator; it is intended to be called by an input 	translator that is taylored to a specific mission.    CATEGORY: 	NV/CONFIG    CALLING SEQUENCE: 	result = spice_input(dd, keyword, prefix)    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	keyword:	String giving the name of the translator quantity. 			The following keywords are recognized:  			'CAM_DESCRIPTORS': The function [prefix]_spice_cameras 					   Is called.  			'PLT_DESCRIPTORS': The function [prefix]_spice_planets 					   Is called.  			'STR_DESCRIPTORS': The function [prefix]_spice_sun 					   Is called.  Only the sun is 				           recognized.  	prefix:		String giving a prefix to use in constructing the names 			of the input functions:  			  [prefix]_spice_cameras 			  [prefix]_spice_planets 			  [prefix]_spice_sun  			These functions are wrappers that prepare the relevant 			inputs for a specific mission and call either 			spice_cameras or spice_planets to obtain the appropriate 			descriptors.  To obtain sun data, a planet descriptor is 			obtained from spice_planets and converted to a star 			descriptor.  See cas_spice_input for an example of how 			to write such functions.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	key1:		Camera descriptor.  	key7:		Requested object time.  	key8:		Array of requested object names.  Planets are requested 			in the order given, except that the primary target body 			is placed at the front of the list.    OUTPUT: 	status:		Zero if valid data is returned.     TRANSLATOR KEYWORDS: 	ref:		Name of the reference frame for the output quantities. 			Default is 'j2000'.  	j2000:		/j2000 is equivalent to specifying ref=j2000.  	b1950:		/b1950 is equivalent to specifying ref=b1950.  	klist:		Name of a file giving a list of SPICE kernels to use. 			If no path is included, the path is taken from the 			NV_SPICE_KER environment variable.  Note that this 			keyword is effective only before any kernels have been 			loaded or when /reload is specified.  This file 			contains a list of file specifications, one per line. 			Lines beginning with '#' are ignored.  Kernels may 			also be selected by image time using the keywords 			START_TIME, STOP_TIME, and DEFAULT as in the 			following example:   			$NV_SPICE_SPK/010419_SE_SAT077.bsp 			$NV_SPICE_CK/051008_051217_s15s16_port3_pa.bc  			START_TIME = 2002-270T10:57:56.870 			 $NV_SPICE_SPK/000331R_SK_LP0_V1P32.bsp 			 $NV_SPICE_SPK/010419_SE_SAT077.bsp 			STOP_TIME = 2002-281T20:57:56.870  			START_TIME = 2002-290T20:57:56.870 			 $NV_SPICE_SPK/000331R_SK_LP0_V1P32.bsp 			 $NV_SPICE_SPK/010419_SE_SAT077.bsp 			STOP_TIME = 2002-291T20:57:56.870  			DEFAULT 			 $NV_SPICE_SPK/000331R_SK_LP0_V1P32.bsp 			 $NV_SPICE_SPK/010419_SE_SAT077.bsp-bb   			Files appearing before the first START_TIME are always 			loaded.  If the image time is not covered in a 			START/STOP_TIME block, then the DEFAULT kernels are 			loaded.  Keywords must appear at the beginning of 			the line and DEFAULT must come last.  	<type>_in:	List of input kernels of the given type; e,g, ck_in, 			spk_in, lsk_in, etc.  List must be delineated by 			semimcolons with no space.  The kernel list 			file is still used, but these kernels take 			precedence.  Entries in this list may be file 			specification strings.  On each call, kernels are 			loaded and unloaded such that the kernel pool will 			consist of the klist kernels and these kernels. 			If the value 'auto' is given, then an attempt may be 			made to detect the correct kernel file for the given 			image, depending on the instrument.  Kernels specified 			explicitly by name here take precedence over those 			determined using the auto-detection.  If a path 			is specified with 'auto', the kernels that path 			is used to autodetection instead of the path given 			by the relevant environment variable.  	reverse:	If set, klist kernels are loaded last, causing them to 			take precedence.  	<type>_reverse:	If set, the type of kernel will be loaded before 			the klist, demoting their precedence.  	<type>_strict:	Causes /strict to be passed to the corresponding 			kernel auto-detection routine.  The behavior 			depends on the routine, but typically this will 			result in fewer kernels being loaded.  	<type>_all:	Causes /all to be passed to the corresponding 			kernel auto-detection routine.  The behavior 			depends on the routine, but typically this should 			result in all kernels of the given type being loaded.  	protect:	Semicolon-delimited list of file specifications.  All 			kernels matched are left untouched in the kernel pool. 			If a file specification starts with '!', then only 			kernels not matched will be left untouched in the 			kernel pool.  	reload:		If set, all kernels are unloaded and the current 			kernel pool is loaded from scratch.  The interface 			operates very reliably, but very inefficiently using 			this option.  	constants:	If set, only kernels containing constants are loaded. 			Only those quantities are filled in.  	targets:	Name of text file listing the targets to be requested 			from the kernel pool.  If not given, the name of the 			file is taken from the environment variable 			[prefix]_SPICE_TARGETS.  	nokernels:	If set, the kernel pool will not be modified.  	name:		If given, objects names are taken from this keyword 			rather than from key8.  	obs:		Name or NAIF ID of observer.  Default is SSB.  	pos:		Get only position information, not pointing.  	strict_priority:If set, previously loaded kernels are uncloded and 			reloaded in order to preserve thei priority.  This is 			potentially very slow.    ENVIRONMENT VARIABLES: 	NV_SPICE_KER:		Directory containing the kernel list file.  	NV_SPICE_<type>:	Directory containing the kernel files specified 				using <type>_in.  Multiple directories can be 				delimited using the ':' character.  	[prefix]_SPICE_TARGETS:	Name of optional targets file; see targets 				keyword.    RETURN: 	Data associated with the requested keyword.    STATUS: 	Complete    FULL DESCRIPTION:    The purpose of the OMINAS SPICE interface is to allow SPICE kernels to be   directly read into and written from OMINAS via input and output translators.   Because SPICE kernels are mission-dependent (the exact layout of the C-matrix   depends on the camera in question, for example), unique input and output   translators must be written for each mission supported.  Translators and   supporting routines for each mission reside in subdirectories whose names are   abbreviations of the mission name, for example 'cas' or 'gll'. The package   described here provides as much generic support for those specific transators   as possible.    The SPICE input translator, SPICE_INPUT, reads all of the SPICE spacecraft   and planetary ephemeris data and returns the appropriate descriptors.  The   SPICE output translator, SPICE_OUTPUT, currently recognizes only camera   descriptors, writing only a C-kernel containing any number of C matrices.     Generic Kernel Detectors   ------------------------   The fundamental problem in the NAIF/SPICE system is determining which kernels   are needed for a given image.   For kernels generated by NAIF, ths is relatively   simple, as they adhere to a strict naming convention.  However, project-   generated kernels (mainly CK and SPK) reside in a special level of hell where   file names may have any meaning or none at all, may give the coverage dates,   some kind of mission-specific version code, may be generated according to an   algorithm, or may be written by a human operator who may or may not have had   a good day.  Therefore, automatic construction of a kernel pool is not trivial.   Indeed, we are not aware that it has ever been accomplished in a generic sense.    One solution to the problem is to have a separate set of kernel detectors for   each mission.  For example, the CAS package has a set of detectors that can   identify kernels based on known Cassini conventions.  However, coding such a   system is often one of the most difficult parts of adding a SPICE translator   for a new mission.  Therefore we have attempted to developed and automatic   system for generic kernel pool detection.  These detectors are automatically   called if no specific detectors are fould for a mission package.  At present,   the system funtions, but needs refinement to produce the most concise kernel   pool.    Coverage times are specified within the kernel or its detached label, so   determining a set of kernels that covers a given observation is conceptually   simple.  In practice, reading the coverage times from every available kernel   file and finding the relevant kernels may take minutes, so we have implemented   a system that catalogs all relevant kernel information into a database that can   be searched quickly (see below).    Determining the latest version of a kernel is much more difficult because the   SPICE system does not track version information; that information typically   is encoded (if at all) in the kernel file name, in a project-specific code.   We attempt to solve this problem by looking at a number of indicators like   segment interval lengths, label time stamps, file time stamps, etc.     [[needs updating...]]   Kernel Databases  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/spice_input.html#si_manage_kernels", "si_manage_kernels", 'routine in <a href="config/spice/spice_input.html">spice_input.pro</a>', "spice_input.pro", "", "si_manage_kernels", "", "prefixposreloadconstantstimestatusdd", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/spice/spice_input.html#si_get", "si_get", 'routine in <a href="config/spice/spice_input.html">spice_input.pro</a>', "spice_input.pro", "", "si_get", "", "odtimestatusddkeywordprefix", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/spice/spice_input.html#spice_input", "spice_input", 'routine in <a href="config/spice/spice_input.html">spice_input.pro</a>', "spice_input.pro", "", "spice_input", "", "valuesstatusddkeywordprefix@nv_trs_keywords_include.pro", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/spice_jed2et.html", "spice_jed2et.pro", '.pro file in <a href="config/spice/dir-overview.html">config/spice/ directory</a>', "spice_jed2et.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/spice_jed2et.html#spice_jed2et", "spice_jed2et", 'routine in <a href="config/spice/spice_jed2et.html">spice_jed2et.pro</a>', "spice_jed2et.pro", "", "spice_jed2et", "", "jeds", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/spice_kernel_parse.html", "spice_kernel_parse.pro", '.pro file in <a href="config/spice/dir-overview.html">config/spice/ directory</a>', "spice_kernel_parse.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/spice_kernel_parse.html#skp_simple", "skp_simple", 'routine in <a href="config/spice/spice_kernel_parse.html">spice_kernel_parse.pro</a>', "spice_kernel_parse.pro", "", "skp_simple", "", "extddpath", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/spice/spice_kernel_parse.html#spice_kernel_parse", "spice_kernel_parse", 'routine in <a href="config/spice/spice_kernel_parse.html">spice_kernel_parse.pro</a>', "spice_kernel_parse.pro", "", "spice_kernel_parse", "", "exttimeexplicitstrictallddprefixtype", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/icy/spice_load.html", "spice_load.pro", '.pro file in <a href="config/spice/icy/dir-overview.html">config/spice/icy/ directory</a>', "spice_load.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/icy/spice_load.html#spice_load", "spice_load", 'routine in <a href="config/spice/icy/spice_load.html">spice_load.pro</a>', "spice_load.pro", "", "spice_load", "", "uk_inpoolk_in", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/icy/spice_loaded.html", "spice_loaded.pro", '.pro file in <a href="config/spice/icy/dir-overview.html">config/spice/icy/ directory</a>', "spice_loaded.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/icy/spice_loaded.html#spice_loaded", "spice_loaded", 'routine in <a href="config/spice/icy/spice_loaded.html">spice_loaded.pro</a>', "spice_loaded.pro", "", "spice_loaded", "", "fullverbatim", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/spice_output.html", "spice_output.pro", '.pro file in <a href="config/spice/dir-overview.html">config/spice/ directory</a>', "spice_output.pro", "", "", " NAME: 	spice_output    PURPOSE: 	Generic NAIF/SPICE output translator core.  This routine is not a 	OMINAS output translator; it is intended to be called by an output 	translator that is taylored to a specific mission.  This routine 	works only for camera descriptors.    CATEGORY: 	NV/CONFIG    CALLING SEQUENCE: 	spice_output, dd, keyword, value, prefix    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	keyword:	String giving the name of the translator quantity. 			Only 'CAM_DESCRIPTORS' is recognized and the routine 			[prefix]_spice_write_cameras is called.  	value:		The data to write.  	prefix:		String giving a prefix to use in contructing the names 			of the input function:  			  [prefix]_spice_write_cameras  			This function is a wrapper that prepares the relevant 			inputs for a specific mission and calls 			spice_write_cameras to write a C-kernel.  See 			cas_spice_output for an example of how to write such 			a function.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	key1:		Camera descriptor.    OUTPUT: 	status:		Zero unless a problem occurs.     TRANSLATOR KEYWORDS: 	ref:		Name of the reference frame for the input quantities. 			Default is 'j2000'.  	j2000:		/j2000 is equivalent to specifying ref=j2000.  	b1950:		/b1950 is equivalent to specifying ref=b1950.  	klist:		Name of a file giving a list of SPICE kernels to use. 			If no path is included, the path is taken from the 			NV_SPICE environment variable.  	ck_out:		String giving the name of the new C-kernel to write.  	reload:		If set, new kernels are loaded, as specified by the 			klist keyword.     ENVIRONMENT VARIABLES: 	NV_SPICE_KER:	Directory containing the kernel list file.    STATUS: 	Complete    SEE ALSO: 	spice_input    MODIFICATION HISTORY:  	Written by:	Spitale, 10/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/spice_output.html#spice_output", "spice_output", 'routine in <a href="config/spice/spice_output.html">spice_output.pro</a>', "spice_output.pro", "", "spice_output", "", "statusddkeywordvalueprefix@nv_trs_keywords_include.pro", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/spice_parse_strings.html", "spice_parse_strings.pro", '.pro file in <a href="config/spice/dir-overview.html">config/spice/ directory</a>', "spice_parse_strings.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/spice_parse_strings.html#spice_parse_strings", "spice_parse_strings", 'routine in <a href="config/spice/spice_parse_strings.html">spice_parse_strings.pro</a>', "spice_parse_strings.pro", "", "spice_parse_strings", "", "s", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/icy/spice_planets.html", "spice_planets.pro", '.pro file in <a href="config/spice/icy/dir-overview.html">config/spice/icy/ directory</a>', "spice_planets.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/icy/spice_planets.html#spice_planets", "spice_planets", 'routine in <a href="config/spice/icy/spice_planets.html">spice_planets.pro</a>', "spice_planets.pro", "", "spice_planets", "", "nametimetargetn_objdimstatusconstantsobsddref", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/icy/spice_put_cameras.html", "spice_put_cameras.pro", '.pro file in <a href="config/spice/icy/dir-overview.html">config/spice/icy/ directory</a>', "spice_put_cameras.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/icy/spice_put_cameras.html#spice_put_cameras", "spice_put_cameras", 'routine in <a href="config/spice/icy/spice_put_cameras.html">spice_put_cameras.pro</a>', "spice_put_cameras.pro", "", "spice_put_cameras", "", "scinstplatreffnamecommentetexpposvelcmat_avel", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/spice_read_klist.html", "spice_read_klist.pro", '.pro file in <a href="config/spice/dir-overview.html">config/spice/ directory</a>', "spice_read_klist.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/spice_read_klist.html#spice_read_klist", "spice_read_klist", 'routine in <a href="config/spice/spice_read_klist.html">spice_read_klist.pro</a>', "spice_read_klist.pro", "", "spice_read_klist", "", "ck_outtimeprefixnotimeextensionddklist", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/spice_read_targets.html", "spice_read_targets.pro", '.pro file in <a href="config/spice/dir-overview.html">config/spice/ directory</a>', "spice_read_targets.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/spice_read_targets.html#spice_read_targets", "spice_read_targets", 'routine in <a href="config/spice/spice_read_targets.html">spice_read_targets.pro</a>', "spice_read_targets.pro", "", "spice_read_targets", "", "fname", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/icy/spice_sct2et.html", "spice_sct2et.pro", '.pro file in <a href="config/spice/icy/dir-overview.html">config/spice/icy/ directory</a>', "spice_sct2et.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/icy/spice_sct2et.html#spice_sct2et", "spice_sct2et", 'routine in <a href="config/spice/icy/spice_sct2et.html">spice_sct2et.pro</a>', "spice_sct2et.pro", "", "spice_sct2et", "", "timessc", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/spice_sort_kernels.html", "spice_sort_kernels.pro", '.pro file in <a href="config/spice/dir-overview.html">config/spice/ directory</a>', "spice_sort_kernels.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/spice_sort_kernels.html#si_get_kernels_to_load", "si_get_kernels_to_load", 'routine in <a href="config/spice/spice_sort_kernels.html">spice_sort_kernels.pro</a>', "spice_sort_kernels.pro", "", "si_get_kernels_to_load", "", "reloadexplicitk_inloaded_kernels", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/spice/spice_sort_kernels.html#si_protect_kernels", "si_protect_kernels", 'routine in <a href="config/spice/spice_sort_kernels.html">spice_sort_kernels.pro</a>', "spice_sort_kernels.pro", "", "si_protect_kernels", "", "_kernelsspecs", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/spice/spice_sort_kernels.html#spice_sort_kernels", "spice_sort_kernels", 'routine in <a href="config/spice/spice_sort_kernels.html">spice_sort_kernels.pro</a>', "spice_sort_kernels.pro", "", "spice_sort_kernels", "", "reloadreverseprotectk_inck_inspk_inpck_infk_inik_insck_inlsk_inxk_inck_expspk_exppck_expfk_expik_expsck_explsk_expxk_expkernels_to_loadkernels_to_unloadck_reversespk_reversepck_reversefk_reverseik_reversesck_reverselsk_reversexk_reversestrict_priorityall_kernels", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/icy/spice_stpool.html", "spice_stpool.pro", '.pro file in <a href="config/spice/icy/dir-overview.html">config/spice/icy/ directory</a>', "spice_stpool.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/icy/spice_stpool.html#spice_stpool", "spice_stpool", 'routine in <a href="config/spice/icy/spice_stpool.html">spice_stpool.pro</a>', "spice_stpool.pro", "", "spice_stpool", "", "idnameval", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/icy/spice_str2et.html", "spice_str2et.pro", '.pro file in <a href="config/spice/icy/dir-overview.html">config/spice/icy/ directory</a>', "spice_str2et.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/icy/spice_str2et.html#spice_str2et", "spice_str2et", 'routine in <a href="config/spice/icy/spice_str2et.html">spice_str2et.pro</a>', "spice_str2et.pro", "", "spice_str2et", "", "times", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/spice_str2jed.html", "spice_str2jed.pro", '.pro file in <a href="config/spice/dir-overview.html">config/spice/ directory</a>', "spice_str2jed.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/spice_str2jed.html#spice_str2jed", "spice_str2jed", 'routine in <a href="config/spice/spice_str2jed.html">spice_str2jed.pro</a>', "spice_str2jed.pro", "", "spice_str2jed", "", "time", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/spice_test.html", "spice_test.pro", '.pro file in <a href="config/spice/dir-overview.html">config/spice/ directory</a>', "spice_test.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/spice_test.html#spice_test", "spice_test", 'routine in <a href="config/spice/spice_test.html">spice_test.pro</a>', "spice_test.pro", "", "spice_test", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/icy/spice_unitim.html", "spice_unitim.pro", '.pro file in <a href="config/spice/icy/dir-overview.html">config/spice/icy/ directory</a>', "spice_unitim.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/icy/spice_unitim.html#spice_unitim", "spice_unitim", 'routine in <a href="config/spice/icy/spice_unitim.html">spice_unitim.pro</a>', "spice_unitim.pro", "", "spice_unitim", "", "_tsinsysoutsys", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/icy/spice_write_cameras.html", "spice_write_cameras.pro", '.pro file in <a href="config/spice/icy/dir-overview.html">config/spice/icy/ directory</a>', "spice_write_cameras.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/icy/spice_write_cameras.html#spice_write_cameras", "spice_write_cameras", 'routine in <a href="config/spice/icy/spice_write_cameras.html">spice_write_cameras.pro</a>', "spice_write_cameras.pro", "", "spice_write_cameras", "", "scinstplatstatusddrefck_filecd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/spice/icy/bug/spkbug.html", "spkbug.pro", '.pro file in <a href="config/spice/icy/bug/dir-overview.html">config/spice/icy/bug/ directory</a>', "spkbug.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/spice/icy/bug/spkbug.html#spkbug", "spkbug", 'routine in <a href="config/spice/icy/bug/spkbug.html">spkbug.pro</a>', "spkbug.pro", "", "spkbug", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/split_filename.html", "split_filename.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "split_filename.pro", "", "", " NAME: 	split_filename    PURPOSE: 	Divides a path in to directory and filename.    CATEGORY: 	UTIL    CALLING SEQUENCE: 	split_filename, filename, dir, name    ARGUMENTS:   INPUT: 	filename:	filenames to split    OUTPUT: 	dir:	directories  	name:	base filenames  	ext:	If this argument is given, the file extension is returned 		and the 'name' output contains only the base name without 		the extension.    RETURN: 	NONE     MODIFICATION HISTORY:  	Written by:	Spitale, 11/2001   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/split_filename.html#split_filename", "split_filename", 'routine in <a href="util/split_filename.html">split_filename.pro</a>', "split_filename.pro", "", "split_filename", "", "filenamedirnameext", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/split_filename.html#_split_filename", "_split_filename", 'routine in <a href="util/split_filename.html">split_filename.pro</a>', "split_filename.pro", "", "_split_filename", "", "filenamedirname", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/ssort.html", "ssort.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "ssort.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/ssort.html#ssort", "ssort", 'routine in <a href="util/ssort.html">ssort.pro</a>', "ssort.pro", "", "ssort", "", "array", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/star_psf_gaussian.html", "star_psf_gaussian.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "star_psf_gaussian.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/star_psf_gaussian.html#star_psf_gaussian", "star_psf_gaussian", 'routine in <a href="util/star_psf_gaussian.html">star_psf_gaussian.pro</a>', "star_psf_gaussian.pro", "", "star_psf_gaussian", "", "imagepwidth", "          -1", "");
  
  

libdata[libdataItem++] = new Array("demo/defunct/stars_example.html", "stars_example.pro", '.pro file in <a href="demo/defunct/dir-overview.html">demo/defunct/ directory</a>', "stars_example.pro", "", "", " Star fitting example   This example requires a star catalog. The options are: UCAC4, UCACT,  TYCHO2, SAO, and GSC2. To learn more about where to obtain these  catalogs, please see the documentation for the star catalog translators,  strcat_ucac4_input, strcat_ucact_input, strcat_tycho2_input,  strcat_sao_input, and strcat_gsc2_input.   In this script, the star fitting capabilities of OMINAS will be demonstrated.   This example file can be executed from the UNIX command line using: <span class= code-output >ominas stars_example</span>  or from within an OMINAS IDL session using: <span class= code-output >@stars_example</span>  After the example stops, later code samples in this file may be executed by  pasting them onto the IDL command line.   Image read and display   This first section uses dat_read to read in the image. There are several  available image files to use for the preocessing:   	c1138223.gem: Voyager VICAR format file where the image has had  	the camera distortions removed with the VICAR program GEOMA.   	N1456251768_1.IMG: Cassini ISS-NA image, obtained from the PDS imaging  	node.   dat_read reads the image portion (im) and the image label (label) and its  output is a data descriptor (dd). tvim is called to display the image (im)  at 3/4 size in a new window with the y coordinate as top-down.   Note: Users with a 24-bit display, you may want to do the device command  'pseudo=8' so that xloadct can be used to contrast enhance the image.   Code: <span class= code-output >;dd = dat_read('data/c1138223.gem', im, label)           ; VICAR format file</span> <span class= code-output >dd = dat_read(getenv('OMINAS_DIR')+'/demo/data/N1456251768_1.IMG', im, label)    ; Cas ISS-NA image</span> <span class= code-output >tvim, im, zoom=0.75, /order</span>   Filling the descriptors   This section fills the camera descriptor (cd), the planet descriptor  (pd) and the ring descriptor (rd) for use by the software.   Code: <span class= code-output >cd = pg_get_cameras(dd)</span> <span class= code-output >pd = pg_get_planets(dd, od=cd)</span> <span class= code-output >rd = pg_get_rings(dd, pd=pd, od=cd)</span>   Filling the generic descriptor   This line fills a  generic  descriptor, which is a standard IDL struct.  Generic descriptors are a convenient notation for several descriptors to  be grouped into a structure that can be passed to functions in one piece.   The components of the generic descriptor are: <span class= code-output >cd - camera descriptor part</span> <span class= code-output >gbx - globe descriptor part</span> <span class= code-output >dkx - disk descriptor part</span>  Code: <span class= code-output >gd = {cd:cd, gbx:pd, dkx:rd}</span>   Filling the star descriptor   This line fills a star descriptor by reading the star catalog using  pg_get_stars. pg_get_stars calls back-end functions to read the  translator table. Therefore, for a specific instrument (for instance,  both ISS-NA and ISS-WA), the star catalog should be specified. The  translators.tab for this demo (in data/translators.tab) should contain  a line with the star catalog to be used: <span class= code-output > -   strcat_tycho2_input     -       /j2000    # or /b1950 if desired</span>  This line specifies that the tycho2 catalog should be used, and all  coordinates should be for the j2000 epoch. Likewise, such a line should  be included in the translator for any mission to be processed.   NOTES:   If the keyword 'tr_override' is specified, only the specified   translator is called instead of whatever star catalog   translators are listed in the translators table.    The translator keyword 'faint' selects only stars with magnitudes   brighter than 14.  The keyword, 'bright' may be used place an upper   bound on the brightness.    /no_sort suppresses the default behavior of returning only   the first object found with any given name.  That operation can be   very time consuming when a large number of objects are returned   by the translators.  In the first case, we have specified that only one   translator will be called, and we know that it will not return   duplicate objects.   Code: <span class= code-output >;sd = pg_get_stars(dd, od=cd, /no_sort, tr_ov='strcat_gsc2_input', 'faint=8')</span> <span class= code-output >sd = pg_get_stars(dd, od=cd, 'faint=14')</span>   Calculating the star centers   The star centers are calculated using pg_center. bx is an output  keyword which contains the body descriptor, in this case it is an  array of star descriptors. Each star descriptor describes the  data for one star.   pg_hide is called to remove (/rm) any star points covered by the  planet (/globe). Although there is no planet in the Cassini image,  this technique should be used to hide star points in general, were  there to be a limb_ptd.   Determining the plot characteristics   The star elements are chosen to be red, with a symbol type of *  (code 2), a font size of 2, and labels corresponding to the name of  each star. Stars can have either catalog names or common names.   Code: <span class= code-output >star_ptd=pg_center(bx=sd, gd=gd) & pg_hide, star_ptd, gd=gd, bx=pd, /rm</span> <span class= code-output >n_stars=n_elements(sd)</span> <span class= code-output >color = ctred()</span> <span class= code-output >psym = 6</span> <span class= code-output >csizes = 2</span> <span class= code-output >plabels = cor_name(sd)</span>   Drawing the star centers   This section draws the stars in the star_ptd with the colors, plot  symbols, font size, and labels defined earlier.   In this particular example, the planet does not appear in the image.   Code: <span class= code-output >pg_draw, star_ptd, color=color, psym=psym, plabel=plabels, csi=csizes</span>   Drawing the stellar spectral types   This pasteable section uses the stellar library function str_sp to return  spectral types of the stars and uses them instead of the star names. If  the spectral type is not available for the catalog, then no information  will be plotted in the labels.   Code: <span class= code-output >tvim, im</span> <span class= code-output >spt=str_sp(sd)</span> <span class= code-output >psyms_str=make_array(n_stars,val=6)</span> <span class= code-output >pg_draw, star_ptd, color=color, psym=psym, plabel=spt, csi=csizes</span>   Drawing stellar magnitudes   This pasteable section uses the stellar library function str_get_mag to get  visual magnitudes of the stars and uses them instead of the star names.   Code: <span class= code-output >tvim, im</span> <span class= code-output >sm = str_get_mag(sd)</span> <span class= code-output >smag = string(sm, format='(f4.1)')</span> <span class= code-output >psyms_str=make_array(n_stars,val=6)</span> <span class= code-output >pg_draw, star_ptd, color=color, psym=psym, plabel=smag, csi=csizes</span>   Manually repointing the geometry   This pasteable section first clears the screen of the plotted points  by redisplaying the image with tvim.  It then calls pg_drag to allow  the user to use the cursor to drag the pointing, and with it the stars.  To move the pointing with pg_drag, use the left mouse button and  translate the pointing in x,y.  Use the middle mouse button to rotate  the pointing about an axis (in this case, the axis of rotation is set  as the optic axis of the image (star_ptd) which is defined using the  routine pnt_create_descrptors with the points being the camera optic  axis as returned by the camera library routine cam_oaxis.  When the  desired pointing is set, the right mouse button accepts it.  pg_drag  returns the delta x,y amount dragged (dxy) as well as the rotation  angle (dtheta).  pg_repoint uses the dxy and dtheta to update the  camera descriptor (cd, passed by gd).  The limb, ring and star points  are then recalculated, the image redisplayed to clear the objects drawn,  and then pg_draw is called to replot.   Code: <span class= code-output >optic_ptd = pnt_create_descriptors(points=cam_oaxis(cd))</span> <span class= code-output >tvim, im</span> <span class= code-output >dxy = pg_drag(star_ptd, dtheta=dtheta, axis=optic_ptd, symbol=6)  ; square</span> <span class= code-output >pg_repoint, dxy, dtheta, axis=optic_ptd, gd=gd</span> <span class= code-output >star_ptd=pg_center(bx=sd, gd=gd) & pg_hide, star_ptd, gd=gd, bx=pd, /rm</span> <span class= code-output >tvim, im</span> <span class= code-output >pg_draw, star_ptd, color=color, psym=psym, plabel=plabels</span>   Scanning to find the stars and using it to calculate the pointing   This section calls pg_ptscan to scan the image around the predicted  star positions (within width of 40 pixels) and find the pixels with  the highest correlation with a given edge model (example uses the  default gaussian) for each star.  These points are then plotted.   Code: <span class= code-output >ptscan_ptd = pg_ptscan(dd, star_ptd, edge=30, width=40)</span> <span class= code-output >pg_draw, ptscan_ptd, psym=1, col=ctyellow()</span>   Thresholding using correlation coefficient   This section (optional) calls pg_threshold to remove points with lower  correlation coefficients.  This example only keeps stars with a  correlation coefficient above 0.6.  Notice that each object can have  its own min and max value.   Code: <span class= code-output >pg_threshold, ptscan_ptd, min=make_array(n_stars,val=0.6), $</span> <span class= code-output >                          max=make_array(n_stars,val=1.0)</span> <span class= code-output >tvim, im</span> <span class= code-output >pg_draw, object_ptd, colors=colors, psyms=psyms, psizes=psizes, plabel=plabels</span> <span class= code-output >pg_draw, ptscan_ptd, psym=1, col=ctyellow()</span>   Removing regions of bad points   This section (optional) calls pg_select to remove points within a  polygonal region as defined by the cursor.  Click the left mouse  button to mark a point and move the mouse to the next point and  click.  Use the middle mouse button to erase a point and the right  mouse button to end the region.  pg_trim removes the points in the  just defined region.  The scan points are then replotted.  Repeat these statements for each region a user wants to remove.   Code: <span class= code-output >region=pg_select(dd)</span> <span class= code-output >pg_trim, dd, ptscan_ptd, region</span> <span class= code-output >tvim, im</span> <span class= code-output >pg_draw, object_ptd, colors=colors, psyms=psyms, psizes=psizes, plabel=plabels</span> <span class= code-output >pg_draw, ptscan_ptd, psym=1, col=ctyellow()</span>   Fitting the pointing to the found stars   This section calls pg_ptscan_coeff to determine the linear  least-squares coefficients for a fit to the image coordinate translation  and rotation which matches the computed positions to the scanned  positions. It then calls pg_fit to do the fit with the calculated  coefficients to calculate the correction in translation (dxy) and  rotation (dtheta).  It calls pg_ptchisq to get the chi square of the  fit.  It then calls pg_repoint to update the pointing.  Recalculates  the limb, rings and stars and replots.   Code: <span class= code-output >optic_ptd = pnt_create_descriptors(points=cam_oaxis(cd))</span> <span class= code-output >ptscan_cf = pg_ptscan_coeff(ptscan_ptd, axis=optic_ptd)</span> <span class= code-output >dxy = pg_fit([ptscan_cf], dtheta=dtheta)</span> <span class= code-output >chisq = pg_chisq(dxy, dtheta, ptscan_ptd, axis=optic_ptd[0])</span> <span class= code-output >covar = pg_covariance([ptscan_cf])</span> <span class= code-output >print, dxy, dtheta*180./!pi, chisq, covar</span> <span class= code-output >pg_repoint, dxy, dtheta, axis=optic_ptd, gd=gd</span> <span class= code-output >star_ptd = pg_center(bx=sd, gd=gd) & pg_hide, star_ptd, gd=gd, bx=pd, /rm</span> <span class= code-output >tvim, im</span> <span class= code-output >pg_draw, star_ptd, color=color, psym=psym, plabel=plabels</span>   Output the new state   This section (optional) shows how you can save your output: any changes  to the image data into a new file and the new pointing into a detached  header.   Code: <span class= code-output >pg_put_cameras, dd, gd=gd</span> <span class= code-output >dat_write, getenv('OMINAS_DIR')+'/demo/data/c1138223_nv.gem', dd</span>  ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("config/stn/station_input.html", "station_input.pro", '.pro file in <a href="config/stn/dir-overview.html">config/stn/ directory</a>', "station_input.pro", "", "", " NAME: 	station_input    PURPOSE: 	Input translator for planet-based stations.    CATEGORY: 	NV/CONFIG    CALLING SEQUENCE(only to be called by dat_get_value): 	result = station_input(dd, keyword)    ARGUMENTS:   INPUT: 	dd:  Data descriptor.  	keyword: String giving the name of the translator quantity.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	key2:  Primary body descriptor    OUTPUT: 	status:  Zero if valid data is returned    ENVIRONMENT VARIABLES: 	NV_STATION_DATA:	Sets the directory in which to look for data 				files.    TRANSLATOR KEYWORDS: 	NONE    RETURN: 	Data associated with the requested keyword.    STATUS: 	Complete    MODIFICATION HISTORY: 	Written by: Spitale; 7/2007   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/stn/station_input.html#station_input", "station_input", 'routine in <a href="config/stn/station_input.html">station_input.pro</a>', "station_input.pro", "", "station_input", "", "valuesstatusddkeywordprefix@nv_trs_keywords_include.pro", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/stn/station_read.html", "station_read.pro", '.pro file in <a href="config/stn/dir-overview.html">config/stn/ directory</a>', "station_read.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/stn/station_read.html#station_read", "station_read", 'routine in <a href="config/stn/station_read.html">station_read.pro</a>', "station_read.pro", "", "station_read", "", "namesdefaultfilename", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/stn/station_record__define.html", "station_record__define.pro", '.pro file in <a href="config/stn/dir-overview.html">config/stn/ directory</a>', "station_record__define.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/stn/station_record__define.html#station_record__define", "station_record__define", 'routine in <a href="config/stn/station_record__define.html">station_record__define.pro</a>', "station_record__define.pro", "", "station_record__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/stellab.html", "stellab.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "stellab.pro", "", "", " NAME:        stellab    PURPOSE: 	Corrects body positions for stellar aberration on objects for which the 	correction has not already been performed..    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        stellab, obs_bx, targ_bx    ARGUMENTS:   INPUT: 	obs_bx:		Array (nt) of any subclass of BODY describing 			the observer.  	targ_bx:	Array (nt) of any subclass of BODY describing 			the target.  The position of this body is modified.    OUTPUT:  NONE    KEYWORDS:   INPUT: 	c:		Speed of light.  	invert:		If set, the inverse correction is performed.    OUTPUT: NONE    RETURN: NONE    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/stellab.html#stellab", "stellab", 'routine in <a href="nv/obj/tools/stellab.html">stellab.pro</a>', "stellab.pro", "", "stellab", "", "cfastinvertobs_bx_targ_bx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/stellab_pos.html", "stellab_pos.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "stellab_pos.pro", "", "", " NAME:        stellab_pos    PURPOSE: 	Corrects positions for stellar aberration.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        new_pos = stellab_pos(pos, vel)    ARGUMENTS:   INPUT: 	pos:	Array (nv,3) of target inertial position vectors to be 		corrected.  	vel:	Array (nv,3) of observer inertial velocity vectors. 		Note observer is assumed to be at the origin.    OUTPUT:  NONE    KEYWORDS:   INPUT: 	c:	Speed of light.    OUTPUT: 	axis:	Array (nv,3) of rotation axes corresponding to each 		correction.  	theta:	Array (nv) of rotation angles corresponding to each 		correction.    RETURN: 	Array (nv,3) of corrected position vectors.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/stellab_pos.html#stellab_pos", "stellab_pos", 'routine in <a href="nv/obj/tools/stellab_pos.html">stellab_pos.pro</a>', "stellab_pos.pro", "", "stellab_pos", "", "caxisthetafastposvel", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/stellab_radec.html", "stellab_radec.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "stellab_radec.pro", "", "", " NAME:        stellab_radec    PURPOSE: 	Corrects positions given in the radec system for stellar 	aberration.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        new_radec = stellab_radec(radec, vel)    ARGUMENTS:   INPUT: 	radec:	Array (nv,3) of target inertial position vectors to be 		corrected, given in the radec system.  	vel:	Array (nv,3) of observer inertial velocity vectors. 		Note observer is assumed to be at the origin.    OUTPUT:  NONE    KEYWORDS:   INPUT: 	c:	Speed of light.    OUTPUT: NONE    RETURN: 	Array (nv,3) of corrected position vectors in the radec system.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/stellab_radec.html#stellab_radec", "stellab_radec", 'routine in <a href="nv/obj/tools/stellab_radec.html">stellab_radec.pro</a>', "stellab_radec.pro", "", "stellab_radec", "", "cradecvel", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/stereo_split.html", "stereo_split.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "stereo_split.pro", "", "", " NAME:        stereo_split    PURPOSE:        Splits a given camera descriptor into a stereo pair.    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        cds = stereo_split(cd, sep=sep)    ARGUMENTS:   INPUT: 	cd:	Camera descriptor.    OUTPUT: NONE    KEYOWRDS:   INPUT:        sep:	Separation distance of output descriptors.    OUTPUT: NONE   RETURN: 	Array (2) giving the left and right camera descriptors. 	Each descriptor is cloned from the input descripor, and has 	been translated +/- sep/2 in the camara body 0-axis direction.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/stereo_split.html#stereo_split", "stereo_split", 'routine in <a href="nv/obj/tools/stereo_split.html">stereo_split.pro</a>', "stereo_split.pro", "", "stereo_split", "", "sepcd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/stn/stn_assign.html", "stn_assign.pro", '.pro file in <a href="nv/obj/stn/dir-overview.html">nv/obj/stn/ directory</a>', "stn_assign.pro", "", "", " NAME: 	stn_assign    PURPOSE: 	Replaces fields in a STATION object.  This is a convenient way of 	setting multiple fields in one call, and only a single event is 	generated.    CATEGORY: 	NV/OBJ/CAM    CALLING SEQUENCE: 	stn_assign, std, <keywords>=<values>    ARGUMENTS:   INPUT: 	std:		STATION object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	STATION fields to set.  	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	stn_set_*     MODIFICATION HISTORY:  	Written by:	Spitale		2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/stn/stn_assign.html#stn_assign", "stn_assign", 'routine in <a href="nv/obj/stn/stn_assign.html">stn_assign.pro</a>', "stn_assign.pro", "", "stn_assign", "", "noeventxd@stn__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/stn/stn_create_descriptors.html", "stn_create_descriptors.pro", '.pro file in <a href="nv/obj/stn/dir-overview.html">nv/obj/stn/ directory</a>', "stn_create_descriptors.pro", "", "", " NAME:        stn_create_descriptors    PURPOSE: 	Init method for the STATION class.    CATEGORY:        NV/LIB/STN    CALLING SEQUENCE:        std = stn_create_descriptors(n)    ARGUMENTS:   INPUT:        n:      Number of station descriptors.    OUTPUT:        NONE    KEYWORDS:   INPUT: 	std:	Station descriptor(s) to initialize, instead of creating new 		ones.  	bd:	Body descriptor(s) to pass to bod_create_descriptors.  	crd:	Core descriptor(s) to pass to cor_create_descriptors.  	primary:	Array (n) of primary descriptors.    OUTPUT: NONE   RETURN:        An array (n) of station descriptors.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/stn/stn_create_descriptors.html#stn_create_descriptors", "stn_create_descriptors", 'routine in <a href="nv/obj/stn/stn_create_descriptors.html">stn_create_descriptors.pro</a>', "stn_create_descriptors.pro", "", "stn_create_descriptors", "", "crdbdstdn@stn__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/stn/stn_evolve.html", "stn_evolve.pro", '.pro file in <a href="nv/obj/stn/dir-overview.html">nv/obj/stn/ directory</a>', "stn_evolve.pro", "", "", " NAME: 	stn_evolve    PURPOSE: 	Computes new station descriptors at the given time offsets from the 	given station descriptors using the taylor series expansion 	corresponding to the derivatives contained in the given station 	descriptor.    CATEGORY: 	NV/LIB/STN    CALLING SEQUENCE: 	sdt = stn_evolve(stx, dt)    ARGUMENTS:   INPUT: 	stx:	 Any subclass of STATION.  	dt:	 Time offset.    OUTPUT: NONE    KEYWORDS:   INPUT: 	nodv:	 If set, derivatives will not be evolved.  	copy:	If set, the evolved descriptor is copied into the input 		descriptor and it is freed.  The input descriptor is returned.     OUTPUT: NONE    RETURN: 	Array (nstd,ndt) of newly allocated descriptors, of class STATION, 	evolved by time dt, where nstd is the number of stx, and ndt 	is the number of dt.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/stn/stn_evolve.html#stn_evolve", "stn_evolve", 'routine in <a href="nv/obj/stn/stn_evolve.html">stn_evolve.pro</a>', "stn_evolve.pro", "", "stn_evolve", "", "nodvcopystddt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/stn/stn_primary.html", "stn_primary.pro", '.pro file in <a href="nv/obj/stn/dir-overview.html">nv/obj/stn/ directory</a>', "stn_primary.pro", "", "", " NAME: 	stn_primary    PURPOSE: 	Returns the primary string for each given station descriptor.    CATEGORY: 	NV/LIB/STN    CALLING SEQUENCE: 	primary = stn_primary(std)    ARGUMENTS:   INPUT: 	std:	 Array (nt) of STATION descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Primary descriptor associated with each given station descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/stn/stn_primary.html#stn_primary", "stn_primary", 'routine in <a href="nv/obj/stn/stn_primary.html">stn_primary.pro</a>', "stn_primary.pro", "", "stn_primary", "", "noeventstd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/stn/stn_query.html", "stn_query.pro", '.pro file in <a href="nv/obj/stn/dir-overview.html">nv/obj/stn/ directory</a>', "stn_query.pro", "", "", " NAME: 	stn_query    PURPOSE: 	Returns the fields associated with a STATION object.  This is a 	convenient way of getting multiple fields in one call, and only a 	single event is generated.    CATEGORY: 	NV/OBJ/CAM    CALLING SEQUENCE: 	stn_query, std, <keywords>=<values>    ARGUMENTS:   INPUT: 	std:	STATION object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	STATION object fields to set.  	condition:	Structure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT object, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.  	cat:		If set, arrays from mulitple input objets are 			concatenated.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.  	noevent:	If set, no event is generated.    OUTPUT: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/stn/stn_query.html#stn_query", "stn_query", 'routine in <a href="nv/obj/stn/stn_query.html">stn_query.pro</a>', "stn_query.pro", "", "stn_query", "", "conditioncatnoeventxd@stn__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/stn/stn_read_array.html", "stn_read_array.pro", '.pro file in <a href="config/stn/dir-overview.html">config/stn/ directory</a>', "stn_read_array.pro", "", "", " NAME: 	stn_read_array    PURPOSE: 	Reads an station array file.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	array = stn_read_array(filename)    ARGUMENTS:   INPUT: 	filename:	 String giving the name of the file.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: Array of body-frame points.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2012   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/stn/stn_read_array.html#stn_read_array", "stn_read_array", 'routine in <a href="config/stn/stn_read_array.html">stn_read_array.pro</a>', "stn_read_array.pro", "", "stn_read_array", "", "filename", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/stn/stn_read_scan_bin.html", "stn_read_scan_bin.pro", '.pro file in <a href="config/stn/dir-overview.html">config/stn/ directory</a>', "stn_read_scan_bin.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/stn/stn_read_scan_bin.html#stn_read_scan_bin", "stn_read_scan_bin", 'routine in <a href="config/stn/stn_read_scan_bin.html">stn_read_scan_bin.pro</a>', "stn_read_scan_bin.pro", "", "stn_read_scan_bin", "", "nodatasampleddheader", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/stn/stn_replicate.html", "stn_replicate.pro", '.pro file in <a href="nv/obj/stn/dir-overview.html">nv/obj/stn/ directory</a>', "stn_replicate.pro", "", "", " NAME: 	stn_replicate    PURPOSE: 	Replicates the given descriptor, producing an array of the given 	dimensions containing cloned versions of the input descriptor.    CATEGORY: 	NV/LIB/STN    CALLING SEQUENCE: 	stds = str_replicate(std, dim)    ARGUMENTS:   INPUT: 	std:	 Station descriptor.  	dim:	 Dimensions of the result.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Array of the given dimensions containing cloned versions of the input 	descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/stn/stn_replicate.html#stn_replicate", "stn_replicate", 'routine in <a href="nv/obj/stn/stn_replicate.html">stn_replicate.pro</a>', "stn_replicate.pro", "", "stn_replicate", "", "stddim", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/stn/stn_set_primary.html", "stn_set_primary.pro", '.pro file in <a href="nv/obj/stn/dir-overview.html">nv/obj/stn/ directory</a>', "stn_set_primary.pro", "", "", " NAME: 	stn_set_primary    PURPOSE: 	Replaces the primary string in each given station descriptor.    CATEGORY: 	NV/LIB/STN    CALLING SEQUENCE: 	stn_set_primary, std, primary    ARGUMENTS:   INPUT: 	std:	Array (nt) of STATION descriptors.  	primary:	Array (nt) of primary descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/stn/stn_set_primary.html#stn_set_primary", "stn_set_primary", 'routine in <a href="nv/obj/stn/stn_set_primary.html">stn_set_primary.pro</a>', "stn_set_primary.pro", "", "stn_set_primary", "", "noeventstdprimary", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/stn/stn_set_surface_pt.html", "stn_set_surface_pt.pro", '.pro file in <a href="nv/obj/stn/dir-overview.html">nv/obj/stn/ directory</a>', "stn_set_surface_pt.pro", "", "", " NAME: 	stn_set_surface_pt    PURPOSE: 	Replaces the surface_pt vector in each given station descriptor.    CATEGORY: 	NV/LIB/STN    CALLING SEQUENCE: 	stn_set_surface_pt, std, surface_pt    ARGUMENTS:   INPUT: 	std:	Array (nt) of STATION descriptors.  	surface_pt:	Array (1,3,nt) of surface_pt vectors.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/stn/stn_set_surface_pt.html#stn_set_surface_pt", "stn_set_surface_pt", 'routine in <a href="nv/obj/stn/stn_set_surface_pt.html">stn_set_surface_pt.pro</a>', "stn_set_surface_pt.pro", "", "stn_set_surface_pt", "", "noeventstdsurface_pt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/stn/stn_surface_pt.html", "stn_surface_pt.pro", '.pro file in <a href="nv/obj/stn/dir-overview.html">nv/obj/stn/ directory</a>', "stn_surface_pt.pro", "", "", " NAME: 	stn_surface_pt    PURPOSE: 	Returns the surface_pt vector for each given station descriptor.    CATEGORY: 	NV/LIB/STN    CALLING SEQUENCE: 	surface_pt = stn_surface_pt(std)    ARGUMENTS:   INPUT: 	std:	 Array (nt) of STATION descriptors.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (1,3,nt) of surface_pt vectors associated with each given 	station descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/stn/stn_surface_pt.html#stn_surface_pt", "stn_surface_pt", 'routine in <a href="nv/obj/stn/stn_surface_pt.html">stn_surface_pt.pro</a>', "stn_surface_pt.pro", "", "stn_surface_pt", "", "noeventstd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/stn/stn_write_array.html", "stn_write_array.pro", '.pro file in <a href="config/stn/dir-overview.html">config/stn/ directory</a>', "stn_write_array.pro", "", "", " NAME: 	stn_write_array    PURPOSE: 	Write a station array file.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	stn_write_array, filename, array    ARGUMENTS:   INPUT: 	filename:	 String giving the name of the file.  	array:	 Array of points in the body frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2012   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/stn/stn_write_array.html#stn_write_array", "stn_write_array", 'routine in <a href="config/stn/stn_write_array.html">stn_write_array.pro</a>', "stn_write_array.pro", "", "stn_write_array", "", "filenamearray", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/str2num.html", "str2num.pro", '.pro file in <a href="config/pds/Readpds_4.4/dir-overview.html">config/pds/Readpds_4.4/ directory</a>', "str2num.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/str2num.html#STR2NUM", "STR2NUM", 'routine in <a href="config/pds/Readpds_4.4/str2num.html">str2num.pro</a>', "str2num.pro", "", "STR2NUM", "", "TYPEsvalue", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/str/str_assign.html", "str_assign.pro", '.pro file in <a href="nv/obj/str/dir-overview.html">nv/obj/str/ directory</a>', "str_assign.pro", "", "", " NAME: 	str_assign    PURPOSE: 	Replaces fields in a STAR object.  This is a convenient way of 	setting multiple fields in one call, and only a single event is 	generated.    CATEGORY: 	NV/OBJ/STR    CALLING SEQUENCE: 	str_assign, sd, <keywords>=<values>    ARGUMENTS:   INPUT: 	sd:		STAR object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	STAR fields to set.  	noevent:	If set, no event is generated.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	str_set_*     MODIFICATION HISTORY:  	Written by:	Spitale		2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/str/str_assign.html#str_assign", "str_assign", 'routine in <a href="nv/obj/str/str_assign.html">str_assign.pro</a>', "str_assign.pro", "", "str_assign", "", "noeventxd@str__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/str/str_cat.html", "str_cat.pro", '.pro file in <a href="util/str/dir-overview.html">util/str/ directory</a>', "str_cat.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/str/str_cat.html#str_cat", "str_cat", 'routine in <a href="util/str/str_cat.html">str_cat.pro</a>', "str_cat.pro", "", "str_cat", "", "inserts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/str/str_comma_list.html", "str_comma_list.pro", '.pro file in <a href="util/str/dir-overview.html">util/str/ directory</a>', "str_comma_list.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/str/str_comma_list.html#str_comma_list", "str_comma_list", 'routine in <a href="util/str/str_comma_list.html">str_comma_list.pro</a>', "str_comma_list.pro", "", "str_comma_list", "", "delimss", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/str/str_comma_list.html#__str_comma_list", "__str_comma_list", 'routine in <a href="util/str/str_comma_list.html">str_comma_list.pro</a>', "str_comma_list.pro", "", "__str_comma_list", "", "delim_x", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/str/str_compress.html", "str_compress.pro", '.pro file in <a href="util/str/dir-overview.html">util/str/ directory</a>', "str_compress.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/str/str_compress.html#str_compress", "str_compress", 'routine in <a href="util/str/str_compress.html">str_compress.pro</a>', "str_compress.pro", "", "str_compress", "", "remove_alls", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/str/str_convert.html", "str_convert.pro", '.pro file in <a href="util/str/dir-overview.html">util/str/ directory</a>', "str_convert.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/str/str_convert.html#str_convert", "str_convert", 'routine in <a href="util/str/str_convert.html">str_convert.pro</a>', "str_convert.pro", "", "str_convert", "", "stype", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/str/str_create_descriptors.html", "str_create_descriptors.pro", '.pro file in <a href="nv/obj/str/dir-overview.html">nv/obj/str/ directory</a>', "str_create_descriptors.pro", "", "", " NAME:        str_create_descriptors    PURPOSE: 	Init method for the STAR class.    CATEGORY:        NV/LIB/STR    CALLING SEQUENCE:        sd = str_create_descriptors(n)    ARGUMENTS:   INPUT:        n:      Number of star descriptors.    OUTPUT:        NONE    KEYWORDS:   INPUT: 	sd:	Star descriptor(s) to initialize, instead of creating new ones.  	gbd:	Globe descriptor(s) to pass to glb_create_descriptors.  	sld:	Solid descriptor(s) to pass to sld_create_descriptors.  	bd:	Body descriptor(s) to pass to bod_create_descriptors.  	crd:	Core descriptor(s) to pass to cor_create_descriptors.  	lum:	Array (n) of luminosity values.  	sp:	Array (n) of spectral class strings.    OUTPUT: NONE   RETURN:        An array (n) of star descriptors.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Haemmerle, 5/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/str/str_create_descriptors.html#str_create_descriptors", "str_create_descriptors", 'routine in <a href="nv/obj/str/str_create_descriptors.html">str_create_descriptors.pro</a>', "str_create_descriptors.pro", "", "str_create_descriptors", "", "crdbdsldgbdsdn@str__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/str/str_decomp.html", "str_decomp.pro", '.pro file in <a href="util/str/dir-overview.html">util/str/ directory</a>', "str_decomp.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/str/str_decomp.html#str_decomp", "str_decomp", 'routine in <a href="util/str/str_decomp.html">str_decomp.pro</a>', "str_decomp.pro", "", "str_decomp", "", "s", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/str/str_evolve.html", "str_evolve.pro", '.pro file in <a href="nv/obj/str/dir-overview.html">nv/obj/str/ directory</a>', "str_evolve.pro", "", "", " NAME: 	str_evolve    PURPOSE: 	Computes new star descriptors at the given time offsets from the 	given star descriptors using the taylor series expansion 	corresponding to the derivatives contained in the given star 	descriptor.    CATEGORY: 	NV/LIB/STR    CALLING SEQUENCE: 	sdt = str_evolve(sx, dt)    ARGUMENTS:   INPUT: 	sx:	 Any subclass of STAR.  	dt:	 Time offset.    OUTPUT: NONE    KEYWORDS:   INPUT: 	nodv:	 If set, derivatives will not be evolved.  	copy:	If set, the evolved descriptor is copied into the input 		descriptor and it is freed.  The input descriptor is returned.     OUTPUT: NONE    RETURN: 	Array (nsd,ndt) of newly allocated descriptors, of class STAR, 	evolved by time dt, where nsd is the number of sx, and ndt 	is the number of dt.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/str/str_evolve.html#str_evolve", "str_evolve", 'routine in <a href="nv/obj/str/str_evolve.html">str_evolve.pro</a>', "str_evolve.pro", "", "str_evolve", "", "nodvcopysddt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/str/str_ext.html", "str_ext.pro", '.pro file in <a href="util/str/dir-overview.html">util/str/ directory</a>', "str_ext.pro", "", "", " NAME:        str_ext   PURPOSE:        Extracts the substring which is delimited by the given tokens.    CATEGORY:        UTIL    CALLING SEQUENCE:        return = str_ext(string, token1, token2, rstring, position=position)    ARGUMENTS:   INPUT:         string:        An input string          token1:        First token          token2:        Second token    OUTPUT:        rstring:        Original string minus the part which was extracted    KEYWORDS:   INPUT:        NONE    OUTPUT:       position:        Position at which the string was found    RETURN:        The extracted string is returned.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/str/str_ext.html#str_ext", "str_ext", 'routine in <a href="util/str/str_ext.html">str_ext.pro</a>', "str_ext.pro", "", "str_ext", "", "positionstringtoken1token2rstring", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/str/str_flip.html", "str_flip.pro", '.pro file in <a href="util/str/dir-overview.html">util/str/ directory</a>', "str_flip.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/str/str_flip.html#str_flip", "str_flip", 'routine in <a href="util/str/str_flip.html">str_flip.pro</a>', "str_flip.pro", "", "str_flip", "", "s", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/str/str_get_mag.html", "str_get_mag.pro", '.pro file in <a href="nv/obj/str/dir-overview.html">nv/obj/str/ directory</a>', "str_get_mag.pro", "", "", " NAME:        str_get_mag    PURPOSE:        Calculates the visual magnitude for each given star descriptor.    CATEGORY:        NV/LIB/STR    CALLING SEQUENCE:        result = str_get_mag(sd)    ARGUMENTS:   INPUT:        sd:    Array (nt) of star descriptors.    OUTPUT:        NONE    KEYWORDS:          NONE   RETURN:        An array (nt) of magnitues.   PROCEDURE:        Calls str_body to get the position vector.  The position is assumed        to be in meters and the Luminosity (sds.lum) is in J/sec.  Absolute        visual magnitude is calculated by using the formula for the Sun.        Mv = 4.83 - 2.5 log (L/Lsun)        where Lsun = 3.826e+26 J/sec        Visual magnitude is corrected by using the distance modulus.        m = Mv + 5 log (dist/pc) - 5        where pc = 3.085678e+16 m  (parsec)   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Haemmerle, 5/1998 	Modified by:	Haemmerle, 12/2000  	Adapted by:	Spitale, 5/2016    ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/str/str_get_mag.html#str_get_mag", "str_get_mag", 'routine in <a href="nv/obj/str/str_get_mag.html">str_get_mag.pro</a>', "str_get_mag.pro", "", "str_get_mag", "", "sd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/str/str_insert.html", "str_insert.pro", '.pro file in <a href="util/str/dir-overview.html">util/str/ directory</a>', "str_insert.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/str/str_insert.html#str_insert", "str_insert", 'routine in <a href="util/str/str_insert.html">str_insert.pro</a>', "str_insert.pro", "", "str_insert", "", "ssspos", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/str/str_isalgebraic.html", "str_isalgebraic.pro", '.pro file in <a href="util/str/dir-overview.html">util/str/ directory</a>', "str_isalgebraic.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/str/str_isalgebraic.html#str_isalgebraic", "str_isalgebraic", 'routine in <a href="util/str/str_isalgebraic.html">str_isalgebraic.pro</a>', "str_isalgebraic.pro", "", "str_isalgebraic", "", "ss", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/str/str_isalpha.html", "str_isalpha.pro", '.pro file in <a href="util/str/dir-overview.html">util/str/ directory</a>', "str_isalpha.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/str/str_isalpha.html#str_isalpha", "str_isalpha", 'routine in <a href="util/str/str_isalpha.html">str_isalpha.pro</a>', "str_isalpha.pro", "", "str_isalpha", "", "ss", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/str/str_isalphanum.html", "str_isalphanum.pro", '.pro file in <a href="util/str/dir-overview.html">util/str/ directory</a>', "str_isalphanum.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/str/str_isalphanum.html#str_isalphanum", "str_isalphanum", 'routine in <a href="util/str/str_isalphanum.html">str_isalphanum.pro</a>', "str_isalphanum.pro", "", "str_isalphanum", "", "ss", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/str/str_isfloat.html", "str_isfloat.pro", '.pro file in <a href="util/str/dir-overview.html">util/str/ directory</a>', "str_isfloat.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/str/str_isfloat.html#str_isfloat", "str_isfloat", 'routine in <a href="util/str/str_isfloat.html">str_isfloat.pro</a>', "str_isfloat.pro", "", "str_isfloat", "", "ss", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/str/str_isnum.html", "str_isnum.pro", '.pro file in <a href="util/str/dir-overview.html">util/str/ directory</a>', "str_isnum.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/str/str_isnum.html#str_isnum", "str_isnum", 'routine in <a href="util/str/str_isnum.html">str_isnum.pro</a>', "str_isnum.pro", "", "str_isnum", "", "ss", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/str/str_isvar.html", "str_isvar.pro", '.pro file in <a href="util/str/dir-overview.html">util/str/ directory</a>', "str_isvar.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/str/str_isvar.html#str_isvar", "str_isvar", 'routine in <a href="util/str/str_isvar.html">str_isvar.pro</a>', "str_isvar.pro", "", "str_isvar", "", "ss", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/str/str_limit_mag.html", "str_limit_mag.pro", '.pro file in <a href="nv/obj/str/dir-overview.html">nv/obj/str/ directory</a>', "str_limit_mag.pro", "", "", " NAME:        str_limit_mag    PURPOSE:        Returns subscripts of stars with magnitudes within the min, max range.    CATEGORY:        NV/LIB/STR    CALLING SEQUENCE:        result = str_limit_mag(sd, min=min, max=max)    ARGUMENTS:   INPUT:        sd:    Array of star descriptors.    OUTPUT:        NONE    KEYWORDS:   INPUT:        min:    Minimum threshold for magnitude.         max:    Maximum threshold for magnitude.    OUTPUT:          NONE   RETURN:        An array of subscripts into sd for stars fitting 	min <=  magnitude <= max.    SEE ALSO: 	pg_str_limit_mag   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Haemmerle, 5/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/str/str_limit_mag.html#str_limit_mag", "str_limit_mag", 'routine in <a href="nv/obj/str/str_limit_mag.html">str_limit_mag.pro</a>', "str_limit_mag.pro", "", "str_limit_mag", "", "minmaxsd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/str/str_lum.html", "str_lum.pro", '.pro file in <a href="nv/obj/str/dir-overview.html">nv/obj/str/ directory</a>', "str_lum.pro", "", "", " NAME:        str_lum    PURPOSE:        Returns a luminosity for each given star descriptor.    CATEGORY:        NV/LIB/STR    CALLING SEQUENCE:        result = str_lum(sd)    ARGUMENTS:   INPUT:        sd:    Array (nt) of star descriptors    OUTPUT:        NONE    KEYWORDS:          NONE   RETURN:        An array (nt) of luminosities.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Haemmerle, 5/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/str/str_lum.html#str_lum", "str_lum", 'routine in <a href="nv/obj/str/str_lum.html">str_lum.pro</a>', "str_lum.pro", "", "str_lum", "", "noeventsd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/str/str_month.html", "str_month.pro", '.pro file in <a href="util/str/dir-overview.html">util/str/ directory</a>', "str_month.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/str/str_month.html#str_month", "str_month", 'routine in <a href="util/str/str_month.html">str_month.pro</a>', "str_month.pro", "", "str_month", "", "mm", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/str/str_nmatch.html", "str_nmatch.pro", '.pro file in <a href="util/str/dir-overview.html">util/str/ directory</a>', "str_nmatch.pro", "", "", " NAME:        str_nmatch   PURPOSE:        Identifies element of one string array that match those of another.    CATEGORY:        UTIL    CALLING SEQUENCE:        sub = str_nmatch(strings, tests)    ARGUMENTS:   INPUT: 	strings:	Array of strings.  	tests:		Strings to search for.    OUTPUT:        NONE    KEYWORDS:        NONE    RETURN:        Array of subsripts into the strings array.  -1 if no matches found.   STATUS:        Complete.    MODIFICATION HISTORY:        Written by:     Spitale; 7/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/str/str_nmatch.html#str_nmatch", "str_nmatch", 'routine in <a href="util/str/str_nmatch.html">str_nmatch.pro</a>', "str_nmatch.pro", "", "str_nmatch", "", "stringstests", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/str/str_nnsplit.html", "str_nnsplit.pro", '.pro file in <a href="util/str/dir-overview.html">util/str/ directory</a>', "str_nnsplit.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/str/str_nnsplit.html#str_nnsplit", "str_nnsplit", 'routine in <a href="util/str/str_nnsplit.html">str_nnsplit.pro</a>', "str_nnsplit.pro", "", "str_nnsplit", "", "remainderposstringstoken", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/str/str_nsplit.html", "str_nsplit.pro", '.pro file in <a href="util/str/dir-overview.html">util/str/ directory</a>', "str_nsplit.pro", "", "", " NAME:        str_nsplit   PURPOSE:        Splits the string into substrings delimited by the given token.    CATEGORY:        UTIL    CALLING SEQUENCE:        return = str_nsplit(string, token)    ARGUMENTS:   INPUT:         string:        An input string           token:        String delimiter    OUTPUT:        NONE    KEYWORDS:        NONE    RETURN:        Array of substrings.  If the token is not found in the string,        the original string is returned.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale; 2/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/str/str_nsplit.html#str_nsplit", "str_nsplit", 'routine in <a href="util/str/str_nsplit.html">str_nsplit.pro</a>', "str_nsplit.pro", "", "str_nsplit", "", "stringtoken", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/str/str_pad.html", "str_pad.pro", '.pro file in <a href="util/str/dir-overview.html">util/str/ directory</a>', "str_pad.pro", "", "", " NAME: 	xx    PURPOSE: 	xx    CATEGORY: 	UTIL    CALLING SEQUENCE: 	result = xx(xx, xx) 	xx, xx, xx    ARGUMENTS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    KEYWORDS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    ENVIRONMENT VARIABLES: 	xx:	xx  	xx:	xx    RETURN: 	xx    COMMON BLOCKS: 	xx:	xx  	xx:	xx    SIDE EFFECTS: 	xx    RESTRICTIONS: 	xx    PROCEDURE: 	xx    EXAMPLE: 	xx    STATUS: 	xx    SEE ALSO: 	xx, xx, xx    MODIFICATION HISTORY:  	Written by:	xx, xx/xx/xxxx   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/str/str_pad.html#str_pad", "str_pad", 'routine in <a href="util/str/str_pad.html">str_pad.pro</a>', "str_pad.pro", "", "str_pad", "", "aligncsn", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/str/str_query.html", "str_query.pro", '.pro file in <a href="nv/obj/str/dir-overview.html">nv/obj/str/ directory</a>', "str_query.pro", "", "", " NAME: 	str_query    PURPOSE: 	Returns the fields associated with a STAR object.  This is a 	convenient way of getting multiple fields in one call, and only a 	single event is generated.    CATEGORY: 	NV/OBJ/STR    CALLING SEQUENCE: 	str_query, sd, <keywords>=<values>    ARGUMENTS:   INPUT: 	sd:	STAR object.    OUTPUT: NONE    KEYWORDS:   INPUT: 	<keywords>:	STAR object fields to set.  	condition:	Structure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT object, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.  	cat:		If set, arrays from mulitple input objets are 			concatenated.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.  	noevent:	If set, no event is generated.    OUTPUT: NONE    STATUS: 	Complete     MODIFICATION HISTORY:  	Written by:	Spitale, 2/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/str/str_query.html#str_query", "str_query", 'routine in <a href="nv/obj/str/str_query.html">str_query.pro</a>', "str_query.pro", "", "str_query", "", "conditioncatnoeventxd@str__keywords.include", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/str/str_recomp.html", "str_recomp.pro", '.pro file in <a href="util/str/dir-overview.html">util/str/ directory</a>', "str_recomp.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/str/str_recomp.html#str_recomp", "str_recomp", 'routine in <a href="util/str/str_recomp.html">str_recomp.pro</a>', "str_recomp.pro", "", "str_recomp", "", "s", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/str/str_reduce.html", "str_reduce.pro", '.pro file in <a href="util/str/dir-overview.html">util/str/ directory</a>', "str_reduce.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/str/str_reduce.html#str_reduce", "str_reduce", 'routine in <a href="util/str/str_reduce.html">str_reduce.pro</a>', "str_reduce.pro", "", "str_reduce", "", "scc", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/str/str_replicate.html", "str_replicate.pro", '.pro file in <a href="nv/obj/str/dir-overview.html">nv/obj/str/ directory</a>', "str_replicate.pro", "", "", " NAME: 	str_replicate    PURPOSE: 	Replicates the given descriptor, producing an array of the given 	dimensions containing cloned versions of the input descriptor.    CATEGORY: 	NV/LIB/STR    CALLING SEQUENCE: 	sds = str_replicate(sd, dim)    ARGUMENTS:   INPUT: 	sd:	 Star descriptor.  	dim:	 Dimensions of the result.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Array of the given dimensions containing cloned versions of the input 	descriptor.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/str/str_replicate.html#str_replicate", "str_replicate", 'routine in <a href="nv/obj/str/str_replicate.html">str_replicate.pro</a>', "str_replicate.pro", "", "str_replicate", "", "sddim", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/str/str_rnd.html", "str_rnd.pro", '.pro file in <a href="util/str/dir-overview.html">util/str/ directory</a>', "str_rnd.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/str/str_rnd.html#str_rnd", "str_rnd", 'routine in <a href="util/str/str_rnd.html">str_rnd.pro</a>', "str_rnd.pro", "", "str_rnd", "", "xndecnpad", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/str/str_set_lum.html", "str_set_lum.pro", '.pro file in <a href="nv/obj/str/dir-overview.html">nv/obj/str/ directory</a>', "str_set_lum.pro", "", "", " NAME: 	str_set_lum    PURPOSE: 	Replaces the luminosities for each given star descriptor.    CATEGORY: 	NV/LIB/STR    CALLING SEQUENCE: 	str_set_lum, sd, lum    ARGUMENTS:   INPUT: 	sd:	 Array (nt) of any subclass of STAR.  	lum:	 Array (nt) of new luminosity values.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/str/str_set_lum.html#str_set_lum", "str_set_lum", 'routine in <a href="nv/obj/str/str_set_lum.html">str_set_lum.pro</a>', "str_set_lum.pro", "", "str_set_lum", "", "noeventsdlum", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/str/str_set_sp.html", "str_set_sp.pro", '.pro file in <a href="nv/obj/str/dir-overview.html">nv/obj/str/ directory</a>', "str_set_sp.pro", "", "", " NAME: 	str_set_sp    PURPOSE: 	Replaces the spectra class for each given star descriptor.    CATEGORY: 	NV/LIB/STR    CALLING SEQUENCE: 	str_set_sp, sd, sp    ARGUMENTS:   INPUT: 	sd:	 Array (nt) of any subclass of STAR.  	sp:	 Array (nt) of new sp strings.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/str/str_set_sp.html#str_set_sp", "str_set_sp", 'routine in <a href="nv/obj/str/str_set_sp.html">str_set_sp.pro</a>', "str_set_sp.pro", "", "str_set_sp", "", "noeventsdsp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/str/str_sp.html", "str_sp.pro", '.pro file in <a href="nv/obj/str/dir-overview.html">nv/obj/str/ directory</a>', "str_sp.pro", "", "", " NAME:        str_sp    PURPOSE:        Returns a spectral type for each given star descriptor.    CATEGORY:        NV/LIB/STR    CALLING SEQUENCE:        result = str_sp(sd)    ARGUMENTS:   INPUT:        sd:    Array (t) of star descriptors    OUTPUT:        NONE    KEYWORDS:          NONE   RETURN:        An array (nt) of spectral types which is a three character string.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Haemmerle, 5/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/str/str_sp.html#str_sp", "str_sp", 'routine in <a href="nv/obj/str/str_sp.html">str_sp.pro</a>', "str_sp.pro", "", "str_sp", "", "noeventsd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/str/str_split.html", "str_split.pro", '.pro file in <a href="util/str/dir-overview.html">util/str/ directory</a>', "str_split.pro", "", "", " NAME:        str_split   PURPOSE:        Splits the string into two substrings delimited by the given token.    CATEGORY:        UTIL    CALLING SEQUENCE:        return = str_split(string, token)    ARGUMENTS:   INPUT:         string:        An input string           token:        String delimiter    OUTPUT:        NONE    KEYWORDS:        NONE    RETURN:        Two substrings are returned split at the given token but not        including the token.  If the token is not found in the string,        the original string is returned.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/str/str_split.html#str_split", "str_split", 'routine in <a href="util/str/str_split.html">str_split.pro</a>', "str_split.pro", "", "str_split", "", "stringtoken", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/str/str_tailnum.html", "str_tailnum.pro", '.pro file in <a href="util/str/dir-overview.html">util/str/ directory</a>', "str_tailnum.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/str/str_tailnum.html#str_tailnum", "str_tailnum", 'routine in <a href="util/str/str_tailnum.html">str_tailnum.pro</a>', "str_tailnum.pro", "", "str_tailnum", "", "numw_sorts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/str/strcap.html", "strcap.pro", '.pro file in <a href="util/str/dir-overview.html">util/str/ directory</a>', "strcap.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/str/strcap.html#strcap", "strcap", 'routine in <a href="util/str/strcap.html">strcap.pro</a>', "strcap.pro", "", "strcap", "", "s", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/strcat/strcat_common_input.html", "strcat_common_input.pro", '.pro file in <a href="config/strcat/dir-overview.html">config/strcat/ directory</a>', "strcat_common_input.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/strcat/strcat_common_input.html#strcat_common_input", "strcat_common_input", 'routine in <a href="config/strcat/strcat_common_input.html">strcat_common_input.pro</a>', "strcat_common_input.pro", "", "strcat_common_input", "", "valuesstatusddkeyword@nv_trs_keywords_include.pro", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/strcat/strcat_common_names.html", "strcat_common_names.pro", '.pro file in <a href="config/strcat/dir-overview.html">config/strcat/ directory</a>', "strcat_common_names.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/strcat/strcat_common_names.html#strcat_common_names", "strcat_common_names", 'routine in <a href="config/strcat/strcat_common_names.html">strcat_common_names.pro</a>', "strcat_common_names.pro", "", "strcat_common_names", "", "starsname", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/strcat/strcat_get_inputs.html", "strcat_get_inputs.pro", '.pro file in <a href="config/strcat/dir-overview.html">config/strcat/ directory</a>', "strcat_get_inputs.pro", "", "", " Obtains scene data to be used by star catalog translator.   Notes  	Assumes star positions are wrt SSB, not sun  	Assumes camera coordinate system is Earth equatorial   ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("config/strcat/strcat_gsc_input.html", "strcat_gsc_input.pro", '.pro file in <a href="config/strcat/dir-overview.html">config/strcat/ directory</a>', "strcat_gsc_input.pro", "", "", " Input translator for GSC star catalog.   Returns  =======    Star descriptor containing all the stars found.  The Sp part of    the star descriptor does not contain the Spectral type since this    is not available.  Instead it contains the GSC class of the object::     0 - star     1 - galaxy     2 - blend or member of incorrectly resolved blend.     3 - non-star     5 - potential artifact     (Note that code 1 is used only for a few  hand-entered errata;    galaxies successfully processed by the software have a    classification of 3 [non-stellar].  Also code 4 is never used.)   Restrictions  ============   Since the distance to stars are not given in the GSC catalog, the  position vector magnitude is set as 10 parsec and the luminosity  is calculated from the visual magnitude and the 10 parsec distance.  	This translator does not correct for proper motion.    Procedure  =========   Stars are found in a square area in RA and DEC around a given  or calculated center.  The star descriptor is filled with stars  that fit in this area.  If B1950 is selected, input ods orient 	matrix is assumed to be B1950 also, if not, input is assumed to be 	J2000, like the catalog.   :Private:   :Categories:    nv, config   :History:     Written by:     Vance Haemmerle, 3/2000 (pg_get_stars_gsc.pro)      Modified:       Spitale 9/2001 - changed to strcat_gsc_input.pro    :Private:  :Hidden:   gsc_fzone:  Determine the Declination zone of a GSC region   :Private:  :Hidden:   gsc_initzd: Initialize GSC directory names   :Private:  :Hidden:   Search the index table to find the region identifiers whose coordinate  limits overlap the specified field. Save list of paths to gsc files for  these regions.   :Private:  :Hidden:   Given a GSC region filename, load the stars that fit within  region (ra1 - ra2) and (dec1 - dec2) into a star descriptor.   :Private:  :Hidden:  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/strcat/strcat_gsc_input.html#gsc_fzone", "gsc_fzone", 'routine in <a href="config/strcat/strcat_gsc_input.html">strcat_gsc_input.pro</a>', "strcat_gsc_input.pro", "", "gsc_fzone", "", "declowdechi", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/strcat/strcat_gsc_input.html#gsc_initzd", "gsc_initzd", 'routine in <a href="config/strcat/strcat_gsc_input.html">strcat_gsc_input.pro</a>', "strcat_gsc_input.pro", "", "gsc_initzd", "", "zdir", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/strcat/strcat_gsc_input.html#gsc_get_regions", "gsc_get_regions", 'routine in <a href="config/strcat/strcat_gsc_input.html">strcat_gsc_input.pro</a>', "strcat_gsc_input.pro", "", "gsc_get_regions", "", "path_gscra1ra2dec1dec2", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/strcat/strcat_gsc_input.html#gsc_get_stars", "gsc_get_stars", 'routine in <a href="config/strcat/strcat_gsc_input.html">strcat_gsc_input.pro</a>', "strcat_gsc_input.pro", "", "gsc_get_stars", "", "cam_velb1950ra1ra2dec1dec2faintbrightnbrightnoaberrnamesmagjtimefilename", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/strcat/strcat_gsc_input.html#strcat_gsc_input", "strcat_gsc_input", 'routine in <a href="config/strcat/strcat_gsc_input.html">strcat_gsc_input.pro</a>', "strcat_gsc_input.pro", "", "strcat_gsc_input", "", "n_objdimvaluesstatusddkeyword@nv_trs_keywords_include.pro", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/strcat/strcat_input.html", "strcat_input.pro", '.pro file in <a href="config/strcat/dir-overview.html">config/strcat/ directory</a>', "strcat_input.pro", "", "", "  Processes catalog-independent components of star catalog translation.   :Private:   :Author:    Spitale, 3/2004     Ryan, 8/2016    :Hidden:  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/strcat/strcat_input.html#strcat_input", "strcat_input", 'routine in <a href="config/strcat/strcat_input.html">strcat_input.pro</a>', "strcat_input.pro", "", "strcat_input", "", "n_objdimvaluesstatuscatddkeyword@nv_trs_keywords_include.pro", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/strcat/strcat_nbright.html", "strcat_nbright.pro", '.pro file in <a href="config/strcat/dir-overview.html">config/strcat/ directory</a>', "strcat_nbright.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/strcat/strcat_nbright.html#strcat_nbright", "strcat_nbright", 'routine in <a href="config/strcat/strcat_nbright.html">strcat_nbright.pro</a>', "strcat_nbright.pro", "", "strcat_nbright", " Retrieves n brightest stars from a set of magnitudes   ", "mags       vector of star magnitudes  nbright       number of stars to return   ", "          -1", "     Vector of magnitudes with length nbright   ");
  
  

libdata[libdataItem++] = new Array("config/strcat/strcat_radec_regions.html", "strcat_radec_regions.pro", '.pro file in <a href="config/strcat/dir-overview.html">config/strcat/ directory</a>', "strcat_radec_regions.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/strcat/strcat_radec_regions.html#strcat_radec_regions", "strcat_radec_regions", 'routine in <a href="config/strcat/strcat_radec_regions.html">strcat_radec_regions.pro</a>', "strcat_radec_regions.pro", "", "strcat_radec_regions", "", "ra_fovdec_fovra1_regionsra2_regionsdec1_regionsdec2_regions", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/strcat/strcat_radec_regions.html#_______strcat_radec_regions", "_______strcat_radec_regions", 'routine in <a href="config/strcat/strcat_radec_regions.html">strcat_radec_regions.pro</a>', "strcat_radec_regions.pro", "", "_______strcat_radec_regions", "", "radec0fieldraminsramaxesdecminsdecmaxes", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/strcat/strcat_sao_input.html", "strcat_sao_input.pro", '.pro file in <a href="config/strcat/dir-overview.html">config/strcat/ directory</a>', "strcat_sao_input.pro", "", "", "  Input translator for SAO star catalog.   Usage  =====  This routine is called via `dat_get_value`, which is used to read the  translator table. In particular, the specific translator for the scene  to be processed should contain the following line::        -   strcat_sao_input     -       /j2000    # or /b1950 if desired   For the star catalog translator system to work properly, only one type  of catalog may be used at a time for a particular instrument.  	The version of the SAO catalog which is expected by this translator is  the 1984 binary catalog format used by NAV. The star catalog file,  sao_idl.str, must be kept in the location of the path_sao variable,  which uses the NV_SAO_DATA environment variable by default.   In the file, the data is grouped into 18 segments of 10 degrees each.  Each star has a data record of 36 bytes.  RA (radians), RAMu (pm in  sec time/year), DEC (radians), DECMu (pm in sec arc/year), Visual  Magnitude, 13-byte Name and 3-byte Spectral type. The first 4 records  of the output catalog are 18 sets of pointers to the records for the  start and end of each segment. The real values (RA, RAMu, DEC, DECMu  and Mag) are in XDR.  The pointer integers are in network byte order.   The catalog uses the b1950 epoch, but all coordinates can be precessed  to J2000 by using the /j2000 keyword.   Restrictions  ============  Since the distance to stars are not given in the SAO catalog, the  position vector magnitude is set as 10 parsec and the luminosity  is calculated from the visual magnitude and the 10 parsec distance.   :History:        Written by:     Vance Haemmerle,  5/1998  	      Modified:                         1/1999         Modified:       Tiscareno,        7/2000         Modified:       Haemmerle,       12/2000         Modified:       Spitale,          9/2001    :Private:  :Hidden:   :Private:  :Hidden:  Ingests a set of records from the SAO star catalog and generates star  descriptors for each star within a specified scene.   :Returns:    array of star descriptors   :Params:    dd : in, required, type= data descriptor        data descriptor    filename : in, required, type=string       name of index file, or regions file   :Keywords:    cam_vel : in, optional, type=double       camera velocity from scene data, used to correct for stellar       aberration    b1950 : in, optional, type=string       if set, coordinates are output wrt b1950    ra1 : in, required, type=double       lower bound in right ascension of scene    ra2 : in, required, type=double       upper bound in right ascension of scene    dec1 : in, required, type=double       lower bound in declination of scene    dec2 : in, required, type=double       upper bound in declination of scene    faint : in, optional, type=double       stars with magnitudes fainter than this will not be returned    bright : in, optional, type=double       stars with magnitudes brighter than this will not be returned    nbright : in, optional, type=double       if set, selects only the n brightest stars    noaberr : in, optional, type=string       if set, stellar aberration will not be calculated    names : in, optional, type= string array        if set, will return only the stars with the expected names    mag : out, required, type=double       magnitude of returned stars    jtime : in, optional, type=double       Years since 1950 (the epoch of catalog) for precession       and proper motion correction. If not given, it is taken       from the object descriptor bod_time, which is assumed to       be seconds past 2000, unless keyword /b1950 is set   :Private:  :Hidden:  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/strcat/strcat_sao_input.html#sao_get_regions", "sao_get_regions", 'routine in <a href="config/strcat/strcat_sao_input.html">strcat_sao_input.pro</a>', "strcat_sao_input.pro", "", "sao_get_regions", "", "path_saora1ra2dec1dec2", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/strcat/strcat_sao_input.html#sao_get_stars", "sao_get_stars", 'routine in <a href="config/strcat/strcat_sao_input.html">strcat_sao_input.pro</a>', "strcat_sao_input.pro", "", "sao_get_stars", "", "cam_velb1950ra1ra2dec1dec2faintbrightnbrightnoaberrnamesmagjtimefilename", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/strcat/strcat_sao_input.html#strcat_sao_input", "strcat_sao_input", 'routine in <a href="config/strcat/strcat_sao_input.html">strcat_sao_input.pro</a>', "strcat_sao_input.pro", "", "strcat_sao_input", "", "n_objdimvaluesstatusddkeyword@nv_trs_keywords_include.pro", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/strcat/strcat_tycho2_input.html", "strcat_tycho2_input.pro", '.pro file in <a href="config/strcat/dir-overview.html">config/strcat/ directory</a>', "strcat_tycho2_input.pro", "", "", "  Input translator for TYCHO-2 star catalog.   Usage  =====  This routine is called via `dat_get_value`, which is used to read the  translator table. In particular, the specific translator for the scene  to be processed should contain the following line::        -   strcat_tycho2_input     -       /j2000    # or /b1950 if desired   For the star catalog translator system to work properly, only one type  of catalog may be used at a time for a particular instrument.   The version of the TYCHO-2 catalog which is expected by this translator  can be obtained from the `CDS Strasbourg database <ftp://cdsarc.u-strasbg.fr/pub/cats/I/259/>`.  The twenty individual catalog files should be concatenated into a single  file named tyc2.dat, as per the provided instructions. Another required  file is the index.dat, which is provided on the same webpage. The path  to the catalog files is specified by the NV_TYCHO2_DATA environment  variable, which is set during installation.   Please note that the version of TYCHO-2 in EK format which is distributed  by NAIF is not supported by this translator.   Restrictions  ============   Since the distance to stars are not given in the TYCHO-2 catalog, the  position vector magnitude is set as 10 parsec and the luminosity  is calculated from the visual magnitude and the 10 parsec distance.   Procedure  =========   Stars are found in a square area in RA and DEC around a given  or calculated center.  The star descriptor is filled with stars  that fit in this area.  If B1950 is selected, input sd's orient 	matrix is assumed to be B1950 also, if not, input is assumed to  be J2000, like the catalog.   :Categories:    nv, config   :Author:    Joseph Spitale, 3/2004     Jacqueline Ryan, 8/2016    :Private:  :Hidden:   :Private:  :Hidden:  Ingests a set of records from the TYCHO-2 star catalog and generates star  descriptors for each star within a specified scene.   :Returns:    array of star descriptors   :Params:    dd : in, required, type= data descriptor        data descriptor    filename : in, required, type=string       name of index file, or regions file   :Keywords:    cam_vel : in, optional, type=double       camera velocity from scene data, used to correct for stellar       aberration    b1950 : in, optional, type=string       if set, coordinates are output wrt b1950    ra1 : in, required, type=double       lower bound in right ascension of scene    ra2 : in, required, type=double       upper bound in right ascension of scene    dec1 : in, required, type=double       lower bound in declination of scene    dec2 : in, required, type=double       upper bound in declination of scene    faint : in, optional, type=double       stars with magnitudes fainter than this will not be returned    bright : in, optional, type=double       stars with magnitudes brighter than this will not be returned    nbright : in, optional, type=double       if set, selects only the n brightest stars    noaberr : in, optional, type=string       if set, stellar aberration will not be calculated    names : in, optional, type= string array        if set, will return only the stars with the expected names    mag : out, required, type=double       magnitude of returned stars    jtime : in, optional, type=double       Years since 2000 (the epoch of catalog) for precession       and proper motion correction. If not given, it is taken       from the object descriptor bod_time, which is assumed to       be seconds past 2000, unless keyword /b1950 is set   :Private:  :Hidden:  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/strcat/strcat_tycho2_input.html#tycho2_get_regions", "tycho2_get_regions", 'routine in <a href="config/strcat/strcat_tycho2_input.html">strcat_tycho2_input.pro</a>', "strcat_tycho2_input.pro", "", "tycho2_get_regions", "", "path_tycho2ra1ra2dec1dec2", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/strcat/strcat_tycho2_input.html#tycho2_get_stars", "tycho2_get_stars", 'routine in <a href="config/strcat/strcat_tycho2_input.html">strcat_tycho2_input.pro</a>', "strcat_tycho2_input.pro", "", "tycho2_get_stars", "", "cam_velb1950ra1ra2dec1dec2faintbrightnbrightnoaberrnamesmagjtimeddfilename", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/strcat/strcat_tycho2_input.html#strcat_tycho2_input", "strcat_tycho2_input", 'routine in <a href="config/strcat/strcat_tycho2_input.html">strcat_tycho2_input.pro</a>', "strcat_tycho2_input.pro", "", "strcat_tycho2_input", "", "n_objdimvaluesstatusddkeyword@nv_trs_keywords_include.pro", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/strcat/strcat_tycho_input.html", "strcat_tycho_input.pro", '.pro file in <a href="config/strcat/dir-overview.html">config/strcat/ directory</a>', "strcat_tycho_input.pro", "", "", "         Input translator for Tycho-1 star catalog.   Usage  =====  This routine is called via `dat_get_value`, which is used to read the  translator table. In particular, the specific translator for the scene  to be processed should contain the following line::        -   strcat_tycho_input     -       /j2000    # or /b1950 if desired   For the star catalog translator system to work properly, only one type  of catalog may be used at a time for a particular instrument.  The version of the TYCHO catalog that this translator expects can be  obtained from the original CD's. The catalog data is grouped into  approx 10,000 separate regions in numbered files in 24 separate  subdirectories. Each star has a data record of 16 bytes.Two identifying  numbers: TYCHO_ID_1 and TYCHO_ID_2, RA_DEG and DEC_DEG (degrees),  RApm and DECpm (milliarcseconds/year), and MAG (Visual Magnitude).  The real values (RA_DEG, DEC_DEG, RApm, DECpm, and MAG) are in XDR,  the GSC_ID and CLASS are network-order short integers.    Restrictions  ============   Since the distance to stars are not given in the GSC catalog, the  position vector magnitude is set as 10 parsec and the luminosity  is calculated from the visual magnitude and the 10 parsec distance.    Procedure  =========   Stars are found in a square area in RA and DEC around a given  or calculated center.  The star descriptor is filled with stars  that fit in this area.  If B1950 is selected, input RA, DEC and/or 	ods orient matrix is assumed to be B1950 also, if not, input is 	assumed to be J2000, like the catalog.   :Categories:  nv, config   :History:        Written by:     Vance Haemmerle, 3/2000         Modified:       Tiscareno, 8/2000  	      Modified:	      Haemmerle, 12/2000         Modified:       Spitale 9/2001    :Private:  :Hidden:   :Private:  :Hidden:  Ingests a set of records from the TYCHO-2 star catalog and generates star  descriptors for each star within a specified scene.   :Returns:    array of star descriptors   :Params:    dd : in, required, type= data descriptor        data descriptor    filename : in, required, type=string       name of index file, or regions file   :Keywords:    cam_vel : in, optional, type=double       camera velocity from scene data, used to correct for stellar       aberration    b1950 : in, optional, type=string       if set, coordinates are output wrt b1950    ra1 : in, required, type=double       lower bound in right ascension of scene    ra2 : in, required, type=double       upper bound in right ascension of scene    dec1 : in, required, type=double       lower bound in declination of scene    dec2 : in, required, type=double       upper bound in declination of scene    faint : in, optional, type=double       stars with magnitudes fainter than this will not be returned    bright : in, optional, type=double       stars with magnitudes brighter than this will not be returned    nbright : in, optional, type=double       if set, selects only the n brightest stars    noaberr : in, optional, type=string       if set, stellar aberration will not be calculated    names : in, optional, type= string array        if set, will return only the stars with the expected names    mag : out, required, type=double       magnitude of returned stars    jtime : in, optional, type=double       Years since 1950 (the epoch of catalog) for precession       and proper motion correction. If not given, it is taken       from the object descriptor bod_time, which is assumed to       be seconds past 2000, unless keyword /b1950 is set   :Private:  :Hidden:   :Private:  :Hidden:  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/strcat/strcat_tycho_input.html#tycho_fzone", "tycho_fzone", 'routine in <a href="config/strcat/strcat_tycho_input.html">strcat_tycho_input.pro</a>', "strcat_tycho_input.pro", "", "tycho_fzone", "", "declowdechi", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/strcat/strcat_tycho_input.html#tycho_initzd", "tycho_initzd", 'routine in <a href="config/strcat/strcat_tycho_input.html">strcat_tycho_input.pro</a>', "strcat_tycho_input.pro", "", "tycho_initzd", " :Private:  :Hidden:  Initialize zone directory names for TYCHO catalog  ", "zdir", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/strcat/strcat_tycho_input.html#tycho_get_regions", "tycho_get_regions", 'routine in <a href="config/strcat/strcat_tycho_input.html">strcat_tycho_input.pro</a>', "strcat_tycho_input.pro", "", "tycho_get_regions", " :Private:  :Hidden:  Search the index table to find the region identifiers whose coordinate  limits overlap the specified field. Save list of paths to gsc files for  these regions.  :Params:    ra1 : in, required, type=double       lower bound in right ascension of scene in hours    ra2 : in, required, type=double       upper bound in right ascension of scene in hours    dec1 : in, required, type=double       lower bound in declination of scene in degrees    dec2 : in, required, type=double       upper bound in declination of scene in degrees   :Keywords:     path_tycho : in, required, type=string, default='NV_TYCHO_DATA'        Sets the path to look for catalog files. Uses the value of        the NV_TYCHO_DATA environment variable by default.   :Returns:     Table to store regions found (to search for guide stars)   ", "path_tychora1ra2dec1dec2", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/strcat/strcat_tycho_input.html#tycho_get_stars", "tycho_get_stars", 'routine in <a href="config/strcat/strcat_tycho_input.html">strcat_tycho_input.pro</a>', "strcat_tycho_input.pro", "", "tycho_get_stars", "", "b1950cam_veljtimera1ra2dec1dec2faintbrightnoaberrnamesmagfilename", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/strcat/strcat_tycho_input.html#_strcat_tycho_input", "_strcat_tycho_input", 'routine in <a href="config/strcat/strcat_tycho_input.html">strcat_tycho_input.pro</a>', "strcat_tycho_input.pro", "", "_strcat_tycho_input", "", "n_objdimstatusddkeyword@nv_trs_keywords_include.pro", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/strcat/strcat_tycho_input.html#strcat_tycho_input", "strcat_tycho_input", 'routine in <a href="config/strcat/strcat_tycho_input.html">strcat_tycho_input.pro</a>', "strcat_tycho_input.pro", "", "strcat_tycho_input", "", "n_objdimvaluesstatusddkeyword@nv_trs_keywords_include.pro", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/strcat/strcat_ucac4_input.html", "strcat_ucac4_input.pro", '.pro file in <a href="config/strcat/dir-overview.html">config/strcat/ directory</a>', "strcat_ucac4_input.pro", "", "", "  Input translator for ucact-c star catalog compiled by Bill Owen.   Usage  =====  This routine is called via `dat_get_value`, which is used to read the  translator table. In particular, the specific translator for the scene  to be processed should contain the following line::        -   strcat_ucac4_input     -       /j2000    # or /b1950 if desired   For the star catalog translator system to work properly, only one type  of catalog may be used at a time for a particular instrument.   The UCAC4 catalog is the final release version of the USNO CCD Astrograph  Catalog. The version of the catalog which is expected by this catalog was  obtained from the `CDS Strasbourg database <ftp://cdsarc.u-strasbg.fr/pub/cats/more/UCAC4/u4b/>`.  Each of the 900 zone files is required. Additionally, there is an  `ASCII index file <ftp://cdsarc.u-strasbg.fr/pub/cats/more/UCAC4/u4i/>`  named u4index.asc, which is used to determine which zone files to load.   Restrictions  ============   Since the distance to stars are not given in the UCAC4 catalog, the  position vector magnitude is set as 10 parsec and the luminosity  is calculated from the visual magnitude and the 10 parsec distance.   Procedure  =========   Stars are found in a square area in RA and DEC around a given  or calculated center.  The star descriptor is filled with stars  that fit in this area.  If B1950 is selected, input sd's orient  matrix is assumed to be B1950 also, if not, input is assumed to  be J2000, like the catalog.   :Categories:    nv, config   :Version:     Incomplete   :Author:    Jacqueline Ryan, 8/2016    :Private:  :Hidden:   :Private:  :Hidden:  Ingests a set of records from the UCAC4 star catalog and generates star  descriptors for each star within a specified scene.   :Returns:    array of star descriptors   :Params:    dd : in, required, type= data descriptor        data descriptor    filename : in, required, type=string       name of index file, or regions file   :Keywords:    cam_vel : in, optional, type=double       camera velocity from scene data, used to correct for stellar       aberration    b1950 : in, optional, type=string       if set, coordinates are output wrt b1950    ra1 : in, required, type=double       lower bound in right ascension of scene    ra2 : in, required, type=double       upper bound in right ascension of scene    dec1 : in, required, type=double       lower bound in declination of scene    dec2 : in, required, type=double       upper bound in declination of scene    faint : in, optional, type=double       stars with magnitudes fainter than this will not be returned    bright : in, optional, type=double       stars with magnitudes brighter than this will not be returned    nbright : in, optional, type=double       if set, selects only the n brightest stars    noaberr : in, optional, type=string       if set, stellar aberration will not be calculated    names : in, optional, type= string array        if set, will return only the stars with the expected names    mag : out, required, type=double       magnitude of returned stars    jtime : in, optional, type=double       Years since 1950 (the epoch of catalog) for precession       and proper motion correction. If not given, it is taken       from the object descriptor bod_time, which is assumed to       be seconds past 2000, unless keyword /b1950 is set  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/strcat/strcat_ucac4_input.html#ucac4_get_regions", "ucac4_get_regions", 'routine in <a href="config/strcat/strcat_ucac4_input.html">strcat_ucac4_input.pro</a>', "strcat_ucac4_input.pro", "", "ucac4_get_regions", "", "path_ucac4ra1ra2dec1dec2", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/strcat/strcat_ucac4_input.html#ucac4_get_stars", "ucac4_get_stars", 'routine in <a href="config/strcat/strcat_ucac4_input.html">strcat_ucac4_input.pro</a>', "strcat_ucac4_input.pro", "", "ucac4_get_stars", "", "cam_velb1950ra1ra2dec1dec2faintbrightnbrightnoaberrnamesmagjtimeddfilename", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/strcat/strcat_ucac4_input.html#strcat_ucac4_input", "strcat_ucac4_input", 'routine in <a href="config/strcat/strcat_ucac4_input.html">strcat_ucac4_input.pro</a>', "strcat_ucac4_input.pro", "", "strcat_ucac4_input", " :Private:  :Hidden:  ", "valuesstatusddkeyword@nv_trs_keywords_include.pro", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/strcat/strcat_ucact_input.html", "strcat_ucact_input.pro", '.pro file in <a href="config/strcat/dir-overview.html">config/strcat/ directory</a>', "strcat_ucact_input.pro", "", "", "  Input translator for ucact-c star catalog compiled by Bill Owen.   Usage  =====  This routine is called via `dat_get_value`, which is used to read the  translator table. In particular, the specific translator for the scene  to be processed should contain the following line::        -   strcat_ucact_input     -       /j2000    # or /b1950 if desired   For the star catalog translator system to work properly, only one type  of catalog may be used at a time for a particular instrument.   The UCACT catalog is a composite product of the UCAC2 and TYCHO star  catalogs, and was compiled by Bill Owen. This catalog is proprietary to  the Jet Propulsion Laboratory, and can be obtained by contacting either  `Bill Owen <mailto: William.M.Owen@jpl.nasa.gov>`, or  `Joseph Spitale <mailto: spitale@pirl.lpl.arizona.edu>`. The translator  expects a file called ucact-c.cat, which contains the combined index and  star data for the catalog in a binary format. The path to the catalog  file is set by the NV_UCACT_DATA environment variable, which is specified  during installation.   Restrictions  ============   Since the distance to stars are not given in the UCACT catalog, the  position vector magnitude is set as 10 parsec and the luminosity  is calculated from the visual magnitude and the 10 parsec distance.   Procedure  =========   Stars are found in a square area in RA and DEC around a given  or calculated center.  The star descriptor is filled with stars  that fit in this area.  If B1950 is selected, input sd's orient  matrix is assumed to be B1950 also, if not, input is assumed to  be J2000, like the catalog.   :Categories:    nv, config   :Author:    Joseph Spitale, 3/2004    Jacqueline Ryan, 8/2016    :Private:  :Hidden:   :Private:  :Hidden:  Performs conversion UCACT packed data type to correct units  and values.   :Params:    packed_stars : in, required, type= `ucact_packed_star` array       array of structs containing raw data of stars from binary      catalog file   :Keywords:    ra : optional, type=double      right ascension is converted to degrees    dec : optional, type=double      declination is converted to degrees    _rapm : optional, type=double      proper motion is converted to degrees/year    _decpm : optional, type=double      proper motion is converted to degrees/year    mag : optional, type=double      magnitude is converted to W    px : optional, type=long      parallax    sp : optional, type=integer      sp does not contain the spectral type since this is not      available.  Instead it contains the UCACT class of the object:        0 - star        1 - galaxy        2 - blend or member of incorrectly resolved blend.        3 - non-star        5 - potential artifact       (Note that code 1 is used only for a few  hand-entered errata;       galaxies successfully processed by the software have a       classification of 3 [non-stellar].  Also code 4 is never used.)    num : optional, type=long      UCACT number, this is neither the UCAC number nor the TYCHO number    epochra : optional, type=double      epoch of ra is converted to b1950 in absolute years (NOT years after 1950)    epochdec : optional, type=double      epoch of dec is converted to b1950 in absolute years (NOT years after 1950)    :Private:  :Hidden:  Ingests a set of records from the UCACT star catalog and generates star  descriptors for each star within a specified scene.   :Returns:    array of star descriptors   :Params:    dd : in, required, type= data descriptor        data descriptor    filename : in, required, type=string       name of index file, or regions file   :Keywords:    cam_vel : in, optional, type=double       camera velocity from scene data, used to correct for stellar       aberration    b1950 : in, optional, type=string       if set, coordinates are output wrt b1950    ra1 : in, required, type=double       lower bound in right ascension of scene    ra2 : in, required, type=double       upper bound in right ascension of scene    dec1 : in, required, type=double       lower bound in declination of scene    dec2 : in, required, type=double       upper bound in declination of scene    faint : in, optional, type=double       stars with magnitudes fainter than this will not be returned    bright : in, optional, type=double       stars with magnitudes brighter than this will not be returned    nbright : in, optional, type=double       if set, selects only the n brightest stars    noaberr : in, optional, type=string       if set, stellar aberration will not be calculated    names : in, optional, type= string array        if set, will return only the stars with the expected names    mag : out, required, type=double       magnitude of returned stars    jtime : in, optional, type=double       Years since 1950 (the epoch of catalog) for precession       and proper motion correction. If not given, it is taken       from the object descriptor bod_time, which is assumed to       be seconds past 2000, unless keyword /b1950 is set   :Private:  :Hidden:  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/strcat/strcat_ucact_input.html#ucact_get_regions", "ucact_get_regions", 'routine in <a href="config/strcat/strcat_ucact_input.html">strcat_ucact_input.pro</a>', "strcat_ucact_input.pro", "", "ucact_get_regions", "", "path_ucactra1ra2dec1dec2", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/strcat/strcat_ucact_input.html#ucact_unpack_stars", "ucact_unpack_stars", 'routine in <a href="config/strcat/strcat_ucact_input.html">strcat_ucact_input.pro</a>', "strcat_ucact_input.pro", "", "ucact_unpack_stars", "", "radec_rapm_decpmmagpxspnumepochraepochdecpacked_stars", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/strcat/strcat_ucact_input.html#ucact_get_stars", "ucact_get_stars", 'routine in <a href="config/strcat/strcat_ucact_input.html">strcat_ucact_input.pro</a>', "strcat_ucact_input.pro", "", "ucact_get_stars", "", "cam_velb1950ra1ra2dec1dec2faintbrightnbrightnoaberrnamesmagjtimeddfilename", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/strcat/strcat_ucact_input.html#strcat_ucact_input", "strcat_ucact_input", 'routine in <a href="config/strcat/strcat_ucact_input.html">strcat_ucact_input.pro</a>', "strcat_ucact_input.pro", "", "strcat_ucact_input", "", "valuesstatusddkeyword@nv_trs_keywords_include.pro", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/str/strep.html", "strep.pro", '.pro file in <a href="util/str/dir-overview.html">util/str/ directory</a>', "strep.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/str/strep.html#strep", "strep", 'routine in <a href="util/str/strep.html">strep.pro</a>', "strep.pro", "", "strep", "", "ssspos", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/str/strep_char.html", "strep_char.pro", '.pro file in <a href="util/str/dir-overview.html">util/str/ directory</a>', "strep_char.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/str/strep_char.html#strep_char", "strep_char", 'routine in <a href="util/str/strep_char.html">strep_char.pro</a>', "strep_char.pro", "", "strep_char", "", "sccc", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/str/strep_s.html", "strep_s.pro", '.pro file in <a href="util/str/dir-overview.html">util/str/ directory</a>', "strep_s.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/str/strep_s.html#strep_s", "strep_s", 'routine in <a href="util/str/strep_s.html">strep_s.pro</a>', "strep_s.pro", "", "strep_s", "", "s_sss", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/str/strep_ss.html", "strep_ss.pro", '.pro file in <a href="util/str/dir-overview.html">util/str/ directory</a>', "strep_ss.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/str/strep_ss.html#strep_ss", "strep_ss", 'routine in <a href="util/str/strep_ss.html">strep_ss.pro</a>', "strep_ss.pro", "", "strep_ss", "", "s_sss", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/str/strerr.html", "strerr.pro", '.pro file in <a href="util/str/dir-overview.html">util/str/ directory</a>', "strerr.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/str/strerr.html#strerr_dec", "strerr_dec", 'routine in <a href="util/str/strerr.html">strerr.pro</a>', "strerr.pro", "", "strerr_dec", "", "s", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/str/strerr.html#strerr_exp", "strerr_exp", 'routine in <a href="util/str/strerr.html">strerr.pro</a>', "strerr.pro", "", "strerr_exp", "", "x", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/str/strerr.html#strerr_shift", "strerr_shift", 'routine in <a href="util/str/strerr.html">strerr.pro</a>', "strerr.pro", "", "strerr_shift", "", "ssdn", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/str/strerr.html#strerr", "strerr", 'routine in <a href="util/str/strerr.html">strerr.pro</a>', "strerr.pro", "", "strerr", "", "xdx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/str/strip_comment.html", "strip_comment.pro", '.pro file in <a href="util/str/dir-overview.html">util/str/ directory</a>', "strip_comment.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/str/strip_comment.html#strip_comment", "strip_comment", 'routine in <a href="util/str/strip_comment.html">strip_comment.pro</a>', "strip_comment.pro", "", "strip_comment", "", "comment_charonly_charexclude_charw_lines", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/idl_parse/strip_idl_comments.html", "strip_idl_comments.pro", '.pro file in <a href="util/idl_parse/dir-overview.html">util/idl_parse/ directory</a>', "strip_idl_comments.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/idl_parse/strip_idl_comments.html#strip_idl_comments", "strip_idl_comments", 'routine in <a href="util/idl_parse/strip_idl_comments.html">strip_idl_comments.pro</a>', "strip_idl_comments.pro", "", "strip_idl_comments", "", "inlines", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/str/strmid_11.html", "strmid_11.pro", '.pro file in <a href="util/str/dir-overview.html">util/str/ directory</a>', "strmid_11.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/str/strmid_11.html#strmid_11", "strmid_11", 'routine in <a href="util/str/strmid_11.html">strmid_11.pro</a>', "strmid_11.pro", "", "strmid_11", "", "ss_p_len", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/fits/strn.html", "strn.pro", '.pro file in <a href="config/fits/dir-overview.html">config/fits/ directory</a>', "strn.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/fits/strn.html#strn", "strn", 'routine in <a href="config/fits/strn.html">strn.pro</a>', "strn.pro", "", "strn", " NAME: 	STRN  PURPOSE: 	Convert a number to a string and remove padded blanks.  EXPLANATION: 	The main and original purpose of this procedure is to convert a number 	to an unpadded string (i.e. with no blanks around it.)  However, it 	has been expanded to be a multi-purpose formatting tool.  You may 	specify a length for the output string; the returned string is either 	set to that length or padded to be that length.  You may specify 	characters to be used in padding and which side to be padded.  Finally, 	you may also specify a format for the number.  NOTE that the input 	 number  need not be a number; it may be a string, or anything.  It is 	converted to string.   CALLING SEQEUNCE: 	tmp = STRN( number, [ LENGTH=, PADTYPE=, PADCHAR=, FORMAT = ] )   INPUT: 	NUMBER    This is the input variable to be operated on.  Traditionally, 		 it was a number, but it may be any scalar type.   OPTIONAL INPUT: 	LENGTH    This KEYWORD specifies the length of the returned string. 		If the output would have been longer, it is truncated.  If 		the output would have been shorter, it is padded to the right 		length. 	PADTYPE   This KEYWORD specifies the type of padding to be used, if any. 		0=Padded at End, 1=Padded at front, 2=Centered (pad front/end) 		IF not specified, PADTYPE=1 	PADCHAR   This KEYWORD specifies the character to be used when padding. 		The default is a space (' '). 	FORMAT    This keyword allows the FORTRAN type formatting of the input 		number (e.g. '(f6.2)')   OUTPUT: 	tmp       The formatted string   USEFUL EXAMPLES: 	print,'Used ',strn(stars),' stars.'  ==> 'Used 22 stars.' 	print,'Attempted ',strn(ret,leng=6,padt=1,padch='0'),' retries.' 		==> 'Attempted 000043 retries.' 	print,strn('M81 Star List',length=80,padtype=2) 		==> an 80 character line with 'M81 Star List' centered. 	print,'Error: ',strn(err,format='(f15.2)') 		==> 'Error: 3.24'     or ==> 'Error: 323535.22'   HISTORY: 	03-JUL-90 Version 1 written by Eric W. Deutsch 	10-JUL-90 Trimming and padding options added         (E. Deutsch) 	29-JUL-91 Changed to keywords and header spiffed up     (E. Deutsch) 	Ma7 92 Work correctly for byte values (W. Landsman) 	19-NOV-92 Added Patch to work around IDL 2.4.0 bug which caused an 	error when STRN('(123)') was encountered.            (E. Deutsch) 	Converted to IDL V5.0   W. Landsman   September 1997  ", "LENGTHPADTYPEPADCHARFORMATnumber", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/str/strnpos.html", "strnpos.pro", '.pro file in <a href="util/str/dir-overview.html">util/str/ directory</a>', "strnpos.pro", "", "", " NAME:        strnpos   PURPOSE:        Finds every occurrence of the given character token within the given 	string.    CATEGORY:        UTIL    CALLING SEQUENCE:        return = strnpos(string, token)    ARGUMENTS:   INPUT:         string:        An input string           token:        Character to match    OUTPUT:        NONE    KEYWORDS:        NONE    RETURN:        Array giving the position of every occurrence of the token within 	the string.  -1 if not found.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale; 2/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/str/strnpos.html#strnpos", "strnpos", 'routine in <a href="util/str/strnpos.html">strnpos.pro</a>', "strnpos.pro", "", "strnpos", "", "stringtokens", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/fits/strnumber.html", "strnumber.pro", '.pro file in <a href="config/fits/dir-overview.html">config/fits/ directory</a>', "strnumber.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/fits/strnumber.html#strnumber", "strnumber", 'routine in <a href="config/fits/strnumber.html">strnumber.pro</a>', "strnumber.pro", "", "strnumber", " NAME:       STRNUMBER  PURPOSE:       Function to determine if a string is a valid numeric value.   CALLING SEQUENCE:       result = strnumber( st, [val, /HEX] )   INPUTS:       st - any IDL scalar string   OUTPUTS:       1 is returned as the function value if the string st has a       valid numeric value, otherwise, 0 is returned.   OPTIONAL OUTPUT:       val - (optional) value of the string.  real*8   OPTIONAL INPUT KEYWORD:        /HEX - If present and nonzero, the string is treated as a hexadecimal              longword integer.   EXAMPLES:       IDL> res = strnumber(' ',val)            returns res=0 (not a number) and val is undefined        IDL> res = strnumber('0.2d', val)            returns res=1 (a valid number), and val = 0.2000d   NOTES:       (1) STRNUMBER was modified in February 1993 to include a special test for       empty or null strings, which now returns a 0 (not a number).    Without       this special test, it was found that a empty string (' ') could corrupt       the stack.         (2) STRNUMBER will return a string such as '23.45uyrg' as a valid       number (=23.45) since this is how IDL performs the type conversion.  If       you want a stricter definition of valid number then use the VALID_NUM       function.  HISTORY:       version 1  By D. Lindler Aug. 1987       test for empty string, W. Landsman          February, 1993       Converted to IDL V5.0   W. Landsman   September 1997       Hex keyword added.  MRG, RITSS, 15 March 2000.  ", "hexstval", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/str/strpropcase.html", "strpropcase.pro", '.pro file in <a href="util/str/dir-overview.html">util/str/ directory</a>', "strpropcase.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/str/strpropcase.html#strpropcase", "strpropcase", 'routine in <a href="util/str/strpropcase.html">strpropcase.pro</a>', "strpropcase.pro", "", "strpropcase", "", "s", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/str/strsub_case.html", "strsub_case.pro", '.pro file in <a href="util/str/dir-overview.html">util/str/ directory</a>', "strsub_case.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/str/strsub_case.html#strsub_case", "strsub_case", 'routine in <a href="util/str/strsub_case.html">strsub_case.pro</a>', "strsub_case.pro", "", "strsub_case", "", "matchrules", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/struct_extract.html", "struct_extract.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "struct_extract.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/struct_extract.html#struct_extract", "struct_extract", 'routine in <a href="util/struct_extract.html">struct_extract.pro</a>', "struct_extract.pro", "", "struct_extract", "", "remstructprefix", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/struct_get.html", "struct_get.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "struct_get.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/struct_get.html#struct_get", "struct_get", 'routine in <a href="util/struct_get.html">struct_get.pro</a>', "struct_get.pro", "", "struct_get", "", "prefixstructtag", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/struct_sub.html", "struct_sub.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "struct_sub.pro", "", "", " NAME: 	struct_sub    PURPOSE: 	Creates a new structure whose fields are the same as those in the 	given structure except for the specified substitutions.    CATEGORY: 	UTIL    CALLING SEQUENCE: 	result = struct_sub(struct, sub_tags, sub_val_ps)    ARGUMENTS:   INPUT: 	struct:		Input structure.  	sub_tags:	Tags to substitute  	sub_val_s:	Pointers to values for the substituted tags.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	NONE    OUTPUT: 	NONE    RETURN: 	A new structure is created that is the same as the input structure 	except for the specified field substitutions.    RESTRICTIONS: 	Currently only works for output structures with 10 or fewer fields.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 3/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/struct_sub.html#struct_sub", "struct_sub", 'routine in <a href="util/struct_sub.html">struct_sub.pro</a>', "struct_sub.pro", "", "struct_sub", "", "s_sub_tagssub_val_ps", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/struct_tags.html", "struct_tags.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "struct_tags.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/struct_tags.html#struct_tags", "struct_tags", 'routine in <a href="util/struct_tags.html">struct_tags.pro</a>', "struct_tags.pro", "", "struct_tags", "", "s", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/str/strxpos.html", "strxpos.pro", '.pro file in <a href="util/str/dir-overview.html">util/str/ directory</a>', "strxpos.pro", "", "", " NAME:        strnpos   PURPOSE:        Finds first occurrence of a character other than the given character 	token within the given string.    CATEGORY:        UTIL    CALLING SEQUENCE:        return = strxpos(string, token)    ARGUMENTS:   INPUT:         string:        An input string           token:        Character to match    OUTPUT:        NONE    KEYWORDS:        NONE    RETURN:        Position of first occurence.  -1 if not found.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale; 9/2008   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/str/strxpos.html#strxpos", "strxpos", 'routine in <a href="util/str/strxpos.html">strxpos.pro</a>', "strxpos.pro", "", "strxpos", "", "stringtoken", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/sub_latlon.html", "sub_latlon.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "sub_latlon.pro", "", "", " NAME: 	sub_latlon    PURPOSE: 	Computes sub-observer latitude and longitude on a globe.   CATEGORY: 	NV/LIB/TOOLS    CALLING SEQUENCE:     result = sub_latlon(gbx, v, sublat, sublon)    ARGUMENTS:   INPUT: 	gbx:	Array (nt) of any subclass of GLOBE.  	v:	Array (nv,3,nt) giving the observer position in the BODY frame.    OUTPUT: 	sublat:	Array (nv,nt) of latitude of sub-observer point on gbx.  	sublon:	Array (nv,nt) of longitude of sub-observer point on gbx.    KEYWORDS:   INPUT: 	graphic:   If set, use planetographic coordinates.    OUTPUT: 	body_pt:	Array (nv,3,nt) giving the sub-observer point in 			BODY coordinates.  	surf_pt:	Array (nv,3,nt) giving the sub-observer point in 			SURFACE coordinates.    RETURN: NONE    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/sub_latlon.html#sub_latlon", "sub_latlon", 'routine in <a href="nv/obj/tools/sub_latlon.html">sub_latlon.pro</a>', "sub_latlon.pro", "", "sub_latlon", "", "body_ptsurf_ptgraphicgbxvsublatsublon", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/subimage.html", "subimage.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "subimage.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/subimage.html#subimage", "subimage", 'routine in <a href="util/subimage.html">subimage.pro</a>', "subimage.pro", "", "subimage", "", "imx0y0dxdy", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/subimage_centroid.html", "subimage_centroid.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "subimage_centroid.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/subimage_centroid.html#subimage_centroid", "subimage_centroid", 'routine in <a href="util/subimage_centroid.html">subimage_centroid.pro</a>', "subimage_centroid.pro", "", "subimage_centroid", "", "nsignitshow_im_corners", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/super_resolution_1d.html", "super_resolution_1d.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "super_resolution_1d.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/super_resolution_1d.html#super_resolution_1d", "super_resolution_1d", 'routine in <a href="util/super_resolution_1d.html">super_resolution_1d.pro</a>', "super_resolution_1d.pro", "", "super_resolution_1d", "", "scan_psfactor", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/arr/dat/earth/supmap.html", "supmap.pro", '.pro file in <a href="config/arr/dat/earth/dir-overview.html">config/arr/dat/earth/ directory</a>', "supmap.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/arr/dat/earth/supmap.html#supmap_read", "supmap_read", 'routine in <a href="config/arr/dat/earth/supmap.html">supmap.pro</a>', "supmap.pro", "", "supmap_read", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/arr/dat/earth/supmap.html#supmap", "supmap", 'routine in <a href="config/arr/dat/earth/supmap.html">supmap.pro</a>', "supmap.pro", "", "supmap", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/composite/surface_hide_points.html", "surface_hide_points.pro", '.pro file in <a href="nv/obj/tools/composite/dir-overview.html">nv/obj/tools/composite/ directory</a>', "surface_hide_points.pro", "", "", " NAME: 	surface_hide_points    PURPOSE: 	Hides points with respect to surface objects.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE: 	sub = surface_hide_points(bx, v, r)    ARGUMENTS:   INPUT: 	bx:	Array (nt) of any subclass of BODY descriptors with 		the expected surface parameters.  	v:	Array (nv,3,nt) giving viewer positions in the BODY frame.  	r:	Array (nv,3,nt) giving points to hide in the BODY frame.     OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Subscripts of the points in p that are hidden by the object.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/composite/surface_hide_points.html#surface_hide_points", "surface_hide_points", 'routine in <a href="nv/obj/tools/composite/surface_hide_points.html">surface_hide_points.pro</a>', "surface_hide_points.pro", "", "surface_hide_points", "", "bxvr", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/composite/surface_image_bounds.html", "surface_image_bounds.pro", '.pro file in <a href="nv/obj/tools/composite/dir-overview.html">nv/obj/tools/composite/ directory</a>', "surface_image_bounds.pro", "", "", " NAME:        surface_image_bounds    PURPOSE: 	Computes latitude / longitude ranges visible in an image.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        surface_image_bounds, cd, bx, $ 	            latmin=latmin, latmax=latmax, lonmin=lonmin, lonmax=lonmax    ARGUMENTS:   INPUT: 	cd:      Camera descriptor  	bx:      Object descriptor (subclass of BODY)     OUTPUT: NONE    KEYWORDS:    INPUT: 	slop:	Amount, in pixels, by which to expand the image size 		considered in the calcultaion.     OUTPUT: 	border_pts_im:	Image points on the border of the image defined by cd.  	latmin:	Minimum latitude covered in image  	latmax:	Maximum latitude covered in image  	lonmin:	Minimum longitude covered in image  	lonmax:	Maximum longitude covered in image    RETURN: NONE    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/composite/surface_image_bounds.html#surface_image_bounds", "surface_image_bounds", 'routine in <a href="nv/obj/tools/composite/surface_image_bounds.html">surface_image_bounds.pro</a>', "surface_image_bounds.pro", "", "surface_image_bounds", "", "slopborder_pts_imlatminlatmaxlonminlonmaxstatuscdbx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/composite/surface_intersect.html", "surface_intersect.pro", '.pro file in <a href="nv/obj/tools/composite/dir-overview.html">nv/obj/tools/composite/ directory</a>', "surface_intersect.pro", "", "", " NAME: 	surface_intersect    PURPOSE: 	Computes the intersection of rays with surface objects.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE: 	int_pts = surface_intersect(bx, v, r)    ARGUMENTS:   INPUT: 	bx:	Array (nt) of any subclass of BODY descriptors with 		the expected surface parameters.  	v:	Array (nv,3,nt) giving ray origins in the BODY frame.  	r:	Array (nv,3,nt) giving ray directions in the BODY frame.     OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (2*nv,3,nt) of points in the BODY frame, where 	int_pts[0:nv-1,*,*] correspond to the near-side intersections 	and int_pts[nv:2*nv-1,*,1] correspond to the far side.  Zero 	vector is returned for points with no solution.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/composite/surface_intersect.html#surface_intersect", "surface_intersect", 'routine in <a href="nv/obj/tools/composite/surface_intersect.html">surface_intersect.pro</a>', "surface_intersect.pro", "", "surface_intersect", "", "hitnearfarbxvr", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/surface_normal.html", "surface_normal.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "surface_normal.pro", "", "", " NAME: 	surface_normal    PURPOSE: 	Computes the normal at points on a surface.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE: 	norm_pts = surface_normal(bx, r)    ARGUMENTS:   INPUT: 	bx:	Array (nt) of any subclass of BODY descriptors with 		the expected surface parameters.  	v:	Array (nv,3,nt) giving observer positions in the BODY frame.  	r:	Array (nv,3,nt) giving surface positions in the BODY frame.     OUTPUT: NONE    KEYWORDS:   INPUT: 	frame_bd:  Frame descriptor, if required for bx.  	north:     Passed to dsk_surface_normal.  Causes surface normal 	           to point north regardless of observer position.    OUTPUT: NONE    RETURN: 	Array (nv, 3, nt) of surface unit normals in the BODY frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/surface_normal.html#surface_normal", "surface_normal", 'routine in <a href="nv/obj/tools/surface_normal.html">surface_normal.pro</a>', "surface_normal.pro", "", "surface_normal", "", "frame_bdnorthbxvr", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/composite/surface_normal.html", "surface_normal.pro", '.pro file in <a href="nv/obj/tools/composite/dir-overview.html">nv/obj/tools/composite/ directory</a>', "surface_normal.pro", "", "", " NAME: 	surface_normal    PURPOSE: 	Computes the normal at points on a surface.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE: 	norm_pts = surface_normal(bx, v, r)    ARGUMENTS:   INPUT: 	bx:	Array (nt) of any subclass of BODY descriptors with 		the expected surface parameters.  	v:	Array (nv,3,nt) giving observer positions in the BODY frame.  	r:	Array (nv,3,nt) giving surface positions in the BODY frame.     OUTPUT: NONE    KEYWORDS:   INPUT: 	north:     Passed to dsk_surface_normal.  Causes surface normal 	           to point north regardless of observer position.    OUTPUT: NONE    RETURN: 	Array (nv, 3, nt) of surface unit normals in the BODY frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 7/2015   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/composite/surface_normal.html#surface_normal", "surface_normal", 'routine in <a href="nv/obj/tools/composite/surface_normal.html">surface_normal.pro</a>', "surface_normal.pro", "", "surface_normal", "", "northbxvr", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/composite/surface_to_body.html", "surface_to_body.pro", '.pro file in <a href="nv/obj/tools/composite/dir-overview.html">nv/obj/tools/composite/ directory</a>', "surface_to_body.pro", "", "", " NAME:        surface_to_body    PURPOSE:        Transforms points in any surface coordinate system to body 	coordinates.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = surface_to_body(bx, surface_pts)    ARGUMENTS:   INPUT: 	bx:      Array of nt object descriptors (subclass of BODY).  	surface_pts:       Array (nv x 3 x nt) of surface points    OUTPUT:        NONE   KEYWORDS:    INPUT: NONE     OUTPUT: NONE    RETURN:        Array (nv x 3 x nt) of body coordinates.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/composite/surface_to_body.html#surface_to_body", "surface_to_body", 'routine in <a href="nv/obj/tools/composite/surface_to_body.html">surface_to_body.pro</a>', "surface_to_body.pro", "", "surface_to_body", "", "bxp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/surface_to_degrees.html", "surface_to_degrees.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "surface_to_degrees.pro", "", "", " NAME:        surface_to_degrees    PURPOSE:        Converts angular part of surface vectors from radians to degrees    CATEGORY:        NV/LIB/TOOLS    CALLING SEQUENCE:        result = surface_to_degrees(v)    ARGUMENTS:   INPUT:               v:       An array of surface vectors (nv,3,nt).    OUTPUT:        NONE   RETURN:        Array of vectors (nv,3,nt)   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale		11/12/01  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/surface_to_degrees.html#surface_to_degrees", "surface_to_degrees", 'routine in <a href="nv/obj/tools/surface_to_degrees.html">surface_to_degrees.pro</a>', "surface_to_degrees.pro", "", "surface_to_degrees", "", "v", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/composite/surface_to_image.html", "surface_to_image.pro", '.pro file in <a href="nv/obj/tools/composite/dir-overview.html">nv/obj/tools/composite/ directory</a>', "surface_to_image.pro", "", "", " NAME:        surface_to_image    PURPOSE:        Transforms points in any surface coordinate system to image 	coordinates.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = surface_to_image(cd, bx, surface_pts)    ARGUMENTS:   INPUT: 	cd:      Array of nt camera or map descriptors.  	bx:      Array of nt object descriptors (subclass of BODY).  	surface_pts:       Array (nv x 3 x nt) of surface points    OUTPUT:        NONE   KEYWORDS:    INPUT: NONE     OUTPUT: NONE    RETURN:        Array (2 x nv x nt) of image points.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/composite/surface_to_image.html#surface_to_image", "surface_to_image", 'routine in <a href="nv/obj/tools/composite/surface_to_image.html">surface_to_image.pro</a>', "surface_to_image.pro", "", "surface_to_image", "", "body_ptsvalidcdbxp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/composite/surface_to_map.html", "surface_to_map.pro", '.pro file in <a href="nv/obj/tools/composite/dir-overview.html">nv/obj/tools/composite/ directory</a>', "surface_to_map.pro", "", "", " NAME:        surface_to_map    PURPOSE:        Transforms points in any surface coordinate system to map 	coordinates.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = surface_to_map(md, bx, surface_pts)    ARGUMENTS:   INPUT: 	md:      Array of nt map descriptors.  	bx:      Array of nt object descriptors (subclass of BODY.  	surface_pts:       Array (nv x 3 x nt) of surface points    OUTPUT:        NONE   KEYWORDS:    INPUT: NONE     OUTPUT: NONE    RETURN:        Array (2 x nv x nt) of map coordinates.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/composite/surface_to_map.html#surface_to_map", "surface_to_map", 'routine in <a href="nv/obj/tools/composite/surface_to_map.html">surface_to_map.pro</a>', "surface_to_map.pro", "", "surface_to_map", "", "mdbxsurface_pts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/swap.html", "swap.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "swap.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/swap.html#_swap", "_swap", 'routine in <a href="util/swap.html">swap.pro</a>', "swap.pro", "", "_swap", "", "signab", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/swap.html#swap", "swap", 'routine in <a href="util/swap.html">swap.pro</a>', "swap.pro", "", "swap", "", "signab", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/gen/swapgen.html", "swapgen.pro", '.pro file in <a href="util/gen/dir-overview.html">util/gen/ directory</a>', "swapgen.pro", "", "", " NAME: 	swapgen    PURPOSE: 	Generates an array of subscripts to swap the desired columns or rows 	in an array with dimensions n x m.   CATEGORY: 	UTIL/GEN    CALLING SEQUENCE: 	sub = swapgen(n, m, w1, w2)    ARGUMENTS:   INPUT: 	n,m:		Dimensions of array from which to select.  	w1,w2:		Indices of column or rows to swap.    OUTPUT: NONE    KEYWORDS:   INPUT: 	column:		If set, columns are swapped (default).  	row:		If set, rows are swapped.    OUTPUT: NONE    RETURN: 	Array (n x m) of subscripts that will swap the rows or columns.     STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/gen/swapgen.html#swapgen", "swapgen", 'routine in <a href="util/gen/swapgen.html">swapgen.pro</a>', "swapgen.pro", "", "swapgen", "", "rowcolumnnmw1w2", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/switch.html", "switch.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "switch.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/switch.html#switch", "switch", 'routine in <a href="util/switch.html">switch.pro</a>', "switch.pro", "", "switch", "", "testval1val2", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/fits/sxaddpar.html", "sxaddpar.pro", '.pro file in <a href="config/fits/dir-overview.html">config/fits/ directory</a>', "sxaddpar.pro", "", "", " NAME: 	sxaddpar    PURPOSE: 	Adds or modifies a parameter in a FITS header array.    CATEGORY: 	UTIL/FITS    CALLING SEQUENCE: 	sxaddpar, header, name, value [, comment, location]    ARGUMENTS:   INPUT: 	header:		String array containing FITS header. Max string length 			must be equal to 80.  If not defined, then SXADDPAR will 			create an empty FITS header array.  	name:		Name of parameter. If Name is already in the header the 			value and possibly comment fields are modified. Otherwise 			a new record is added to the header.  If name = 'HISTORY' 			then the value will be added to the record without 			replacement.  In this case the comment parameter is 			ignored.  	value:		Value for parameter.  The value expression must be of the 			correct type, e.g. integer, floating or string.  String 			values of 'T' or 'F' are considered logical values.  	comment:	String field.  The '/' is added by this routine.  Added 			starting in position 31.    If not supplied, or set equal 			to '', then the previous comment field is retained (when 			found).  	location:	Keyword string name.  The parameter will be placed before 			the location of this keyword.    This parameter is 			identical to the BEFORE keyword and is kept only for 			consistency with earlier versions of SXADDPAR.    OUTPUT: 	header:		Modified header.    KEYWORDS:   INPUT: 	before:	Keyword string name.  The parameter will be placed before the 		location of this keyword.  For example, if BEFORE='HISTORY' 		then the parameter will be placed before the first history 		location.  This applies only when adding a new keyword; 		keywords already in the header are kept in the same position.  	after:	Same as BEFORE, but the parameter will be placed after the 		location of this keyword.  This keyword takes precedence over 		BEFORE.  	format:	Specifies FORTRAN-like format for parameter, e.g.  F7.3 .  A 		scalar string should be used.  For complex numbers the format 		should be defined so that it can be applied separately to the 		real and imaginary parts.    OUTPUT: NONE    RETURN: NONE    RESTRICTIONS: 	Parameters and names are not checked against valid FITS parameter names, 	values and types.    STATUS: 	Complete    SEE ALSO: 	sxpar, sxdelpar    MODIFICATION HISTORY: 	DMS, RSI, July, 1983. 	D. Lindler Oct. 86  Added longer string value capability 	Converted to NEWIDL  D. Lindler April 90        Added Format keyword, J. Isensee, July, 1990        Added keywords BEFORE and AFTER. K. Venkatakrishna, May '92   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/fits/sxaddpar.html#sxaddpar", "sxaddpar", 'routine in <a href="config/fits/sxaddpar.html">sxaddpar.pro</a>', "sxaddpar.pro", "", "sxaddpar", "", "beforeafterformatHeaderNameValueCommentLocation", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/fits/sxdelpar.html", "sxdelpar.pro", '.pro file in <a href="config/fits/dir-overview.html">config/fits/ directory</a>', "sxdelpar.pro", "", "", " NAME: 	sxdelpar    PURPOSE: 	Deletes keyword parameters from a FITS header.    CATEGORY: 	UTIL/FITS    CALLING SEQUENCE: 	sxdelpar, h, parname    ARGUMENTS:   INPUT: 	h:		FITS header, string array.  	parname:	String or string array of keyword name(s) to delete.    OUTPUT: 	h:		Modified header.    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: NONE    NOTES:    (1)  Nothing happens if the keyword to be deleted is not found (no message)    (2)  All appearances of a keyword in the header will be deleted    STATUS: 	Complete    SEE ALSO: 	sxpar, sxaddpar    MODIFICATION HISTORY: 	version 1  D. Lindler Feb. 1987 	Converted to new IDL  April 1990 by D. Lindler   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/fits/sxdelpar.html#sxdelpar", "sxdelpar", 'routine in <a href="config/fits/sxdelpar.html">sxdelpar.pro</a>', "sxdelpar.pro", "", "sxdelpar", "", "hparname", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/fits/sxpar.html", "sxpar.pro", '.pro file in <a href="config/fits/dir-overview.html">config/fits/ directory</a>', "sxpar.pro", "", "", " NAME: 	sxpar    PURPOSE: 	Obtains the value of a parameter in a FITS header.    CATEGORY: 	UTIL/FITS    CALLING SEQUENCE: 	result = sxpar(hdr, name [, abort])    ARGUMENTS:   INPUT: 	hdr:	FITS header array, (e.g. as returned by SXOPEN or READFITS) 		string array, each element should have a length of 80 		characters.  	name:	String name of the parameter to return.   If Name is of 		the form 'keyword*' then an array is returned containing 		values of keywordN where N is an integer.  The value 		of keywordN will be placed in RESULT(N-1).  The data type 		of RESULT will be the type of the first valid match of keywordN 		found.  	abort:	String specifying that SXPAR should do a RETALL 		if a parameter is not found.  ABORT should contain 		a string to be printed if the keyword parameter is not found. 		If not supplied SXPAR will return with a negative 		!err if a keyword is not found.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: 	count:	Returns a value equal to the number of parameters found by sxpar.    RETURN: 	Value of parameter in header.  If parameter is double precision, 	floating, long or string, the result is of that type.  Apostrophes are 	stripped from strings.  If the parameter is logical, 1 is returned for T, 	and 0 is returned for F.  If Name was of form 'keyword*' then a vector of 	values are returned.    COMMON BLOCKS: 	xx:	xx  	xx:	xx    SIDE EFFECTS:        Keyword COUNT returns the number of parameters found. 	!err is set to -1 if parameter not found, 0 for a scalar 	value returned.  If a vector is returned it is set to the 	number of keyword matches found.         If a keyword occurs more than once in a header, a warning is given,        and the first occurence is used.    RESTRICTIONS: 	xx    PROCEDURE: 	The first 8 chacters of each element of Hdr are searched for a        match to Name.  The value from the last 20 characters is returned.        An error occurs if there is no parameter with the given name.         If a numeric value has no decimal point it is returned as type        LONG.   If it contains more than 8 numerals, or contains the        character 'D', then it is returned as type DOUBLE.  Otherwise        it is returned as type FLOAT    EXAMPLE:         Given a FITS header, h, return the values of all the NAXISi values         into a vector.    Then place the history records into a string vector.           IDL> naxisi = sxpar( h ,'NAXIS*')         ; Extract NAXISi value          IDL> history = sxpar( h, 'HISTORY' )      ; Extract HISTORY records    STATUS: 	Complete    SEE ALSO: 	sxaddpar, sxdelpar    MODIFICATION HISTORY: 	DMS, May, 1983, Written.    D. Lindler Jan 90 added ABORT input parameter    J. Isensee Jul,90 added COUNT keyword    W. Thompson, Feb. 1992, added support for FITS complex values.    W. Thompson, May 1992, corrected problem with HISTORY/COMMENT/blank 			   keywords, and complex value error correction.   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/fits/sxpar.html#SXPAR", "SXPAR", 'routine in <a href="config/fits/sxpar.html">sxpar.pro</a>', "sxpar.pro", "", "SXPAR", "", "COUNThdrnameabort", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/synth_image.html", "synth_image.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "synth_image.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/synth_image.html#synth_image", "synth_image", 'routine in <a href="nv/obj/tools/synth_image.html">synth_image.pro</a>', "synth_image.pro", "", "synth_image", "", "rdcdpdsund", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/composite/ta_to_az.html", "ta_to_az.pro", '.pro file in <a href="nv/obj/tools/composite/dir-overview.html">nv/obj/tools/composite/ directory</a>', "ta_to_az.pro", "", "", " NAME:        ta_to_az    PURPOSE: 	Computes azimuths relative to a given observer descriptor.    CATEGORY:        NV/LIB/TOOLS/COMPOSITE    CALLING SEQUENCE:        result = ta_to_az(ta, dkx, od)    ARGUMENTS:   INPUT: 	ta:	Longitude.  	dkx:	Disk descriptor.  	od:	Object descriptor (subclass of BODY) describing the observer.    OUTPUT:        NONE   KEYWORDS:    INPUT: NONE     OUTPUT: NONE    RETURN:        An array of azimuths.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/composite/ta_to_az.html#ta_to_az", "ta_to_az", 'routine in <a href="nv/obj/tools/composite/ta_to_az.html">ta_to_az.pro</a>', "ta_to_az.pro", "", "ta_to_az", "", "tadkxod", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/tag_exists.html", "tag_exists.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "tag_exists.pro", "", "", " NAME: 	tag_exists    PURPOSE: 	Determines whether a structure contains a given field.    CATEGORY: 	UTIL    CALLING SEQUENCE: 	result = tag_exists(struct, tag)    ARGUMENTS:   INPUT: 	struct:	Structure to test.  	tag:	String giving tag name to test for.   RETURN: 	True if the tag exists, false otherwise.    MODIFICATION HISTORY:  	Written by:	Spitale, 8/28/2001   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/tag_exists.html#tag_exists", "tag_exists", 'routine in <a href="util/tag_exists.html">tag_exists.pro</a>', "tag_exists.pro", "", "tag_exists", "", "indexstructtag", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/tag_list/tag_list_clone.html", "tag_list_clone.pro", '.pro file in <a href="util/tag_list/dir-overview.html">util/tag_list/ directory</a>', "tag_list_clone.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/tag_list/tag_list_clone.html#tag_list_clone", "tag_list_clone", 'routine in <a href="util/tag_list/tag_list_clone.html">tag_list_clone.pro</a>', "tag_list_clone.pro", "", "tag_list_clone", "", "tlp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/tag_list/tag_list_copy.html", "tag_list_copy.pro", '.pro file in <a href="util/tag_list/dir-overview.html">util/tag_list/ directory</a>', "tag_list_copy.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/tag_list/tag_list_copy.html#tag_list_copy", "tag_list_copy", 'routine in <a href="util/tag_list/tag_list_copy.html">tag_list_copy.pro</a>', "tag_list_copy.pro", "", "tag_list_copy", "", "tlp_dsttlp_src", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/tag_list/tag_list_free.html", "tag_list_free.pro", '.pro file in <a href="util/tag_list/dir-overview.html">util/tag_list/ directory</a>', "tag_list_free.pro", "", "", " NAME: 	xx    PURPOSE: 	xx    CATEGORY: 	UTIL    CALLING SEQUENCE: 	result = xx(xx, xx) 	xx, xx, xx    ARGUMENTS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    KEYWORDS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    ENVIRONMENT VARIABLES: 	xx:	xx  	xx:	xx    RETURN: 	xx    COMMON BLOCKS: 	xx:	xx  	xx:	xx    SIDE EFFECTS: 	xx    RESTRICTIONS: 	xx    PROCEDURE: 	xx    EXAMPLE: 	xx    STATUS: 	xx    SEE ALSO: 	xx, xx, xx    MODIFICATION HISTORY:  	Written by:	xx, xx/xx/xxxx   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/tag_list/tag_list_free.html#tag_list_free", "tag_list_free", 'routine in <a href="util/tag_list/tag_list_free.html">tag_list_free.pro</a>', "tag_list_free.pro", "", "tag_list_free", "", "tlp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/tag_list/tag_list_get.html", "tag_list_get.pro", '.pro file in <a href="util/tag_list/dir-overview.html">util/tag_list/ directory</a>', "tag_list_get.pro", "", "", " NAME: 	xx    PURPOSE: 	xx    CATEGORY: 	UTIL    CALLING SEQUENCE: 	result = xx(xx, xx) 	xx, xx, xx    ARGUMENTS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    KEYWORDS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    ENVIRONMENT VARIABLES: 	xx:	xx  	xx:	xx    RETURN: 	xx    COMMON BLOCKS: 	xx:	xx  	xx:	xx    SIDE EFFECTS: 	xx    RESTRICTIONS: 	xx    PROCEDURE: 	xx    EXAMPLE: 	xx    STATUS: 	xx    SEE ALSO: 	xx, xx, xx    MODIFICATION HISTORY:  	Written by:	xx, xx/xx/xxxx   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/tag_list/tag_list_get.html#tag_list_get", "tag_list_get", 'routine in <a href="util/tag_list/tag_list_get.html">tag_list_get.pro</a>', "tag_list_get.pro", "", "tag_list_get", "", "indexreferenceprefixtlpname", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/tag_list/tag_list_match.html", "tag_list_match.pro", '.pro file in <a href="util/tag_list/dir-overview.html">util/tag_list/ directory</a>', "tag_list_match.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/tag_list/tag_list_match.html#tag_list_match", "tag_list_match", 'routine in <a href="util/tag_list/tag_list_match.html">tag_list_match.pro</a>', "tag_list_match.pro", "", "tag_list_match", "", "prefixtlpname", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/tag_list/tag_list_names.html", "tag_list_names.pro", '.pro file in <a href="util/tag_list/dir-overview.html">util/tag_list/ directory</a>', "tag_list_names.pro", "", "", " NAME: 	xx    PURPOSE: 	xx    CATEGORY: 	UTIL    CALLING SEQUENCE: 	result = xx(xx, xx) 	xx, xx, xx    ARGUMENTS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    KEYWORDS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    ENVIRONMENT VARIABLES: 	xx:	xx  	xx:	xx    RETURN: 	xx    COMMON BLOCKS: 	xx:	xx  	xx:	xx    SIDE EFFECTS: 	xx    RESTRICTIONS: 	xx    PROCEDURE: 	xx    EXAMPLE: 	xx    STATUS: 	xx    SEE ALSO: 	xx, xx, xx    MODIFICATION HISTORY:  	Written by:	xx, xx/xx/xxxx   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/tag_list/tag_list_names.html#tag_list_names", "tag_list_names", 'routine in <a href="util/tag_list/tag_list_names.html">tag_list_names.pro</a>', "tag_list_names.pro", "", "tag_list_names", "", "tlp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/tag_list/tag_list_read.html", "tag_list_read.pro", '.pro file in <a href="util/tag_list/dir-overview.html">util/tag_list/ directory</a>', "tag_list_read.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/tag_list/tag_list_read.html#tag_list_read", "tag_list_read", 'routine in <a href="util/tag_list/tag_list_read.html">tag_list_read.pro</a>', "tag_list_read.pro", "", "tag_list_read", "", "unitbinfilename", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/tag_list/tag_list_rm.html", "tag_list_rm.pro", '.pro file in <a href="util/tag_list/dir-overview.html">util/tag_list/ directory</a>', "tag_list_rm.pro", "", "", " NAME: 	xx    PURPOSE: 	xx    CATEGORY: 	UTIL    CALLING SEQUENCE: 	result = xx(xx, xx) 	xx, xx, xx    ARGUMENTS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    KEYWORDS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    ENVIRONMENT VARIABLES: 	xx:	xx  	xx:	xx    RETURN: 	xx    COMMON BLOCKS: 	xx:	xx  	xx:	xx    SIDE EFFECTS: 	xx    RESTRICTIONS: 	xx    PROCEDURE: 	xx    EXAMPLE: 	xx    STATUS: 	xx    SEE ALSO: 	xx, xx, xx    MODIFICATION HISTORY:  	Written by:	xx, xx/xx/xxxx   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/tag_list/tag_list_rm.html#tag_list_rm", "tag_list_rm", 'routine in <a href="util/tag_list/tag_list_rm.html">tag_list_rm.pro</a>', "tag_list_rm.pro", "", "tag_list_rm", "", "tlpname", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/tag_list/tag_list_set.html", "tag_list_set.pro", '.pro file in <a href="util/tag_list/dir-overview.html">util/tag_list/ directory</a>', "tag_list_set.pro", "", "", " NAME: 	xx    PURPOSE: 	xx    CATEGORY: 	UTIL    CALLING SEQUENCE: 	result = xx(xx, xx) 	xx, xx, xx    ARGUMENTS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    KEYWORDS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    ENVIRONMENT VARIABLES: 	xx:	xx  	xx:	xx    RETURN: 	xx    COMMON BLOCKS: 	xx:	xx  	xx:	xx    SIDE EFFECTS: 	xx    RESTRICTIONS: 	xx    PROCEDURE: 	xx    EXAMPLE: 	xx    STATUS: 	xx    SEE ALSO: 	xx, xx, xx    MODIFICATION HISTORY:  	Written by:	xx, xx/xx/xxxx   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/tag_list/tag_list_set.html#tag_list_set", "tag_list_set", 'routine in <a href="util/tag_list/tag_list_set.html">tag_list_set.pro</a>', "tag_list_set.pro", "", "tag_list_set", "", "indexnewtlpnamedata", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/tag_list/tag_list_struct__define.html", "tag_list_struct__define.pro", '.pro file in <a href="util/tag_list/dir-overview.html">util/tag_list/ directory</a>', "tag_list_struct__define.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/tag_list/tag_list_struct__define.html#tag_list_struct__define", "tag_list_struct__define", 'routine in <a href="util/tag_list/tag_list_struct__define.html">tag_list_struct__define.pro</a>', "tag_list_struct__define.pro", "", "tag_list_struct__define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/tag_list/tag_list_write.html", "tag_list_write.pro", '.pro file in <a href="util/tag_list/dir-overview.html">util/tag_list/ directory</a>', "tag_list_write.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/tag_list/tag_list_write.html#tag_list_write", "tag_list_write", 'routine in <a href="util/tag_list/tag_list_write.html">tag_list_write.pro</a>', "tag_list_write.pro", "", "tag_list_write", "", "unitbintlpfilename", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/tag_list/tag_list_write.html#_tag_list_write", "_tag_list_write", 'routine in <a href="util/tag_list/tag_list_write.html">tag_list_write.pro</a>', "tag_list_write.pro", "", "_tag_list_write", "", "unitbintlpfilename", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/target_altaz.html", "target_altaz.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "target_altaz.pro", "", "", " NAME: 	target_altaz    PURPOSE: 	Computes altitude/azimuth of a target relative to a point on or near the 	surface of a globe.   CATEGORY: 	NV/LIB/TOOLS    CALLING SEQUENCE:     result = target_altaz(bx, gbx, lat, lon, alt)    ARGUMENTS:   INPUT: 	bx:	Array (nt) of any subclass of BODY giving the target.  	gbx:	Array (nt) of any subclass of GLOBE.  	lat:	Latitude of observer wrt gbx.  	lon:	Longitude of observer wrt gbx.  	alt:	Altitude of observer wrt gbx.    OUTPUT:         NONE   KEYWORDS:   INPUT: 	  cd:	Camera descriptor.           gd:   Optional generic descriptor containing cd.    OUTPUT:     profile:   The profile.        sigma:   Array giving the standard deviation at each point in the 		profile.      distance:  Array giving the distance, in pixels, along the profile.    RETURN: 	Vector from observer to target in the altaz system.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/target_altaz.html#target_altaz", "target_altaz", 'routine in <a href="nv/obj/tools/target_altaz.html">target_altaz.pro</a>', "target_altaz.pro", "", "target_altaz", "", "bxpdlatlonalt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/tascpds.html", "tascpds.pro", '.pro file in <a href="config/pds/Readpds_4.4/dir-overview.html">config/pds/Readpds_4.4/ directory</a>', "tascpds.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/tascpds.html#obtain_keyword", "obtain_keyword", 'routine in <a href="config/pds/Readpds_4.4/tascpds.html">tascpds.pro</a>', "tascpds.pro", "", "obtain_keyword", "", "namelabelstart_indend_ind", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/tascpds.html#remove_table_name", "remove_table_name", 'routine in <a href="config/pds/Readpds_4.4/tascpds.html">tascpds.pro</a>', "tascpds.pro", "", "remove_table_name", "", "namelabelstart_indend_ind", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/tascpds.html#separate_table_data_type", "separate_table_data_type", 'routine in <a href="config/pds/Readpds_4.4/tascpds.html">tascpds.pro</a>', "tascpds.pro", "", "separate_table_data_type", "", "data_type", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/tascpds.html#process_table_items", "process_table_items", 'routine in <a href="config/pds/Readpds_4.4/tascpds.html">tascpds.pro</a>', "tascpds.pro", "", "process_table_items", "", "keywdsitemscurposcurr_indnext_ind", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/tascpds.html#convert_table_element", "convert_table_element", 'routine in <a href="config/pds/Readpds_4.4/tascpds.html">tascpds.pro</a>', "tascpds.pro", "", "convert_table_element", "", "elementtyperows", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/tascpds.html#tasc_interform", "tasc_interform", 'routine in <a href="config/pds/Readpds_4.4/tascpds.html">tascpds.pro</a>', "tascpds.pro", "", "tasc_interform", "", "labelstart_indend_ind", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/tascpds.html#obtain_table_req", "obtain_table_req", 'routine in <a href="config/pds/Readpds_4.4/tascpds.html">tascpds.pro</a>', "tascpds.pro", "", "obtain_table_req", "", "labelstart_indend_ind", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/tascpds.html#obtain_tasc_opt", "obtain_tasc_opt", 'routine in <a href="config/pds/Readpds_4.4/tascpds.html">tascpds.pro</a>', "tascpds.pro", "", "obtain_tasc_opt", "", "labelstart_indend_ind", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/tascpds.html#obtain_table_items", "obtain_table_items", 'routine in <a href="config/pds/Readpds_4.4/tascpds.html">tascpds.pro</a>', "tascpds.pro", "", "obtain_table_items", "", "labelreq_keywdsstart_indend_ind", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/tascpds.html#create_table_struct", "create_table_struct", 'routine in <a href="config/pds/Readpds_4.4/tascpds.html">tascpds.pro</a>', "tascpds.pro", "", "create_table_struct", "", "keywdsoptitemslabelstart_indend_ind", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/tascpds.html#read_table_data", "read_table_data", 'routine in <a href="config/pds/Readpds_4.4/tascpds.html">tascpds.pro</a>', "tascpds.pro", "", "read_table_data", "", "pointerdata_structkeywdssilent", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/tascpds.html#tascpds", "tascpds", 'routine in <a href="config/pds/Readpds_4.4/tascpds.html">tascpds.pro</a>', "tascpds.pro", "", "tascpds", "", "SILENTfnamelabelobjindex", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/tbinpds.html", "tbinpds.pro", '.pro file in <a href="config/pds/Readpds_4.4/dir-overview.html">config/pds/Readpds_4.4/ directory</a>', "tbinpds.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/tbinpds.html#OBTAIN_KEYWORD", "OBTAIN_KEYWORD", 'routine in <a href="config/pds/Readpds_4.4/tbinpds.html">tbinpds.pro</a>', "tbinpds.pro", "", "OBTAIN_KEYWORD", "", "namelabelstart_indend_ind", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/tbinpds.html#REMOVE_TBIN_NAME", "REMOVE_TBIN_NAME", 'routine in <a href="config/pds/Readpds_4.4/tbinpds.html">tbinpds.pro</a>', "tbinpds.pro", "", "REMOVE_TBIN_NAME", "", "namelabelstart_indend_ind", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/tbinpds.html#OBTAIN_TBIN_ARCH", "OBTAIN_TBIN_ARCH", 'routine in <a href="config/pds/Readpds_4.4/tbinpds.html">tbinpds.pro</a>', "tbinpds.pro", "", "OBTAIN_TBIN_ARCH", "", "data_type", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/tbinpds.html#SEPARATE_TBIN_DATA_TYPE", "SEPARATE_TBIN_DATA_TYPE", 'routine in <a href="config/pds/Readpds_4.4/tbinpds.html">tbinpds.pro</a>', "tbinpds.pro", "", "SEPARATE_TBIN_DATA_TYPE", "", "data_type", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/tbinpds.html#PROCESS_TBIN_ITEMS", "PROCESS_TBIN_ITEMS", 'routine in <a href="config/pds/Readpds_4.4/tbinpds.html">tbinpds.pro</a>', "tbinpds.pro", "", "PROCESS_TBIN_ITEMS", "", "keywdsitemscurposcurr_indnext_ind", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/tbinpds.html#TBIN_INTERFORM", "TBIN_INTERFORM", 'routine in <a href="config/pds/Readpds_4.4/tbinpds.html">tbinpds.pro</a>', "tbinpds.pro", "", "TBIN_INTERFORM", "", "labelstart_indend_ind", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/tbinpds.html#OBTAIN_TBIN_REQ", "OBTAIN_TBIN_REQ", 'routine in <a href="config/pds/Readpds_4.4/tbinpds.html">tbinpds.pro</a>', "tbinpds.pro", "", "OBTAIN_TBIN_REQ", "", "labelstart_indend_ind", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/tbinpds.html#OBTAIN_TBIN_OPT", "OBTAIN_TBIN_OPT", 'routine in <a href="config/pds/Readpds_4.4/tbinpds.html">tbinpds.pro</a>', "tbinpds.pro", "", "OBTAIN_TBIN_OPT", "", "labelstart_indend_ind", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/tbinpds.html#OBTAIN_TBIN_ITEMS", "OBTAIN_TBIN_ITEMS", 'routine in <a href="config/pds/Readpds_4.4/tbinpds.html">tbinpds.pro</a>', "tbinpds.pro", "", "OBTAIN_TBIN_ITEMS", "", "labelreq_keywdsstart_indend_ind", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/tbinpds.html#OBTAIN_TBIN_CONTAINERS", "OBTAIN_TBIN_CONTAINERS", 'routine in <a href="config/pds/Readpds_4.4/tbinpds.html">tbinpds.pro</a>', "tbinpds.pro", "", "OBTAIN_TBIN_CONTAINERS", "", "labelreq_keywdsstart_indend_ind", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/tbinpds.html#PROCESS_TBIN_BIT_COLUMNS", "PROCESS_TBIN_BIT_COLUMNS", 'routine in <a href="config/pds/Readpds_4.4/tbinpds.html">tbinpds.pro</a>', "tbinpds.pro", "", "PROCESS_TBIN_BIT_COLUMNS", "", "datalabelreq_keywdsbit_columns", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/tbinpds.html#OBTAIN_TBIN_BIT_COLUMNS", "OBTAIN_TBIN_BIT_COLUMNS", 'routine in <a href="config/pds/Readpds_4.4/tbinpds.html">tbinpds.pro</a>', "tbinpds.pro", "", "OBTAIN_TBIN_BIT_COLUMNS", "", "labelreq_keywdsstart_indend_ind", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/tbinpds.html#CREATE_TBIN_STRUCT", "CREATE_TBIN_STRUCT", 'routine in <a href="config/pds/Readpds_4.4/tbinpds.html">tbinpds.pro</a>', "tbinpds.pro", "", "CREATE_TBIN_STRUCT", "", "keywdsoptitemscontainerslabelstart_indend_ind", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/tbinpds.html#READ_TBIN_DATA", "READ_TBIN_DATA", 'routine in <a href="config/pds/Readpds_4.4/tbinpds.html">tbinpds.pro</a>', "tbinpds.pro", "", "READ_TBIN_DATA", "", "pointerdata_structkeywdssilent", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/tbinpds.html#FORMAT_COLUMN", "FORMAT_COLUMN", 'routine in <a href="config/pds/Readpds_4.4/tbinpds.html">tbinpds.pro</a>', "tbinpds.pro", "", "FORMAT_COLUMN", "", "elementkeywdsitemsrepetitionsrowstypeindex1index2", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/tbinpds.html#ORGANIZE_TBIN_DATA", "ORGANIZE_TBIN_DATA", 'routine in <a href="config/pds/Readpds_4.4/tbinpds.html">tbinpds.pro</a>', "tbinpds.pro", "", "ORGANIZE_TBIN_DATA", "", "keywdsitemsdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/tbinpds.html#TBINPDS", "TBINPDS", 'routine in <a href="config/pds/Readpds_4.4/tbinpds.html">tbinpds.pro</a>', "tbinpds.pro", "", "TBINPDS", "", "SILENTfnamelabelobjindex", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/test_endian.html", "test_endian.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "test_endian.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/test_endian.html#test_endian", "test_endian", 'routine in <a href="util/test_endian.html">test_endian.pro</a>', "test_endian.pro", "", "test_endian", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/textedit.html", "textedit.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "textedit.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/textedit.html#textedit_event", "textedit_event", 'routine in <a href="util/textedit.html">textedit.pro</a>', "textedit.pro", "", "textedit_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/textedit.html#textedit", "textedit", 'routine in <a href="util/textedit.html">textedit.pro</a>', "textedit.pro", "", "textedit", "", "xsizeysizebaseeditableresource_prefixtext", "          -1", "");
  
  

libdata[libdataItem++] = new Array("demo/tiepoints_example.html", "tiepoints_example.pro", '.pro file in <a href="demo/dir-overview.html">demo/ directory</a>', "tiepoints_example.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/timepds.html", "timepds.pro", '.pro file in <a href="config/pds/Readpds_4.4/dir-overview.html">config/pds/Readpds_4.4/ directory</a>', "timepds.pro", "", "", " NAME: 	TIMEPDS   PURPOSE: 	To extract time from a PDS label or ASCII table, express it as 	either Julian Date, decimal day of year, or decimal day from some 	specific user-specified date.  Then to store the date in an IDL 	variable.   CALLING SEQUENCE: 	Result = TIMEPDS(label, month, day, [/doy, /jd])   INPUTS:        LABEL = IDL string array containing the PDS label associated with        the file.  First use HEADPDS.PRO to retrieve the label.         MONTH = Month from which to start counting.  If either /doy or /jd        are set, month should not be specified.         DAY = Day from which to start counting.  If either /doy or /jd are        set, day should not be specified.   OUTPUTS:        If the PDS file is a PDS IMAGE:           If no optional keywords are present or if /doy is present: 	      Result = Single precision floating point scalar           If /jd is present:              Result = Double precision floating point scalar for /jd        If the file is a PDS ASCII table:           If no optional keywords are present or if /doy is set:              Result = Single precision floating point array           If /jd is present:              Result = Double precision floating point array for /jd   OPTIONAL INPUT KEYWORDS: 	DOY - If present and non zero, then the output will be the decimal              day of year of the observation.  	JD - If present and non zero, then the output will be the Julian date             of the observation.   EXAMPLE: 	Read a PDS label associated with an image to get the day of year of        the observation:                 IDL> LABEL = HEADPDS('TEST.LBL') 		IDL> doy = TIMEPDS(LABEL, /DOY)         Obtain an array of decimal dates counting from January 22 using values 	from a PDS ASCII index table:                 IDL> LABEL = HEADPDS('INDEX.LBL')                IDL> cu_arr = TIMEPDS(LABEL, 1, 22)   WARNINGS:        The default setting, with no keywords set, is to give the date(s) as        decimal day counting from the user-specified 'month' and 'day' values,        whereas if /doy is set, counting begins on 0 January.         When present and non-zero, the optional keyword /doy or /jd        should take the place of the keywords, 'month' and 'day'.         TIMEPDS requires at least a date to be present in the PDS label or        table.  An error will occur if there is a time but no date.   PROCEDURES USED: 	Functions:  PDSPAR, TASCPDS   MODIFICATION HISTORY: 	July 27 1999, M. Barker   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/timepds.html#JDATE", "JDATE", 'routine in <a href="config/pds/Readpds_4.4/timepds.html">timepds.pro</a>', "timepds.pro", "", "JDATE", "", "yyyy_startmm_startdd_starttime", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/timepds.html#LPYEAR", "LPYEAR", 'routine in <a href="config/pds/Readpds_4.4/timepds.html">timepds.pro</a>', "timepds.pro", "", "LPYEAR", "", "year", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/timepds.html#DAY_OF_YEAR", "DAY_OF_YEAR", 'routine in <a href="config/pds/Readpds_4.4/timepds.html">timepds.pro</a>', "timepds.pro", "", "DAY_OF_YEAR", "", "yyyy_startmm_startdd_starttime", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/timepds.html#CUSTOM", "CUSTOM", 'routine in <a href="config/pds/Readpds_4.4/timepds.html">timepds.pro</a>', "timepds.pro", "", "CUSTOM", "", "final_doyyyyy_startmm_startdd_startusr_monthusr_day", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/timepds.html#CAL_DATE", "CAL_DATE", 'routine in <a href="config/pds/Readpds_4.4/timepds.html">timepds.pro</a>', "timepds.pro", "", "CAL_DATE", "", "yyyy_startdoy", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/timepds.html#DATE_SEP", "DATE_SEP", 'routine in <a href="config/pds/Readpds_4.4/timepds.html">timepds.pro</a>', "timepds.pro", "", "DATE_SEP", "", "date", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/timepds.html#TIME_SEP", "TIME_SEP", 'routine in <a href="config/pds/Readpds_4.4/timepds.html">timepds.pro</a>', "timepds.pro", "", "TIME_SEP", "", "tm", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/pds/Readpds_4.4/timepds.html#TIMEPDS", "TIMEPDS", 'routine in <a href="config/pds/Readpds_4.4/timepds.html">timepds.pro</a>', "timepds.pro", "", "TIMEPDS", "", "DOYJDlabelusr_monthusr_day", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/timeplot.html", "timeplot.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "timeplot.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/timeplot.html#timeplot", "timeplot", 'routine in <a href="util/timeplot.html">timeplot.pro</a>', "timeplot.pro", "", "timeplot", "", "xrangeyrangepsymsymsizetitlextitleytitlecolorsdelaytautime_ratetime_offsetxy_tdt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/timer.html", "timer.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "timer.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/timer.html#timer", "timer", 'routine in <a href="util/timer.html">timer.pro</a>', "timer.pro", "", "timer", "", "t0s", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/timer/timer_spice_input.html", "timer_spice_input.pro", '.pro file in <a href="config/timer/dir-overview.html">config/timer/ directory</a>', "timer_spice_input.pro", "", "", " NAME: 	timer_spice_input    PURPOSE: 	NAIF/SPICE input translator for TIMER.    CATEGORY: 	NV/CONFIG    CALLING SEQUENCE: 	result = timer_spice_input(dd, keyword)    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	keyword:	String giving the name of the translator quantity.     OUTPUT: 	NONE    KEYWORDS:   INPUT: 	key1:		Camera descriptor.    OUTPUT: 	status:		Zero if valid data is returned.     TRANSLATOR KEYWORDS: 	ref:		Name of the reference frame for the output quantities. 			Default is 'j2000'.  	j2000:		/j2000 is equivalent to specifying ref=j2000.  	b1950:		/b1950 is equivalent to specifying ref=b1950.  	klist:		Name of a file giving a list of SPICE kernels to use. 			If no path is included, the path is taken from the 			NV_SPICE_KER environment variable.  	ck_in:		List of input C kernel files to use.  List must be 			delineated by semimcolons with no space.  The kernel 			list file is still used, but these kernels take 			precedence.  Entries in this list may be file 			specification strings.  	planets:	List of planets to for which to request ephemeris. 			Must be delineated by semicolons with no space.  	reload:		If set, new kernels are loaded, as specified by the 			klist and ck_in keywords.    RETURN: 	Data associated with the requested keyword.    STATUS: 	Complete    SEE ALSO: 	timer_spice_output    MODIFICATION HISTORY:  	Written by:	Spitale, 5/2014   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/timer/timer_spice_input.html#timer_spice_cameras", "timer_spice_cameras", 'routine in <a href="config/timer/timer_spice_input.html">timer_spice_input.pro</a>', "timer_spice_input.pro", "", "timer_spice_cameras", "", "posconstantsn_objdimstatustimeorientobsddref", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/timer/timer_spice_input.html#timer_spice_planets", "timer_spice_planets", 'routine in <a href="config/timer/timer_spice_input.html">timer_spice_input.pro</a>', "timer_spice_input.pro", "", "timer_spice_planets", "", "timeplanetsn_objdimstatustarg_listconstantsobsddref", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/timer/timer_spice_input.html#timer_spice_sun", "timer_spice_sun", 'routine in <a href="config/timer/timer_spice_input.html">timer_spice_input.pro</a>', "timer_spice_input.pro", "", "timer_spice_sun", "", "n_objdimconstantsstatustimeobsddref", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/timer/timer_spice_input.html#timer_spice_input", "timer_spice_input", 'routine in <a href="config/timer/timer_spice_input.html">timer_spice_input.pro</a>', "timer_spice_input.pro", "", "timer_spice_input", "", "valuesstatusddkeyword@nv_trs_keywords_include.pro", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/timer/timer_spice_sc.html", "timer_spice_sc.pro", '.pro file in <a href="config/timer/dir-overview.html">config/timer/ directory</a>', "timer_spice_sc.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/timer/timer_spice_sc.html#cas_spice_sc", "cas_spice_sc", 'routine in <a href="config/timer/timer_spice_sc.html">timer_spice_sc.pro</a>', "timer_spice_sc.pro", "", "cas_spice_sc", "", "dd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/timer/timer_to_ominas.html", "timer_to_ominas.pro", '.pro file in <a href="config/timer/dir-overview.html">config/timer/ directory</a>', "timer_to_ominas.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/timer/timer_to_ominas.html#timer_to_ominas", "timer_to_ominas", 'routine in <a href="config/timer/timer_to_ominas.html">timer_to_ominas.pro</a>', "timer_to_ominas.pro", "", "timer_to_ominas", "", "od", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/timeseed.html", "timeseed.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "timeseed.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/timeseed.html#timeseed", "timeseed", 'routine in <a href="util/timeseed.html">timeseed.pro</a>', "timeseed.pro", "", "timeseed", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/abbrev/tr.html", "tr.pro", '.pro file in <a href="util/abbrev/dir-overview.html">util/abbrev/ directory</a>', "tr.pro", "", "", " NAME: 	tr   PURPOSE: 	Abbreviation for the transpose() function   CATEGORY:        UTIL/ABBREV  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/abbrev/tr.html#tr", "tr", 'routine in <a href="util/abbrev/tr.html">tr.pro</a>', "tr.pro", "", "tr", "", "x", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/dat/tr_keyword_value.html", "tr_keyword_value.pro", '.pro file in <a href="nv/obj/dat/dir-overview.html">nv/obj/dat/ directory</a>', "tr_keyword_value.pro", "", "", " NAME: 	tr_keyword_value    PURPOSE: 	Looks up a keyword in the data descriptor-stored keyword/value pairs.    CATEGORY: 	NV/SYS    CALLING SEQUENCE: 	value = tr_keyword_value(dd, keyword)    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  If an array, only the first element is 			considered.  	keyword:	Keyword to look up.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Value string associated with the given keyword.  Note that transient 	keyword/value pairs take precedence.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/dat/tr_keyword_value.html#trkv_match", "trkv_match", 'routine in <a href="nv/obj/dat/tr_keyword_value.html">tr_keyword_value.pro</a>', "tr_keyword_value.pro", "", "trkv_match", "", "valuekvikeyword", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/dat/tr_keyword_value.html#trkv_parse", "trkv_parse", 'routine in <a href="nv/obj/dat/tr_keyword_value.html">tr_keyword_value.pro</a>', "tr_keyword_value.pro", "", "trkv_parse", "", "value", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/dat/tr_keyword_value.html#tr_keyword_value", "tr_keyword_value", 'routine in <a href="nv/obj/dat/tr_keyword_value.html">tr_keyword_value.pro</a>', "tr_keyword_value.pro", "", "tr_keyword_value", "", "ddkeyword", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/traceback.html", "traceback.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "traceback.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/traceback.html#traceback", "traceback", 'routine in <a href="util/traceback.html">traceback.pro</a>', "traceback.pro", "", "traceback", "", "n", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/trans_solve.html", "trans_solve.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "trans_solve.pro", "", "", " NAME: 	trans_solve    PURPOSE: 	Solves the transcendental equation x = f(x) using iteration.    CATEGORY: 	UTIL    CALLING SEQUENCE: 	result = xx(xx, xx) 	xx, xx, xx    ARGUMENTS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    KEYWORDS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    ENVIRONMENT VARIABLES: 	xx:	xx  	xx:	xx    RETURN: 	xx    COMMON BLOCKS: 	xx:	xx  	xx:	xx    SIDE EFFECTS: 	xx    RESTRICTIONS: 	xx    PROCEDURE: 	xx    EXAMPLE: 	xx    STATUS: 	xx    SEE ALSO: 	xx, xx, xx    MODIFICATION HISTORY:  	Written by:	Spitale, 5/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/trans_solve.html#trans_solve", "trans_solve", 'routine in <a href="util/trans_solve.html">trans_solve.pro</a>', "trans_solve.pro", "", "trans_solve", "", "epsilonfnx0data", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/transpose_struct.html", "transpose_struct.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "transpose_struct.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/transpose_struct.html#transpose_struct", "transpose_struct", 'routine in <a href="util/transpose_struct.html">transpose_struct.pro</a>', "transpose_struct.pro", "", "transpose_struct", "", "sorder", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/gen/trianggen.html", "trianggen.pro", '.pro file in <a href="util/gen/dir-overview.html">util/gen/ directory</a>', "trianggen.pro", "", "", " NAME: 	trianggen    PURPOSE: 	Constructs 1d subscripts of triangular elements of an nxn matrix.    CATEGORY: 	UTIL/GEN    CALLING SEQUENCE: 	sub = trianggen(n)    ARGUMENTS:   INPUT: 	n:	 Degree of matrix, i.e., number of rows / columns.    OUTPUT: NONE    KEYWORDS:   INPUT: 	lower:	Generates indices for the lower triangle.  	upper:	Generates indices for the upper triangle.     OUTPUT: NONE    RETURN: 	Array (n x n) of subscripts.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/gen/trianggen.html#trianggen", "trianggen", 'routine in <a href="util/gen/trianggen.html">trianggen.pro</a>', "trianggen.pro", "", "trianggen", "", "loweruppern", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/trim_external_points.html", "trim_external_points.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "trim_external_points.pro", "", "", " NAME:        trim_external_points    PURPOSE:        Trim external points from an array of image points.    CATEGORY:        UTIL    CALLING SEQUENCE:        result = trim_external_points(points, x0, x1, y0, y1)    ARGUMENTS:   INPUT:        points:         An array of image points.             x0:         Lower x bound.             x1:         Upper x bound.             y0:         Lower y bound.             y1:         Upper y bound.    OUTPUT:           sub:         Subscripts of the points that are not external   RETURN:        An array of points that fall inside the rectangle whose corners        are (x0,y0) and (x1,y1).  The external points are trimmed.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/trim_external_points.html#trim_external_points", "trim_external_points", 'routine in <a href="util/trim_external_points.html">trim_external_points.pro</a>', "trim_external_points.pro", "", "trim_external_points", "", "subpointsx0x1y0y1", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/trim_region.html", "trim_region.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "trim_region.pro", "", "", " NAME:        trim_region    PURPOSE:        Trim points outside a defined region.    CATEGORY:        UTIL    CALLING SEQUENCE:        result = trim_region(points, region, xsize, ysize)    ARGUMENTS:   INPUT:        points:         An array of image points.         region:         Subscripts representing the region.          xsize:         Size of image in x          ysize:         Size of image in y     OUTPUT:        NONE   RETURN:        Subscripts of points which are contained in the given region.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/trim_region.html#trim_region", "trim_region", 'routine in <a href="util/trim_region.html">trim_region.pro</a>', "trim_region.pro", "", "trim_region", "", "pointsregionxsizeysize", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/trprint.html", "trprint.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "trprint.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/trprint.html#trprint", "trprint", 'routine in <a href="util/trprint.html">trprint.pro</a>', "trprint.pro", "", "trprint", "", "arg", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/tvcursor.html", "tvcursor.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "tvcursor.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/tvcursor.html#tvcursor", "tvcursor", 'routine in <a href="util/tvcursor.html">tvcursor.pro</a>', "tvcursor.pro", "", "tvcursor", "", "restoresetcursor", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/tvdrag.html", "tvdrag.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "tvdrag.pro", "", "", " NAME: 	tvdrag    PURPOSE: 	Allows user to drag a given image across a background image.    CATEGORY: 	UTIL    CALLING SEQUENCE: 	p = tvdrag(bg_image, drag_image, p0)    ARGUMENTS:   INPUT: 	bg_image:	Background image.  	drag_image:	Image to be dragged across bg_image.  	p0:		Initial point in bg_image for origin of drag_image.    OUTPUT: NONE    KEYWORDS:   INPUT: 	win_num:	Window number of IDL graphics window in which to select 			box.  Default is current window.  	restore:	If set, the original image is restored at the end.  	grid_function:	Function which will quantize a point onto 			a grid.  It should take an orderered 			pair as its only argument and return an 			ordered pair.  Default is the identity function.  	cursor_init:	2-element vector giving Initial position for cursor. 			If not set, the routine will wait for a button 			to be pressed before continuing.  	no_scale:	If set, tvdrag will not scale the levels of the 			drag image to the bg image.    OUTPUT: NONE    RETURN: 	2 element vector giving the point where the mouse button was released.    STATUS: 	Complete    SEE ALSO: 	tvline, tvpath, tvrec, tvcursor    MODIFICATION HISTORY:  	Written by:	Spitale, 7/1995 	Modified:	Spitale, 8/2008 	 Added window number inputs, xor_graphics option   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/tvdrag.html#tvdrag_identity", "tvdrag_identity", 'routine in <a href="util/tvdrag.html">tvdrag.pro</a>', "tvdrag.pro", "", "tvdrag_identity", "", "p", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/tvdrag.html#tvdrag", "tvdrag", 'routine in <a href="util/tvdrag.html">tvdrag.pro</a>', "tvdrag.pro", "", "tvdrag", "", "win_numrestoregrid_functioncursor_initno_scalexor_graphicsaddbg_imagedrag_imagep0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/tvgr/tvgr.html", "tvgr.pro", '.pro file in <a href="util/tvgr/dir-overview.html">util/tvgr/ directory</a>', "tvgr.pro", "", "", " NAME:        tvgr    PURPOSE:        Displays a graph in an IDL window, sets display properties        (xrange, yrange, and position) and maintains a data coordinate 	system for the window.    CATEGORY:        UTIL/TVGR    CALLING SEQUENCE: 	tvgr, arg1 <, arg2, arg3>    ARGUMENTS:   INPUT:            arg1:     May be window number, x-array, or y-array.             arg2:     If arg1 is the x-array then arg2 is the y-array.  If 	              arg1 is a window number, then arg2 may be the x-array                      or y-array.  	    arg3:     If arg3 exists, it is taken as the y-array.    OUTPUT:        NONE   KEYWORDS:   INPUT:          silent:     If set, supresses output of messages.              new:     If set, creates a new window.          inherit:     If set, window will inherit the settings of the                      current tvgr window.            xsize:     Set the x size of the window to this amount.            ysize:     Set the y size of the window to this amount.              all:     If set, print all display properties (not implemented)          default:     If set, use default properties.           entire:     If set, ranges are set such that the entire                      plot is visible in the current window.         previous:     If set, restore last-used properties.          restore:     If set, use saved properties.               dx:     Change the xrange by this amount.               dy:     Change the yrange by this amount.             save:     Save the current properties.             flip:     If set, reverse display order.            erase:     If set, erase the display window before displaying image.           noplot:     If set, do all the calculations but do not display the                      image.           pixmap:     If set and if this is a new window, the window will                      be a pixmap.             list:     If set, the  wnum  keyword will return a list                      valid tvgr window numbers.          no_wset:     If set, the window number is not changed.         no_coord:     If set, the coordinate system is not changed.           nodraw:     If set, no plot is drawn.           xrange:     See PLOT.           yrange:     See PLOT.           xtitle:     See PLOT.           ytitle:     See PLOT.            title:     See PLOT.            thick:     See PLOT.            color:     See PLOT.             psym:     See PLOT.          symsize:     See PLOT.          ticklen:     See PLOT.         position:     See PLOT.             nsum:     See OPLOT.     OUTPUT:        wnum:		Window number of current tvgr instance.  	get_info:	Returns the tvgr data structure for the current 			window, see tvgr_data__define below.    COMMON BLOCKS:       tvgr_block:     tvd, tvgr_top    SEE ALSO:        tvim   MODIFICATION HISTORY:        Written by:     Spitale		5/2003   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/tvgr/tvgr.html#tvgr_data__define", "tvgr_data__define", 'routine in <a href="util/tvgr/tvgr.html">tvgr.pro</a>', "tvgr.pro", "", "tvgr_data__define", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/tvgr/tvgr.html#tvgr_get_index", "tvgr_get_index", 'routine in <a href="util/tvgr/tvgr.html">tvgr.pro</a>', "tvgr.pro", "", "tvgr_get_index", "", "createwnum", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/tvgr/tvgr.html#tvgr_set", "tvgr_set", 'routine in <a href="util/tvgr/tvgr.html">tvgr.pro</a>', "tvgr.pro", "", "tvgr_set", "", "currentticklenxrangeyrangepositionxtitleytitletitlenodraw", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/tvgr/tvgr.html#tvgr_set_num", "tvgr_set_num", 'routine in <a href="util/tvgr/tvgr.html">tvgr.pro</a>', "tvgr.pro", "", "tvgr_set_num", "", "no_wsetno_coordnodrawwnum", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/tvgr/tvgr.html#tvgr", "tvgr", 'routine in <a href="util/tvgr/tvgr.html">tvgr.pro</a>', "tvgr.pro", "", "tvgr", "", "silentnewinheritxsizeysizealldefaultpreviousrestoreentiresaveflipxrangeyrangepositionget_infoerasenoplotno_wsetno_coordwnumpixmapdxdyxtitleytitletitlethicknsumcolorpsymnodrawticklensymsizearg1arg2arg3list", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/tvim/tvim.html", "tvim.pro", '.pro file in <a href="util/tvim/dir-overview.html">util/tvim/ directory</a>', "tvim.pro", "", "", " NAME:        tvim    PURPOSE:        Displays an image in an IDL window, sets display properties        (zoom, offset and order) and maintains a data coordinate system for        the window.    CATEGORY:        UTIL/TVIM    CALLING SEQUENCE:        tvim, arg1 <, arg2>    ARGUMENTS:   INPUT:            arg1:     Can be window number if argument has 1 dimension, or                      an image if argument has 2 dimensions.  If it's an image,                      then that image is displayed.  If it's a window number,                      then that window becomes the current window.             arg2:     Same as above, either window number or image.                      If no args are given, tvim prints the current window                      number.    OUTPUT:        NONE   KEYWORDS:   INPUT:          silent:     If set, supresses output of messages.              new:     If set, creates a new window.          inherit:     If set, window will inherit the settings of the                      current tvim window.            xsize:     Set the x size of the window to this amount.            ysize:     Set the y size of the window to this amount.              all:     If set, print all display properties (not implemented)          default:     If set, use default properties (zoom=[1,1], offset=[0,0]                      order=0 [bottom-up])           entire:     If set, zoom and offset are set such that the entire                      image is visible in the current window.         previous:     If set, restore last-used properties.          restore:     If set, use saved properties.             home:     If set, set the offset to [0,0].          channel:     Display plane (1, 2, or 3) to display image in.          doffset:     Change the offset property by this amount.             save:     Save the current properties.             zoom:     2-element array giving the zoom in each direction.            order:     If set, y coordinate display order is top-down.            rotate:    If set, coordinates are transformed as in the idl                      'rotate' command.             flip:     If set, reverse display order.           offset:     Set the corner of image for display to this value.    local_scaling:     If set, pixel values are scaled based only on the 		      pixel visible with the current tvim settings.  	no_scale:     If set, pixel values are not altered.              top:     Set the top stretch value to this value.  If not given, 		      tvim, attempts to use the system variable !ct_top, which 		      is set by ctmod.            erase:     If set, erase the display window before displaying image.           noplot:     If set, do all the calculations but do not display the                      image.           pixmap:     If set and if this is a new window, the window will                      be a pixmap.      draw_pixmap:     If set, the image will be written to this pixmap                      and then copied to the main window.  If /no_copy,                      then the image will not be copied to the main window.          no_copy:     See the   draw_pixmap  keyword.           retain:      Retain  value to be passed to the IDL routine                      widget_draw.            title:     Title text for the window frame.             bufz:     If set, the z-buffer is used.      force_xsize:     If set, the window is forced to this x-size.      force_ysize:     If set, the window is forced to this y-size.            nowin:     If set, then no window is opened.             list:     If set, the  wnum  keyword will return a list                      valid tvim window numbers.          no_wset:     If set, the window number is not changed.         no_coord:     If set, the coordinate system is not changed.      OUTPUT:        wnum:		Window number of current tvim instance.  	get_info:	Returns the tvim data structure for the current 			window, see tvim_data__define below.          tvimage:     The scaled image is returned by this keyword.              min:      Minimum data value in each image plane.              max:      Maximum data value in each image plane.    COMMON BLOCKS:       tvim_block:     tvd, tvim_top    SEE ALSO:        tvzoom, tvmove   MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/tvim/tvim.html#tvim_zoom_valid", "tvim_zoom_valid", 'routine in <a href="util/tvim/tvim.html">tvim.pro</a>', "tvim.pro", "", "tvim_zoom_valid", "", "zoom", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/tvim/tvim.html#tvim_data__define", "tvim_data__define", 'routine in <a href="util/tvim/tvim.html">tvim.pro</a>', "tvim.pro", "", "tvim_data__define", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/tvim/tvim.html#tvim_get_index", "tvim_get_index", 'routine in <a href="util/tvim/tvim.html">tvim.pro</a>', "tvim.pro", "", "tvim_get_index", "", "createwnum", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/tvim/tvim.html#tvim_set", "tvim_set", 'routine in <a href="util/tvim/tvim.html">tvim.pro</a>', "tvim.pro", "", "tvim_set", "", "currentzoomorderrotateoffsetforce_xsizeforce_ysizexminxmaxyminymaxno_coord", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/tvim/tvim.html#tvim_set_num", "tvim_set_num", 'routine in <a href="util/tvim/tvim.html">tvim.pro</a>', "tvim.pro", "", "tvim_set_num", "", "no_wsetno_coordwnum", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/tvim/tvim.html#tvim", "tvim", 'routine in <a href="util/tvim/tvim.html">tvim.pro</a>', "tvim.pro", "", "tvim", "", "draw_pixmaptvimageretaintitlesilentnewinheritxsizeysizealldefaultpreviousrestorechannelentiredoffsethomesaveminmaxno_copyzoombufzorderrotateflipforce_xsizeforce_ysizeoffsetbaselocal_scalingno_scaleget_infonowintoperasenoplotwnumlistpixmapno_wsetno_coordarg1arg2", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/tvim/tvim_compare.html", "tvim_compare.pro", '.pro file in <a href="util/tvim/dir-overview.html">util/tvim/ directory</a>', "tvim_compare.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/tvim/tvim_compare.html#tvim_compare", "tvim_compare", 'routine in <a href="util/tvim/tvim_compare.html">tvim_compare.pro</a>', "tvim_compare.pro", "", "tvim_compare", "", "tvd1tvd2", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/tvline.html", "tvline.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "tvline.pro", "", "", " NAME: 	tvline    PURPOSE: 	Returns device coordinates of the beginning and end points of a user 	selected line.    CATEGORY: 	UTIL    CALLING SEQUENCE: 	line = tvline()    ARGUMENTS:   INPUT: 	win_num:	Window number of IDL graphics window in which to select 			the line.  Default is current window.    OUTPUT: NONE    KEYWORDS:   INPUT: 	thick:		Thickness of line.  	restore:	If set, the line is removed from the image at the end.  	p0:		First point of line.  If set, then the routine 			immediately begins to drag from that point until a 			button is released.  	grid_function:	Function that will quantize a point onto  			a grid.  It should take an orderered 			pair as its only argument and return an 			ordered pair.  Default is the identity function.  	linestyle:	Linestyle to use for line, default is 0.  	cancel_button:	Index of mouse button to be used as a cancel 			button.  Default is no cancel button.  	action_button:	Index of button to use as the action button 			instead of the left button, 1.    OUTPUT: 	cancelled:	1 if the cancel button was pressed, 0 otherwise.    RETURN: 	2D array containing the two selected endpoints of the line as 	[p,q] where p and q are 2D arrays in device coordinates.    PROCEDURE: 	The line is selected by clicking the 'action button' at the location 	of the first point and dragging to endpoint and releasing.    STATUS: 	Complete    SEE ALSO: 	tvdrag, tvpath, tvrec, tvcursor    MODIFICATION HISTORY:  	Written by:	Spitale, 7/1995   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/tvline.html#tvline_identity", "tvline_identity", 'routine in <a href="util/tvline.html">tvline.pro</a>', "tvline.pro", "", "tvline_identity", "", "p", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/tvline.html#tvline", "tvline", 'routine in <a href="util/tvline.html">tvline.pro</a>', "tvline.pro", "", "tvline", "", "thickcolorfn_drawfn_erasefn_datarestorenodrawp0grid_functionlinestylecancel_buttoncancelledaction_buttonxor_graphicspixmapwin_num", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/tvim/tvmove.html", "tvmove.pro", '.pro file in <a href="util/tvim/dir-overview.html">util/tvim/ directory</a>', "tvmove.pro", "", "", " NAME:        tvmove    PURPOSE:        Move a displayed image by an offset determined by the cursor    CATEGORY:        UTIL/TVIM    CALLING SEQUENCE:        tvmove, image, wnum, new=new, erase=erase    ARGUMENTS:   INPUT:          image:        Image to display            wnum:        window number of display    OUTPUT:        NONE   KEYWORDS:   INPUT: 	new:	If set, creates a new window  	erase:	If set, erases display first  	noplot:	If set, the image is not redisplayed.   	p0:	First point.  If set, then the routine 		immediately begins to drag from that point until a 		button is released.  	cursor:	Device code of cursor to use.  Default is a custom cursor.  	hourglass_id:	If set, this is used as the widget id of a draw 			window in which to set the hourglass cursor after 			the line has been selected until the procedure 			is complete.   OUTPUT:        NONE    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/tvim/tvmove.html#tvmove", "tvmove", 'routine in <a href="util/tvim/tvmove.html">tvmove.pro</a>', "tvmove.pro", "", "tvmove", "", "newerasep0cursorhourglass_idnoplotoutput_wnumcolorimagewnum", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/tvim/tvpan.html", "tvpan.pro", '.pro file in <a href="util/tvim/dir-overview.html">util/tvim/ directory</a>', "tvpan.pro", "", "", " NAME:        tvpan    PURPOSE:        Move a displayed image by an offset determined by the cursor; show 	the image during the drag.    CATEGORY:        UTIL/TVIM    CALLING SEQUENCE:        tvpan, image, wnum, new=new, erase=erase    ARGUMENTS:   INPUT:          image:        Image to display            wnum:        window number of display    OUTPUT:        NONE   KEYWORDS:   INPUT: 	new:	If set, creates a new window  	erase:	If set, erases display first  	noplot:	If set, the image is not redisplayed.   	p0:	First point.  If set, then the routine 		immediately begins to drag from that point until a 		button is released.  	cursor:	Device code of cursor to use.  Default is a custom cursor.  	hourglass_id:	If set, this is used as the widget id of a draw 			window in which to set the hourglass cursor after 			the line has been selected until the procedure 			is complete.   OUTPUT:        NONE    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale; 9/7/05   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/tvim/tvpan.html#tvpan_draw", "tvpan_draw", 'routine in <a href="util/tvim/tvpan.html">tvpan.pro</a>', "tvpan.pro", "", "tvpan_draw", "", "dataxarryarrpixmapwin_num", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/tvim/tvpan.html#tvpan_erase", "tvpan_erase", 'routine in <a href="util/tvim/tvpan.html">tvpan.pro</a>', "tvpan.pro", "", "tvpan_erase", "", "dataoldxarroldyarrpixmapwin_num", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/tvim/tvpan.html#tvpan", "tvpan", 'routine in <a href="util/tvim/tvpan.html">tvpan.pro</a>', "tvpan.pro", "", "tvpan", "", "wnumnewerasep0cursorhourglass_idnoplotoutput_wnumcoloredgenotvimdoffsetpixmapxor_graphicsimage", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/tvpath.html", "tvpath.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "tvpath.pro", "", "", " NAME: 	tvpath    PURPOSE: 	Returns device coordinates of vertices on a curve selected by the user.    CATEGORY: 	UTIL    CALLING SEQUENCE: 	vertices = tvpath()    ARGUMENTS:   INPUT: 	win_num:	Window number of IDL graphics window in which to select 			the path.  Default is current window.    OUTPUT: NONE    KEYWORDS:   INPUT: 	thick:		Thickness of the curve.  	restore:	If set, the line is removed from the image at the end.  	p0:		First point of line.  If set, then the routine 			immediately begins to drag from that point until a 			button is released.  	grid_function:	Function which will quantize a point onto  			a grid.  It should take an orderered 			pair as its only argument and return an 			ordered pair.  Default is the identity function.  	linestyle:	Linestyle to use for curve, default is 0.  	select_button:	Index of button to use as the select button instead 			of the left button (1).  	erase_button:	Index of button to use as the erase button instead 			of the middle button (2).  	end_button:	Index of button to use as the end button instead 			of the right button (4).  	cancel_button:	Index of mouse button to be used as a cancel 			button instead of left+middle, (3).  	close:		If set, the curve will be closed when the end button 			is pressed.  	points:		If set, do not connect points.  	psym:		Plotting symbol to use for each point.  	copy		If set, copy mode is used instead of xor mode 			for drawing.  An offscreen pixmap is used for erasing.  	one:		If set, tvpath returns after any button is pressed. 			If it is not the select button, then cancelled is set.  	number:		If set, points are numbered as they are selected.     OUTPUT: 	cancelled:	1 if the cancel button was pressed, 0 otherwise. 			If /one, then 1 if any button other than select was 			pressed.    RETURN: 	2xn array containing the selected vertices in device coordinates.    PROCEDURE: 	Points on the curve are selected by clicking the 'select button', 	which is the left button by default.  Points are removed with 	the 'erase button', the middle button by default.  The 'end button', 	by default the right button, completes the curve.    STATUS: 	Complete    SEE ALSO: 	tvdrag, tvline, tvrec, tvcursor    MODIFICATION HISTORY:  	Written by:	Spitale, 7/1995   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/tvpath.html#tvpath_identity", "tvpath_identity", 'routine in <a href="util/tvpath.html">tvpath.pro</a>', "tvpath.pro", "", "tvpath_identity", "", "p", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/tvpath.html#tvpath", "tvpath", 'routine in <a href="util/tvpath.html">tvpath.pro</a>', "tvpath.pro", "", "tvpath", "", "thickrestorecloseautoclosep0grid_functionlinestylecancel_buttoncancelledselect_buttonerase_buttonend_buttonpsymcolorcopyonenumberpointsnpwin_num", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/tvplot.html", "tvplot.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "tvplot.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/tvplot.html#tvplot", "tvplot", 'routine in <a href="util/tvplot.html">tvplot.pro</a>', "tvplot.pro", "", "tvplot", "", "xrangeyrangecolor_ref_extraimage", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/tvrec.html", "tvrec.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "tvrec.pro", "", "", " NAME: 	tvrec    PURPOSE: 	Returns device coordinates of the upper left and lower right corner 	of a user-selected box.    CATEGORY: 	UTIL    CALLING SEQUENCE: 	box = tvrec()    ARGUMENTS:   INPUT: 	win_num:	Window number of IDL graphics window in which to select 			box, default is current window.    OUTPUT: NONE    KEYWORDS:   INPUT: 	thick:		Thickness of box outline.  	restore:	If set, the box is not left in the image.  	p0:		First corner of box.  If set, then the routine 			immediately begins to drag from that point until a 			button is released.  	grid_function:	Function which will quantize a point onto 			a grid.  It should take an orderered 			pair as its only argument and return an 			ordered pair.  Default is the identity function.  	linestyle:	Linestyle to use for rectangle, default is 0.  	color:		Color to use for rectangle, default is !color.  	aspect:		Aspect ratio (y/x) to maintain when drawing the 			dragged zoom box.  	all_corners:	If set, coordinates of all four corners are returned.  	vline:		If set, only one line of the box is drawn: the vertical 			line touching the start point.  	hline:		If set, only one line of the box is drawn: the horizotal 			line touching the start point.     OUTPUT: NONE    RETURN: 	2x2 array containing the two selected corners of the box as: 	[p,q] where p and q are 2D arrays in device coordinates.    PROCEDURE: 	The box is selected by clicking at the location of the first corner 	and dragging to opposite corner and releasing.    STATUS: 	Complete    SEE ALSO: 	tvdrag, tvline, tvpath, tvcursor    MODIFICATION HISTORY:  	Written by:	Spitale, 8/1994   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/tvrec.html#tvrec_identity", "tvrec_identity", 'routine in <a href="util/tvrec.html">tvrec.pro</a>', "tvrec.pro", "", "tvrec_identity", "", "p", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/tvrec.html#tvrec_constrain", "tvrec_constrain", 'routine in <a href="util/tvrec.html">tvrec.pro</a>', "tvrec.pro", "", "tvrec_constrain", "", "pxpyqxqyaspect", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/tvrec.html#tvrec", "tvrec", 'routine in <a href="util/tvrec.html">tvrec.pro</a>', "tvrec.pro", "", "tvrec", "", "thickrestorep0grid_functionlinestylecolorcursoraspectxor_graphicsall_cornersvlinehlinewin_num", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/tvim/tvunzoom.html", "tvunzoom.pro", '.pro file in <a href="util/tvim/dir-overview.html">util/tvim/ directory</a>', "tvunzoom.pro", "", "", " NAME:        tvunzoom    PURPOSE:        Unzoom full viewport to a cursor-defined box.    CATEGORY:        UTIL/TVIM    CALLING SEQUENCE:        tvunzoom, image, wnum, new=new, erase=erase    ARGUMENTS:   INPUT: 	image:        Image to display  	wnum:        window number of display    OUTPUT:        NONE   KEYWORDS:   INPUT: 	new:	If set, creates a new window  	erase:	If set, erases display first  	noplot:	If set, the image is not redisplayed.  	p0:	First corner of box.  If set, then the routine 		immediately begins to drag from that point until a 		button is released.  	cursor:	Device code of cursor to use.  Default is a custom cursor.  	hourglass_id:	If set, this is used as the widget id of a draw 			window in which to set the hourglass cursor after 			the zoom region has been selected until the procedure 			is complete.  	output_wnum:	Window number for output display.  	minbox:	Minimum size of zoom box.  If smaller than this size in either 		direction, the zoom will not be changed.  	aspect:	Aspect ratio (y/x) to maintain when drawing the dragged zoom 		box.  	color:	Color of zoom box.      OUTPUT:        NONE    STATUS:        Complete, but apparently not correct.    MODIFICATION HISTORY:        Written by:     Spitale; 6/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/tvim/tvunzoom.html#tvunzoom", "tvunzoom", 'routine in <a href="util/tvim/tvunzoom.html">tvunzoom.pro</a>', "tvunzoom.pro", "", "tvunzoom", "", "newerasep0cursorhourglass_idnoplotcoloroutput_wnumminboxaspectxyimagewnum", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/tvxmap.html", "tvxmap.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "tvxmap.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/tvxmap.html#tvxmap", "tvxmap", 'routine in <a href="nv/obj/tools/tvxmap.html">tvxmap.pro</a>', "tvxmap.pro", "", "tvxmap", "", "colorfndatamaxminradiusweightbinoffset_xmap_ptd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/tvim/tvzoom.html", "tvzoom.pro", '.pro file in <a href="util/tvim/dir-overview.html">util/tvim/ directory</a>', "tvzoom.pro", "", "", " NAME:        tvzoom    PURPOSE:        Zoom a cursor defined box to full viewport.    CATEGORY:        UTIL/TVIM    CALLING SEQUENCE:        tvzoom, image, wnum, new=new, erase=erase    ARGUMENTS:   INPUT: 	image:        Image to display  	wnum:        window number of display    OUTPUT:        NONE   KEYWORDS:   INPUT: 	new:	If set, creates a new window  	erase:	If set, erases display first  	noplot:	If set, the image is not redisplayed.  	p0:	First corner of box.  If set, then the routine 		immediately begins to drag from that point until a 		button is released.  	cursor:	Device code of cursor to use.  Default is a custom cursor.  	hourglass_id:	If set, this is used as the widget id of a draw 			window in which to set the hourglass cursor after 			the zoom region has been selected until the procedure 			is complete.  	output_wnum:	Window number for output display.  	minbox:	Minimum size of zoom box.  If smaller than this size in either 		direction, the zoom will not be changed.  	aspect:	Aspect ratio (y/x) to maintain when drawing the dragged zoom 		box.  	color:	Color of zoom box.      OUTPUT:        NONE    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/tvim/tvzoom.html#tvzoom", "tvzoom", 'routine in <a href="util/tvim/tvzoom.html">tvzoom.pro</a>', "tvzoom.pro", "", "tvzoom", "", "newerasep0cursorhourglass_idnoplotcoloroutput_wnumminboxaspectxycornersimagewnum", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/strcat/tycho2_index__define.html", "tycho2_index__define.pro", '.pro file in <a href="config/strcat/dir-overview.html">config/strcat/ directory</a>', "tycho2_index__define.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/strcat/tycho2_index__define.html#tycho2_index__define", "tycho2_index__define", 'routine in <a href="config/strcat/tycho2_index__define.html">tycho2_index__define.pro</a>', "tycho2_index__define.pro", "", "tycho2_index__define", " Format of one line in TYCHO-2 index.dat   ", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/strcat/tycho2_record__define.html", "tycho2_record__define.pro", '.pro file in <a href="config/strcat/dir-overview.html">config/strcat/ directory</a>', "tycho2_record__define.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/strcat/tycho2_record__define.html#tycho2_record__define", "tycho2_record__define", 'routine in <a href="config/strcat/tycho2_record__define.html">tycho2_record__define.pro</a>', "tycho2_record__define.pro", "", "tycho2_record__define", " Format of one line of the TYCHO-2 tyc2.dat catalog file   ", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/strcat/tycho2_star__define.html", "tycho2_star__define.pro", '.pro file in <a href="config/strcat/dir-overview.html">config/strcat/ directory</a>', "tycho2_star__define.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/strcat/tycho2_star__define.html#tycho2_star__define", "tycho2_star__define", 'routine in <a href="config/strcat/tycho2_star__define.html">tycho2_star__define.pro</a>', "tycho2_star__define.pro", "", "tycho2_star__define", " Format of the standardized star structure.   ", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/strcat/tycho_record__define.html", "tycho_record__define.pro", '.pro file in <a href="config/strcat/dir-overview.html">config/strcat/ directory</a>', "tycho_record__define.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/strcat/tycho_record__define.html#tycho_record__define", "tycho_record__define", 'routine in <a href="config/strcat/tycho_record__define.html">tycho_record__define.pro</a>', "tycho_record__define.pro", "", "tycho_record__define", " Format of a Tycho (1) catalog star record.   ", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/strcat/tycho_region__define.html", "tycho_region__define.pro", '.pro file in <a href="config/strcat/dir-overview.html">config/strcat/ directory</a>', "tycho_region__define.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/strcat/tycho_region__define.html#tycho_region__define", "tycho_region__define", 'routine in <a href="config/strcat/tycho_region__define.html">tycho_region__define.pro</a>', "tycho_region__define.pro", "", "tycho_region__define", " Format of the Tycho (1) region index.   ", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/unique.html", "unique.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "unique.pro", "", "", " NAME: 	unique    PURPOSE: 	Returns unique elements of an array.    CATEGORY: 	UTIL    CALLING SEQUENCE: 	result = unique(array, s)    ARGUMENTS:   INPUT: array: 		Array to process.  	s:	Array of sorted subscripts.  If given, these subscripts 		are used to sort the array instead of peforming a sort 		operation.    OUTPUT: 	s:	Sorted subsctripts.    KEYWORDS:   INPUT: 	nosort:	If set, the input array is not sorted.    OUTPUT: 	reverse_indices: 		Array of subscripts mapping the output elements to their 		original positions in the input array.    RETURN: 	Unique array elements.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/unique.html#unique", "unique", 'routine in <a href="util/unique.html">unique.pro</a>', "unique.pro", "", "unique", "", "nosortreverse_indices_xss", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/downloader/unpack_gsc.html", "unpack_gsc.pro", '.pro file in <a href="util/downloader/dir-overview.html">util/downloader/ directory</a>', "unpack_gsc.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/downloader/unpack_gsc.html#unpack_gsc", "unpack_gsc", 'routine in <a href="util/downloader/unpack_gsc.html">unpack_gsc.pro</a>', "unpack_gsc.pro", "", "unpack_gsc", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/downloader/unpack_tycho2.html", "unpack_tycho2.pro", '.pro file in <a href="util/downloader/dir-overview.html">util/downloader/ directory</a>', "unpack_tycho2.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/downloader/unpack_tycho2.html#unpack_tycho2", "unpack_tycho2", 'routine in <a href="util/downloader/unpack_tycho2.html">unpack_tycho2.pro</a>', "unpack_tycho2.pro", "", "unpack_tycho2", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/unwrap_phase.html", "unwrap_phase.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "unwrap_phase.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/unwrap_phase.html#unwrap_phase", "unwrap_phase", 'routine in <a href="util/unwrap_phase.html">unwrap_phase.pro</a>', "unwrap_phase.pro", "", "unwrap_phase", "", "nsigphi0", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/unwrap_phase.html#_unwrap_phase", "_unwrap_phase", 'routine in <a href="util/unwrap_phase.html">unwrap_phase.pro</a>', "unwrap_phase.pro", "", "_unwrap_phase", "", "nsigphi0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/v/v_abscissa.html", "v_abscissa.pro", '.pro file in <a href="util/v/dir-overview.html">util/v/ directory</a>', "v_abscissa.pro", "", "", " NAME:        v_abscissa    PURPOSE:        Creates a 1-D abscissa for the given curve compsed of column vectors.    CATEGORY:        UTIL/V    CALLING SEQUENCE:        result = v_abscissa(v)    ARGUMENTS:   INPUT: 		v:      An array of nv column vectors  (i.e., nv x 3 array).    OUTPUT:        NONE    KEYWORDS:   INPUT:        NONE    OUTPUT:      		len:	Length of the entire path.    RETURN:        Array of abscissa values (i.e. 1-D offsets along the given curve).     STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  1/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/v/v_abscissa.html#v_abscissa", "v_abscissa", 'routine in <a href="util/v/v_abscissa.html">v_abscissa.pro</a>', "v_abscissa.pro", "", "v_abscissa", "", "lenv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/v/v_angle.html", "v_angle.pro", '.pro file in <a href="util/v/dir-overview.html">util/v/ directory</a>', "v_angle.pro", "", "", " NAME:        v_angle    PURPOSE:        Computes the angles between the given arrays of column vectors.   CATEGORY:        UTIL/V    CALLING SEQUENCE:        result = v_angle(v1, v2)    ARGUMENTS:   INPUT:        v1:     An array of nv x nt column vectors (i.e. nv x 3 x nt).         v2:     Another array of nv x nt column vectors).     OUTPUT:        NONE   RETURN:        Array of nv x nt angles in radians.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale	3/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/v/v_angle.html#v_angle", "v_angle", 'routine in <a href="util/v/v_angle.html">v_angle.pro</a>', "v_angle.pro", "", "v_angle", "", "v1v2", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/v/v_cross.html", "v_cross.pro", '.pro file in <a href="util/v/dir-overview.html">util/v/ directory</a>', "v_cross.pro", "", "", " NAME:        v_cross    PURPOSE:        Computes the cross products between the given arrays of column        vectors.   CATEGORY:        UTIL/V    CALLING SEQUENCE:        result = v_cross(v1, v2)    ARGUMENTS:   INPUT:        v1:     An array of nv x nt column vectors (i.e. nv x 3 x nt).         v2:     Another array of nv x nt column vectors.     OUTPUT:        NONE   RETURN:        Array of nv x nt cross products.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/v/v_cross.html#v_cross", "v_cross", 'routine in <a href="util/v/v_cross.html">v_cross.pro</a>', "v_cross.pro", "", "v_cross", "", "v1v2", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/v/v_deriv.html", "v_deriv.pro", '.pro file in <a href="util/v/dir-overview.html">util/v/ directory</a>', "v_deriv.pro", "", "", " NAME:        v_deriv    PURPOSE:        Computes tangent vectors to a given curve composed of column vectors.    CATEGORY:        UTIL/V    CALLING SEQUENCE:        result = v_deriv(v)    ARGUMENTS:   INPUT:                v:      An array of nv column vectors  (i.e., nv x 3 array) 			to resample.  		dv:	Spacing for new array.    OUTPUT:        NONE   RETURN:        Array of nv tangent unit vectors.     STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  1/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/v/v_deriv.html#v_deriv", "v_deriv", 'routine in <a href="util/v/v_deriv.html">v_deriv.pro</a>', "v_deriv.pro", "", "v_deriv", "", "v", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/v/v_inner.html", "v_inner.pro", '.pro file in <a href="util/v/dir-overview.html">util/v/ directory</a>', "v_inner.pro", "", "", " NAME:        v_inner    PURPOSE:        Computes the inner products between the given arrays of column        vectors.   CATEGORY:        UTIL/V    CALLING SEQUENCE:        result = v_inner(v1, v2)    ARGUMENTS:   INPUT:        v1:     An array of nv x nt column vectors (i.e. nv x 3 x nt).         v2:     Another array of nv x nt column vectors.     OUTPUT:        NONE   RETURN:        Array of nv x nt inner products.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/v/v_inner.html#v_inner", "v_inner", 'routine in <a href="util/v/v_inner.html">v_inner.pro</a>', "v_inner.pro", "", "v_inner", "", "v1v2", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/v/v_interior_convex.html", "v_interior_convex.pro", '.pro file in <a href="util/v/dir-overview.html">util/v/ directory</a>', "v_interior_convex.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/v/v_interior_convex.html#v_interior_convex", "v_interior_convex", 'routine in <a href="util/v/v_interior_convex.html">v_interior_convex.pro</a>', "v_interior_convex.pro", "", "v_interior_convex", "", "v_vertv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/v/v_interp.html", "v_interp.pro", '.pro file in <a href="util/v/dir-overview.html">util/v/ directory</a>', "v_interp.pro", "", "", " NAME:        v_interp    PURPOSE:        Interpolates column vectors along a curve.    CATEGORY:        UTIL/V    CALLING SEQUENCE:        result = v_interp(v, x)    ARGUMENTS:   INPUT:                v:      An array of nv column vectors  (i.e., nv x 3 array) 			to resample.  		x:	1-D coordinate along curve for each interpolate.    OUTPUT:        NONE    KEYWORDS:   INPUT:	uniform:	If set, the 'x' argument is taken as a uniform 				grid spacing instead of grid.   OUTPUT:        NONE    RETURN:        Array of interpolated column vectors.     STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  1/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/v/v_interp.html#v_interp", "v_interp", 'routine in <a href="util/v/v_interp.html">v_interp.pro</a>', "v_interp.pro", "", "v_interp", "", "uniformsplinelsquadraticquadraticv_xx", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/v/v_mag.html", "v_mag.pro", '.pro file in <a href="util/v/dir-overview.html">util/v/ directory</a>', "v_mag.pro", "", "", " NAME:        v_mag    PURPOSE:        Computes the magnitudes of the given array of column vectors.   CATEGORY:        UTIL/V    CALLING SEQUENCE:        result = v_mag(v)    ARGUMENTS:   INPUT:        v:     An array of nv x nt column vectors (i.e. nv x 3 x nt).     OUTPUT:        NONE   RETURN:        Array of nv x nt magnitudes.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/v/v_mag.html#v_mag", "v_mag", 'routine in <a href="util/v/v_mag.html">v_mag.pro</a>', "v_mag.pro", "", "v_mag", "", "v", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/v/v_mean.html", "v_mean.pro", '.pro file in <a href="util/v/dir-overview.html">util/v/ directory</a>', "v_mean.pro", "", "", " NAME:        v_mean    PURPOSE:        Computes the mean values of the given array of column vectors 	in the x direction.   CATEGORY:        UTIL/V    CALLING SEQUENCE:        result = v_mean(v)    ARGUMENTS:   INPUT:        v:     An array of nv x nt column vectors (i.e. nv x 3 x nt).     OUTPUT:        NONE   RETURN:        Array of 1 x nt column vectors (i.e., 1 x 3 x nt).    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/v/v_mean.html#v_mean", "v_mean", 'routine in <a href="util/v/v_mean.html">v_mean.pro</a>', "v_mean.pro", "", "v_mean", "", "wtv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/v/v_median.html", "v_median.pro", '.pro file in <a href="util/v/dir-overview.html">util/v/ directory</a>', "v_median.pro", "", "", " NAME:        v_median    PURPOSE:        Computes the median values of the given array of column vectors 	in the x direction.   CATEGORY:        UTIL/V    CALLING SEQUENCE:        result = v_mean(v)    ARGUMENTS:   INPUT:        v:     An array of nv x nt column vectors (i.e. nv x 3 x nt).     OUTPUT:        NONE   RETURN:        Array of 1 x nt column vectors (i.e., 1 x 3 x nt).    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/v/v_median.html#v_median", "v_median", 'routine in <a href="util/v/v_median.html">v_median.pro</a>', "v_median.pro", "", "v_median", "", "v", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/v/v_mxm.html", "v_mxm.pro", '.pro file in <a href="util/v/dir-overview.html">util/v/ directory</a>', "v_mxm.pro", "", "", " NAME:        v_mxm    PURPOSE:        Performs matrix multiplication.   CATEGORY:        UTIL/V    CALLING SEQUENCE:        result = v_mxm(m1, m2)    ARGUMENTS:   INPUT:        m1:     An array of nt matrices (i.e. 3 x 3 x nt).         m1:     Another array of nt matrices.     OUTPUT:        NONE   RETURN:        Array of nt matrix products (i.e. 3 x 3 x nt).    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/v/v_mxm.html#v_mxm", "v_mxm", 'routine in <a href="util/v/v_mxm.html">v_mxm.pro</a>', "v_mxm.pro", "", "v_mxm", "", "m1m2", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/v/v_project.html", "v_project.pro", '.pro file in <a href="util/v/dir-overview.html">util/v/ directory</a>', "v_project.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/v/v_project.html#v_project", "v_project", 'routine in <a href="util/v/v_project.html">v_project.pro</a>', "v_project.pro", "", "v_project", "", "Mvalidthresholdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/v/v_rot.html", "v_rot.pro", '.pro file in <a href="util/v/dir-overview.html">util/v/ directory</a>', "v_rot.pro", "", "", " NAME:        v_rot    PURPOSE:        Computes a rotation matrix between two vectors.    CATEGORY:        UTIL/V    CALLING SEQUENCE: 	result = v_rot(v1, v2)    ARGUMENTS:   INPUT: 	v1, v2:      Arrays (nv,3,nt) of column unit vectors.    OUTPUT:        NONE   RETURN: 	Rotation matrix transforming v1 to v2, i.e.: v2 = R##v1.    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/v/v_rot.html#v_rot", "v_rot", 'routine in <a href="util/v/v_rot.html">v_rot.pro</a>', "v_rot.pro", "", "v_rot", "", "v1v2", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/v/v_rotate.html", "v_rotate.pro", '.pro file in <a href="util/v/dir-overview.html">util/v/ directory</a>', "v_rotate.pro", "", "", " NAME:        v_rotate    PURPOSE:        Rotates the (N,3) column vectors, v, about the (N,3) column vectors,        n, by the angles theta.  The sin and cos of theta are given in        order to improve performance.    CATEGORY:        UTIL/V    CALLING SEQUENCE:        result = v_rotate(v, n, sin_theta, cos_theta)    ARGUMENTS:   INPUT:                v:      An array of N column vectors                 n:      An array of N column vectors         sin_theta:      Sine of rotation angle theta         cos_theta:      Cosine of rotation angle theta     OUTPUT:        NONE   RETURN:        If the arguments have dimensions v(N,3), n(N,3) and sin_theta(M),        cos_theta(M) then the result has dimensions (N,3,M)    RESTRICTIONS:        v and n must have exactly the same dimensions.        sin_theta and cos_theta must be 1-dimensional arrays of any length        as long as the lengths are the same.  Note that if only one theta        is specified, the arguments must be given as [sin_theta], [cos_theta]        instead of as scalars.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/v/v_rotate.html#v_rotate", "v_rotate", 'routine in <a href="util/v/v_rotate.html">v_rotate.pro</a>', "v_rotate.pro", "", "v_rotate", "", "vnsin_thetacos_theta", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/v/v_rotate_11.html", "v_rotate_11.pro", '.pro file in <a href="util/v/dir-overview.html">util/v/ directory</a>', "v_rotate_11.pro", "", "", " NAME:        v_rotate_11    PURPOSE:        Rotates the (nv,3,nt) column vectors, v, about the (nv,3,nt) column        vectors, n, by the (nv,nt) angles theta.  The sin and cos of theta are        given in order to improve performance.  Each vector in v is rotated        about the corresponding vector in n by the corresponding angle in theta.    CATEGORY:        UTIL/V    CALLING SEQUENCE:        result = v_rotate_11(v, n, sin_theta, cos_theta)    ARGUMENTS:   INPUT:                v:      An array of N column vectors                 n:      An array of N column vectors         sin_theta:      Sine of rotation angle theta         cos_theta:      Cosine of rotation angle theta     OUTPUT:        NONE   RETURN:        If the arguments have dimensions v(nv,3,nt), n(nv,3,nt) and        sin_theta(nv,nt), cos_theta(nv,nt) then the result has dimensions        (nv,3,nt).    RESTRICTIONS:        v and n must have exactly the same dimensions.        sin_theta and cos_theta must be 1-dimensional arrays of any length        as long as the lengths are the same.  Note that if only one theta        is specified, the arguments must be given as [sin_theta], [cos_theta]        instead of as scalars.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/v/v_rotate_11.html#v_rotate_11", "v_rotate_11", 'routine in <a href="util/v/v_rotate_11.html">v_rotate_11.pro</a>', "v_rotate_11.pro", "", "v_rotate_11", "", "vnsin_thetacos_theta", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/v/v_sample.html", "v_sample.pro", '.pro file in <a href="util/v/dir-overview.html">util/v/ directory</a>', "v_sample.pro", "", "", " NAME:        v_sample    PURPOSE:        Resamples the given column vectors such that their spacing is 	uniform.    CATEGORY:        UTIL/V    CALLING SEQUENCE:        result = v_sample(v, dv)    ARGUMENTS:   INPUT:                v:      An array of nv column vectors  (i.e., nv x 3 array) 			to resample.  Note that the reason there is no 			nt direction is that unifrom spacing would impose 			differing numbers of elements in that direction, which 			is not permissible.  		dv:	Spacing for new array.    OUTPUT:        NONE   RETURN:        Array of nv uniformly-spaced column vectors.     STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale  9/2012   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/v/v_sample.html#v_sample", "v_sample", 'routine in <a href="util/v/v_sample.html">v_sample.pro</a>', "v_sample.pro", "", "v_sample", "", "splinelsquadraticquadraticvdv", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/v/v_sample.html#v_sample", "v_sample", 'routine in <a href="util/v/v_sample.html">v_sample.pro</a>', "v_sample.pro", "", "v_sample", "", "splinelsquadraticquadraticvdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/v/v_sqmag.html", "v_sqmag.pro", '.pro file in <a href="util/v/dir-overview.html">util/v/ directory</a>', "v_sqmag.pro", "", "", " NAME:        v_sqmag    PURPOSE:        Computes the squared magnitudes of the given array of column vectors.    CATEGORY:        UTIL/V    CALLING SEQUENCE:        result = v_sqmag(v)    ARGUMENTS:   INPUT:        v:     An array of nv x nt column vectors (i.e. nv x 3 x nt).    OUTPUT:        NONE   RETURN: 	An array of nv x nt squared magnitudes    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/v/v_sqmag.html#v_sqmag", "v_sqmag", 'routine in <a href="util/v/v_sqmag.html">v_sqmag.pro</a>', "v_sqmag.pro", "", "v_sqmag", "", "v", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/v/v_stdev.html", "v_stdev.pro", '.pro file in <a href="util/v/dir-overview.html">util/v/ directory</a>', "v_stdev.pro", "", "", " NAME:        v_stdev    PURPOSE:        Computes the standard deviations of the given array of column vectors 	in the x direction.   CATEGORY:        UTIL/V    CALLING SEQUENCE:        result = v_stdev(v)    ARGUMENTS:   INPUT:        v:     An array of nv x nt column vectors (i.e. nv x 3 x nt).     OUTPUT:        NONE   RETURN:        Array of 1 x nt column vectors (i.e., 1 x 3 x nt).    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/v/v_stdev.html#v_stdev", "v_stdev", 'routine in <a href="util/v/v_stdev.html">v_stdev.pro</a>', "v_stdev.pro", "", "v_stdev", "", "meanmean2wtv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/v/v_transform_forward.html", "v_transform_forward.pro", '.pro file in <a href="util/v/dir-overview.html">util/v/ directory</a>', "v_transform_forward.pro", "", "", " NAME:        v_transform_forward    PURPOSE:        Transforms vectors given rotation matrices and translation vectors.    CATEGORY:        UTIL/V    CALLING SEQUENCE:        result = v_transform_forward(M, p, v)    ARGUMENTS:   INPUT:        M:      array of nt (nel x nel) rotation matrices         p:      array of nt nel-element column vectors         v:      v is array (nv,nel,nt) of nel-element column vectors    OUTPUT:        NONE   RETURN:        Array (nv,nel,nt) of nel-element transformed column vectors.   PROCEDURE:        Vectors are first rotated using M and then translated using p.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/v/v_transform_forward.html#v_transform_forward", "v_transform_forward", 'routine in <a href="util/v/v_transform_forward.html">v_transform_forward.pro</a>', "v_transform_forward.pro", "", "v_transform_forward", "", "Mpv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/v/v_transform_reverse.html", "v_transform_reverse.pro", '.pro file in <a href="util/v/dir-overview.html">util/v/ directory</a>', "v_transform_reverse.pro", "", "", " NAME:        v_transform_reverse    PURPOSE:        Transforms vectors given rotation matrices and translation vectors.    CATEGORY:        UTIL/V    CALLING SEQUENCE:        result = v_transform_reverse(M, p, v)    ARGUMENTS:   INPUT:        M:      array of nt (nel x nel) rotation matrices         p:      array of nt nel-element column vectors         v:      v is array (nv,nel,nt) of nel-element column vectors    OUTPUT:        NONE   RETURN:        Array (nv,nel,nt) of nel-element transformed column vectors.   PROCEDURE:        Vectors are first translated using p and then rotated using M.   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/v/v_transform_reverse.html#v_transform_reverse", "v_transform_reverse", 'routine in <a href="util/v/v_transform_reverse.html">v_transform_reverse.pro</a>', "v_transform_reverse.pro", "", "v_transform_reverse", "", "Mpv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/v/v_unit.html", "v_unit.pro", '.pro file in <a href="util/v/dir-overview.html">util/v/ directory</a>', "v_unit.pro", "", "", " NAME:        v_unit    PURPOSE:        Returns unit vectors in the directions given by v.    CATEGORY:        UTIL/V    CALLING SEQUENCE:        result = v_unit(v)    ARGUMENTS:   INPUT:        v:     An array of nv x nt column vectors (i.e. nv x 3 x nt).    OUTPUT:        NONE   RETURN:        An array of nv x nt unit vectors    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/v/v_unit.html#v_unit", "v_unit", 'routine in <a href="util/v/v_unit.html">v_unit.pro</a>', "v_unit.pro", "", "v_unit", "", "magv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/valid_index.html", "valid_index.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "valid_index.pro", "", "", " NAME:        valid_index    PURPOSE:        Determines if an index into an array is valid    CATEGORY:        UTIL    CALLING SEQUENCE:        result = valid_index(array, index)    ARGUMENTS:   INPUT:        array:  An array         index:  An index into that array    OUTPUT:        NONE   RETURN:        A boolean value whether the index is valid    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/valid_index.html#valid_index", "valid_index", 'routine in <a href="util/valid_index.html">valid_index.pro</a>', "valid_index.pro", "", "valid_index", "", "arrayindex", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/valid_rotation.html", "valid_rotation.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "valid_rotation.pro", "", "", " NAME: 	xx    PURPOSE: 	xx    CATEGORY: 	UTIL    CALLING SEQUENCE: 	result = xx(xx, xx) 	xx, xx, xx    ARGUMENTS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    KEYWORDS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    ENVIRONMENT VARIABLES: 	xx:	xx  	xx:	xx    RETURN: 	xx    COMMON BLOCKS: 	xx:	xx  	xx:	xx    SIDE EFFECTS: 	xx    RESTRICTIONS: 	xx    PROCEDURE: 	xx    EXAMPLE: 	xx    STATUS: 	xx    SEE ALSO: 	xx, xx, xx    MODIFICATION HISTORY:  	Written by:	xx, xx/xx/xxxx   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/valid_rotation.html#valid_rotation", "valid_rotation", 'routine in <a href="util/valid_rotation.html">valid_rotation.pro</a>', "valid_rotation.pro", "", "valid_rotation", "", "epsilonM", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/gen/vecgen.html", "vecgen.pro", '.pro file in <a href="util/gen/dir-overview.html">util/gen/ directory</a>', "vecgen.pro", "", "", " NAME: 	vecgen    PURPOSE:  	Generates subscripts for an array of nn n x m matrices such that  	subscripting the array of matrices will produce an array of column  	vectors with each vector being a column of one of the matrices.     CATEGORY: 	UTIL/GEN    CALLING SEQUENCE: 	sub = vecgen(n, m, nn)    ARGUMENTS:   INPUT: 	n:	 Number of matrix columns.  	m: 	 Number of matrix rows.  	nn:	 Number of matrices.    OUTPUT: NONE    KEYWORDS:   INPUT:  NONE    OUTPUT: NONE    RETURN: 	Array (n+m x nn) of subscripts.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/gen/vecgen.html#vecgen", "vecgen", 'routine in <a href="util/gen/vecgen.html">vecgen.pro</a>', "vecgen.pro", "", "vecgen", "", "nmnn", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/vector_interp.html", "vector_interp.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "vector_interp.pro", "", "", " NAME: 	vector_interp    PURPOSE: 	Performs Lagrange interpolation on an array of vectors.    CATEGORY: 	UTIL    CALLING SEQUENCE: 	result = xx(xx, xx) 	xx, xx, xx    ARGUMENTS:   INPUT: 	vi:	Array (nv,3,nt) of vectors.  	ti:	Array (nt) of times for the given vectors.  	t:	Array (n) of times at which to interpolate.   KEYWORDS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    RETURN: 	Array (nv,3,n) of interpolated vectors.    STATUS: 	xx    SEE ALSO: 	xx, xx, xx    MODIFICATION HISTORY:  	Written by:	Spitale, 1/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/vector_interp.html#vector_interp", "vector_interp", 'routine in <a href="util/vector_interp.html">vector_interp.pro</a>', "vector_interp.pro", "", "vector_interp", "", "vitit", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/vfact.html", "vfact.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "vfact.pro", "", "", " NAME:        vfact    PURPOSE:        Computes the factorial of each element of x    CATEGORY:        UTIL    CALLING SEQUENCE:        result = vfact(x)    ARGUMENTS:   INPUT:            x:  Float or double vector    OUTPUT:        NONE    RETURN:        Array of factorials for each element of x    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/vfact.html#vfact", "vfact", 'routine in <a href="util/vfact.html">vfact.pro</a>', "vfact.pro", "", "vfact", "", "x", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/vgr_cd/vgr_cd_bin_path.html", "vgr_cd_bin_path.pro", '.pro file in <a href="config/vgr_cd/dir-overview.html">config/vgr_cd/ directory</a>', "vgr_cd_bin_path.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/vgr_cd/vgr_cd_bin_path.html#vgr_cd_bin_path", "vgr_cd_bin_path", 'routine in <a href="config/vgr_cd/vgr_cd_bin_path.html">vgr_cd_bin_path.pro</a>', "vgr_cd_bin_path.pro", "", "vgr_cd_bin_path", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/vgr/iss/vgr_cmat_to_orient_iss.html", "vgr_cmat_to_orient_iss.pro", '.pro file in <a href="config/vgr/iss/dir-overview.html">config/vgr/iss/ directory</a>', "vgr_cmat_to_orient_iss.pro", "", "", " NAME: 	vgr_cmat_to_orient_iss    PURPOSE: 	Converts Voyager C matrix to a OMINAS camera orientation matrix.    CATEGORY: 	NV/CONFIG    CALLING SEQUENCE: 	result = vgr_cmat_to_orient(cmat)    ARGUMENTS:   INPUT: 	cmat:	Voyager C matrix    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	NONE    OUTPUT: 	NONE    RETURN: 	OMINAS camera orientation matrix.    STATUS: 	Complete    SEE ALSO: 	vgr_orient_to_cmat    MODIFICATION HISTORY:  	Written by:	Spitale, 11/2004   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/vgr/iss/vgr_cmat_to_orient_iss.html#vgr_cmat_to_orient_iss", "vgr_cmat_to_orient_iss", 'routine in <a href="config/vgr/iss/vgr_cmat_to_orient_iss.html">vgr_cmat_to_orient_iss.pro</a>', "vgr_cmat_to_orient_iss.pro", "", "vgr_cmat_to_orient_iss", "", "cmat", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/vgr/iss/vgr_compute_psf.html", "vgr_compute_psf.pro", '.pro file in <a href="config/vgr/iss/dir-overview.html">config/vgr/iss/ directory</a>', "vgr_compute_psf.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/vgr/iss/vgr_compute_psf.html#vgr_psf", "vgr_psf", 'routine in <a href="config/vgr/iss/vgr_compute_psf.html">vgr_compute_psf.pro</a>', "vgr_compute_psf.pro", "", "vgr_psf", "", "defaultcdxy", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/vgr/iss/vgr_from_ominas.html", "vgr_from_ominas.pro", '.pro file in <a href="config/vgr/iss/dir-overview.html">config/vgr/iss/ directory</a>', "vgr_from_ominas.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/vgr/iss/vgr_from_ominas.html#vgr_from_ominas", "vgr_from_ominas", 'routine in <a href="config/vgr/iss/vgr_from_ominas.html">vgr_from_ominas.pro</a>', "vgr_from_ominas.pro", "", "vgr_from_ominas", "", "odorient_fn", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/vgr/iss/vgr_image_time_to_scet.html", "vgr_image_time_to_scet.pro", '.pro file in <a href="config/vgr/iss/dir-overview.html">config/vgr/iss/ directory</a>', "vgr_image_time_to_scet.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/vgr/iss/vgr_image_time_to_scet.html#vgr_image_time_to_scet", "vgr_image_time_to_scet", 'routine in <a href="config/vgr/iss/vgr_image_time_to_scet.html">vgr_image_time_to_scet.pro</a>', "vgr_image_time_to_scet.pro", "", "vgr_image_time_to_scet", "", "image_time", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/vgr/iss/vgr_orient_to_cmat_iss.html", "vgr_orient_to_cmat_iss.pro", '.pro file in <a href="config/vgr/iss/dir-overview.html">config/vgr/iss/ directory</a>', "vgr_orient_to_cmat_iss.pro", "", "", " NAME: 	vgr_orient_to_cmat_iss    PURPOSE: 	Converts Voyager C matrix to a OMINAS camera orientation matrix.    CATEGORY: 	NV/CONFIG    CALLING SEQUENCE: 	result = vgr_orient_to_cmat(cmat)    ARGUMENTS:   INPUT: 	orient:		OMINAS camera orientation matrix.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	NONE    OUTPUT: 	NONE    RETURN: 	Voyager C matrix.    STATUS: 	Complete    SEE ALSO: 	vgr_cmat_to_orient    MODIFICATION HISTORY:  	Written by:	Spitale, 11/2004   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/vgr/iss/vgr_orient_to_cmat_iss.html#vgr_orient_to_cmat_iss", "vgr_orient_to_cmat_iss", 'routine in <a href="config/vgr/iss/vgr_orient_to_cmat_iss.html">vgr_orient_to_cmat_iss.pro</a>', "vgr_orient_to_cmat_iss.pro", "", "vgr_orient_to_cmat_iss", "", "orient", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/vgr/vgr_parse_inst.html", "vgr_parse_inst.pro", '.pro file in <a href="config/vgr/dir-overview.html">config/vgr/ directory</a>', "vgr_parse_inst.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/vgr/vgr_parse_inst.html#vgr_parse_inst", "vgr_parse_inst", 'routine in <a href="config/vgr/vgr_parse_inst.html">vgr_parse_inst.pro</a>', "vgr_parse_inst.pro", "", "vgr_parse_inst", "", "caminst", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/vgr/iss/vgr_pixel_scale.html", "vgr_pixel_scale.pro", '.pro file in <a href="config/vgr/iss/dir-overview.html">config/vgr/iss/ directory</a>', "vgr_pixel_scale.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/vgr/iss/vgr_pixel_scale.html#vgr_pixel_scale", "vgr_pixel_scale", 'routine in <a href="config/vgr/iss/vgr_pixel_scale.html">vgr_pixel_scale.pro</a>', "vgr_pixel_scale.pro", "", "vgr_pixel_scale", "", "geomcam", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/vgr/iss/vgr_psf.html", "vgr_psf.pro", '.pro file in <a href="config/vgr/iss/dir-overview.html">config/vgr/iss/ directory</a>', "vgr_psf.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/vgr/iss/vgr_psf.html#vgr_psf", "vgr_psf", 'routine in <a href="config/vgr/iss/vgr_psf.html">vgr_psf.pro</a>', "vgr_psf.pro", "", "vgr_psf", "", "cdxy", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/vgr/iss/vgr_scet_to_image_time.html", "vgr_scet_to_image_time.pro", '.pro file in <a href="config/vgr/iss/dir-overview.html">config/vgr/iss/ directory</a>', "vgr_scet_to_image_time.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/vgr/iss/vgr_scet_to_image_time.html#vgr_scet_to_image_time", "vgr_scet_to_image_time", 'routine in <a href="config/vgr/iss/vgr_scet_to_image_time.html">vgr_scet_to_image_time.pro</a>', "vgr_scet_to_image_time.pro", "", "vgr_scet_to_image_time", "", "scet", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/vgr/iss/vgr_spice_ck_detect.html", "vgr_spice_ck_detect.pro", '.pro file in <a href="config/vgr/iss/dir-overview.html">config/vgr/iss/ directory</a>', "vgr_spice_ck_detect.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/vgr/iss/vgr_spice_ck_detect.html#vgr_spice_ck_detect", "vgr_spice_ck_detect", 'routine in <a href="config/vgr/iss/vgr_spice_ck_detect.html">vgr_spice_ck_detect.pro</a>', "vgr_spice_ck_detect.pro", "", "vgr_spice_ck_detect", "", "scdjdtimeallstrictddkpath", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/vgr/vgr_spice_fk_detect.html", "vgr_spice_fk_detect.pro", '.pro file in <a href="config/vgr/dir-overview.html">config/vgr/ directory</a>', "vgr_spice_fk_detect.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/vgr/vgr_spice_fk_detect.html#vgr_spice_fk_detect", "vgr_spice_fk_detect", 'routine in <a href="config/vgr/vgr_spice_fk_detect.html">vgr_spice_fk_detect.pro</a>', "vgr_spice_fk_detect.pro", "", "vgr_spice_fk_detect", "", "sctimestrictallddkpath", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/vgr/vgr_spice_ik_detect.html", "vgr_spice_ik_detect.pro", '.pro file in <a href="config/vgr/dir-overview.html">config/vgr/ directory</a>', "vgr_spice_ik_detect.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/vgr/vgr_spice_ik_detect.html#vgr_spice_ik_detect", "vgr_spice_ik_detect", 'routine in <a href="config/vgr/vgr_spice_ik_detect.html">vgr_spice_ik_detect.pro</a>', "vgr_spice_ik_detect.pro", "", "vgr_spice_ik_detect", "", "sctimestrictallddkpath", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/vgr/iss/vgr_spice_input.html", "vgr_spice_input.pro", '.pro file in <a href="config/vgr/iss/dir-overview.html">config/vgr/iss/ directory</a>', "vgr_spice_input.pro", "", "", " NAME: 	vgr_spice_input    PURPOSE: 	NAIF/SPICE input translator for Voyager.    CATEGORY: 	NV/CONFIG    CALLING SEQUENCE: 	result = vgr_spice_input(dd, keyword)    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	keyword:	String giving the name of the translator quantity.     OUTPUT: 	NONE    KEYWORDS:   INPUT: 	key1:		Camera descriptor.    OUTPUT: 	status:		Zero if valid data is returned.     TRANSLATOR KEYWORDS: 	ref:		Name of the reference frame for the output quantities. 			Default is 'j2000'.  	j2000:		/j2000 is equivalent to specifying ref=j2000.  	b1950:		/b1950 is equivalent to specifying ref=b1950.  	klist:		Name of a file giving a list of SPICE kernels to use. 			If no path is included, the path is taken from the 			NV_SPICE_KER environment variable.  	ck_in:		List of input C kernel files to use.  List must be 			delineated by semimcolons with no space.  The kernel 			list file is still used, but these kernels take 			precedence.  Entries in this list may be file 			specification strings.  	planets:	List of planets to for which to request ephemeris. 			Must be delineated by semicolons with no space.  	reload:		If set, new kernels are loaded, as specified by the 			klist and ck_in keywords.    RETURN: 	Data associated with the requested keyword.    STATUS: 	Complete    SEE ALSO: 	vgr_spice_output    MODIFICATION HISTORY:  	Written by:	Spitale, 10/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/vgr/iss/vgr_spice_input.html#vgr_spice_parse_labels", "vgr_spice_parse_labels", 'routine in <a href="config/vgr/iss/vgr_spice_input.html">vgr_spice_input.pro</a>', "vgr_spice_input.pro", "", "vgr_spice_parse_labels", "", "exposuresizefiltersoaxisscaletargetdd_time", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/vgr/iss/vgr_spice_input.html#vgr_spice_cameras", "vgr_spice_cameras", 'routine in <a href="config/vgr/iss/vgr_spice_input.html">vgr_spice_input.pro</a>', "vgr_spice_input.pro", "", "vgr_spice_cameras", "", "posconstantsn_objdimstatustimeorientobsddref", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/vgr/iss/vgr_spice_input.html#vgr_spice_planets", "vgr_spice_planets", 'routine in <a href="config/vgr/iss/vgr_spice_input.html">vgr_spice_input.pro</a>', "vgr_spice_input.pro", "", "vgr_spice_planets", "", "timeplanetsn_objdimstatustarg_listconstantsobsddref", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/vgr/iss/vgr_spice_input.html#vgr_spice_sun", "vgr_spice_sun", 'routine in <a href="config/vgr/iss/vgr_spice_input.html">vgr_spice_input.pro</a>', "vgr_spice_input.pro", "", "vgr_spice_sun", "", "n_objdimstatustimeconstantsobsddref", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/vgr/iss/vgr_spice_input.html#vgr_spice_input", "vgr_spice_input", 'routine in <a href="config/vgr/iss/vgr_spice_input.html">vgr_spice_input.pro</a>', "vgr_spice_input.pro", "", "vgr_spice_input", "", "valuesstatusddkeyword@nv_trs_keywords_include.pro", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/vgr/iss/vgr_spice_output.html", "vgr_spice_output.pro", '.pro file in <a href="config/vgr/iss/dir-overview.html">config/vgr/iss/ directory</a>', "vgr_spice_output.pro", "", "", " NAME: 	vgr_spice_output    PURPOSE: 	NAIF/SPICE output translator for Voyager.    CATEGORY: 	NV/CONFIG    CALLING SEQUENCE(only to be called by nv_xx_value): 	vgr_spice_output, dd, keyword, value    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	keyword:	String giving the name of the translator quantity.  	value:		The data to write.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	key1:		Camera descriptor.    OUTPUT: 	status:		Zero unless a problem occurs.     TRANSLATOR KEYWORDS: 	ref:		Name of the reference frame for the input quantities. 			Default is 'j2000'.  	j2000:		/j2000 is equivalent to specifying ref=j2000.  	b1950:		/b1950 is equivalent to specifying ref=b1950.  	ck_out:		String giving the name of the new C-kernel to write.    STATUS: 	Complete    SEE ALSO: 	vgr_spice_input    MODIFICATION HISTORY:  	Written by:	Spitale, 10/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/vgr/iss/vgr_spice_output.html#vgr_spice_write_cameras", "vgr_spice_write_cameras", 'routine in <a href="config/vgr/iss/vgr_spice_output.html">vgr_spice_output.pro</a>', "vgr_spice_output.pro", "", "vgr_spice_write_cameras", "", "reloadn_objdimstatusddvaluerefck_file", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/vgr/iss/vgr_spice_output.html#vgr_spice_output", "vgr_spice_output", 'routine in <a href="config/vgr/iss/vgr_spice_output.html">vgr_spice_output.pro</a>', "vgr_spice_output.pro", "", "vgr_spice_output", "", "statusddkeywordvalue@nv_trs_keywords_include.pro", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/vgr/vgr_spice_sc.html", "vgr_spice_sc.pro", '.pro file in <a href="config/vgr/dir-overview.html">config/vgr/ directory</a>', "vgr_spice_sc.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/vgr/vgr_spice_sc.html#vgr_spice_sc", "vgr_spice_sc", 'routine in <a href="config/vgr/vgr_spice_sc.html">vgr_spice_sc.pro</a>', "vgr_spice_sc.pro", "", "vgr_spice_sc", "", "dd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/vgr/vgr_spice_sck_detect.html", "vgr_spice_sck_detect.pro", '.pro file in <a href="config/vgr/dir-overview.html">config/vgr/ directory</a>', "vgr_spice_sck_detect.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/vgr/vgr_spice_sck_detect.html#vgr_spice_sck_detect", "vgr_spice_sck_detect", 'routine in <a href="config/vgr/vgr_spice_sck_detect.html">vgr_spice_sck_detect.pro</a>', "vgr_spice_sck_detect.pro", "", "vgr_spice_sck_detect", "", "sctimestrictallddkpath", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/vgr/vgr_spice_sct2et.html", "vgr_spice_sct2et.pro", '.pro file in <a href="config/vgr/dir-overview.html">config/vgr/ directory</a>', "vgr_spice_sct2et.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/vgr/vgr_spice_sct2et.html#vgr_spice_sct2et", "vgr_spice_sct2et", 'routine in <a href="config/vgr/vgr_spice_sct2et.html">vgr_spice_sct2et.pro</a>', "vgr_spice_sct2et.pro", "", "vgr_spice_sct2et", "", "ddtimes", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/vgr/iss/vgr_spice_spk_detect.html", "vgr_spice_spk_detect.pro", '.pro file in <a href="config/vgr/iss/dir-overview.html">config/vgr/iss/ directory</a>', "vgr_spice_spk_detect.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/vgr/iss/vgr_spice_spk_detect.html#vgr_spice_spk_detect", "vgr_spice_spk_detect", 'routine in <a href="config/vgr/iss/vgr_spice_spk_detect.html">vgr_spice_spk_detect.pro</a>', "vgr_spice_spk_detect.pro", "", "vgr_spice_spk_detect", "", "scstrictalltimeddkpath", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/vgr/vgr_spice_time.html", "vgr_spice_time.pro", '.pro file in <a href="config/vgr/dir-overview.html">config/vgr/ directory</a>', "vgr_spice_time.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/vgr/vgr_spice_time.html#vgr_spice_time", "vgr_spice_time", 'routine in <a href="config/vgr/vgr_spice_time.html">vgr_spice_time.pro</a>', "vgr_spice_time.pro", "", "vgr_spice_time", "", "dtstringlabel", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/vgr/iss/vgr_to_ominas.html", "vgr_to_ominas.pro", '.pro file in <a href="config/vgr/iss/dir-overview.html">config/vgr/iss/ directory</a>', "vgr_to_ominas.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/vgr/iss/vgr_to_ominas.html#vgr_to_ominas", "vgr_to_ominas", 'routine in <a href="config/vgr/iss/vgr_to_ominas.html">vgr_to_ominas.pro</a>', "vgr_to_ominas.pro", "", "vgr_to_ominas", "", "odorient_fn", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/vicar/vic_str_pad.html", "vic_str_pad.pro", '.pro file in <a href="config/vicar/dir-overview.html">config/vicar/ directory</a>', "vic_str_pad.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/vicar/vic_str_pad.html#vic_str_pad", "vic_str_pad", 'routine in <a href="config/vicar/vic_str_pad.html">vic_str_pad.pro</a>', "vic_str_pad.pro", "", "vic_str_pad", "", "aligncsn", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/vicar/vic_str_sep.html", "vic_str_sep.pro", '.pro file in <a href="config/vicar/dir-overview.html">config/vicar/ directory</a>', "vic_str_sep.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/vicar/vic_str_sep.html#vic_str_sep", "vic_str_sep", 'routine in <a href="config/vicar/vic_str_sep.html">vic_str_sep.pro</a>', "vic_str_sep.pro", "", "vic_str_sep", " NAME:     STR_SEP   PURPOSE:     This routine cuts a string into pieces which are separated by the     separator string.  CATEGORY:     String processing.  CALLING SEQUENCE:     arr = STR_SEP(str, separator)   INPUTS:     str - The string to be separated.     separator - The separator.   KEYWORDS:     ESC = escape character.  Only valid if separator is a single character. 		Characters following the escape character are treated 		literally and not interpreted as separators. 		For example, if the separator is a comma, 		and the escape character is a backslash, the character 		sequence 'a\,b' is a single field containing the characters 		'a,b'.     REMOVE_ALL = if set, remove all blanks from fields.     TRIM = if set, remove only leading and trailing blanks from fields.   OUTPUT:     An array of strings as function value.   COMMON BLOCKS:     None   SIDE EFFECTS:     No known side effects.   RESTRICTIONS:     None.   EXAMPLE:     array = STR_SEP ( ulib.usca.test ,  . )   MODIFICATION HISTORY: 	July 1992, AH,	CreaSo		Created. 	December, 1994, DMS, RSI	Added TRIM and REMOVE_ALL.  ", "REMOVE_ALLTRIMESCstrseparator", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/sedr/vicar_vgrkey.html", "vicar_vgrkey.pro", '.pro file in <a href="config/sedr/dir-overview.html">config/sedr/ directory</a>', "vicar_vgrkey.pro", "", "", " NAME: 	vicar_vgrkey    PURPOSE: 	Return keyword values from a Voyager vicar label.    CATEGORY: 	UTIL/SEDR    CALLING SEQUENCE: 	result = vicar_vgrkey(label, keyword)    ARGUMENTS:   INPUT:  	label:		A label/header from a Voyager VICAR image  	keyword:	A string array of one or more supported keywords: 			SCNUM : Spacecraft number (1 or 2) 			FDS   : Flight Data Subsystem count (hhhhh.mm) 			SCTIME: FDS x 100 (no decimal) 			PICNO : Picture number (nnnnPm+ddd) 			PLANET: Planet of encounter (from PICNO) 			SCET  : Spacecraft Event Time (yy.ddd hh:mm:ss) 			ERT   : Earth Receive Time (yy.ddd hh:mm:ss) 			CAMERA: Image camera (NA or WA) 			EXP   : Exposure in milliseconds 			FILNUM: Filter wheel position number 			FILTER: Filter 			SCAN  : Scan rate (1, 3, 5, or 10) 			MODE  : Camera mode (NAONLY, WAONLY or BOTSIM) 			GAIN  : Camera gain (LO or HI)     OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    PROCEDURE: 	Searchs a Voyager VICAR label for supported input keyword values 	and returns them as an array of strings.  If the number of values 	is one, then a scalar is returned rather than an array of dim =[1]    RESTRICTIONS: 	NONE.    STATUS: 	Complete.    MODIFICATION HISTORY: 	Written by:    Haemmerle, 1/1999 	               using ideas from S. Ewald 10/98 	               and the VICAR routine ABLE77V2   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/sedr/vicar_vgrkey.html#vicar_vgrkey", "vicar_vgrkey", 'routine in <a href="config/sedr/vicar_vgrkey.html">vicar_vgrkey.pro</a>', "vicar_vgrkey.pro", "", "vicar_vgrkey", "", "labelkeyword", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/vicar/vicdelpar.html", "vicdelpar.pro", '.pro file in <a href="config/vicar/dir-overview.html">config/vicar/ directory</a>', "vicdelpar.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/vicar/vicdelpar.html#vicdelpar", "vicdelpar", 'routine in <a href="config/vicar/vicdelpar.html">vicdelpar.pro</a>', "vicdelpar.pro", "", "vicdelpar", "", "labelkeyword", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/vicar/vicgetpar.html", "vicgetpar.pro", '.pro file in <a href="config/vicar/dir-overview.html">config/vicar/ directory</a>', "vicgetpar.pro", "", "", " NAME: 	vicgetpar    PURPOSE: 	Reads the value of a VICAR label keyword.    CATEGORY: 	UTIL/VIC    CALLING SEQUENCE: 	value = vicgetpar(label, keyword)    ARGUMENTS:   INPUT: 	label:		String array giving the VICAR label.  	keyword:	String giving the keyword whose value is to be obtained.    OUTPUT: NONE    KEYWORDS:   INPUT: 	string:		If set, the value will be returned as the exact string 			read from the label instead of converting it based 			quotes.    OUTPUT: 	pos:		Position of keyword in label.  	status:		If no errors occur, status will be zero, otherwise 			it will be a string giving an error message.  If the 			keyword is not found, status will contain a message.    RETURN: 	The data array read from the file.    STATUS: 	Complete    RESTRICTIONS: 	Will not work for keyword values in which strings contain commas as 	it is used as the delimiter.    SEE ALSO: 	vicsetpar    MODIFICATION HISTORY:  	Written by:	Spitale, 5/1996 	Modified by:	Haemmerle, 10/2000  (add arrays)   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/vicar/vicgetpar.html#vgp_get_lab_pair", "vgp_get_lab_pair", 'routine in <a href="config/vicar/vicgetpar.html">vicgetpar.pro</a>', "vicgetpar.pro", "", "vgp_get_lab_pair", "", "labelpos", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/vicar/vicgetpar.html#vicgetpar", "vicgetpar", 'routine in <a href="config/vicar/vicgetpar.html">vicgetpar.pro</a>', "vicgetpar.pro", "", "vicgetpar", "", "statusposstringlabelkeyword", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/vicar/vicsetpar.html", "vicsetpar.pro", '.pro file in <a href="config/vicar/dir-overview.html">config/vicar/ directory</a>', "vicsetpar.pro", "", "", " NAME: 	vicsetpar    PURPOSE: 	Add, delete, or change a keyword/value pair in a VICAR label.    CATEGORY: 	UTIL/VIC    CALLING SEQUENCE: 	vicsetpar, label, keyword, value    ARGUMENTS:   INPUT: 	label:		String array giving the VICAR label.  	keyword:	String giving the keyword whose value is to be set. 			If the keyword is not found, it will be added.  	value:		Value for the given keyword.    OUTPUT: NONE    KEYWORDS:   INPUT: 	delete:		If set, the keyword/value pair will be deleted from the 			label, if found.  	prepend:	If set, and if the keyword doesn't already exist, it 			will be prepended instead of appended.  	pad:		If set, spaces are added to the end of the keyword/value 			pair to attain this length, not including the two 			spaces before the following keyword.    OUTPUT: 	pos:		Position at which the keyword was placed in the label.  	status:		If no errors occur, status will be zero, otherwise 			it will be a string giving an error message.    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	vicgetpar    MODIFICATION HISTORY:  	Written by:	Spitale, 5/1996 	Spitale 2/2004:	Added /prepend 	Spitale 6/2004:	Added pad keyword   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/vicar/vicsetpar.html#vicsetpar", "vicsetpar", 'routine in <a href="config/vicar/vicsetpar.html">vicsetpar.pro</a>', "vicsetpar.pro", "", "vicsetpar", "", "statusposdeleteprependpadlabelkeywordvalue", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/vims/vims_body_to_image.html", "vims_body_to_image.pro", '.pro file in <a href="config/cas/vims/dir-overview.html">config/cas/vims/ directory</a>', "vims_body_to_image.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/vims/vims_body_to_image.html#vims_body_to_image", "vims_body_to_image", 'routine in <a href="config/cas/vims/vims_body_to_image.html">vims_body_to_image.pro</a>', "vims_body_to_image.pro", "", "vims_body_to_image", "", "cdbxv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/vims/vims_body_to_inertial.html", "vims_body_to_inertial.pro", '.pro file in <a href="config/cas/vims/dir-overview.html">config/cas/vims/ directory</a>', "vims_body_to_inertial.pro", "", "", " NAME: 	bod_body_to_inertial    PURPOSE: 	Transforms the given column vectors from the body coordinate 	system to the inertial coordinate system.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	inertial_pts = bod_body_to_inertial(bx, body_pts)    ARGUMENTS:   INPUT: 	bx:	 	Any subclass of BODY.  	body_pts:	Array (nv,3,nt) of column vectors in the body frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN: 	Array (nv,3,nt) of column vectors in the bx inertial frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/vims/vims_body_to_inertial.html#vims_body_to_inertial", "vims_body_to_inertial", 'routine in <a href="config/cas/vims/vims_body_to_inertial.html">vims_body_to_inertial.pro</a>', "vims_body_to_inertial.pro", "", "vims_body_to_inertial", "", "bdvcamvecs", "          -1", "");
  
  

libdata[libdataItem++] = new Array("demo/vims_example.html", "vims_example.pro", '.pro file in <a href="demo/dir-overview.html">demo/ directory</a>', "vims_example.pro", "", "", " VIMS EXAMPLE     This script demonstrates reading Cassini RADAR VIMS cubes and projecting them    onto an equirectangular mosaic.     The data files are provided in the demo/data directory.     Setup: The instrument detectors, translators and transforms must contain the    VIMS definitions, as is included in demo/data/instrument_detectors.tab,    demo/data/translators.tab, and demo/data/transforms.tab.     This example requires SPICE/Icy to have been setup. It can be run just by doing: <span class= code-output > .run vims_example</span>    from within an OMINAS IDL session.    Read VIMS files       Set up a hash containing the file names and precomputed pointing offsets: <span class= code-output > hdxy=hash()</span> <span class= code-output > hdxy['CM_1559100372_1_ir_eg.cub']=[-2d0,-2d0]</span> <span class= code-output > hdxy['CM_1503358311_1_ir_eg.cub']=[5d0,-1d0]</span> <span class= code-output > hdxy['CM_1477456632_1_ir_eg.cub']=[2d0,-3d0]</span> <span class= code-output > hdxy['CM_1504754217_1_ir_eg.cub']=[1d0,-2d0]</span>  <span class= code-output > files=getenv('OMINAS_DIR')+'/demo/data/'+((hdxy.keys()).toarray())</span> <span class= code-output > n = n_elements(files)</span> <span class= code-output > dd = dat_read(files)</span> <span class= code-output > foreach ddd,dd do dat_set_data,ddd,0.&gt;dat_data(ddd)&lt;0.1</span>   Set up descriptors needed to make the grids and mosaic       Create an array of global descriptors and populate it: <span class= code-output > gd = replicate({cd:obj_new(),cds:objarr(256), gbx:obj_new(), dkx:obj_new(), sund:obj_new()}, n)</span> <span class= code-output > for i=0, n-1 do gd[i].cds = pg_get_cameras(dd[i])</span> <span class= code-output > for i=0, n-1 do gd[i].cd=gd[i].cds[0]</span> <span class= code-output > for i=0, n-1 do gd[i].gbx = pg_get_planets(dd[i], od=gd[i].cd, name='TITAN')</span> <span class= code-output > for i=0, n-1 do gd[i].sund = pg_get_stars(dd[i], od=gd[i].cd, name='SUN')</span>      Apply the pointing shifts and compute the limbs: <span class= code-output > limb_ps = objarr(n)</span> <span class= code-output > dxy = dblarr(2,n)</span> <span class= code-output > for i=0, n-1 do dxy[*,i] = hdxy[file_basename(files[i])]</span> <span class= code-output > for i=0, n-1 do for j=0,255 do pg_repoint, dxy[*,i], 0d, cd=gd[i].cds[j]</span> <span class= code-output > for i=0, n-1 do gd[i].cd=gd[i].cds[0]</span> <span class= code-output > for i=0, n-1 do limb_ps[i] = pg_limb(gd=gd[i]);</span>   Display an image of one of the bands with a limb and grid on top       Create an array of global descriptors and populate it: <span class= code-output > xsize=800</span> <span class= code-output > ysize=800</span> <span class= code-output > zoom=8</span> <span class= code-output > offset=[-20,-20]</span> <span class= code-output > for i=0, n-1 do begin</span> <span class= code-output >   tvim, (dat_data(dd[i]))[*,*,70], $</span> <span class= code-output >     zoom=zoom,/order, /new,offset=offset,$</span> <span class= code-output >     xsize=xsize,ysize=ysize</span> <span class= code-output >   pg_draw, limb_ps[i]</span> <span class= code-output >   write_png,tvrd()</span> <span class= code-output > endfor</span> <span class= code-output > tvim, /list, wnum=ww</span>      Create and draw the lat/lon grid and labels: <span class= code-output > imc=0</span> <span class= code-output > for i=0,n-1 do begin</span> <span class= code-output >   grid_ps = pg_grid(gd=gd[i], lat=lat, lon=lon)</span> <span class= code-output >   pg_hide, grid_ps, cd=gd[i].cd, gbx=gd[i].gbx</span> <span class= code-output >   pg_hide, grid_ps, cd=gd[i].cd, gbx=gd[i].gbx,$</span> <span class= code-output >     od=gd[i].sund</span> <span class= code-output >   pg_draw, grid_ps, color=ctblue(),wnum=ww[i]</span> <span class= code-output >   plat_ps = pg_grid(gd=gd[i],slon=!dpi/2d,lat=lat,nlon=0)</span> <span class= code-output >   pg_hide, plat_ps[0], cd=gd[i].cd, gbx=gd[0].gbx</span> <span class= code-output >   pg_draw, plat_ps[0], psym=3, $</span> <span class= code-output >     plabel=strtrim(round(lat*180d/!dpi),2),$</span> <span class= code-output >     /label_p,wnum=ww[i]</span> <span class= code-output >   plon_ps = pg_grid(gd=gd[i], slat=0d, lon=lon, nlat=0)</span> <span class= code-output >   pg_hide, plon_ps[0], cd=gd[i].cd, gbx=gd[i].gbx</span> <span class= code-output >   pg_draw, plon_ps[0], psym=3, $</span> <span class= code-output >     plabel=strtrim(round(lon*180d/!dpi),2),$</span> <span class= code-output >     /label_p,wnum=ww[i]</span> <span class= code-output > endfor</span>      These 4 images would look like                               ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("config/cas/vims/vims_focal_to_image_linear.html", "vims_focal_to_image_linear.pro", '.pro file in <a href="config/cas/vims/dir-overview.html">config/cas/vims/ directory</a>', "vims_focal_to_image_linear.pro", "", "", " NAME: 	cam_focal_to_image_linear    PURPOSE:        Transforms the given array of points in the focal plane        coordinate system to an array of points in the image        coordinate system using a linear model that assumes that        distances in the image are proportional to angles in the focal        plane.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	image_pts = cam_focal_to_image_linear(cd, focal_pts)    ARGUMENTS:   INPUT: 	cd:	        Array (nt) of CAMERA descriptors.  	focal_pts:	Array (2,nv,nt) of points in the camera focal frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (2,nv,nt) of points in the image coordinate system.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/vims/vims_focal_to_image_linear.html#vims_focal_to_image_linear", "vims_focal_to_image_linear", 'routine in <a href="config/cas/vims/vims_focal_to_image_linear.html">vims_focal_to_image_linear.pro</a>', "vims_focal_to_image_linear.pro", "", "vims_focal_to_image_linear", "", "cdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/vims/vims_image_to_focal_linear.html", "vims_image_to_focal_linear.pro", '.pro file in <a href="config/cas/vims/dir-overview.html">config/cas/vims/ directory</a>', "vims_image_to_focal_linear.pro", "", "", " NAME: 	cam_image_to_focal_linear    PURPOSE:        Transforms the given array of points in the image coordinate        system to an array of points in the camera focal plane        coordinate system using a linear model that assumes that        distances in the image are proportional to angles in the focal        plane.    CATEGORY: 	NV/LIB/CAM    CALLING SEQUENCE: 	focal_pts = cam_image_to_focal_linear(cd, image_pts)    ARGUMENTS:   INPUT: 	cd:	        Array (nt) of CAMERA descriptors.  	image_pts:	Array (2,nv,nt) of points in the image coordinate system.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (2,nv,nt) of points in the camera focal frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/vims/vims_image_to_focal_linear.html#vims_image_to_focal_linear", "vims_image_to_focal_linear", 'routine in <a href="config/cas/vims/vims_image_to_focal_linear.html">vims_image_to_focal_linear.pro</a>', "vims_image_to_focal_linear.pro", "", "vims_image_to_focal_linear", "", "cdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/vims/vims_inertial_to_body_pos.html", "vims_inertial_to_body_pos.pro", '.pro file in <a href="config/cas/vims/dir-overview.html">config/cas/vims/ directory</a>', "vims_inertial_to_body_pos.pro", "", "", " NAME: 	bod_inertial_to_body_pos    PURPOSE:        Transforms the given column position vectors from the inertial        coordinate system to the body coordinate system.    CATEGORY: 	NV/LIB/BOD    CALLING SEQUENCE: 	body_pts = bod_inertial_to_body_pos(bx, inertial_pts)    ARGUMENTS:   INPUT: 	bx:	 	Array (nt) of any subclass of BODY descriptors.  	inertial_pts:	Array (nv,3,nt) of column POSITION vectors in the inertial frame.    OUTPUT: NONE    KEYWORDS:   INPUT: NONE    OUTPUT: NONE    RETURN:        Array (nv,3,nt) of column position vectors in the bx body        frame.    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/vims/vims_inertial_to_body_pos.html#vims_inertial_to_body_pos", "vims_inertial_to_body_pos", 'routine in <a href="config/cas/vims/vims_inertial_to_body_pos.html">vims_inertial_to_body_pos.pro</a>', "vims_inertial_to_body_pos.pro", "", "vims_inertial_to_body_pos", "", "bdv", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/vims/vims_spice_fk_detect.html", "vims_spice_fk_detect.pro", '.pro file in <a href="config/cas/vims/dir-overview.html">config/cas/vims/ directory</a>', "vims_spice_fk_detect.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/vims/vims_spice_fk_detect.html#vims_spice_fk_detect", "vims_spice_fk_detect", 'routine in <a href="config/cas/vims/vims_spice_fk_detect.html">vims_spice_fk_detect.pro</a>', "vims_spice_fk_detect.pro", "", "vims_spice_fk_detect", "", "timerejectstrictallscddkpath", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/vims/vims_spice_ik_detect.html", "vims_spice_ik_detect.pro", '.pro file in <a href="config/cas/vims/dir-overview.html">config/cas/vims/ directory</a>', "vims_spice_ik_detect.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/vims/vims_spice_ik_detect.html#vims_spice_ik_detect", "vims_spice_ik_detect", 'routine in <a href="config/cas/vims/vims_spice_ik_detect.html">vims_spice_ik_detect.pro</a>', "vims_spice_ik_detect.pro", "", "vims_spice_ik_detect", "", "timerejectstrictallscddkpath", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/vims/vims_spice_input.html", "vims_spice_input.pro", '.pro file in <a href="config/cas/vims/dir-overview.html">config/cas/vims/ directory</a>', "vims_spice_input.pro", "", "", " NAME: 	vims_spice_input    PURPOSE: 	NAIF/SPICE input translator for Cassini.    CATEGORY: 	NV/CONFIG    CALLING SEQUENCE: 	result = cas_spice_input(dd, keyword)    ARGUMENTS:   INPUT: 	dd:		Data descriptor.  	keyword:	String giving the name of the translator quantity.     OUTPUT: 	NONE    KEYWORDS:   INPUT: 	key1:		Camera descriptor.    OUTPUT: 	status:		Zero if valid data is returned.  	n_obj:		Number of objects returned.  	dim:		Dimensions of return objects.     TRANSLATOR KEYWORDS: 	ref:		Name of the reference frame for the output quantities. 			Default is 'j2000'.  	j2000:		/j2000 is equivalent to specifying ref=j2000.  	b1950:		/b1950 is equivalent to specifying ref=b1950.  	klist:		Name of a file giving a list of SPICE kernels to use. 			If no path is included, the path is taken from the 			NV_SPICE_KER environment variable.  	ck_in:		List of input C kernel files to use.  List must be 			delineated by semimcolons with no space.  The kernel 			list file is still used, but these kernels take 			precedence.  Entries in this list may be file 			specification strings.  	planets:	List of planets to for which to request ephemeris. 			Must be delineated by semicolons with no space.  	reload:		If set, new kernels are loaded, as specified by the 			klist and ck_in keywords.    RETURN: 	Data associated with the requested keyword.    STATUS: 	Complete    SEE ALSO: 	cas_spice_output    MODIFICATION HISTORY:  	Written by:	Spitale, 10/2002   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/vims/vims_spice_input.html#vims_spice_parse_labels", "vims_spice_parse_labels", 'routine in <a href="config/cas/vims/vims_spice_input.html">vims_spice_input.pro</a>', "vims_spice_input.pro", "", "vims_spice_parse_labels", "", "exposuresizefiltersoaxistargetendjdstartjddd_time", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/cas/vims/vims_spice_input.html#vims_spice_cameras", "vims_spice_cameras", 'routine in <a href="config/cas/vims/vims_spice_input.html">vims_spice_input.pro</a>', "vims_spice_input.pro", "", "vims_spice_cameras", "", "posconstantsn_objdimstatustimeorientobsddref", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/cas/vims/vims_spice_input.html#vims_spice_planets", "vims_spice_planets", 'routine in <a href="config/cas/vims/vims_spice_input.html">vims_spice_input.pro</a>', "vims_spice_input.pro", "", "vims_spice_planets", "", "timeplanetsn_objdimstatustarg_listconstantsobsddref", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/cas/vims/vims_spice_input.html#vims_spice_sun", "vims_spice_sun", 'routine in <a href="config/cas/vims/vims_spice_input.html">vims_spice_input.pro</a>', "vims_spice_input.pro", "", "vims_spice_sun", "", "n_objdimconstantsstatustimeobsddref", "          -1", "");
  
  libdata[libdataItem++] = new Array("config/cas/vims/vims_spice_input.html#vims_spice_input", "vims_spice_input", 'routine in <a href="config/cas/vims/vims_spice_input.html">vims_spice_input.pro</a>', "vims_spice_input.pro", "", "vims_spice_input", "", "n_objdimvaluesstatusddkeyword@nv_trs_keywords_include.pro", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/vims/vims_spice_sc.html", "vims_spice_sc.pro", '.pro file in <a href="config/cas/vims/dir-overview.html">config/cas/vims/ directory</a>', "vims_spice_sc.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/vims/vims_spice_sc.html#vims_spice_sc", "vims_spice_sc", 'routine in <a href="config/cas/vims/vims_spice_sc.html">vims_spice_sc.pro</a>', "vims_spice_sc.pro", "", "vims_spice_sc", "", "dd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/vims/vims_spice_sck_detect.html", "vims_spice_sck_detect.pro", '.pro file in <a href="config/cas/vims/dir-overview.html">config/cas/vims/ directory</a>', "vims_spice_sck_detect.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/vims/vims_spice_sck_detect.html#vims_spice_sck_detect", "vims_spice_sck_detect", 'routine in <a href="config/cas/vims/vims_spice_sck_detect.html">vims_spice_sck_detect.pro</a>', "vims_spice_sck_detect.pro", "", "vims_spice_sck_detect", "", "timerejectstrictallscddkpath", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/cas/vims/vims_spice_time.html", "vims_spice_time.pro", '.pro file in <a href="config/cas/vims/dir-overview.html">config/cas/vims/ directory</a>', "vims_spice_time.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/cas/vims/vims_spice_time.html#vims_spice_time", "vims_spice_time", 'routine in <a href="config/cas/vims/vims_spice_time.html">vims_spice_time.pro</a>', "vims_spice_time.pro", "", "vims_spice_time", "", "dtstatusstartjdendjdlabel", "          -1", "");
  
  

libdata[libdataItem++] = new Array("demo/voyager-cp_example.html", "voyager-cp_example.pro", '.pro file in <a href="demo/dir-overview.html">demo/ directory</a>', "voyager-cp_example.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("demo/voyager-pn.example.html", "voyager-pn.example.pro", '.pro file in <a href="demo/dir-overview.html">demo/ directory</a>', "voyager-pn.example.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("util/vtaylor.html", "vtaylor.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "vtaylor.pro", "", "", " NAME:        vtaylor    PURPOSE:        Evaluates a taylor series using the given t=0 derivatives, dv, at        each time t=dt.    CATEGORY:        UTIL    CALLING SEQUENCE:        result = vtaylor(dv, dt)    ARGUMENTS:   INPUT:        dv:    dblarr(ndv,nelm)         dt:    dblarr(ndt)    OUTPUT:        NONE   RETURN:        dblarr(ndt,nelm)   RESTRICTIONS:        Works for column vectors - not scalars   STATUS:        Works, but coeff not implemented    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/vtaylor.html#vtaylor", "vtaylor", 'routine in <a href="util/vtaylor.html">vtaylor.pro</a>', "vtaylor.pro", "", "vtaylor", "", "coeff_dv_dt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/vtaylor_full.html", "vtaylor_full.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "vtaylor_full.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/vtaylor_full.html#vtaylor_full", "vtaylor_full", 'routine in <a href="util/vtaylor_full.html">vtaylor_full.pro</a>', "vtaylor_full.pro", "", "vtaylor_full", "", "dvdt", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/w_to_nd.html", "w_to_nd.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "w_to_nd.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/w_to_nd.html#w_to_nd", "w_to_nd", 'routine in <a href="util/w_to_nd.html">w_to_nd.pro</a>', "w_to_nd.pro", "", "w_to_nd", "", "_dim_w", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/w_to_xy.html", "w_to_xy.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "w_to_xy.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/w_to_xy.html#w_to_xy", "w_to_xy", 'routine in <a href="util/w_to_xy.html">w_to_xy.pro</a>', "w_to_xy.pro", "", "w_to_xy", "", "sxsyimw", "          -1", "");
  
  

libdata[libdataItem++] = new Array("nv/obj/tools/warp_cp.html", "warp_cp.pro", '.pro file in <a href="nv/obj/tools/dir-overview.html">nv/obj/tools/ directory</a>', "warp_cp.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("nv/obj/tools/warp_cp.html#wcp_add_quad", "wcp_add_quad", 'routine in <a href="nv/obj/tools/warp_cp.html">warp_cp.pro</a>', "warp_cp.pro", "", "wcp_add_quad", "", "triijquadnquadqtrip0", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/tools/warp_cp.html#wcp_longest_side", "wcp_longest_side", 'routine in <a href="nv/obj/tools/warp_cp.html">warp_cp.pro</a>', "warp_cp.pro", "", "wcp_longest_side", "", "p0tripq", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/tools/warp_cp.html#wcp_requadrangulate", "wcp_requadrangulate", 'routine in <a href="nv/obj/tools/warp_cp.html">warp_cp.pro</a>', "warp_cp.pro", "", "wcp_requadrangulate", "", "p0triqtri", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/tools/warp_cp.html#wcp_map_quad_coords", "wcp_map_quad_coords", 'routine in <a href="nv/obj/tools/warp_cp.html">warp_cp.pro</a>', "warp_cp.pro", "", "wcp_map_quad_coords", "", "x0y0p0p1quadx1y1", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/tools/warp_cp.html#wcp_map_quad", "wcp_map_quad", 'routine in <a href="nv/obj/tools/warp_cp.html">warp_cp.pro</a>', "warp_cp.pro", "", "wcp_map_quad", "", "cdinterpimagep0p1quadtriqtrisize", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/tools/warp_cp.html#wcp_map_tri_coords", "wcp_map_tri_coords", 'routine in <a href="nv/obj/tools/warp_cp.html">warp_cp.pro</a>', "warp_cp.pro", "", "wcp_map_tri_coords", "", "x0y0p0p1trix1y1", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/tools/warp_cp.html#wcp_map_tri", "wcp_map_tri", 'routine in <a href="nv/obj/tools/warp_cp.html">warp_cp.pro</a>', "warp_cp.pro", "", "wcp_map_tri", "", "cdimagep0p1trisize", "          -1", "");
  
  libdata[libdataItem++] = new Array("nv/obj/tools/warp_cp.html#warp_cp", "warp_cp", 'routine in <a href="nv/obj/tools/warp_cp.html">warp_cp.pro</a>', "warp_cp.pro", "", "warp_cp", "", "cdsizequadinterpimagep0p1", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/wavelet1d.html", "wavelet1d.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "wavelet1d.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/wavelet1d.html#wavelet1d", "wavelet1d", 'routine in <a href="util/wavelet1d.html">wavelet1d.pro</a>', "wavelet1d.pro", "", "wavelet1d", "", "llkklmaxkmaxpsiaspectdescale_xw0", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/wavelet1d.html#test", "test", 'routine in <a href="util/wavelet1d.html">wavelet1d.pro</a>', "wavelet1d.pro", "", "test", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/wavelet2d.html", "wavelet2d.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "wavelet2d.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/wavelet2d.html#wavelet1d", "wavelet1d", 'routine in <a href="util/wavelet2d.html">wavelet2d.pro</a>', "wavelet2d.pro", "", "wavelet1d", "", "l_zw0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/west_to_east_longitude.html", "west_to_east_longitude.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "west_to_east_longitude.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/west_to_east_longitude.html#west_to_east_longitude", "west_to_east_longitude", 'routine in <a href="util/west_to_east_longitude.html">west_to_east_longitude.pro</a>', "west_to_east_longitude.pro", "", "west_to_east_longitude", "", "lon", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/which.html", "which.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "which.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/which.html#which", "which", 'routine in <a href="util/which.html">which.pro</a>', "which.pro", "", "which", "", "outputname", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/widget_find.html", "widget_find.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "widget_find.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/widget_find.html#wf_compare", "wf_compare", 'routine in <a href="util/widget_find.html">widget_find.pro</a>', "widget_find.pro", "", "wf_compare", "", "x_x", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/widget_find.html#wf_descend", "wf_descend", 'routine in <a href="util/widget_find.html">widget_find.pro</a>', "widget_find.pro", "", "wf_descend", "", "valueuvaluefirstid", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/widget_find.html#widget_find", "widget_find", 'routine in <a href="util/widget_find.html">widget_find.pro</a>', "widget_find.pro", "", "widget_find", "", "valueuvaluefirst", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/widget_get_mbar_height.html", "widget_get_mbar_height.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "widget_get_mbar_height.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/widget_get_mbar_height.html#widget_get_mbar_height", "widget_get_mbar_height", 'routine in <a href="util/widget_get_mbar_height.html">widget_get_mbar_height.pro</a>', "widget_get_mbar_height.pro", "", "widget_get_mbar_height", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/widget_parm.html", "widget_parm.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "widget_parm.pro", "", "", " NAME: 	widget_parm    PURPOSE: 	Generic widget interface for varying parameters.    CATEGORY: 	UTIL    CALLING SEQUENCE: 	base = widget_parm(parm, callback=callback)    ARGUMENTS:   INPUT: 	parm:	Structure specifying the parameters to vary.  Format is:  		{<name>: <value>, [opt1]_<name>:<items>, [opt2]_<name>:<items>, ...}  		where <name> is the parameter name, <value> is the initial 		value, [opt] depends on the type of parameter, and <items> 		is an array of items specific to the option.  Parameter types are 		as follows:  		Numeric:	Input is varied via a slider widget.  Options are: 				 RANGE:	Upper and lower bounds for the slider. 				 UNITS:	Value to convert units for display.  		String input:	Input is given using a text widget.  There is 				no [option].  		String select:	Input is given using droplist whose items are 				given by the <items> array with the [option] 				'OPTION'.    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	callback:	String giving the name of a prodcedure to be called 			whenever the parameters are updated.  	data:		Data to be passed to the callback procedure as the 			sole argument.  	title:		String giving the title for the widget base.  	xsize:		Width of widget in pixels.    OUTPUT: NONE    RETURN: Widget ID of the base widget.    OPERATION: 	Widget_parm operates in two modes: continuous and manual, toggled using 	the CONTINUOUS button.  In continuous mode, the callback procedure is 	call whenever any parameter is changed.  In manual mode, the callback 	procedure is called only when the UPDATE button is preseed.    EXAMPLE: 	base = widget_parm( $ 	           { x:10,		range_x:[0,100], $ 		     y:5,		range_y:[0,10], units_y: !dpi/180, $ 		     s:'test', $ 		     ss:'option 1',	options_ss:['option 1', 'option 2'] }, $ 		    callback='test_callback')    STATUS: 	Complete    MODIFICATION HISTORY:  	Written by:	Spitale		5/2017   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/widget_parm.html#wprm_widget_to_value", "wprm_widget_to_value", 'routine in <a href="util/widget_parm.html">widget_parm.pro</a>', "widget_parm.pro", "", "wprm_widget_to_value", "", "displayid", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/widget_parm.html#wprm_value_to_widget", "wprm_value_to_widget", 'routine in <a href="util/widget_parm.html">widget_parm.pro</a>', "widget_parm.pro", "", "wprm_value_to_widget", "", "idparm", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/widget_parm.html#wprm_parm_to_widget", "wprm_parm_to_widget", 'routine in <a href="util/widget_parm.html">widget_parm.pro</a>', "widget_parm.pro", "", "wprm_parm_to_widget", "", "dataparm", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/widget_parm.html#wprm_widget_to_parm", "wprm_widget_to_parm", 'routine in <a href="util/widget_parm.html">widget_parm.pro</a>', "widget_parm.pro", "", "wprm_widget_to_parm", "", "data", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/widget_parm.html#wprm_update", "wprm_update", 'routine in <a href="util/widget_parm.html">widget_parm.pro</a>', "widget_parm.pro", "", "wprm_update", "", "data", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/widget_parm.html#widget_parm_event", "widget_parm_event", 'routine in <a href="util/widget_parm.html">widget_parm.pro</a>', "widget_parm.pro", "", "widget_parm_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/widget_parm.html#wprm_get_value", "wprm_get_value", 'routine in <a href="util/widget_parm.html">widget_parm.pro</a>', "widget_parm.pro", "", "wprm_get_value", "", "defaultparm0prefixname", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/widget_parm.html#widget_parm", "widget_parm", 'routine in <a href="util/widget_parm.html">widget_parm.pro</a>', "widget_parm.pro", "", "widget_parm", "", "titlexsizecallbackdataparm0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/widget_pickfiles.html", "widget_pickfiles.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "widget_pickfiles.pro", "", "", " NAME: 	xx    PURPOSE: 	xx    CATEGORY: 	UTIL    CALLING SEQUENCE: 	result = xx(xx, xx) 	xx, xx, xx    ARGUMENTS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    KEYWORDS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    ENVIRONMENT VARIABLES: 	xx:	xx  	xx:	xx    RETURN: 	xx    COMMON BLOCKS: 	xx:	xx  	xx:	xx    SIDE EFFECTS: 	xx    RESTRICTIONS: 	xx    PROCEDURE: 	xx    EXAMPLE: 	xx    STATUS: 	xx    SEE ALSO: 	xx, xx, xx    MODIFICATION HISTORY:  	Written by:	xx, xx/xx/xxxx   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/widget_pickfiles.html#wpf_clean", "wpf_clean", 'routine in <a href="util/widget_pickfiles.html">widget_pickfiles.pro</a>', "widget_pickfiles.pro", "", "wpf_clean", "", "path", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/widget_pickfiles.html#wpf_get_dirs", "wpf_get_dirs", 'routine in <a href="util/widget_pickfiles.html">widget_pickfiles.pro</a>', "widget_pickfiles.pro", "", "wpf_get_dirs", "", "data", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/widget_pickfiles.html#wpf_get_files", "wpf_get_files", 'routine in <a href="util/widget_pickfiles.html">widget_pickfiles.pro</a>', "widget_pickfiles.pro", "", "wpf_get_files", "", "data", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/widget_pickfiles.html#wpf_filter_event", "wpf_filter_event", 'routine in <a href="util/widget_pickfiles.html">widget_pickfiles.pro</a>', "widget_pickfiles.pro", "", "wpf_filter_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/widget_pickfiles.html#wpf_call_ok", "wpf_call_ok", 'routine in <a href="util/widget_pickfiles.html">widget_pickfiles.pro</a>', "widget_pickfiles.pro", "", "wpf_call_ok", "", "data", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/widget_pickfiles.html#wpf_sel_text_event", "wpf_sel_text_event", 'routine in <a href="util/widget_pickfiles.html">widget_pickfiles.pro</a>', "widget_pickfiles.pro", "", "wpf_sel_text_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/widget_pickfiles.html#wpf_sel_list_event", "wpf_sel_list_event", 'routine in <a href="util/widget_pickfiles.html">widget_pickfiles.pro</a>', "widget_pickfiles.pro", "", "wpf_sel_list_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/widget_pickfiles.html#wpf_file_list_event", "wpf_file_list_event", 'routine in <a href="util/widget_pickfiles.html">widget_pickfiles.pro</a>', "widget_pickfiles.pro", "", "wpf_file_list_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/widget_pickfiles.html#wpf_dir_list_event", "wpf_dir_list_event", 'routine in <a href="util/widget_pickfiles.html">widget_pickfiles.pro</a>', "widget_pickfiles.pro", "", "wpf_dir_list_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/widget_pickfiles.html#wpf_cancel_event", "wpf_cancel_event", 'routine in <a href="util/widget_pickfiles.html">widget_pickfiles.pro</a>', "widget_pickfiles.pro", "", "wpf_cancel_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/widget_pickfiles.html#wpf_button_event", "wpf_button_event", 'routine in <a href="util/widget_pickfiles.html">widget_pickfiles.pro</a>', "widget_pickfiles.pro", "", "wpf_button_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/widget_pickfiles.html#widget_pickfiles", "widget_pickfiles", 'routine in <a href="util/widget_pickfiles.html">widget_pickfiles.pro</a>', "widget_pickfiles.pro", "", "widget_pickfiles", "", "pathonefiltercancel_callbackok_callbackmust_existbutton_basedefaultok_buttonparent", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/width_2d.html", "width_2d.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "width_2d.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/width_2d.html#width_2d", "width_2d", 'routine in <a href="util/width_2d.html">width_2d.pro</a>', "width_2d.pro", "", "width_2d", "", "data", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/wrap_range.html", "wrap_range.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "wrap_range.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/wrap_range.html#wrap_range", "wrap_range", 'routine in <a href="util/wrap_range.html">wrap_range.pro</a>', "wrap_range.pro", "", "wrap_range", "", "xmax", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/write_bin_file.html", "write_bin_file.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "write_bin_file.pro", "", "", " NAME: 	write_bin_file    PURPOSE: 	Writes data to a binary file.    CATEGORY: 	UTIL    CALLING SEQUENCE: 	write_bin_file, fname, data    ARGUMENTS:   INPUT: 	fname:	Name of file to read.  	data:	Data to write to the file.    OUTPUT: NONE    KEYWORDS:   INPUT: 	append:	If set, the data will be appended if the file already exists.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO:    MODIFICATION HISTORY:  	Written by:	Spitale, 11/1994   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/write_bin_file.html#write_bin_file", "write_bin_file", 'routine in <a href="util/write_bin_file.html">write_bin_file.pro</a>', "write_bin_file.pro", "", "write_bin_file", "", "appendfnamedata", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/fits/write_fits.html", "write_fits.pro", '.pro file in <a href="config/fits/dir-overview.html">config/fits/ directory</a>', "write_fits.pro", "", "", " NAME: 	write_fits    PURPOSE: 	Writes an an IDL array into a disk FITS file.    CATEGORY: 	UTIL/FITS    CALLING SEQUENCE: 	writefits, filename, data [,header]    ARGUMENTS:   INPUT: 	filename:	String containing the name of the file to be written.  	data:		Image array to be written to FITS file.  	header:		String array containing the header for the FITS file. 			If variable HEADER is not given, the program will 			generate a minimal FITS header.    OUTPUT: NONE    KEYWORDS:   INPUT: 	NaNvalue:	Value in the data array to be set to the IEEE NaN 			condition.  This is the FITS representation of undefined  			values.  	silent:		If set, suppress superfluous printed output.    OUTPUT: NONE    RETURN: NONE    RESTRICTIONS:        (1) It recommended that BSCALE and BZERO not be used (or set equal            to 1. and 0) with REAL*4 or REAL*8 data.        (2) WRITEFITS will remove any group parameters from the FITS header. 	(3) Does not handle groups or extensions.    EXAMPLE:        Write a randomn 50 x 50 array as a FITS file creating a minimal header.         IDL> im = randomn(seed, 50, 50)        ;Create array        IDL> writefits, 'test', im             ;Write to a FITS file  test     STATUS: 	Complete    SEE ALSO: 	read_fits    MODIFICATION HISTORY: 	WRITTEN, Jim Wofford, January, 29 1989        MODIFIED, Wayne Landsman, added BITPIX = -32,-64 support for UNIX        Fixed Unix bug when writing FITS header, 13-Feb-92        Use new BYTEODER keywords 22-Feb-92 	J.Spitale Jan 1998; changed name from 'writefits' to 'write_fits' 	Spitale, 3/2002 -- add silent keyword   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/fits/write_fits.html#write_fits", "write_fits", 'routine in <a href="config/fits/write_fits.html">write_fits.pro</a>', "write_fits.pro", "", "write_fits", "", "NaNvaluesilentfilenamedataheader", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/mask/write_mask.html", "write_mask.pro", '.pro file in <a href="config/mask/dir-overview.html">config/mask/ directory</a>', "write_mask.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/mask/write_mask.html#write_mask", "write_mask", 'routine in <a href="config/mask/write_mask.html">write_mask.pro</a>', "write_mask.pro", "", "write_mask", "", "dimsilentfilename_dataheader", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/multi/write_multi.html", "write_multi.pro", '.pro file in <a href="config/multi/dir-overview.html">config/multi/ directory</a>', "write_multi.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/multi/write_multi.html#write_multi", "write_multi", 'routine in <a href="config/multi/write_multi.html">write_multi.pro</a>', "write_multi.pro", "", "write_multi", "", "filename_data", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/occ/write_occ.html", "write_occ.pro", '.pro file in <a href="config/occ/dir-overview.html">config/occ/ directory</a>', "write_occ.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/occ/write_occ.html#write_occ", "write_occ", 'routine in <a href="config/occ/write_occ.html">write_occ.pro</a>', "write_occ.pro", "", "write_occ", "", "binsmoothinstrumenttime_offsettime_unitsresradfilename_times_dn_rad_lon", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/write_povray.html", "write_povray.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "write_povray.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/write_povray.html#write_povray", "write_povray", 'routine in <a href="util/write_povray.html">write_povray.pro</a>', "write_povray.pro", "", "write_povray", "", "filenamevertsfaces", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/tdl/write_tdl.html", "write_tdl.pro", '.pro file in <a href="config/tdl/dir-overview.html">config/tdl/ directory</a>', "write_tdl.pro", "", "", " NAME: 	write_tdl    PURPOSE: 	Writes a tab-delimited (tdl) text data file.  This is essentially 	a VICAR file, except that the data is written as tab-delimited 	text, suitable for reading into excel.  The label is written 	as the first line of the file.  You may need to use '.csv' file 	extensio for Excel to recognize the format.    CATEGORY: 	UTIL/TDL    CALLING SEQUENCE: 	write_tdl, filename, data, label    ARGUMENTS:   INPUT: 	filename:	String giving the name of the file to be written.  	data:		Data to be written.  	label:		String giving the tdl label.  System items 			will be added or changed as appropriate.  This is 			essentially a VICAR label, adabpted for this purpose.    OUTPUT: NONE    KEYWORDS:   INPUT: 	silent:	If set, no messages are printed.     OUTPUT: 	status:	If no errors occur, status will be zero, otherwise 		it will be a string giving an error message.    RETURN: NONE    RESTRICTIONS:  	This routine relies on the presence of the routines vigetpar 	and vicsetpar.    STATUS: 	Complete    SEE ALSO: 	read_tdl    MODIFICATION HISTORY:  	Written by:	Spitale, 1/2006   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/tdl/write_tdl.html#write_tdl", "write_tdl", 'routine in <a href="config/tdl/write_tdl.html">write_tdl.pro</a>', "write_tdl.pro", "", "write_tdl", "", "statussilentshowfilenamedatalabel", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/trk/write_trk.html", "write_trk.pro", '.pro file in <a href="config/trk/dir-overview.html">config/trk/ directory</a>', "write_trk.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/trk/write_trk.html#write_trk", "write_trk", 'routine in <a href="config/trk/write_trk.html">write_trk.pro</a>', "write_trk.pro", "", "write_trk", "", "radectargetstationfilenameetdata", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/write_txt_file.html", "write_txt_file.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "write_txt_file.pro", "", "", " NAME: 	write_txt_file    PURPOSE: 	Writes text to a file.    CATEGORY: 	UTIL    CALLING SEQUENCE: 	write_txt_file, fname, text    ARGUMENTS:   INPUT: 	fname:	Name of file to read.  	text:	Text to write to the file.    OUTPUT: NONE    KEYWORDS:   INPUT: 	append:	If set, the text will be appended if the file already exists.    OUTPUT: NONE    RETURN: NONE    STATUS: 	Complete    SEE ALSO: 	read_txt_file    MODIFICATION HISTORY:  	Written by:	Spitale, 11/1994   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/write_txt_file.html#write_txt_file", "write_txt_file", 'routine in <a href="util/write_txt_file.html">write_txt_file.pro</a>', "write_txt_file.pro", "", "write_txt_file", "", "appendfnametext", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/write_txt_table.html", "write_txt_table.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "write_txt_table.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/write_txt_table.html#write_txt_table", "write_txt_table", 'routine in <a href="util/write_txt_table.html">write_txt_table.pro</a>', "write_txt_table.pro", "", "write_txt_table", "", "headerdelimfnamedata", "          -1", "");
  
  

libdata[libdataItem++] = new Array("config/vicar/write_vicar.html", "write_vicar.pro", '.pro file in <a href="config/vicar/dir-overview.html">config/vicar/ directory</a>', "write_vicar.pro", "", "", " NAME: 	write_vicar    PURPOSE: 	Writes a vicar data file.    CATEGORY: 	UTIL/VIC    CALLING SEQUENCE: 	write_vicar, filename, data, label    ARGUMENTS:   INPUT: 	filename:	String giving the name of the file to be written.  	data:		Data to be written.  	label:		String giving the vicar label.  System items 			will be added or changed as appropriate.    OUTPUT: NONE    KEYWORDS:   INPUT: 	silent:	If set, no messages are printed.  	swap:	If set, the data array will be byte-swapped.  	flip:	If set, the data array will be subjected to a rotate(data, 7), 		i.e., if its an image, it will be flipped vertically.         bpa:    Binary Prefix Array.  	bha:	Binary Header Array.    OUTPUT: 	status:	If no errors occur, status will be zero, otherwise 		it will be a string giving an error message.    RETURN: NONE    RESTRICTIONS: 	This program only writes band-sequential data with no binary header 	or prefixes.    STATUS: 	Complete    SEE ALSO: 	read_vicar    MODIFICATION HISTORY:  	Written by:	Spitale, 5/1996 	Spitale 2/2004:	fixed bug where LBLSIZE wasn't always placed at the                        start of the header. 	Spitale 6/2004:	added bpa and bha output.   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("config/vicar/write_vicar.html#write_vicar", "write_vicar", 'routine in <a href="config/vicar/write_vicar.html">write_vicar.pro</a>', "write_vicar.pro", "", "write_vicar", "", "statussilentswapshowflipbpabhafilenamedatalabel", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/gen/wrong_selgen.html", "wrong_selgen.pro", '.pro file in <a href="util/gen/dir-overview.html">util/gen/ directory</a>', "wrong_selgen.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/gen/wrong_selgen.html#wrong_selgen", "wrong_selgen", 'routine in <a href="util/gen/wrong_selgen.html">wrong_selgen.pro</a>', "wrong_selgen.pro", "", "wrong_selgen", "", "nvnntw", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/wwrite.html", "wwrite.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "wwrite.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/wwrite.html#wwrite", "wwrite", 'routine in <a href="util/wwrite.html">wwrite.pro</a>', "wwrite.pro", "", "wwrite", "", "commentfnamefilespts", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/x_window.html", "x_window.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "x_window.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/x_window.html#x_window", "x_window", 'routine in <a href="util/x_window.html">x_window.pro</a>', "x_window.pro", "", "x_window", "", "freexsizeysizepixmapretaintitlebase", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/xbound.html", "xbound.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "xbound.pro", "", "", " NAME:        xbound    PURPOSE:        Return y values of points bounding with x values    CATEGORY:        UTIL    CALLING SEQUENCE:        result = xbound(x, y, xbounds, bx=bx)    ARGUMENTS:   INPUT:              x:        Array of x positions               y:        Array of y positions         xbounds:        Array containing the lower and upper x bound    OUTPUT: 	NONE    KEYWORDS:   INPUT: 	NONE    OUTPUT:             bx:        x value of array of points within x bound   RETURN:        Y values of array of points within x bound    STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Spitale   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/xbound.html#xbound", "xbound", 'routine in <a href="util/xbound.html">xbound.pro</a>', "xbound.pro", "", "xbound", "", "bxxyxbounds", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/xshade.html", "xshade.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "xshade.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/xshade.html#xshade", "xshade", 'routine in <a href="util/xshade.html">xshade.pro</a>', "xshade.pro", "", "xshade", "", "maptvradiususemapgetmapcolormaxweightpshade", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/xwin.html", "xwin.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "xwin.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/xwin.html#xwin_event", "xwin_event", 'routine in <a href="util/xwin.html">xwin.pro</a>', "xwin.pro", "", "xwin_event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/xwin.html#xwin", "xwin", 'routine in <a href="util/xwin.html">xwin.pro</a>', "xwin.pro", "", "xwin", "", "fnxsizeysizewnumwidgetswid", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/xy_to_ls.html", "xy_to_ls.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "xy_to_ls.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/xy_to_ls.html#xy_to_ls", "xy_to_ls", 'routine in <a href="util/xy_to_ls.html">xy_to_ls.pro</a>', "xy_to_ls.pro", "", "xy_to_ls", "", "ordersizexyimage", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/xy_to_w.html", "xy_to_w.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "xy_to_w.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/xy_to_w.html#xy_to_w", "xy_to_w", 'routine in <a href="util/xy_to_w.html">xy_to_w.pro</a>', "xy_to_w.pro", "", "xy_to_w", "", "sxsyimp", "          -1", "");
  
  libdata[libdataItem++] = new Array("util/xy_to_w.html#_xy_to_w", "_xy_to_w", 'routine in <a href="util/xy_to_w.html">xy_to_w.pro</a>', "xy_to_w.pro", "", "_xy_to_w", "", "imp", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/xygrid.html", "xygrid.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "xygrid.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/xygrid.html#xygrid", "xygrid", 'routine in <a href="util/xygrid.html">xygrid.pro</a>', "xygrid.pro", "", "xygrid", "", "xynxny", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/xyz_to_ra.html", "xyz_to_ra.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "xyz_to_ra.pro", "", "", " NAME:        xyz_to_ra    PURPOSE: 	Convert an array of position vectors [x, y, z] to RA and DEC    CATEGORY:        UTIL    CALLING SEQUENCE:        xyz_to_ra, pos, ra, dec    ARGUMENTS:   INPUT:        pos:	An array of 1x3 column vectors (1,3,n)    OUTPUT:         ra:	Output array of Right Ascension (in degrees)         dec:	Output array of Declination (in degrees)   KEYWORDS:         NONE   STATUS:        Completed.    MODIFICATION HISTORY:        Written by:     Haemmerle 6/2000   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/xyz_to_ra.html#xyz_to_ra", "xyz_to_ra", 'routine in <a href="util/xyz_to_ra.html">xyz_to_ra.pro</a>', "xyz_to_ra.pro", "", "xyz_to_ra", "", "posradec", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/yes_no.html", "yes_no.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "yes_no.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/yes_no.html#yes_no", "yes_no", 'routine in <a href="util/yes_no.html">yes_no.pro</a>', "yes_no.pro", "", "yes_no", "", "tf", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/yydoy_to_jd.html", "yydoy_to_jd.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "yydoy_to_jd.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/yydoy_to_jd.html#yydoy_to_jd", "yydoy_to_jd", 'routine in <a href="util/yydoy_to_jd.html">yydoy_to_jd.pro</a>', "yydoy_to_jd.pro", "", "yydoy_to_jd", "", "centuryyydoy", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/yymmdd_to_jd.html", "yymmdd_to_jd.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "yymmdd_to_jd.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/yymmdd_to_jd.html#yymmdd_to_jd", "yymmdd_to_jd", 'routine in <a href="util/yymmdd_to_jd.html">yymmdd_to_jd.pro</a>', "yymmdd_to_jd.pro", "", "yymmdd_to_jd", "", "centuryyymmdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/yymmdd_to_yydoy.html", "yymmdd_to_yydoy.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "yymmdd_to_yydoy.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/yymmdd_to_yydoy.html#yymmdd_to_yydoy", "yymmdd_to_yydoy", 'routine in <a href="util/yymmdd_to_yydoy.html">yymmdd_to_yydoy.pro</a>', "yymmdd_to_yydoy.pro", "", "yymmdd_to_yydoy", "", "yymmdd", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/zbin.html", "zbin.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "zbin.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/zbin.html#zbin", "zbin", 'routine in <a href="util/zbin.html">zbin.pro</a>', "zbin.pro", "", "zbin", "", "imagez", "          -1", "");
  
  

libdata[libdataItem++] = new Array("util/zfill.html", "zfill.pro", '.pro file in <a href="util/dir-overview.html">util/ directory</a>', "zfill.pro", "", "", " NAME: 	zfill    PURPOSE: 	Replace tagged (default=0) values in array with mean of box 	around pixel.    CATEGORY: 	UTIL    CALLING SEQUENCE: 	zfill, image, fill, nsw, nlw    ARGUMENTS:   INPUT: 	image:	image to be operated on  	fill:	DN value to fill and not be included in mean calculation  	nsw:	size of sample window in mean calculation (default = 1)  	nlw:	size of line window in mean calculation (default = 3)    OUTPUT: 	mask:	Mask of changed pixels (changed = 1)     KEYWORDS:   INPUT: 	xx:	xx  	xx:	xx    OUTPUT: 	xx:	xx  	xx:	xx    RETURN: 	xx    COMMON BLOCKS: 	xx:	xx  	xx:	xx    SIDE EFFECTS: 	xx    RESTRICTIONS:     PROCEDURE: 	xx    EXAMPLE: 	xx    STATUS: 	xx    SEE ALSO: 	xx, xx, xx    MODIFICATION HISTORY:  	Written by:	V. Haemmerle 8/26/99   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("util/zfill.html#zfill", "zfill", 'routine in <a href="util/zfill.html">zfill.pro</a>', "zfill.pro", "", "zfill", "", "imagefillnswnlwmask", "          -1", "");
  
  

